const bool MLLESetupSuccessful = MLLE::Setup(); ///@MLLE-Generated
#include "MLLE-Include-1.6.asc" ///@MLLE-Generated
#pragma require "STVpixelmaptest.j2l" ///@MLLE-Generated
#pragma name "pixelmaptest"
#pragma require "STVutil.asc"

#include "STVutil.asc"

class Track
{
    float fCurvature;
    float fDistance;

    Track(float fCurvature, float fDistance) {
        this.fCurvature = fCurvature;
        this.fDistance = fDistance;
    }
};

float fDistance = 0.0f;
float fCurvature = 0.0f;
float fPlayerCurvature = 0.0f;
float fPlayer2Curvature = 0.0f;
float fPlayerPos = 0.0f;
float fPlayerSpeed = 5.0f;
bool isPlayerRolling = false;

array<Track@> vecTrack;

int screenWidth = 320;
int screenHeight = 200;
jjPIXELMAP@ pixelMap = jjPIXELMAP(screenWidth, screenHeight);
ANIM::Set playerAnimation = ANIM::JAZZ3D;
AnimatedSprite@ playerSprite = AnimatedSprite(
    0, 0, 0,
    int(screenHeight * 0.8),
    0.25, false);

const int updateFrequency = 2;
jjPAL mainPalette = jjPAL();

enum GameLocation {
    MENU = 0,
    GAME = 1
};

void onLevelBegin()
{
    // thank you minmay (I removed the sky, replaced it with a nicer sky from his demo level)
    // and made the parallax effect
    jjLayers[4].hasTiles = false;

    vecTrack.insertLast(Track(0.0f, 10.0f));		// Short section for start/finish line
    vecTrack.insertLast(Track(0.0f, 200.0f));
    vecTrack.insertLast(Track(1.0f, 200.0f));
    vecTrack.insertLast(Track(0.0f, 400.0f));
    vecTrack.insertLast(Track(-1.0f, 100.0f));
    vecTrack.insertLast(Track(0.0f, 200.0f));
    vecTrack.insertLast(Track(-1.0f, 200.0f));
    vecTrack.insertLast(Track(1.0f, 200.0f));
    vecTrack.insertLast(Track(0.0f, 200.0f));
    vecTrack.insertLast(Track(0.2f, 500.0f));
    vecTrack.insertLast(Track(0.0f, 200.0f));

    // grass
    mainPalette.color[1] = jjPALCOLOR(0, 255, 0); // green
    mainPalette.color[2] = jjPALCOLOR(50, 205, 50); // dark green

    // road
    mainPalette.color[3] = jjPALCOLOR(255, 0, 0); // red
    mainPalette.color[4] = jjPALCOLOR(255, 255, 255); // white

    // sky
    mainPalette.color[5] = jjPALCOLOR(176, 224, 230); // powder blue
    mainPalette.color[6] = jjPALCOLOR(73, 216, 230); // light blue

    // ground
    mainPalette.color[7] = jjPALCOLOR(127, 127, 127); // gray

    array<uint8> indexMapping;
    indexMapping.insertLast(0);
    indexMapping.insertLast(1);
    indexMapping.insertLast(2);
    indexMapping.insertLast(3);
    indexMapping.insertLast(4);
    indexMapping.insertLast(5);
    indexMapping.insertLast(6);

    jjSpriteModeSetMapping(1, indexMapping, mainPalette);

    playerSprite.animSet = playerAnimation;
    playerSprite.xScale = 2;
    playerSprite.yScale = 2;

    jjAnimSets[playerAnimation].load();

    updateFrame();
}

void updateFrame(bool drawRoad = true)
{
    const float halfScreenHeight = screenHeight/2;

    for (int y = 0; y < halfScreenHeight; y++)
    {
        float perspective = y / halfScreenHeight;
        float middlePoint = 0.5f + fCurvature * pow(1.0f - perspective, 2);
        float roadWidth = 0.1f + perspective * 0.8f;
        float clipWidth = roadWidth * 0.15f;
        roadWidth *= 0.5f;

        float leftGrass = (middlePoint - roadWidth - clipWidth) * screenWidth;
        float leftClip = (middlePoint - roadWidth) * screenWidth;
        float rightClip = (middlePoint + roadWidth) * screenWidth;
        float rightGrass = (middlePoint + roadWidth + clipWidth) * screenWidth;
        int row = int(halfScreenHeight + y);
        int grassColor = sin(20.0f * pow(1.0f - perspective, 3) + fDistance * 0.1f) > 0.0f ? 1 : 2;
        int clipColor = sin(80.0f * pow(1.0f - perspective, 2) + fDistance * 0.4f) > 0.0f ? 3 : 4;

        // very cool effect but doesn't make sense
        // jjLayers[8].yOffset = fDistance * 0.8f;
        jjLayers[8].yOffset = jjGameTicks;

        for (int x = 0; x < screenWidth; x++)
        {
            if (x < leftGrass)
                pixelMap[x, row] = grassColor;
            else if (x < leftClip && drawRoad)
                pixelMap[x, row] = clipColor;
            else if (x < rightClip && drawRoad)
                pixelMap[x, row] = 7;
            else if (x < rightGrass && drawRoad)
                pixelMap[x, row] = clipColor;
            else
                pixelMap[x, row] = grassColor;
        }
    }
}

void onMain()
{
    if (jjGameTicks % updateFrequency == 0)
    {
        float fOffset = 0;
        uint nTrackSection = 0;

        while(
            nTrackSection < vecTrack.length() &&
            fOffset <= fDistance
        ) {
            fOffset += vecTrack[nTrackSection].fDistance;
            nTrackSection++;
        }

        if(fDistance < 1) {
            fDistance = 1;
            return;
        }

        float fTargetCurvature = vecTrack[nTrackSection - 1].fCurvature;
        float fTrackCurveDiff = (fTargetCurvature - fCurvature);

        // Apply interpolation for smoother transition
        const float interpolationRate = 0.05f;
        fCurvature += fTrackCurveDiff * interpolationRate;

        if (jjP.keyUp)
            fDistance += isPlayerRolling ? fPlayerSpeed * 2 : fPlayerSpeed;
        else if (jjP.keyDown)
            fDistance -= isPlayerRolling ? fPlayerSpeed * 2 : fPlayerSpeed;

        if (jjP.keyRight)
            fPlayerCurvature += 0.05f;
        if (jjP.keyLeft)
            fPlayerCurvature -= 0.05f;

        if(jjP.keyJump) isPlayerRolling = true; else isPlayerRolling = false;

        // if(jjKey[])
        
        if(fPlayerCurvature > 0.3f)
            fPlayerCurvature = 0.3f;
        if(fPlayerCurvature < -0.6f)
            fPlayerCurvature = -0.6f;

        updateFrame(true);    
    }

    playerSprite.id = jjP.keyJump ? 2 : (jjP.keyUp || jjP.keyDown ? 3 : 0);
    // playerSprite.id = jjP.keyUp || jjP.keyDown ? 3 : (jjP.keyJump ? 2 : 0);
    playerSprite.update();
}

bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ screen)
{
    player.cameraFreeze(32, 32, false, true);

    pixelMap.save(jjAnimFrames[jjAnimations[jjAnimSets[ANIM::CUSTOM[0]].firstAnim].firstFrame + 1]);
    screen.drawResizedSprite(0, 0, ANIM::CUSTOM[0], 1, 0, 2.5, 3, SPRITE::MAPPING, 1);

    fPlayerPos = fPlayerCurvature;

    const float nPlayerPos = (screenWidth / 2 + (screenWidth * fPlayerPos) / 2) * 3;
    playerSprite.x = int(nPlayerPos);
    playerSprite.y = (screenHeight / 2) * 5;
    playerSprite.draw(screen);

    screen.drawString(0, 10, "fDistance: " + fDistance);
    screen.drawString(0, 30, "fCurvature: " + fCurvature);
    screen.drawString(0, 50, "fPlayerCurvature: " + fPlayerCurvature);
    screen.drawString(0, 70, "fPlayerPos: " + fPlayerPos);
    screen.drawString(0, 90, "nPlayerPos: " + nPlayerPos);
    screen.drawString(0, 110, "FPS: " + jjFPS);

    return true;
}

bool onDrawHealth(jjPLAYER@ player, jjCANVAS@ canvas) { return true; }
bool onDrawLives(jjPLAYER@ player, jjCANVAS@ canvas) { return true; }
bool onDrawPlayerTimer(jjPLAYER@ player, jjCANVAS@ canvas) { return true; }
bool onDrawScore(jjPLAYER@ player, jjCANVAS@ canvas) { return true; }
bool onDrawGameModeHUD(jjPLAYER@ player, jjCANVAS@ canvas) { return true; }
