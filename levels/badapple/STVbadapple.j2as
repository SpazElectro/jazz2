/*
	struct video {
		int uncompressedSize;
		char compressedData[];
	};
	struct videodata {
		int width;
		int height;
		char pixels[width * height];
	};

	Each 8 pixels are stored in a byte
	0b00000000 -> 8 pixels, all black
	0b11111111 -> 8 pixels, all white
*/

#pragma require "STVutil.asc"

#include "STVutil.asc"

#define COLOR_DEPTH_CHECKS
// #define COLOR_DEBUG

jjSTREAM@ videoStream;
jjPIXELMAP@ screenPixelmap = jjPIXELMAP(1, 1);

int videoWidth = 0;
int videoHeight = 0;
bool videoEnded = false;

#ifdef COLOR_DEPTH_CHECKS
int lastColorDepth = 0;
#endif

int WHITE = -1;
int BLACK = -1;

jjANIMFRAME@ pixelmapDestination;
ANIM::Set usedAnimSet = ANIM::FISH;

void setColors() {
	// DO NOT USE COLORS FROM 0-15
	// IT WILL CRASH THE GAME
	// 0-15 are reserved

	if (jjColorDepth == 8) {
		WHITE = 255;
		BLACK = 63;
	} else {
		WHITE = 255;
		BLACK = 246;
	}

#ifdef COLOR_DEPTH_CHECKS
	lastColorDepth = jjColorDepth;
#endif
}

void onPlayer(jjPLAYER@ player) {
    player.cameraFreeze(0, 0, false, true);
	player.ballTime = 1;
	player.keyJump = player.keyRun = false;
}

void onLevelBegin() {
	setColors();

	/* Load the compressed video stream */
	jjSpy("Loading video...");
	jjSTREAM@ uncompressedVideoStream = jjSTREAM(
		#asset "badapplevideo.asdat"
	);

	/* Decompress the video stream */
	int uncompressedSize;
	uncompressedVideoStream.pop(uncompressedSize);
	jjSpy("Decompressing video... (uncompressed size of "+uncompressedSize/1024/1024+" megabytes, "+uncompressedSize+" bytes, compressed size:"+uncompressedVideoStream.getSize()+" bytes)");
	@videoStream = jjSTREAM();
	jjZlibUncompress(uncompressedVideoStream, videoStream, uncompressedSize);
	/* Read the width and height */
	videoStream.pop(videoWidth);
	videoStream.pop(videoHeight);
	jjSpy("Video is "+videoWidth+"x"+videoHeight);
	
	/* Prepare the FISH animation set so we could overwrite it with our pixelmap */
	jjAnimSets[usedAnimSet].load();
	// @pixelmapDestination = jjAnimFrames[jjAnimations[jjAnimSets[usedAnimSet].firstAnim].firstFrame];
	@screenPixelmap = screenPixelmap.resize(videoWidth, videoHeight);

	setColors();
}

uint8 pixels;

// Returns is OK
bool decodeFrame() {
    if (videoStream.isEmpty()) {
		jjConsole("Video ended!");
        videoEnded = true;
        return false;
    }

    for (int y = 0; y < videoHeight; ++y) {
        for (int x = 0; x < videoWidth; x += 8) {
            videoStream.pop(pixels);

			for (int i = 0; i < 8; ++i) {
				/* Set the pixel color by getting the corresponding bit */
				screenPixelmap[x + i, y] = ((pixels & (1 << (7 - i))) != 0) ? BLACK : WHITE;
			}
        }
    }

	return true;
}

bool ok = true;
bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas) {
	if (!videoEnded) {
#ifdef COLOR_DEPTH_CHECKS
		if (lastColorDepth != jjColorDepth)
			setColors();
#endif

		ok = decodeFrame();
		screenPixelmap.save(jjAnimFrames[jjAnimations[jjAnimSets[usedAnimSet].firstAnim].firstFrame]);
	}

	if (ok)
		canvas.drawSprite(
			jjResolutionWidth / 2 - videoWidth / 2,
			jjResolutionHeight / 2 - videoHeight / 2,
			usedAnimSet, 0, 0, 0, SPRITE::NORMAL);

#ifdef COLOR_DEBUG
	canvas.drawRectangle(
		15,
		jjResolutionHeight-30,
		1000, 1000,
		18
	);
	for (int colorIndex = 15; colorIndex < 256; colorIndex++) {
		canvas.drawRectangle(
			15 + colorIndex,
			jjResolutionHeight - 50,
			1, 50,
			colorIndex
		);
	}

	int mouseX = jjMouseX;
	int mouseY = jjMouseY;

	if (mouseY >= jjResolutionHeight - 50 && mouseY < jjResolutionHeight) {
		int colorIndex = mouseX - 15;
		if (colorIndex >= 15 && colorIndex < 256) {
			jjConsole("Mouse is touching color index: " + colorIndex);
			canvas.drawRectangle(
				0, 0,
				50, 50,
				colorIndex
			);
		}
	}
#endif

	return true;
}

bool onDrawHealth(jjPLAYER@ player, jjCANVAS@ canvas) 		{ return true; }
bool onDrawLives(jjPLAYER@ player, jjCANVAS@ canvas) 		{ return true; }
bool onDrawPlayerTimer(jjPLAYER@ player, jjCANVAS@ canvas)	{ return true; }
bool onDrawScore(jjPLAYER@ player, jjCANVAS@ canvas) 		{ return true; }
bool onDrawGameModeHUD(jjPLAYER@ player, jjCANVAS@ canvas)	{ return true; }
void onPlayerDraw(jjPLAYERDRAW& pd) {
	pd.gunFlash = false;
	pd.name = false;
	pd.sprite = false;
	pd.trail = false;
}
