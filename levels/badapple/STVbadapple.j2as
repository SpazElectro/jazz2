/*
	struct video {
		int uncompressedSize;
		char compressedData[];
	};
	struct videodata {
		int width;
		int height;
		char pixels[width * height];
	};

	Each 8 pixels are stored in a byte
	0b00000000 -> 8 pixels, all black
	0b11111111 -> 8 pixels, all white
*/

#pragma require "STVutil.asc"

#include "STVutil.asc"

// #define COLOR_DEPTH_CHECKS


jjSTREAM@ videoStream;
jjPIXELMAP@ screenPixelmap = jjPIXELMAP(1, 1);

int videoWidth = 0;
int videoHeight = 0;
bool videoEnded = false;

#ifdef COLOR_DEPTH_CHECKS
int lastColorDepth = 0;
#endif

int WHITE = 0;
int BLACK = 0;

jjANIMFRAME@ pixelmapDestination;
ANIM::Set usedAnimSet = ANIM::FISH;

void setColors() {
	if (jjColorDepth == 8) {
		WHITE = 255;
		BLACK = 0;
	} else {
		WHITE = 255;
		BLACK = 246;
	}

#ifdef COLOR_DEPTH_CHECKS
	lastColorDepth = jjColorDepth;
#endif
}

void onLevelBegin() {
	setColors();

	/* Load the compressed video stream */
	jjSpy("Loading video...");
	jjSTREAM@ uncompressedVideoStream = jjSTREAM(
		#asset "badapplevideo.asdat"
	);

	/* Decompress the video stream */
	int uncompressedSize;
	uncompressedVideoStream.pop(uncompressedSize);
	jjSpy("Decompressing video... (uncompressed size of "+uncompressedSize/1024/1024+" megabytes, "+uncompressedSize+" bytes, compressed size:"+uncompressedVideoStream.getSize()+" bytes)");
	@videoStream = jjSTREAM();
	jjZlibUncompress(uncompressedVideoStream, videoStream, uncompressedSize);
	// high possibility of crashing cuz of compression
	/* Read the width and height */
	videoStream.pop(videoWidth);
	videoStream.pop(videoHeight);
	jjSpy("Video is "+videoWidth+"x"+videoHeight);
	
	/* Prepare the FISH animation set so we could overwrite it with our pixelmap */
	jjAnimSets[usedAnimSet].load();
	// @pixelmapDestination = jjAnimFrames[jjAnimations[jjAnimSets[usedAnimSet].firstAnim].firstFrame];
	@screenPixelmap = screenPixelmap.resize(videoWidth, videoHeight);

	setColors();
}

uint64 pixelmapCalls = 0;
int8 pixels;

// Returns is OK
bool decodeFrame() {
    if (videoStream.isEmpty()) {
		jjConsole("Video ended!");
        videoEnded = true;
        return false;
    }

	if (pixelmapCalls >= 10000000)
	{
		jjConsole("Pixelmap calls: "+pixelmapCalls+" videoWidth: "+videoWidth+" videoHeight: "+videoHeight);
		pixelmapCalls = 0;
		@screenPixelmap = jjPIXELMAP(1, 1);
		@screenPixelmap = screenPixelmap.resize(videoWidth, videoHeight);
		usedAnimSet = ANIM::CAT;
	}

	// 141976808 - 134330400 = 7646408
	// compressed size => 6895683
	// jjConsole(""+videoStream.getSize());

    for (int y = 0; y < videoHeight; ++y) {
        for (int x = 0; x < videoWidth; x += 8) {
            videoStream.pop(pixels);

			for (int i = 0; i < 8; ++i) {
				/* Set the pixel color by getting the corresponding bit */
				screenPixelmap[x + i, y] = ((pixels & (1 << (7 - i))) != 0) ? BLACK : WHITE;
				pixelmapCalls += 1;
			}
        }
    }

	return true;
}

bool ok = true;
bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas) {
	if (!videoEnded) {
#ifdef COLOR_DEPTH_CHECKS
		if (lastColorDepth != jjColorDepth)
			setColors();
#endif

		ok = decodeFrame();
		screenPixelmap.save(jjAnimFrames[jjAnimations[jjAnimSets[usedAnimSet].firstAnim].firstFrame]);
	}

	if (ok)
		canvas.drawSprite(
			jjResolutionWidth / 2 - videoWidth / 2,
			jjResolutionHeight / 2 - videoHeight / 2,
			usedAnimSet, 0, 0, 0, SPRITE::NORMAL);
	canvas.drawString(
		0, 15,
		"" + pixelmapCalls
	);

	return true;
}

bool onDrawHealth(jjPLAYER@ player, jjCANVAS@ canvas) 		{ return true; }
bool onDrawLives(jjPLAYER@ player, jjCANVAS@ canvas) 		{ return true; }
bool onDrawPlayerTimer(jjPLAYER@ player, jjCANVAS@ canvas)	{ return true; }
bool onDrawScore(jjPLAYER@ player, jjCANVAS@ canvas) 		{ return true; }
bool onDrawGameModeHUD(jjPLAYER@ player, jjCANVAS@ canvas)	{ return true; }
void onPlayerDraw(jjPLAYERDRAW& pd) {
	pd.gunFlash = false;
	pd.name = false;
	pd.sprite = false;
	pd.trail = false;
}
