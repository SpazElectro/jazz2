#pragma require "STVutil.asc"

#include "STVutil.asc"

// for intellisense
#include "../../scripts/STVutil.asc"

array<dictionary>@ grid = {};
const int DIM = 4;

const int BLANK = 0;
const int UP = 1;
const int RIGHT = 2;
const int DOWN = 3;
const int LEFT = 4;

dictionary rules = {
    {"BLANK", {{"BLANK", "BLANK"}, {"BLANK", "UP"}, {"BLANK", "RIGHT"}, {"BLANK", "DOWN"}, {"BLANK", "LEFT"}}},
    {"UP", {{"UP", "RIGHT"}, {"UP", "DOWN"}, {"UP", "LEFT"}}},
    {"RIGHT", {}},
    {"DOWN", {}},
    {"LEFT", {}}
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {
    stvutilRNG.seed(generateSeed());
    deCollapseAll();
    return true;
}

void onLevelBegin() {
    jjAnimSets[ANIM::CUSTOM[0]].load(jjPIXELMAP("blank.png"), frameWidth: 50, frameHeight: 50, frameSpacingX: 0, frameSpacingY: 0, startY: 0);
    jjAnimSets[ANIM::CUSTOM[1]].load(jjPIXELMAP("up.png"), frameWidth: 50, frameHeight: 50, frameSpacingX: 0, frameSpacingY: 0, startY: 0);
    jjAnimSets[ANIM::CUSTOM[2]].load(jjPIXELMAP("right.png"), frameWidth: 50, frameHeight: 50, frameSpacingX: 0, frameSpacingY: 0, startY: 0);
    jjAnimSets[ANIM::CUSTOM[3]].load(jjPIXELMAP("down.png"), frameWidth: 50, frameHeight: 50, frameSpacingX: 0, frameSpacingY: 0, startY: 0);
    jjAnimSets[ANIM::CUSTOM[4]].load(jjPIXELMAP("left.png"), frameWidth: 50, frameHeight: 50, frameSpacingX: 0, frameSpacingY: 0, startY: 0);
    
    jjConsole("Started!");

    for (int i = 0; i < DIM * DIM; i++)
    {
        grid.insertLast({});
    }

    deCollapseAll();
}

void onMain() {
    stvutilRNG.seed(generateSeed());

    array<dictionary> gridCopy = cloneDictionaryArray(grid);

    gridCopy.sort(function(a, b) {
        array<int> optionsA;
        a.get("options", optionsA);

        array<int> optionsB;
        b.get("options", optionsB);
        
        return optionsA.length() < optionsB.length();
    });
    
    array<int> options;
    gridCopy[0].get("options", options);
    int len = options.length();
    int stopIndex = 0;

    array<int> options2;

    for (uint i = 0; i < gridCopy.length(); i++)
    {
        gridCopy[i].get("options", options2);

        if (int(options2.length()) > len) {
            stopIndex = i;
            break;
        }
    }

    if(stopIndex > 0) gridCopy.resize(stopIndex);

    int cellN = getRandomNumber(0, gridCopy.length() - 1);
    dictionary cell = gridCopy[cellN];
    cell.set("collapsed", true);
    
    array<int> optionsCell;
    cell.get("options", optionsCell);
    
    int pick = optionsCell[getRandomNumber(0, optionsCell.length() - 1)];
    array<int> newOptions = {pick};
    cell.set("options", newOptions);

    array<dictionary> nextTiles = {};

    for (int j = 0; j < DIM; j++)
    {
        for (int i = 0; i < DIM; i++)
        {
            int index = i + j * DIM;
            bool tileCollapsed;
            tiles[index].get("collapsed", tileCollapsed);

            if(tileCollapsed) {
                nextTiles[index] = tiles[index];
            } else {
                array<int> options = {};

                // look up


                // look right
                

                // look down
                

                // look left


            }
        }
    }
    

    grid[cellN] = cell;
}

void deCollapseAll() {
    array<int> fullOptions = {BLANK, UP, RIGHT, DOWN, LEFT};

    for (int i = 0; i < DIM * DIM; i++)
    {
        grid[i] = {
            {"collapsed", false},
            {"options", fullOptions}
        };
    }
}

bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas) {
    int width = jjResolutionWidth;
    int height = jjResolutionHeight;
    int w = width/DIM;
    int h = height/DIM;

    for (int j = 0; j < DIM; j++)
    {
        for (int i = 0; i < DIM; i++)
        {
            dictionary cell = grid[i+j*DIM];
            bool collapsed = false;
            cell.get("collapsed", collapsed);

            if(collapsed) {
                array<int> options = {};
                cell.get("options", options);
                
                int index = options[0];

                canvas.drawResizedSprite(i*w, j*h, ANIM::CUSTOM[index], 0, 0, w/25, h/24);
            } else {
                canvas.drawRectangle(i*w, j*h, w, h, 5);
            }
        }
    }
    
    return false;
}