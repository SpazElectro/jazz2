#include "STVutil.asc"

int lastHealth = jjMaxHealth;
int shield = 0;

RabbitNPC@ npc = RabbitNPC(2463, 1164, 50, CHAR::SPAZ);
float npcSpeed = 1.0;
float fallSpeed = 5.0;

uint8 shieldEventId = 144;

class ShieldCollectable : jjBEHAVIORINTERFACE {
	void onBehave(jjOBJ@ obj) {
		obj.behave(BEHAVIOR::PICKUP);
	}

	bool onObjectHit(jjOBJ@ obj, jjOBJ@ bullet, jjPLAYER@ player, int force) {
        jjConsole("ShieldCollectable::onObjectHit");

		shield += 1;

		jjSample(obj.xPos, obj.yPos, SOUND::COMMON_HARP1);

		obj.frameID = 0;
		obj.behavior = BEHAVIOR::EXPLOSION2;
		
		return true;
	}
}

void onLevelBegin() {
    // fur needs to be fixed
    // npc.updateFur(673194016);

    npc.setState(RabbitState::RUNNING);

    jjAnimSets[45].load();

    // teeworlds.zombies
    jjConsole("[TW.Z] Started!");
}

void onPlayer(jjPLAYER@ player) {    
    if(npc.sprite.x >= player.xPos) {
        npc.direction = -1;
    } else {
        npc.direction = 1;
    }

    if(npc.direction == 1) {
        npc.sprite.x += int(2 * npcSpeed);
    } else {
        npc.sprite.x -= int(npcSpeed);
    }

    if (npc.colliding())
    {
        bool collideLeft = false;
        bool collideRight = false;

        if(not jjMaskedPixel(npc.sprite.x - (1 * 32), npc.sprite.y)) {
            collideLeft = true;
        }

        if(not jjMaskedPixel(npc.sprite.x + (1 * 32), npc.sprite.y)) {
            collideRight = true;
        }

        if(collideLeft) {
            npc.sprite.x -= int(npcSpeed);
        } else {
            npc.sprite.x += int(2 * npcSpeed);
        }

        if(collideRight) {
            npc.sprite.x += int(npcSpeed);
        } else {
            npc.sprite.x -= int(2 * npcSpeed);
        }
    }

    if(
        (not npc.onGround())
    ) {
        if(npc.state != RabbitState::FALLING) {
            npc.setState(RabbitState::FALLING);
        }

        npc.sprite.y += int(fallSpeed);
    } else {
        if(npc.state != RabbitState::RUNNING) {
            npc.setState(RabbitState::RUNNING);
        }
    }

    // this is the worst way to do this but it works so FUCKING GOOD
    // if you can find a better way to do this, please make a pull request
    // also bypasses the kill command

    if(lastHealth != player.health) {
        int actualHealth = player.health + shield;

        if(actualHealth > jjMaxHealth) {
            shield -= (actualHealth - jjMaxHealth);
            player.health = jjMaxHealth;
        } else {
            player.health = actualHealth;
            shield = 0;
        }

        lastHealth = player.health;
    }
}

void onMain() {
    for (int i = 1; i < jjObjectCount; i++) {
        jjOBJ@ o = jjObjects[i];

        if (o.isActive && o.eventID == shieldEventId) {
            o.state = STATE::HIDE;
            o.behavior = ShieldCollectable();
        }
    }

    npc.update();
}

void onDrawLayer4(jjPLAYER@ player, jjCANVAS@ canvas) {
    for (int i = 1; i < jjObjectCount; i++) {
        jjOBJ@ o = jjObjects[i];

        if (o.isActive && o.eventID == shieldEventId) {
            // you're probably wondering why i always use '123' in the last parameter
            // that's because its the default number from the documentation
            
            canvas.drawSprite(int(o.xPos), int(o.yPos), 45, 0, 0, 1, SPRITE::NORMAL, 123); 
        }
    }

    npc.draw(canvas);
}

bool onDrawHealth(jjPLAYER@ player, jjCANVAS@ canvas) {
    for (int i = 0; i < shield; i++)
    {
        canvas.drawSprite(jjResolutionWidth - 10 - (i * 20), 25, 45, 0, 0, 1, SPRITE::NORMAL, 123);
    }

    return false;
}