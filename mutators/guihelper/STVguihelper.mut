#pragma name "guihelper"
#pragma require "STVutil.asc"
#pragma require "STVmenu.asc"

#include "STVutil.asc"
#include "STVmenu.asc"

// for intellisense
#include "../../scripts/STVutil.asc"

enum GUIElementType {
    NORMAL = 0,
    TEXT = 1,
    RECTANGLE = 2
};

class GUIElement {
    int x, y;
    bool visible = false;
    SPRITE::Mode spriteMode;
    uint8 modeParam;
    GUIElementType type = NORMAL;
    string _id;

    GUIElement(int x = 0, int y = 0) {
        this.x = x;
        this.y = y;
        this._id = generateUUID();
    }

    void Update() {}
    void Draw(jjCANVAS@ canvas) {}
};

class TextElement: GUIElement {
    string text;
    STRING::Size size;
    STRING::Mode mode;

    TextElement(int x = 0, int y = 0, string text = "TextElement", STRING::Size size = STRING::MEDIUM) {
        super(x, y);

        this.text = text;
        this.size = size;
        this.visible = true;
        this.type = TEXT;
    }

    void Update() {}
    void Draw(jjCANVAS@ canvas) {
        canvas.drawString(this.x, this.y, this.text, this.size, this.mode, this.modeParam);
    }
}

class RectangleElement: GUIElement {
    int width, height;
    uint8 color;

    RectangleElement(int x = 0, int y = 0, int width = 0, int height = 0) {
        super(x, y);

        this.width = width;
        this.height = height;
        this.visible = true;
        this.type = RECTANGLE;
    }

    void Update() {}
    void Draw(jjCANVAS@ canvas) {
        canvas.drawRectangle(this.x, this.y, this.width, this.height, this.color, this.spriteMode, this.modeParam);
    }
}

array<GUIElement@> guiElements;

// debug
bool debugView = false;

// locating
bool locatingItem = false;
bool locatingDebounce = false;
GUIElement@ itemBeingLocated;

int gridSize = 10;

// menu
CustomMenu@ menu = CustomMenu();
array<MenuButton@> menuButtons;

int snap(int spot) {
    return (spot + gridSize / 2) / gridSize * gridSize;
}

void onKeyPress(uint key) {
    if(key == KEYS[48].code) {
        menu.toggle();
    }
}

void onLevelBegin() {
    jjConsole("Started!");

    menu.header = "GUI Helper";
    menu.footer = "GUI Helper v0.1 by Spaz Electro";

    menuButtons.insertLast(MenuButton("Create new TextElement", -1, {
        Button(
            0, function(button) {
                locatingItem = true;
                @itemBeingLocated = TextElement();
                guiElements.insertLast(itemBeingLocated);

                menu.disable();
                
                locatingDebounce = true;

                TimerV(70, function() {
                    locatingDebounce = false;
                });
            }, "C", true)
    }));

    menuButtons.insertLast(MenuButton("Create new RectangleElement", 0, {
        Button(
            0, function(button) {
                locatingItem = true;
                @itemBeingLocated = RectangleElement(0, 0, 100, 100);
                guiElements.insertLast(itemBeingLocated);

                menu.disable();
                
                locatingDebounce = true;

                TimerV(70, function() {
                    locatingDebounce = false;
                });
            }, "C", true)
    }));

    keyPressCallbacks.insertLast(onKeyPress);
}

void onPlayer(jjPLAYER@ player) {
    if(locatingItem) {
        itemBeingLocated.x = snap(jjMouseX);
        itemBeingLocated.y = snap(jjMouseY);

        if(jjKey[0x1] && !locatingDebounce) {
            locatingItem = false;
            @itemBeingLocated = null;
        }
    }

    for (uint i = 0; i < menuButtons.length(); i++)
    {
        MenuButton @button = menuButtons[i];
        button.input(player);
    }

    menu.update();

    updateKeys();
}

bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas) {
    menu.draw(canvas);
    
    for (uint i = 0; i < menuButtons.length(); i++)
    {
        MenuButton @button = menuButtons[i];
        button.draw(canvas);
    }
    
    menu.finishDrawing(canvas);

    for (uint i = 0; i < guiElements.length; i++) {
        if (guiElements[i].visible) {
            if(debugView)
                canvas.drawString(guiElements[i].x - 5, guiElements[i].y + 70, "ID: " + guiElements[i]._id);
            
            guiElements[i].Draw(canvas);
        }
    }

    // utils
    if(locatingItem) {
        int x = itemBeingLocated.x;
        int y = itemBeingLocated.y;

        x -= 5;
        y += 65;

        int xRatio = (jjResolutionWidth / 2) - snap(jjMouseX);
        int yRatio = jjResolutionHeight - snap(jjMouseY);

        if(x + jjGetStringWidth("Bottom center ratio: " + xRatio + "x" + yRatio, STRING::SMALL, normalTextAppearance) >= jjResolutionWidth) {
            x -= 200;
        }

        if(y <= 50) {
            y += 80;
        }

        canvas.drawString(x, y - 10, "" + snap(jjMouseX) + " - " + snap(jjMouseY), STRING::SMALL);
        canvas.drawString(x, y - 20, "Ratio: " + (jjResolutionWidth - snap(jjMouseX)) + "x" + (jjResolutionHeight - snap(jjMouseY)), STRING::SMALL);
        canvas.drawString(x, y - 30, "Center ratio: " + xRatio + "x" + ((jjResolutionHeight / 2) - snap(jjMouseY)), STRING::SMALL);
        canvas.drawString(x, y - 40, "Bottom center ratio: " + xRatio + "x" + yRatio, STRING::SMALL);
    }

    return false;
}
