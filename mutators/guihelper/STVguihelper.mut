#pragma name "guihelper"
#pragma require "STVutil.asc"
#pragma require "STVmainMenu.asc"

#include "STVutil.asc"
#include "STVmenu.asc"

// for intellisense
#include "../../scripts/STVutil.asc"

enum GUIElementType {
    NORMAL = 0,
    TEXT = 1,
    RECTANGLE = 2
};

class GUIElement {
    int x, y;
    bool visible = false;
    SPRITE::Mode spriteMode;
    uint8 modeParam;
    GUIElementType type = NORMAL;
    string _id;

    GUIElement(int x = 0, int y = 0) {
        this.x = x;
        this.y = y;
        this._id = generateUUID();
    }

    void update() {}
    void draw(jjCANVAS@ canvas) {}
};

class TextElement: GUIElement {
    string text;
    STRING::Size size;
    STRING::Mode mode;

    TextElement(int x = 0, int y = 0, string text = "TextElement", STRING::Size size = STRING::MEDIUM) {
        super(x, y);

        this.text = text;
        this.size = size;
        this.visible = true;
        this.type = TEXT;
    }

    void update() {}
    void draw(jjCANVAS@ canvas) {
        canvas.drawString(this.x, this.y, this.text, this.size, this.mode, this.modeParam);
    }
}

class RectangleElement: GUIElement {
    int width, height;
    uint8 color;

    RectangleElement(int x = 0, int y = 0, int width = 0, int height = 0) {
        super(x, y);

        this.width = width;
        this.height = height;
        this.visible = true;
        this.type = RECTANGLE;
    }

    void update() {}
    void draw(jjCANVAS@ canvas) {
        canvas.drawRectangle(this.x, this.y, this.width, this.height, this.color, this.spriteMode, this.modeParam);
    }
}

// the only reason i seperated PropertyManager to elsewhere is because
// the code at the draw and update methods looks horrible
// and i dont want to EVER touch it or see it again
class PropertyManager {
    CustomMenu@ pMenu = CustomMenu(Vector2(), false);
    
    PropertyManager() {}

    void update(jjPLAYER@ player) {
        @pMenu.position = Vector2(jjResolutionWidth - 300, 0);
        @pMenu.size = Vector2(300, jjResolutionHeight);
        pMenu.enabled = showPropertyManager;
        pMenu.update();
    }
    
    void draw(jjCANVAS@ canvas) {
        if(!pMenu.enabled) return;
        if(@propertyManager_selectedItem == null) return;

        pMenu.draw(canvas);
        
        canvas.drawString(pMenu.position.x + 25, pMenu.position.y + 20 + 6, "Property Manager", STRING::MEDIUM);

        if(@propertyManager_selectedItem.type == TEXT) {
            drawButton(canvas, 1, false, "text");
        } else if(@propertyManager_selectedItem == RECTANGLE) {
            drawButton(canvas, 1, false, "rectangle");
        }

        pMenu.finishDrawing(canvas);
    }

    void drawButton(jjCANVAS@ canvas, int index, bool checked, string text) {
        // I'm gonna explain everything from here because if future me wants to review
        // this old code, it's easier to understand

        // we arent using the MenuButton or Button class because they are VERY wack
        // we hate them >:(

        // the 50 in pm_pos_x is for spacing, pm_pos_y is self-explanatory
        canvas.drawRectangle(pMenu.position.x + 50, pMenu.position.y + (index * 50), 25, 25, 0);
        // the 6 is to make the dot in the center, same thing for this   \/, also we use size 12
        // because its the half of 25 (the half of 25 is 12.5, but it'll get rounded either way)
        canvas.drawRectangle(pMenu.position.x + 6 + 50, pMenu.position.y + 6 + (index * 50), 12, 12, getCheckedColor(checked));
        
        // 30 is for spacing, the 6 in pm_pos_y is to make it look like the text is in the center horizontally
        canvas.drawString(pMenu.position.x + 50 + 30, pMenu.position.y + (index * 50) + 6, text, STRING::MEDIUM);
    }
}

array<GUIElement@> guiElements;

// debug
bool debugView = false;

// locating
bool locatingItem = false;
bool locatingDebounce = false;
GUIElement@ itemBeingLocated;

int gridSize = 10;

// menu
CustomMenu@ mainMenu = CustomMenu();
array<MenuButton@> menuButtons;

// property manager
PropertyManager@ propertyManager = PropertyManager();
bool showPropertyManager = false;
GUIElement@ propertyManager_selectedItem;

int snap(int spot) {
    return (spot + gridSize / 2) / gridSize * gridSize;
}

void onKeyPress(uint key) {
    // 48 == numpad dot
    if(key == KEYS[48].code) {
        mainMenu.toggle();
    }

    // 47 == numpad zero
    if(key == KEYS[47].code) {
        showPropertyManager = !showPropertyManager;
    }
}

void onLevelBegin() {
    jjConsole("Started!");

    mainMenu.header = "GUI Helper";
    mainMenu.footer = "GUI Helper v0.1 by Spaz Electro";

    menuButtons.insertLast(MenuButton("Create new TextElement", -1, {
        Button(
            3, function(button) {
                locatingItem = true;
                @itemBeingLocated = TextElement();
                guiElements.insertLast(itemBeingLocated);

                mainMenu.disable();
                
                locatingDebounce = true;

                TimerV(70, function() {
                    locatingDebounce = false;
                });
            }, "C", true)
    }, mainMenu));

    menuButtons.insertLast(MenuButton("Create new RectangleElement", 0, {
        Button(
            3, function(button) {
                locatingItem = true;
                @itemBeingLocated = RectangleElement(0, 0, 100, 100);
                guiElements.insertLast(itemBeingLocated);

                mainMenu.disable();
                
                locatingDebounce = true;

                TimerV(70, function() {
                    locatingDebounce = false;
                });
            }, "C", true)
    }, mainMenu));

    keyPressCallbacks.insertLast(onKeyPress);
}

void onPlayer(jjPLAYER@ player) {
    if(locatingItem) {
        itemBeingLocated.x = snap(jjMouseX);
        itemBeingLocated.y = snap(jjMouseY);

        if(jjKey[0x1] && !locatingDebounce) {
            locatingItem = false;
            @itemBeingLocated = null;
        }
    }

    for (uint i = 0; i < menuButtons.length(); i++)
    {
        MenuButton @button = menuButtons[i];
        button.input(player);
    }

    mainMenu.update();
    propertyManager.update(player);

    updateKeys();
}

bool onDrawHealth(jjPLAYER@ player, jjCANVAS@ canvas) {
    mainMenu.draw(canvas);
    
    for (uint i = 0; i < menuButtons.length(); i++)
    {
        MenuButton @button = menuButtons[i];
        button.draw(canvas);
    }
    
    mainMenu.finishDrawing(canvas);

    for (uint i = 0; i < guiElements.length; i++) {
        if (guiElements[i].visible) {
            if(debugView)
                canvas.drawString(guiElements[i].x - 5, guiElements[i].y + 70, "ID: " + guiElements[i]._id);
            
            guiElements[i].draw(canvas);
        }
    }

    // utils
    if(locatingItem) {
        int x = itemBeingLocated.x;
        int y = itemBeingLocated.y;

        x -= 5;
        y += 65;

        int xRatio = (jjResolutionWidth / 2) - snap(jjMouseX);
        int yRatio = jjResolutionHeight - snap(jjMouseY);

        if(x + jjGetStringWidth("Bottom center ratio: " + xRatio + "x" + yRatio, STRING::SMALL, normalTextAppearance) >= jjResolutionWidth) {
            x -= 200;
        }

        if(y <= 50) {
            y += 80;
        }

        canvas.drawString(x, y - 10, "" + snap(jjMouseX) + " - " + snap(jjMouseY), STRING::SMALL);
        canvas.drawString(x, y - 20, "Ratio: " + (jjResolutionWidth - snap(jjMouseX)) + "x" + (jjResolutionHeight - snap(jjMouseY)), STRING::SMALL);
        canvas.drawString(x, y - 30, "Center ratio: " + xRatio + "x" + ((jjResolutionHeight / 2) - snap(jjMouseY)), STRING::SMALL);
        canvas.drawString(x, y - 40, "Bottom center ratio: " + xRatio + "x" + yRatio, STRING::SMALL);
    }

    propertyManager.draw(canvas);

    return false;
}