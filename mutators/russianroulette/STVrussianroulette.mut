funcdef void TimerVDictionaryFunction(dictionary@);
class TimerV : jjBEHAVIORINTERFACE {
  TimerV(int time, jjVOIDFUNC@ callback) {
    @_callback = @callback;
    _start(time);
  }
  TimerV(int time, TimerVDictionaryFunction@ callback, dictionary@ arguments) {
    @_callbackWithArguments = @callback;
    @_arguments = @arguments;
    _start(time);
  }
  bool get_Active() const {
    return cast<jjBEHAVIORINTERFACE@>(_object.behavior) is this;
  }
  int get_Elapsed() const {
    if (Active) return _object.age;
    return -1;
  }
  int get_Total() const {
    if (Active) return _object.counter;
    return -1;
  }
  int get_Remaining() const {
    if (Active) return _object.counter - _object.age;
    return -1;
  }
  bool Stop() {
    if (Active && _object.age < _object.counter) {
      _object.delete();
      return true;
    }
    return false;
  }
  bool Paused = false;
 
 
 
 
 
  private jjVOIDFUNC@ _callback = null;
  private TimerVDictionaryFunction@ _callbackWithArguments;
  private dictionary@ _arguments;
  private jjOBJ@ _object;
  private int _startTime;
  private void _start(int time) {
    if (time > 0) {
      @_object = jjObjects[jjAddObject(OBJECT::BEES, -1000, -1000, 0, CREATOR::OBJECT, BEHAVIOR::BEES)];
      _object.behavior = this;
      _object.counter = time;
      _object.age = 0;
      _object.playerHandling = HANDLING::PARTICLE;
      _object.deactivates = false;
      _startTime = jjGameTicks;
    } else {
      @_object = jjObjects[0]; //avoid null pointer access
      _pickCallback();
    }
  }
  private void onBehave(jjOBJ@ obj) {
    if (!Paused && jjGameTicks > _startTime && obj is _object && ++_object.age >= _object.counter) {
      _pickCallback();
      _object.delete();
    }
  }
  private void _pickCallback() {
    if (_callback !is null)
      _callback();
    else
      _callbackWithArguments(_arguments);
  }
}

enum packet { GET_EXECUTIONED_USER }

bool gameStarted = false;

array<jjPLAYER@> aliveUsers;
jjPLAYER@ currentExecution;

jjRNG mainRNG = jjRNG();

int getRandom(int min, int max) {
    int num = mainRNG();

    if (num < 0)
        num *= -1;

    num = (num % (max - min + 1)) + min;

    return num;
}

jjPLAYER@ getRandomPlayer() {
    jjPLAYER@ user = jjPlayers[getRandom(0, jjPlayerCount)];

    return user;
}

void onLevelBegin() {
    if(jjIsServer) {
        jjConsole("[RR] Starting in 10 seconds", true);
        
        TimerV(1 * 70, function() {
            jjConsole("[RR] Started.", true);
            gameStarted = true;
        });

        TimerV(70, gameLoop);
    }
}

void gameLoop() {
    jjConsole("t");

    jjPLAYER@ user = getRandomPlayer();
    @currentExecution = @user;
    jjConsole("[RR] Player: " + user.nameUnformatted, true);
    jjConsole("[RR] " + user.nameUnformatted + ", say your last words.", true);

    dictionary@ args = {{"user", @user}};

    TimerV(10, function(argz) {
        jjPLAYER@ user;
        argz.get("user", @user);

        jjConsole("[RR] ok anyways your dead lol", true);
        user.kill();
        jjConsole("[RR] New execution starting in 5 seconds.", true);
        
        TimerV(70, gameLoop);
    }, args);
}

void onMain() {
    if(gameStarted && !jjIsServer) {
        jjSTREAM@ packet;
        packet.push(uint8(GET_EXECUTIONED_USER));
        jjSendPacket(packet);
    }
}

void onReceive(jjSTREAM &in packet, int fromClientID) {
    uint8 type;
    packet.pop(type);

    if(jjIsServer) {
        if(type == GET_EXECUTIONED_USER) {
            jjSTREAM@ packet2;
            packet2.push(uint8(GET_EXECUTIONED_USER));
            packet2.push(currentExecution.clientID);
            jjSendPacket(packet2, fromClientID);
        }
    } else {
        if(type == GET_EXECUTIONED_USER) {
            int t;
            packet.pop(t);
            @currentExecution = jjPlayers[t];
        }
    }
}

bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas) {
    if(currentExecution != null) {
        canvas.drawString(jjResolutionWidth / 2 - (currentExecution.nameUnformatted.length() * 10), jjResolutionHeight / 2, currentExecution.nameUnformatted, STRING::MEDIUM, STRING::NORMAL, 0);
    }

    return false;
}