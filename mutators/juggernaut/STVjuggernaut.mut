#pragma name "Juggernaut"
#pragma require "STVutil.asc"

#include "STVutil.asc"

// for intellisense
#include "../../scripts/STVutil.asc"

enum packet_type { GET_JUGGERNAUT,
				   SEND_JUGGERNAUT_HEALTH,
				   JUGGERNAUT_DEAD }

bool gameStarted = false;

AnimatedSprite@ juggernautPlayerSprite = AnimatedSprite(ANIM::JAZZ, 0, 0, 0, 0.25, false);
jjPLAYER @juggernautPlayer;
int juggernautHealth = 100;
bool juggernautsDeathConfirmed = false;

int timeLeft = 0;

string convertSecondsToTimeString(int seconds)
{
    int minutes = seconds / 60;
    int remainingSeconds = seconds % 60;

    // convert minutes and remaining seconds to strings
    string minuteString = formatInt(minutes, "02");
    string secondString = formatInt(remainingSeconds, "02");

    // return the formatted time string
    return minuteString + ":" + secondString;
}

void onLevelBegin()
{
	if (jjIsServer)
		selectJuggernaut();
	
	if (!jjIsServer)
	{
		jjSTREAM packet;
		packet.push(uint8(GET_JUGGERNAUT));
		jjSendPacket(packet);
	}

	jjConsole("|||Custom Mode: Juggernaut");
}

void onPlayer(jjPLAYER @player)
{
	if (gameStarted && jjIsServer)
	{
		if (juggernautPlayer.health != 7)
		{
			juggernautHealth -= (7 - juggernautPlayer.health);
			juggernautPlayer.health = 7;

			jjSTREAM healthPacket;
			healthPacket.push(int8(SEND_JUGGERNAUT_HEALTH));
			healthPacket.push(juggernautHealth);
			jjSendPacket(healthPacket);
		}

		juggernautPlayer.fastfire = 10;

		if (juggernautHealth <= 0 && !juggernautsDeathConfirmed)
		{
			juggernautsDeathConfirmed = true;
			jjConsole("[JN] The Juggernaut is dead!", true);
			selectJuggernaut();

			jjSTREAM deadPacket;
			deadPacket.push(int8(JUGGERNAUT_DEAD));
			jjSendPacket(deadPacket);
		}
	}
}

void selectJuggernaut()
{
	jjConsole("[JN] Game starting in 5 seconds.", true);

	TimerV(
		5 * 70, function() {
			jjConsole("[JN] Selecting juggernaut.", true);

			juggernautHealth = 100;

			@juggernautPlayer = getRandomPlayer();

			for (int i = 1; i < 9; i++)
			{
				juggernautPlayer.ammo[i] = 999;
			}

			juggernautPlayer.health = 7;

			gameStarted = true;
			juggernautsDeathConfirmed = false;

			jjConsole("[JN] The juggernaut is " + juggernautPlayer.nameUnformatted + ".", true);

			jjSTREAM stream;
			stream.push(int8(GET_JUGGERNAUT));
			stream.push(juggernautPlayer.playerID);
			jjSendPacket(stream);
		});
}

void onReceive(jjSTREAM &in packet, int fromClientID)
{
	if (!jjIsServer)
	{
		int8 type;
		packet.pop(type);

		if (type == GET_JUGGERNAUT)
		{
			int8 juggernautID;
			packet.pop(juggernautID);

			@juggernautPlayer = jjPlayers[juggernautID];
			gameStarted = true;
		} else if (type == SEND_JUGGERNAUT_HEALTH) {
			packet.pop(juggernautHealth);
		} else if(type == JUGGERNAUT_DEAD) {
			gameStarted = false;
		}
	}

	if (jjIsServer)
	{
		int8 type;
		packet.pop(type);

		if (type == GET_JUGGERNAUT && gameStarted)
		{
			jjSTREAM newPacket;
			newPacket.push(int8(GET_JUGGERNAUT));
			newPacket.push(juggernautPlayer.playerID);

			jjSendPacket(newPacket, fromClientID);
		}
	}
}

bool onDrawAmmo(jjPLAYER @player, jjCANVAS @canvas)
{
	if (gameStarted)
	{
		canvas.drawString(jjResolutionWidth / 2 - 150, jjResolutionHeight / 2 - 200, juggernautPlayer.nameUnformatted + ": " + juggernautHealth, STRING::SMALL, STRING::NORMAL, 0);
	}

	return false;
}

//void onDrawLayer3(jjPLAYER @player, jjCANVAS @canvas)
//{
//	canvas.drawSprite(player.xPos - 18, player.yPos, ANIM::CUSTOM[0], 0, 0, 0, SPRITE::NORMAL, 0);
//}
