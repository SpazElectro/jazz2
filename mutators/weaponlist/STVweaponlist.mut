#pragma name "Weapon List"

funcdef void TimerVDictionaryFunction(dictionary@);
class TimerV : jjBEHAVIORINTERFACE {
  TimerV(int time, jjVOIDFUNC@ callback) {
    @_callback = @callback;
    _start(time);
  }
  TimerV(int time, TimerVDictionaryFunction@ callback, dictionary@ arguments) {
    @_callbackWithArguments = @callback;
    @_arguments = @arguments;
    _start(time);
  }
  bool get_Active() const {
    return cast<jjBEHAVIORINTERFACE@>(_object.behavior) is this;
  }
  int get_Elapsed() const {
    if (Active) return _object.age;
    return -1;
  }
  int get_Total() const {
    if (Active) return _object.counter;
    return -1;
  }
  int get_Remaining() const {
    if (Active) return _object.counter - _object.age;
    return -1;
  }
  bool Stop() {
    if (Active && _object.age < _object.counter) {
      _object.delete();
      return true;
    }
    return false;
  }
  bool Paused = false;
 
 
 
 
 
  private jjVOIDFUNC@ _callback = null;
  private TimerVDictionaryFunction@ _callbackWithArguments;
  private dictionary@ _arguments;
  private jjOBJ@ _object;
  private int _startTime;
  private void _start(int time) {
    if (time > 0) {
      @_object = jjObjects[jjAddObject(OBJECT::BEES, -1000, -1000, 0, CREATOR::OBJECT, BEHAVIOR::BEES)];
      _object.behavior = this;
      _object.counter = time;
      _object.age = 0;
      _object.playerHandling = HANDLING::PARTICLE;
      _object.deactivates = false;
      _startTime = jjGameTicks;
    } else {
      @_object = jjObjects[0]; //avoid null pointer access
      _pickCallback();
    }
  }
  private void onBehave(jjOBJ@ obj) {
    if (!Paused && jjGameTicks > _startTime && obj is _object && ++_object.age >= _object.counter) {
      _pickCallback();
      _object.delete();
    }
  }
  private void _pickCallback() {
    if (_callback !is null)
      _callback();
    else
      _callbackWithArguments(_arguments);
  }
}

class AnimatedSprite
{
    int id;
    float frame;
    int frame_count;
    int x;
    int y;
    float anim_speed;
    bool can_reverse;
    bool reverse = false;
    bool visible = true;
    ANIM::Set animSet = ANIM::AMMO;

    AnimatedSprite(int id, int frame, int frame_count, int x, int y, float anim_speed, bool can_reverse)
    {
        this.id = id;
        this.frame = frame;
        this.frame_count = frame_count;
        this.x = x;
        this.y = y;
        this.anim_speed = anim_speed;
        this.can_reverse = can_reverse;
    }

    void setVisible(bool visible)
    {
        this.visible = visible;
    }

    void setAnimSet(ANIM::Set animSet)
    {
        this.animSet = animSet;
    }

    void setId(int id)
    {
        this.id = id;
    }

    void setFrameCount(int frame_count)
    {
        this.frame_count = frame_count;
    }

    void update()
    {
        if(this.reverse == false) {
            this.frame += this.anim_speed;
        } else {
            this.frame -= this.anim_speed;
        }

        if (this.frame > this.frame_count)
        {
            if(this.can_reverse == true) {
                this.reverse = not this.reverse;
            } else {
                this.frame = 0;
            }
        }

        if(this.frame <= 0)
        {
            if(this.can_reverse == true) {
                this.reverse = not this.reverse;
            } else {
                this.frame = 0;
            }
        }
    }

    void draw(jjCANVAS@ canvas)
    {
        if(this.visible) {
            canvas.drawSprite(this.x, this.y, this.animSet, this.id, this.frame, 0, SPRITE::NORMAL, 123);
        }
    }
}

class Key
{
    string id;
    int code;

    Key(string id, int code)
    {
        this.id = id;
        this.code = code;
    }
}

class Button
{
	MenuButton@ mainButton;
	bool debounce = false;
	int horizontalId = 0;

	Button(int horizontalId)
	{
		this.horizontalId = horizontalId;
	}

	bool checkCollision(int sourceX, int sourceY, int sourceWidth, int sourceHeight, int targetX, int targetY, int targetWidth, int targetHeight)
	{
		if(sourceX + sourceWidth > targetX && sourceX < targetX + targetWidth && sourceY + sourceHeight > targetY && sourceY < targetY + targetHeight)
		{
			return true;
		} else { return false; }
	}

	void input(jjPLAYER@ player) {
		if(jjKey[0x01] && this.debounce == false) {
			if(checkCollision(
				jjResolutionWidth / 2 + 100 + (horizontalId * 50),
				jjResolutionHeight / 2 - 165 + ((this.mainButton.id + 1) * 50),
				50, 50,
				jjMouseX, jjMouseY,
				1, 1
			)) {
				this.debounce = true;
				mainButton.setValue(not this.mainButton.value);
				dictionary dict = {{"main", @this}};

				this.mainButton.callback();
				
				TimerV(10, function(this) {
					Button@ t;
					this.get("main", @t);
					t.debounce = false;
				}, dict);
			}
		}
	}

	void draw(jjCANVAS@ canvas) {
		canvas.drawRectangle(jjResolutionWidth / 2 + 100 + (horizontalId * 50), jjResolutionHeight / 2 - 165 + ((this.mainButton.id + 1) * 50), 25, 25, 0, SPRITE::NORMAL, 0);
		canvas.drawRectangle(jjResolutionWidth / 2 + 6 + 100 + (horizontalId * 50), jjResolutionHeight / 2 - 159 + ((this.mainButton.id + 1) * 50), 12, 12, getColorValue(this.mainButton.value), SPRITE::NORMAL, 0);

		if(this.mainButton.showText) canvas.drawString(jjResolutionWidth / 2 - 275, jjResolutionHeight / 2 - 150 + ((this.mainButton.id + 1) * 50), this.mainButton.text, STRING::MEDIUM, STRING::NORMAL, 0);
	}
}

class MenuButton
{
	string text;
	int x;
	int y;
	int width;
	int height;
	int id;
	bool value;
	bool debounce;
	bool showText = true;
	jjVOIDFUNC@ callback;
	array<Button@> buttons;

	MenuButton(string text, int id, array<Button@> buttons, jjVOIDFUNC@ callback)
	{
		this.text = text;
		this.id = id;
		this.buttons = buttons;
		@this.callback = @callback;

		for(int i = 0; i < this.buttons.length(); i++) {
			Button@ button = this.buttons[i];
			@button.mainButton = @this;
		}
	}

	void setValue(bool value)
	{
		this.value = value;
	}

	void draw(jjCANVAS@ canvas) {
		for(int i = 0; i < this.buttons.length(); i++) {
			this.buttons[i].draw(canvas);
		}
	}

	void input(jjPLAYER@ player) {
		for(int i = 0; i < this.buttons.length(); i++) {
			this.buttons[i].input(player);
		}
	}
}

array<Button@> fdsaadsf = {Button(1)};

array<MenuButton@> menu_buttons = {
	MenuButton("Show Index", -1, fdsaadsf, function() {
		showIndex = not showIndex;
		save();
	})

	// MenuButton("Horizontal", 0, function() {
	// 	horizontal = not horizontal;
	// 	save();
	// }),

	// MenuButton("Color Index", 1, function() {
	// 	index_color = not index_color;
	// 	save();
	// }),

	// MenuButton("Color Ammo", 2, function() {
	// 	ammo_color = not ammo_color;
	// 	save();
	// }),

	// MenuButton("Show Empty Ammo", 3, function() {
	// 	show_empty_ammo = not show_empty_ammo;
	// 	save();
	// }),

	// MenuButton("Index font size", 4, function() {
	// 	if(index_fontsize == "small") { index_fontsize = "medium"; } else if(index_fontsize == "medium") { index_fontsize = "small"; }
	// 	save();
	// }),

	// MenuButton("Ammo font size", 5, function() {
	// 	if(ammo_fontsize == "small") { ammo_fontsize = "medium"; } else if(ammo_fontsize == "medium") { ammo_fontsize = "small"; }
	// 	save();
	// })
};

array<Key@> KEYS = {
  Key("F2", 0x71),
  Key("F5", 0x74),
  Key("F6", 0x75),
  Key("F7", 0x76),
  Key("F10", 0x79),
  Key("F11", 0x7A),
  Key("Insert", 0x2D),
  Key("Home", 0x24),
  Key("PageUp", 0x21),
  Key("Delete", 0x2E),
  Key("End", 0x23),
  Key("PageDown", 0x22),
  Key("Colon", 0xBA),
  Key("QuotationMark", 0xDE),
  Key("Backspace", 0x08),
  Key("Backslash", 0xDC),
  Key("Backquote", 0xC0), // default
  Key("BracketLeft", 0xDB),
  Key("BracketRight", 0xDD),
  Key("Comma", 0xBC),
  Key("Minus", 0xBD),
  Key("Period", 0xBE),
  Key("Slash", 0xBF),
  Key("Plus", 0xBB),
  Key("Shift", 0x10),
  Key("Alt", 0x12),
  Key("Control", 0x11),
  Key("Tab", 0x09),
  Key("Caps Lock", 0x14),
  Key("Space", 0x20),
  Key("Up", 0x26),
  Key("Down", 0x28),
  Key("Left", 0x25),
  Key("Right", 0x27),
  Key("NumpadSlash", 0x6F),
  Key("NumpadAsterisk", 0x6A),
  Key("NumpadMinus", 0x6D),
  Key("NumpadPlus", 0x6B),
  Key("Numpad1", 0x61),
  Key("Numpad2", 0x62),
  Key("Numpad3", 0x63),
  Key("Numpad4", 0x64),
  Key("Numpad5", 0x65),
  Key("Numpad6", 0x66),
  Key("Numpad7", 0x67),
  Key("Numpad8", 0x68),
  Key("Numpad9", 0x69),
  Key("Numpad0", 0x60),
  Key("NumpadPeriod", 0x6E),
  Key("0", 0x30),
  Key("1", 0x31),
  Key("2", 0x32),
  Key("3", 0x33),
  Key("4", 0x34),
  Key("5", 0x35),
  Key("6", 0x36),
  Key("7", 0x37),
  Key("8", 0x38),
  Key("9", 0x39),
  Key("A", 0x41),
  Key("B", 0x42),
  Key("C", 0x43),
  Key("D", 0x44),
  Key("E", 0x45),
  Key("F", 0x46),
  Key("G", 0x47),
  Key("H", 0x48),
  Key("I", 0x49),
  Key("J", 0x4A),
  Key("K", 0x4B),
  Key("L", 0x4C),
  Key("M", 0x4D),
  Key("N", 0x4E),
  Key("O", 0x4F),
  Key("P", 0x50),
  Key("Q", 0x51),
  Key("R", 0x52),
  Key("S", 0x53),
  Key("T", 0x54),
  Key("U", 0x55),
  Key("V", 0x56),
  Key("W", 0x57),
  Key("X", 0x58),
  Key("Y", 0x59),
  Key("Z", 0x5A),
};

string data_filename = "WLdata_data.asdat";

int originX = jjResolutionWidth;
int originY = jjResolutionHeight - 15;

int verticalX = jjResolutionWidth - 85;
int horizontalY = jjResolutionHeight - 15;

AnimatedSprite@ bouncer = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);
AnimatedSprite@ ice = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);
AnimatedSprite@ seeker = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);
AnimatedSprite@ rf = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);
AnimatedSprite@ toaster = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);
AnimatedSprite@ tnt = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);
AnimatedSprite@ fireball = AnimatedSprite(0, 0, 9, 0, 0, 0.25, false);
AnimatedSprite@ electroblaster = AnimatedSprite(0, 0, 10, 0, 0, 0.25, false);

bool horizontal = false;

bool show = true;
bool showIndex = true;
bool showMenu = false;
bool showMenuDebounce = false;

bool showSplitscreenWarning = false;
bool splitscreenWarning_triggered = false;

bool holdingTilde = false;

bool ammo_color = true;
bool index_color = true;

bool show_empty_ammo = true;

bool binding = false;
int bind_open = 192;
string mode = "hold";
string index_fontsize = "small";
string ammo_fontsize = "small";

array<int> unupgradedIds;
array<int> upgradedIds;

STRING::Size string_size_to_size(string str) {
	if(str == "small" or str == "tiny") {
		return STRING::SMALL;
	} else if(str == "medium") {
		return STRING::MEDIUM;
	} else if(str == "large" or str == "big") {
		return STRING::LARGE;
	}
	return STRING::MEDIUM;
}

void save() {
    jjSTREAM file();
    file.push(mode);
    file.push(showIndex);
    file.push(horizontal);
    file.push(index_color);
    file.push(ammo_color);
    file.push(show_empty_ammo);
    file.push(bind_open);
	file.push(index_fontsize);
	file.push(ammo_fontsize);
    file.save(data_filename);
}

void onLevelBegin() {
    jjSTREAM file(data_filename);
    file.pop(mode);
    file.pop(showIndex);
    file.pop(horizontal);
    file.pop(index_color);
    file.pop(ammo_color);
    file.pop(show_empty_ammo);
    file.pop(bind_open);
	file.pop(index_fontsize);
	file.pop(ammo_fontsize);

	// menu stuff
	bool m_index_fontsize = false;

	if(index_fontsize == "medium") {
		m_index_fontsize = true;
	}

	bool m_ammo_fontsize = false;

	if(ammo_fontsize == "medium") {
		m_ammo_fontsize = true;
	}

	menu_buttons[0].setValue(showIndex);
	// menu_buttons[1].setValue(horizontal);
	// menu_buttons[2].setValue(index_color);
	// menu_buttons[3].setValue(ammo_color);
	// menu_buttons[4].setValue(show_empty_ammo);
	// menu_buttons[5].setValue(m_index_fontsize);
	// menu_buttons[6].setValue(m_ammo_fontsize);

    if(mode == "") mode = "toggle";
    if(bind_open == 0) bind_open = 192;
	if(index_fontsize == "") index_fontsize = "small";
	if(ammo_fontsize == "") ammo_fontsize = "small";

    jjConsole("[WL] Type ! wl help for a list of commands.");

    // hardcoded stuff
    unupgradedIds.insertLast(25); // bouncer
    unupgradedIds.insertLast(29); // ice
    unupgradedIds.insertLast(34); // seeker
    unupgradedIds.insertLast(49); // rf
    unupgradedIds.insertLast(57); // toaster
    unupgradedIds.insertLast(59); // tnt
    unupgradedIds.insertLast(62); // fireball
    unupgradedIds.insertLast(68); // electroblaster

    upgradedIds.insertLast(24); // bouncer
    upgradedIds.insertLast(28); // ice
    upgradedIds.insertLast(33); // seeker
    upgradedIds.insertLast(48); // rf
    upgradedIds.insertLast(56); // toaster
    upgradedIds.insertLast(59); // tnt
    upgradedIds.insertLast(61); // fireball
    upgradedIds.insertLast(67); // electroblaster

	if(jjLocalPlayerCount > 1) {
		show = false;

        showSplitscreenWarning = true;
        splitscreenWarning_triggered = true;

        TimerV(300, function() {
        	showSplitscreenWarning = false;
        });
	}

    for (int i = 2; i < 10; i++)
    {
        AnimatedSprite@ weapon = idToWeapon(i);
        weapon.x = 0;
        weapon.y = 0;
        
        if(horizontal) {
            weapon.x = (originX - (i * 75));
            weapon.y = horizontalY;
        } else {
            weapon.x = verticalX;
            weapon.y = (originY - (i * 35)) + 25;
        }
    }
}

bool upgraded(jjPLAYER@ player, int id) {
    return player.powerup[id];
}

AnimatedSprite@ idToWeapon(int id) {
    if(id == 3) return ice;
    if(id == 4) return seeker;
    if(id == 5) return rf;
    if(id == 6) return toaster;
    if(id == 7) return tnt;
    if(id == 8) return fireball;
    if(id == 9) return electroblaster;

    return bouncer;
}

void onPlayer(jjPLAYER@ player) {
    for (uint i = 2; i < 10; i++)
    {
        if(upgraded(player, i)) {
            idToWeapon(i).setId(upgradedIds[i - 2]);
        } else {
            idToWeapon(i).setId(unupgradedIds[i - 2]);
        }
    }
}

void onPlayerInput(jjPLAYER@ player) {
	mouseInput(player);

    if(binding) {
		if(jjKey[0x1B]) { // ESC
			binding = false;
			jjConsole("[WL] Cancelled binding.");
		}

        for (uint i = 0; i < KEYS.length() - 1; i++)
        {
            Key@ key = KEYS[i];

            if(jjKey[key.code]) {
                bind_open = key.code;

                jjConsole("[WL] Binded to \"" + key.id + "\".");
                
                binding = false;
                save();
            }

        }
    }

	if(jjKey[0x70] && not showMenuDebounce) { // f1
		showMenu = not showMenu;
		showMenuDebounce = true;

		TimerV(15, function() {
            showMenuDebounce = false;
        });
	}

    if(mode == "toggle") {
        if(jjKey[bind_open] && not holdingTilde) {
            show = not show;
            holdingTilde = true;

            TimerV(15, function() {
                holdingTilde = false;
            });
        }
    } else if(mode == "hold") {
        if(jjKey[bind_open]) {
            show = true;
        } else {
            show = false;
        }
    } else {
        // unknown mode, so we'll set it to true always
        show = true;
    }
}

void onMain() {
	originX = jjResolutionWidth;
	originY = jjResolutionHeight - 15;

	verticalX = jjResolutionWidth - 85;
	horizontalY = jjResolutionHeight - 15;

    for (int i = 2; i < 10; i++)
    {
        AnimatedSprite@ weapon = idToWeapon(i);
        weapon.x = 0;
        weapon.y = 0;
        
        if(horizontal) {
            weapon.x = (originX - (i * 75));
            weapon.y = horizontalY;
        } else {
            weapon.x = verticalX;
            weapon.y = (originY - (i * 35)) + 25;
        }
    }

    bouncer.update();
    ice.update();
    seeker.update();
    rf.update();
    toaster.update();
    tnt.update();
    fireball.update();
    electroblaster.update();
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {    
    if(chatType != CHAT::NORMAL) return false;
    
    if(stringReceived == "!wl help" or stringReceived == "!wl help 1") {
        jjConsole("-----------------------------------------------------");
        jjConsole("! wl help 1-3 - Shows a help message");
        jjConsole("! wl position - Changes the position of the weapon list");
        jjConsole("! wl toggle - Sets the weapon list to Toggle mode");
        jjConsole("! wl hold - Sets the weapon list to Hold mode");
        jjConsole("-----------------------------------------------------");
        return true;
    }

    if(stringReceived == "!wl help 2") {
        jjConsole("-----------------------------------------------------");
        jjConsole("! wl index - Show the weapons' index");
        jjConsole("! wl color ammo - Changes the ammo color");
        jjConsole("! wl color index - Changes the index color");
        jjConsole("! wl bind - Binds the weapon list to a key");
        // jjConsole("! wl mode - Shows the current weapon list mode"); // useless
        jjConsole("-----------------------------------------------------");
        return true;
    }

    if(stringReceived == "!wl help 3") {
        jjConsole("-----------------------------------------------------");
        jjConsole("! wl emptyammo - Toggles whether to show empty ammo or show all ammo");
		jjConsole("! wl size index - Switch between small and medium sizes");
		jjConsole("! wl size ammo - Switch between small and medium sizes");
        jjConsole("-----------------------------------------------------");
        return true;
    }

	if(stringReceived == "!wl size index") {
		if(index_fontsize == "small") {
			index_fontsize = "medium";
			jjConsole("[WL] Index font size set to medium.");
		} else {
			index_fontsize = "small";
			jjConsole("[WL] Index font size set to small.");
		}
		
		save();
		return true;
	}

	if(stringReceived == "!wl size ammo") {
		if(ammo_fontsize == "small") {
			ammo_fontsize = "medium";
			jjConsole("[WL] Ammo font size set to medium.");
		} else {
			ammo_fontsize = "small";
			jjConsole("[WL] Ammo font size set to small.");
		}
		
		save();
		return true;
	}

    if(stringReceived == "!wl emptyammo") {
        show_empty_ammo = not show_empty_ammo;

        jjConsole("[WL] Showing " + (show_empty_ammo ? "empty" : "all") + " ammo.");

        save();

        return true;
    }

    if(stringReceived == "!wl bind") {
        binding = true;
        jjConsole("[WL] Press a key to bind the weapon list to it.");
        return true;
    }

    // if(stringReceived == "!wl mode") { // useless
    //     jjConsole("[WL] Weapon list mode is currently " + (mode == "toggle" ? "Toggle" : "Hold"));
    //     return true;
    // }

    if(stringReceived == "!wl toggle") {
        mode = "toggle";
        show = true;
        jjConsole("[WL] Set the weapon mode to Toggle");

		save();

        return true;
    }

    if(stringReceived == "!wl hold") {
        mode = "hold";
        jjConsole("[WL] Set the weapon mode to Hold");
        save();
        return true;
    }

    if(stringReceived == "!wl index") {
        showIndex = not showIndex;
        jjConsole("[WL] " + (showIndex ? "Showing" : "Hiding") + " the weapons' index");
        
        save();
        return true;
    }

    if(stringReceived == "!wl position") {
        horizontal = not horizontal;
        jjConsole("[WL] The weapons' list is now " + (horizontal ? "Horizontal" : "Vertical"));
        
        save();
        return true;
    }

    if(stringReceived == "!wl color index") {
        index_color = not index_color;
        jjConsole("[WL] Changed the weapons' index color to " + (index_color ? "colorful" : "normal"));

        save();
        return true;
    }

    if(stringReceived == "!wl color ammo") {
        ammo_color = not ammo_color;
        jjConsole("[WL] Changed the weapons' ammo color to " + (ammo_color ? "colorful" : "normal"));

        save();
        return true;
    }

    if(stringReceived.findFirst("!wl") == 0) {
        jjConsole("[WL] Invalid command."); return true;
    }

    return false;
}

int getColorValue(string mode) {
	if(mode == "hold") {
		return 0;
	} else { return 255; }
}

int getColorValue(bool boolean) {
	if(boolean) {
		return 255;
	} else {
		return 0;
	}
}

bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas)
{
    if(show) {
        if(player.ammo[2] > 0 or show_empty_ammo) bouncer.draw(canvas);
        if(player.ammo[3] > 0 or show_empty_ammo) ice.draw(canvas);
        if(player.ammo[4] > 0 or show_empty_ammo) seeker.draw(canvas);
        if(player.ammo[5] > 0 or show_empty_ammo) rf.draw(canvas);
        if(player.ammo[6] > 0 or show_empty_ammo) toaster.draw(canvas);
        if(player.ammo[7] > 0 or show_empty_ammo) tnt.draw(canvas);
        if(player.ammo[8] > 0 or show_empty_ammo) fireball.draw(canvas);
        if(player.ammo[9] > 0 or show_empty_ammo) electroblaster.draw(canvas);
        string coloring = "";

        for (uint i = 2; i < 10; i++)
        {
            if(player.ammo[i] <= 0 and !show_empty_ammo) continue;

            int x = 0;
            int y = 0;
            int indexX = 0;
            int indexY = 0;

            coloring = coloring + "|";

            if(horizontal) {
                x = (originX - (i * 75)) + 15;
                y = horizontalY;
                indexX = (originX - (i * 75)) - 20;
                indexY = horizontalY - 5;
            } else {
                x = verticalX;
                y = (originY - (i * 35)) + 35;
                indexX = verticalX - 20;
                indexY = (originY - (i * 35)) + 25 - 5;
            }

            if(showIndex)
                canvas.drawString(indexX, indexY, (index_color ? coloring : "") + i, string_size_to_size(index_fontsize), STRING::NORMAL, 0);

            canvas.drawString(x, y, (ammo_color ? coloring : "") + "x" + player.ammo[i], string_size_to_size(ammo_fontsize), STRING::NORMAL, 0);
        }

    }

	// menu
	if(showMenu) {
		canvas.drawRectangle(jjResolutionWidth / 2 - 300, jjResolutionHeight / 2 - 200, 600, 400, 255, SPRITE::BLEND_NORMAL, 128);
		canvas.drawString(jjResolutionWidth / 2 - 300 + 10, jjResolutionHeight / 2 - 200 + 10, "Weapon List", string_size_to_size("medium"), STRING::NORMAL, 0);

		for(uint i = 0; i < menu_buttons.length(); i++) {
			MenuButton@ button = menu_buttons[i];
			button.draw(canvas);
		}

		canvas.drawRectangle(jjMouseX - 10, jjMouseY - 10, 10, 10, 18, SPRITE::NORMAL, 0);
	}

    if(binding) canvas.drawString(jjResolutionWidth / 3, jjResolutionHeight / 2, "Binding... (press a key)", STRING::SMALL, STRING::NORMAL, 0);
    if(showSplitscreenWarning) canvas.drawString(jjResolutionWidth / 6, jjResolutionHeight / 8, "Splitscreen is not compatible with the weapon list mutator", STRING::SMALL, STRING::NORMAL, 0);

    return false;
}

void mouseInput(jjPLAYER@ player) {
	for(uint i = 0; i < menu_buttons.length(); i++) {
		MenuButton@ button = menu_buttons[i];
		button.input(player);
	}
}