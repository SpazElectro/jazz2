#pragma name "perlinnoisetest"
#pragma require "STVutil.asc"

#include "STVutil.asc"

// for intellisense
#include "../../scripts/STVutil.asc"

class PerlinNoise {
    array<int> permutation;
    
    PerlinNoise(int seed) {
        permutation.resize(512);
        for (int i = 0; i < 256; ++i) {
            permutation[i] = i;
        }
        
        // Shuffle the permutation array using the provided seed
        for (int i = 0; i < 256; ++i) {
            int j = seed & 255;
            seed >>= 8;
            swap(permutation[i], permutation[j]);
        }
        
        // Duplicate the permutation array to avoid buffer overflow
        for (int i = 256; i < 512; ++i) {
            permutation[i] = permutation[i - 256];
        }
    }
    
    float fade(float t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    
    float lerp(float t, float a, float b) {
        return (1.0 - t) * a + t * b;
    }
    
    float grad(int hash, float x, float y) {
        int h = hash & 15;
        float u = h < 8 ? x : y;
        float v = h < 4 ? y : (h == 12 || h == 14) ? x : 0.0;
        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    }
    
    float noise(float x, float y) {
        int X = int(floor(x)) & 255;
        int Y = int(floor(y)) & 255;
        
        x -= floor(x);
        y -= floor(y);
        
        float u = fade(x);
        float v = fade(y);
        
        int A = permutation[X] + Y;
        int B = permutation[X + 1] + Y;
        
        return lerp(v, lerp(u, grad(permutation[A], x, y), grad(permutation[B], x - 1, y)),
                       lerp(u, grad(permutation[A + 1], x, y - 1), grad(permutation[B + 1], x - 1, y - 1)));
    }
}

PerlinNoise@ noiseGenerator = PerlinNoise(256);

void onLevelBegin() {
    jjConsole("Started!");
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {
    jjConsole("A: " + noiseGenerator.noise(2, 2));
    return false;
}