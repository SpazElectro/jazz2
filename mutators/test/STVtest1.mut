funcdef void TimerVDictionaryFunction(dictionary@);
class TimerV : jjBEHAVIORINTERFACE {
  TimerV(int time, jjVOIDFUNC@ callback) {
    @_callback = @callback;
    _start(time);
  }
  TimerV(int time, TimerVDictionaryFunction@ callback, dictionary@ arguments) {
    @_callbackWithArguments = @callback;
    @_arguments = @arguments;
    _start(time);
  }
  bool get_Active() const {
    return cast<jjBEHAVIORINTERFACE@>(_object.behavior) is this;
  }
  int get_Elapsed() const {
    if (Active) return _object.age;
    return -1;
  }
  int get_Total() const {
    if (Active) return _object.counter;
    return -1;
  }
  int get_Remaining() const {
    if (Active) return _object.counter - _object.age;
    return -1;
  }
  bool Stop() {
    if (Active && _object.age < _object.counter) {
      _object.delete();
      return true;
    }
    return false;
  }
  bool Paused = false;
 
 
 
 
 
  private jjVOIDFUNC@ _callback = null;
  private TimerVDictionaryFunction@ _callbackWithArguments;
  private dictionary@ _arguments;
  private jjOBJ@ _object;
  private int _startTime;
  private void _start(int time) {
    if (time > 0) {
      @_object = jjObjects[jjAddObject(OBJECT::BEES, -1000, -1000, 0, CREATOR::OBJECT, BEHAVIOR::BEES)];
      _object.behavior = this;
      _object.counter = time;
      _object.age = 0;
      _object.playerHandling = HANDLING::PARTICLE;
      _object.deactivates = false;
      _startTime = jjGameTicks;
    } else {
      @_object = jjObjects[0]; //avoid null pointer access
      _pickCallback();
    }
  }
  private void onBehave(jjOBJ@ obj) {
    if (!Paused && jjGameTicks > _startTime && obj is _object && ++_object.age >= _object.counter) {
      _pickCallback();
      _object.delete();
    }
  }
  private void _pickCallback() {
    if (_callback !is null)
      _callback();
    else
      _callbackWithArguments(_arguments);
  }
}

bool alive = true;
bool gameStarted = false;

jjRNG mainRNG = jjRNG();
jjPLAYER@ impostor;

enum packet_type { SET_DEAD, IS_IMPOSTOR }

void log(string message) {
    jjConsole("[AU] " + message);
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {
    if(!alive) {
        log("Your dead, you can't talk.");
        return true;
    }

    return false;
}

void onMain() {
    if(jjMouseAim == false) {
        jjChat("/mouseaim on");
    }
}

void onPlayer(jjPLAYER@ player) {
    player.fly = FLIGHT::FLYCARROT;
    player.ySpeed = 0;

    if(@impostor != @null) {
        if(player.clientID == impostor.clientID) {
            player.noFire = false;
        } else {
            player.noFire = true;
        }
    } else {
        player.noFire = true;
    }
}

void onLevelBegin() {
    if(jjIsServer) {
        dictionary@ n = {{"num", 10}};

        timerTick(n);
    }
}

void onRoast(jjPLAYER@ victim, jjPLAYER@ killer) {
    // making sure an impostor isn't trying to be the impostor
    // see what i did there *drumroll*
    if(killer.clientID == impostor.clientID) {
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        jjConsole("                                     ");
        

        jjSTREAM packet;
        packet.push(uint8(SET_DEAD));
        packet.push(victim.clientID);
        jjSendPacket(packet, victim.clientID);
    }
}

void timerTick(dictionary@ n) {
    int second;
    n.get("num", second);

    if(second == 0) {
        jjPLAYER@ player = getRandomPlayer();
        @impostor = @player;

        jjSTREAM packet;
        packet.push(uint8(IS_IMPOSTOR));
        jjSendPacket(packet, impostor.clientID);

        log("The game has started.");
        gameStarted = true;
        return;
    }

    dictionary@ num = {{"num", second}};

    TimerV(70, function(num) {
        int second;
        num.get("num", second);
        log("Starting in " + second + " seconds...");
        
        dictionary@ newNum = {{"num", second - 1}};

        timerTick(newNum);
    }, num);
}

void onReceive(jjSTREAM &in packet, int fromClientID) {
    uint8 type;
    packet.pop(type);

    if(type == SET_DEAD) {
        int userId;
        packet.pop(userId);

        jjPLAYER@ user = jjPlayers[userId];
        log("Killed by " + user.nameUnformatted);

        alive = false;
    } else if(type == IS_IMPOSTOR) {
        @impostor = @jjLocalPlayers[0];

        log("You're the impostor.");
    }
}

int getRandom(int min, int max) {
    int num = mainRNG();

    if (num < 0)
        num *= -1;

    num = (num % (max - min + 1)) + min;

    return num;
}

int getPlayerCount() {
	int count = 0;

	for (int i = 0; i < 32; i++) {
		if (jjPlayers[i].isActive)
			count++;
	}

	return count;
}

jjPLAYER@ getRandomPlayer() {
    jjPLAYER@ user = jjPlayers[getRandom(0, getPlayerCount())];

    if(user.isActive and !user.isOut)
        return user;
    else
        return getRandomPlayer();
}