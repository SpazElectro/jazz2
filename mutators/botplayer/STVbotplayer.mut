funcdef void TimerVDictionaryFunction(dictionary @);
class TimerV : jjBEHAVIORINTERFACE
{
  TimerV(int time, jjVOIDFUNC @callback)
  {
    @_callback = @callback;
    _start(time);
  }
  TimerV(int time, TimerVDictionaryFunction @callback, dictionary @arguments)
  {
    @_callbackWithArguments = @callback;
    @_arguments = @arguments;
    _start(time);
  }
  bool get_Active() const
  {
    return cast<jjBEHAVIORINTERFACE @>(_object.behavior) is this;
  }
  int get_Elapsed() const
  {
    if (Active)
      return _object.age;
    return -1;
  }
  int get_Total() const
  {
    if (Active)
      return _object.counter;
    return -1;
  }
  int get_Remaining() const
  {
    if (Active)
      return _object.counter - _object.age;
    return -1;
  }
  bool Stop()
  {
    if (Active && _object.age < _object.counter)
    {
      _object.delete();
      return true;
    }
    return false;
  }
  bool Paused = false;

private
  jjVOIDFUNC @_callback = null;
private
  TimerVDictionaryFunction @_callbackWithArguments;
private
  dictionary @_arguments;
private
  jjOBJ @_object;
private
  int _startTime;
private
  void _start(int time)
  {
    if (time > 0)
    {
      @_object = jjObjects[jjAddObject(OBJECT::BEES, -1000, -1000, 0, CREATOR::OBJECT, BEHAVIOR::BEES)];
      _object.behavior = this;
      _object.counter = time;
      _object.age = 0;
      _object.playerHandling = HANDLING::PARTICLE;
      _object.deactivates = false;
      _startTime = jjGameTicks;
    }
    else
    {
      @_object = jjObjects[0]; // avoid null pointer access
      _pickCallback();
    }
  }
private
  void onBehave(jjOBJ @obj)
  {
    if (!Paused && jjGameTicks > _startTime && obj is _object && ++_object.age >= _object.counter)
    {
      _pickCallback();
      _object.delete();
    }
  }
private
  void _pickCallback()
  {
    if (_callback !is null)
      _callback();
    else
      _callbackWithArguments(_arguments);
  }
}

bool botOn = false;

void onLevelBegin()
{
  jjConsole("load bot thing alsdlkjafslkjafd");
}

void onPlayer(jjPLAYER @player)
{
  if (botOn)
  {
    player.keyJump = true;

    int lowestDistance = 99999;
    int lowestDistanceIndex = 0;

    for (int i = 0; i < 32; i++)
    {
      jjPLAYER @datPlayer = jjPlayers[i];

      if (datPlayer.isActive && datPlayer.health != 0 && datPlayer.team != player.team)
      {
        int distance = (player.xPos - datPlayer.xPos) + (player.yPos - datPlayer.yPos);

        if (distance < lowestDistance)
        {
          lowestDistance = distance;
          lowestDistanceIndex = i;
        }
      }
    }

    if (lowestDistance < 10)
    {
      player.keyFire = true;
    }

    int both = 0;
    int xblueflag;
    int yblueflag;
    int xredflag;
    int yredflag;

    for (uint i = 0; i < jjObjectCount; i++)
    {
      if (jjObjects[i].eventID == OBJECT::CTFBASE)
      {
        int flagId = jjParameterGet(int(jjObjects[i].xPos / 32), int(jjObjects[i].yPos / 32), 0, 1);

        if (flagId == 0)
        {
          xblueflag = int(jjObjects[i].xPos / 32);
          yblueflag = int(jjObjects[i].yPos / 32);

          both++;
        }
        else if (flagId == 1)
        {
          xredflag = int(jjObjects[i].xPos / 32);
          yredflag = int(jjObjects[i].yPos / 32);

          both++;
        }

        if (both == 2)
          break;
      }
    }

    if (both != 2)
    {
      jjPLAYER @datPlayer = jjPlayers[lowestDistanceIndex];
      player.direction = datPlayer.xPos > player.xPos ? 1 : -1;
      if (player.direction == 1)
        player.keyRight = true;
      else
        player.keyLeft = true;
    }
    else
    {
      player.direction = xblueflag > player.xPos ? 1 : -1;
      if (player.direction == 1)
        player.keyRight = true;
      else
        player.keyLeft = true;
    }
  }
}

void startBot()
{
  jjConsole("[BOT] Starting bot");

  botOn = !botOn;

  jjConsole("[BOT] Bot started");
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType)
{
  if (stringReceived == "!bot")
  {
    startBot();
    return true;
  }

  return false;
}