#pragma name "pixelmaptest"
#pragma require "STVutil.asc"

#include "STVutil.asc"

class Track
{
    float fCurvature;
    float fDistance;

    Track(float fCurvature, float fDistance) {
        this.fCurvature = fCurvature;
        this.fDistance = fDistance;
    }
};

float fDistance = 0.0f;
float fCurvature = 0.0f;
float fPlayerCurvature = 0.0f;
float fPlayerPos = 0.0f;

array<Track@> vecTrack;

int screenWidth = 800;
int screenHeight = 600;
jjPIXELMAP@ pixelMap = jjPIXELMAP(screenWidth, screenHeight);
ANIM::Set playerAnimation = ANIM::SPAZ3D;
AnimatedSprite@ playerSprite = AnimatedSprite(
    0, 0, 0,
    int(screenHeight * 0.8),
    0.25, false);

void onLevelBegin()
{
    vecTrack.insertLast(Track(0.0f, 10.0f));		// Short section for start/finish line
    vecTrack.insertLast(Track(0.0f, 200.0f));
    vecTrack.insertLast(Track(1.0f, 200.0f));
    vecTrack.insertLast(Track(0.0f, 400.0f));
    vecTrack.insertLast(Track(-1.0f, 100.0f));
    vecTrack.insertLast(Track(0.0f, 200.0f));
    vecTrack.insertLast(Track(-1.0f, 200.0f));
    vecTrack.insertLast(Track(1.0f, 200.0f));
    vecTrack.insertLast(Track(0.0f, 200.0f));
    vecTrack.insertLast(Track(0.2f, 500.0f));
    vecTrack.insertLast(Track(0.0f, 200.0f));

    playerSprite.animSet = playerAnimation;
    playerSprite.xScale = 1;
    playerSprite.yScale = 1;

    jjAnimSets[playerAnimation].load();

    updateFrame();
}

void updateFrame(bool drawRoad = true, bool drawSky = true)
{
    const float halfScreenHeight = screenHeight/2;

    if (drawSky)
    {
        for (int y = 0; y < halfScreenHeight; y++)
            for (int x = 0; x < screenWidth; x++)
                pixelMap[x, y] = y > halfScreenHeight / 16 ? 34 : 33;
    }

    for (int y = 0; y < halfScreenHeight; y++)
    {
        float perspective = y / halfScreenHeight;
        float middlePoint = 0.5f + fCurvature * pow(1.0f - perspective, 3);
        float roadWidth = 0.1f + perspective * 0.8f;
        float clipWidth = roadWidth * 0.15f;
        roadWidth *= 0.5f;

        float leftGrass = (middlePoint - roadWidth - clipWidth) * screenWidth;
        float leftClip = (middlePoint - roadWidth) * screenWidth;
        float rightClip = (middlePoint + roadWidth) * screenWidth;
        float rightGrass = (middlePoint + roadWidth + clipWidth) * screenWidth;
        int row = int(halfScreenHeight + y);
        int grassColor = sin(20.0f * pow(1.0f - perspective, 3) + fDistance * 0.1f) > 0.0f ? 17 : 18;
        int clipColor = sin(80.0f * pow(1.0f - perspective, 2) + fDistance) > 0.0f ? 25 : 15;

        for (int x = 0; x < screenWidth; x++)
        {
            if (x < leftGrass)
                pixelMap[x, row] = grassColor;
            else if (x < leftClip && drawRoad)
                pixelMap[x, row] = clipColor;
            else if (x < rightClip && drawRoad)
                pixelMap[x, row] = 73;
            else if (x < rightGrass && drawRoad)
                pixelMap[x, row] = clipColor;
            else
                pixelMap[x, row] = grassColor;
        }
    }
}

const int updateFrequency = 2;

void onMain()
{
    if (jjGameTicks % updateFrequency == 0)
    {
        float fOffset = 0;
        uint nTrackSection = 0;

        while(
            nTrackSection < vecTrack.length() &&
            fOffset <= fDistance
        ) {
            fOffset += vecTrack[nTrackSection].fDistance;
            nTrackSection++;
        }

        float fTargetCurvature = vecTrack[nTrackSection - 1].fCurvature;
        float fTrackCurveDiff = (fTargetCurvature - fCurvature);

        // Apply interpolation for smoother transition
        const float interpolationRate = 0.1f;
        fCurvature += fTrackCurveDiff * interpolationRate;

        if (jjP.keyUp)
            fDistance += 10.0f;
        else if (jjP.keyDown)
            fDistance -= 10.0f;

        if (jjP.keyRight)
            fPlayerCurvature += 0.05f;
        if (jjP.keyLeft)
            fPlayerCurvature -= 0.05f;
        
        if(fPlayerCurvature > 0.5f)
            fPlayerCurvature = 0.5f;
        if(fPlayerCurvature < -0.5f)
            fPlayerCurvature = -0.5f;

        // if(jjP.keyUp || jjP.keyDown)
        updateFrame(true, false);    
    }

    playerSprite.id = jjP.keyUp || jjP.keyDown ? 3 : 0;
    playerSprite.update();
}

bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ screen)
{
    pixelMap.save(jjAnimFrames[jjAnimations[jjAnimSets[ANIM::CUSTOM[0]].firstAnim].firstFrame + 1]);
    screen.drawSprite(0, 0, ANIM::CUSTOM[0], 1, 0);

    fPlayerPos = fPlayerCurvature;

    const float nPlayerPos = screenWidth / 2 + (screenWidth * fPlayerPos) / 2;
    playerSprite.x = int(nPlayerPos);
    playerSprite.draw(screen);

    screen.drawString(0, 10, "fDistance: " + fDistance);
    screen.drawString(0, 30, "fCurvature: " + fCurvature);
    screen.drawString(0, 50, "fPlayerCurvature: " + fPlayerCurvature);
    screen.drawString(0, 70, "fPlayerPos: " + fPlayerPos);
    screen.drawString(0, 90, "nPlayerPos: " + nPlayerPos);
    screen.drawString(0, 110, "FPS: " + jjFPS);

    return true;
}
