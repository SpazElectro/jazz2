#pragma require "STVutil.asc"
#include "STVutil.asc"

bool isRecording = false;

bool isWatching = false;
string watching = "";

// middle of watching
int watch_playerCount;
int watch_spectating;

jjSTREAM recordStream;
jjSTREAM watchStream;

int playerHeaderLength = 7;

array<FakePlayer@> fakePlayers;

class FakePlayer {
    string name;

    float xPos, yPos;
    
    uint curAnim, curFrame;
    uint fur;

    int direction;

    FakePlayer() {}
};

void onLevelBegin() {
    jjConsole("Mutator started!");
}

void onMain() {
    if(isRecording) {
        for (int i = 0; i < 32; i++)
        {
            jjPLAYER@ player = jjPlayers[i];

            if (player.isActive) {
                recordStream.push(player.name);
                
                recordStream.push(formatFloat(player.xPos));
                recordStream.push(formatFloat(player.yPos));
                
                recordStream.push(formatUInt(player.curAnim));
                recordStream.push(formatUInt(player.curFrame));

                recordStream.push(formatUInt(player.fur));
                recordStream.push(formatInt(player.direction));
            }
	    }
    }

    if(isWatching) {
        for (int i = 0; i < watch_playerCount; i++)
        {
            FakePlayer@ player = fakePlayers[i];

            array<string> items;
            items.resize(playerHeaderLength);

            watchStream.pop(items[0]);

            if(items[0] == "EOF") {
                isWatching = false;
                watching = "";
                watchStream.clear();

                fakePlayers.removeRange(0, watch_playerCount);

                jjConsole("Watched to the end!");
                break;
            } else if(items[0] == "CHAT_MESSAGE__________") {
                string sender;
                string message;
                watchStream.pop(sender);
                watchStream.pop(message);
                
                jjConsole("[REPLAY] " + sender + ": " + message);
                
                return;
            }

            watchStream.pop(items[1]);
            watchStream.pop(items[2]);
            watchStream.pop(items[3]);
            watchStream.pop(items[4]);
            watchStream.pop(items[5]);
            watchStream.pop(items[6]);

            player.name = items[0];
            player.xPos = parseFloat(items[1]);
            player.yPos = parseFloat(items[2]);
            player.curAnim = parseUInt(items[3]);
            player.curFrame = parseUInt(items[4]);
            player.fur = parseUInt(items[5]);
            player.direction = parseInt(items[6]);
	    }
    }
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {
    if(stringReceived == "!record") {
        if(isWatching) { jjConsole("You're already watching a recording, you can't record and watch at the same time!"); return true; }
        if(isRecording) { jjConsole("You're already recording!"); return true; }

        jjConsole("Started recording!");
        
        isRecording = true;
        recordStream = jjSTREAM();
        
        // player count
        recordStream.push(getPlayerCount());

        return true;
    } else if(stringReceived == "!stop") {
        jjConsole("Stopped recording!");

        isRecording = false;

        for (uint i = 0; i < playerHeaderLength * 2; i++)
        {
            recordStream.push("EOF");
        }
        
        recordStream.save("STVrecording_1.asdat");
        recordStream.clear();
        return true;
    } else if(stringReceived == "!watch") {
        if(isRecording) { jjConsole("You're already recording, you can't watch and record at the same time!"); return true; }
        if(isWatching) { jjConsole("You're already watching a recording!"); return true; }

        jjConsole("Started watching the recording!");
        
        isWatching = true;
        watching = "STVrecording_1.asdat";
        
        watchStream = jjSTREAM(watching);
        watchStream.pop(watch_playerCount);

        for (int i = 0; i < watch_playerCount; i++)
        {
            fakePlayers.insertLast(FakePlayer());
        }

        return true;
    }

    // watch commands
    if(stringReceived.findFirst("!spectate") == 0) {
        int toSpectate = parseInt(stringReceived.split(" ")[0]);
        watch_spectating = toSpectate;
    }


    return false;
}

void onChat(int clientID, string &in stringReceived, CHAT::Type chatType) {
    if(isRecording) {
        recordStream.push("CHAT_MESSAGE__________");
        recordStream.push(jjPlayers[clientID].nameUnformatted);
        recordStream.push(stringReceived);
    }
}

void onDrawLayer4(jjPLAYER@ player, jjCANVAS@ canvas) {
    for (uint fpI = 0; fpI < fakePlayers.length; fpI++)
    {
        FakePlayer@ fplayer = fakePlayers[fpI];

        canvas.drawString(
            int(fplayer.xPos) - jjGetStringWidth(fplayer.name, STRING::SMALL, normalTextAppearance) / 2,
            int(fplayer.yPos) - 30, fplayer.name
        );

        canvas.drawSpriteFromCurFrame(
            int(fplayer.xPos), int(fplayer.yPos),
            uint(fplayer.curFrame), int8(fplayer.direction)
        );
    }
}
