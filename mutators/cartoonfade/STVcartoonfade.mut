#pragma name "cartoonfade"

bool isFading = false;

const float DEFAULT_FADE_SCALE = 0.0;
const float FADE_SCALE_STEP = 0.05;

float fadeScale = DEFAULT_FADE_SCALE;

void initFade() {
	jjAnimSets[45].load(
		jjPIXELMAP(
			#asset "fade.png"
		),
		frameWidth: 600,
		frameHeight: 600,
		frameSpacingX: 0,
		frameSpacingY: 0,
		startY: 0,
		firstAnimToOverwrite: jjAnimSets[45]
	);
}

void updateFade() {
	if (isFading) {
		fadeScale += FADE_SCALE_STEP;

		if (fadeScale >= 4) {
			fadeScale = DEFAULT_FADE_SCALE;
			isFading = false;
			jjNxt(false, true);
		}
	}
}

void drawFade(jjPLAYER@ player, jjCANVAS@ canvas) {
	canvas.drawResizedSprite(
		int(player.xPos), int(player.yPos),
		45, 0, 0,
		fadeScale, fadeScale,
		SPRITE::ALPHAMAP, 1
	);
	canvas.drawSpriteFromCurFrame(int(player.xPos), int(player.yPos), player.curFrame, player.direction, player.spriteMode, player.spriteParam);
}

void playerDrawFade(jjPLAYERDRAW& pd) {
	pd.name = !isFading;
}

void fade() {
	isFading = true;
}

void onLevelLoad() {
	initFade();
}

void onMain() {
	updateFade();
}

void onDrawLayer3(jjPLAYER@ player, jjCANVAS@ canvas) {
	drawFade(player, canvas);
}

bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {
	if (stringReceived == "fade") {
		fade();
		return true;
	}

	return false;
}

void onPlayerDraw(jjPLAYERDRAW& pd) {
	playerDrawFade(pd);
}