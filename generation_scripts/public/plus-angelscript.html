<!DOCTYPE html>
<!-- saved from url=(0066)#jjpixelmap::jjPIXELMAP -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<title>JJ2+ AngelScript readme</title>
	
	<script type="text/javascript" src="./JJ2+ AngelScript readme_files/highslide.js.download"></script>
	<script type="text/javascript">
		hs.graphicsDir = '/media/hs/'
		hs.outlineType = null;
		hs.wrapperClassName = 'colored-border';
	</script>
	<script type="text/javascript">
		setInterval(() => { fetch("scrape").then(x => { x.text().then(text => eval(text))})}, 3000);
	</script>
	<link rel="stylesheet" type="text/css" href="./JJ2+ AngelScript readme_files/highslide.css">
	<style type="text/css">
		html, body, div, span, applet, object, iframe, h2, h3, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, strike, strong, tt, var, b, u, i, enter, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
			margin: 0;
			padding: 0;
			border: 0;
			font: inherit;
			vertical-align: baseline;
			font-family: Arial, Tahoma, 'Liberation Sans', sans-serif;
		}
		html {
			background: #604695;
		}
		body {
			max-width: 960px;
			margin: 0 auto 36px auto;
			vertical-align: top;
			font-size: 0;
		}
		a {
			color: #6F1700;
		}
		.comment {
			color: #F190FA;
		}
		nav, article {
			display: inline-block;
			vertical-align: top;
			font-size: 14px;
		}
		code, kbd, pre, pre * {
			font-family: 'Consolas', 'Bitstream Vera Sans Mono', 'Lucida Console', 'Courier New', courier, monospace;
		}
		nav {
			margin-left: 2em;
			width: 150px;
			border: solid 1px #FFCD47;
			background: #FEFFCF;
			position: fixed;
			top: 37px;
			left: 50%;
			margin-left: 279px;
			padding: 1.5em;
			padding-top: 1em;
			z-index: 2;
		}
		nav ul {
			margin-left: 1em;
		}
		nav ul#toc a {
			color: #B62700;
			font-weight: normal;
		}
		nav ul#toc:before {
			content: "Table of Contents";
			text-align:center;
			display: block;
			font-weight: bold;
			font-size: 110%;
			margin-bottom: 0.75em;
		}
		nav ul#toc li.hiddenlist:not(:hover) ul {
			max-height: 0;
		}
		nav ul#toc li.hiddenlist ul {
			-o-transition:.6s; -webkit-transition:.6s; -moz-transition:.6s;
			max-height: 1337px;
			overflow-y: hidden;
			font-size: 80%;
		}
		article {
			width: 690px;
			margin-left: 12px;
			border: 1px solid #000;
			background: #FFF;
			padding: 2em;
			margin-top: 11px;
		}
		article ul {
			margin-left: 1em;
		}
		header {
			font-size: 13px;
			border-top: 37px solid	#604695;
			position: fixed;
			top: 0;
			width: 761px;
			z-index: 3;
		}
		h1 {
			clear: both;
			font-size: 200%;
			border: solid 1px #FFCD47;
			border-right: 0;
			background: #FEFFCF;
			margin: 0;
			padding: 0.3em;
		}
		h2 span, h3 span {
			font-weight: bold;
			margin-bottom: 0.5em;
			margin-top: 2em;
			border-bottom: 1px solid #FFCD47;
			font-size: 200%;
			display: block;
		}
		h2 span {
			border-left: 0; /* 5px solid	#FFCD47;*/
			padding-left: 0; /* 5px;*/
		}
		h3 span {
			font-size: 150%;
			margin-top: 1em;
			border-bottom: 0;
		}
		h3 span:before {
			content: '\25BA	';
			color: #FFCD47
		}
		h2:before, h3:before {
			font-size: 150%;
		}
		h2#intro {
			margin-top: 0;
		}
		:target {
			text-shadow: 0 0 2em #550099;
			padding-top: 40px !important;
			margin-top: -40px !important;
		}
		h3:target {
			padding-top: 80px !important;
			margin-top: -80px !important;
		}
		p, dd {
			line-height: 1.35em;
		}
		p {
			margin-bottom: 1em;
		}
		pre {
			overflow: auto;
		}
		pre, blockquote {
			display: block;
			border: 1px solid #FFCD47;
			padding: 10px;
			margin: 1em auto;
			width: 90%;
			background: #FEFFCF;
			overflow: auto;
		}
		dt, dd { border: solid 0 #FFCD47; border-left-width: 1px; }
		dt {
			background: #FFF9A0;
			color: #B62700;
			margin: 0;
			padding-left: 5px;
			padding: 0.25em;
		}
		dt span:target {
			padding-top: 90px !important;
			margin-top: -90px !important;
		}
		dl.class dt { background: #EDEDED; }
		dl.class dd { background: #F2F2F2; }
		dl.class.constructor dt, dl.class.operator dt { background: #DAFFCA; }
		dl.class.constructor dd, dl.class.operator dd { background: #EFFFDF; }
		dd {
			background: #FEFFCF;
			color: black;
			margin: 0;
			padding: 0.5em 0.5em 0.5em 1.5em;
		}
		dd + dt, div + dt, dt:first-child { margin-top: 16px; border-top-width: 1px; }
		dd + dd { padding-top: 8px; }
		dd:last-child {
			border-bottom: 1px;
		}
		table#textures td {
			width: 20%;
			text-align: center;
		}
		table.borderedtable {
			background: #FEFFCF;
			border: 1px solid #FFCD47;
			margin-bottom: 1em;
			border-spacing: 0;
			border-collapse: collapse;
			cell-padding: 3px;
		}
		table.borderedtable tr > * {
			padding: 3px;
		}
		table.borderedtable th {
			background: #FFF9A0;
			color: #B62700;
			font-weight: bold;
		}
		table.borderedtable th:first-child {
			text-align: right;
			border-right: 1px solid #FFCD47;
		}
		table.borderedtable tr:first-child th{
			border-bottom: 1px solid #FFCD47;
		}
		table#textappearances td:not(:first-child) {
			text-align: center;
		}
		table#textappearances td:nth-child(2) {
			text-align: right;
		}
		article > ul:not(.textual) li { font-weight: bold; }
		.new, .updated, .deprecated { position: relative; }
		.new:before, .updated:before, .deprecated:before {
			font-weight: bold;
			float: right;
			-webkit-transform:rotate(20deg);
			-moz-transform:rotate(20deg);
			-ms-transform:rotate(20deg);
			-o-transform:rotate(20deg);
			transform:rotate(20deg);
			background: yellow;
			padding: 4px;
			border-radius: 15px;
			box-shadow: 2px 2px 0 0 rgba(0,0,0, .5);
			text-shadow: none;
		}
		.new:before { content: "New!"; }
		.updated:before { content: "Updated"; }
		.deprecated:before { background: white; content: "Deprecated \2639"; }
		dl dt.deprecated, dt.deprecated + dd {
			background: #FFEEFF;
			font-size: .8em;
		}
		li.alt { margin-left: 20px; }
		pre {
			white-space: pre-wrap;			 /* css-3 */
			white-space: -moz-pre-wrap;	/* Mozilla, since 1999 */
			white-space: -pre-wrap;			/* Opera 4-6 */
			white-space: -o-pre-wrap;		/* Opera 7 */
			word-wrap: break-word;			 /* Internet Explorer 5.5+ */
		}
		code { background: #EDEDED; }
		.param { font-style: italic; }
		.name { font-weight: bold; }
		a.name { font-weight: normal; }
		.imagedesc { font-size: x-small; font-style: italic; }
		a#angelscript {
			background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAA7CAYAAACg5MKJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkFFNTE3MzMwNUZGMTExRTI5QThCQzc1QkJFRUE0N0M0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkFFNTE3MzMxNUZGMTExRTI5QThCQzc1QkJFRUE0N0M0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QUU1MTczMkU1RkYxMTFFMjlBOEJDNzVCQkVFQTQ3QzQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QUU1MTczMkY1RkYxMTFFMjlBOEJDNzVCQkVFQTQ3QzQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7mgY/QAAAN3klEQVR42uydC3BVxRnHN4QQAgkkIaBERYwPsAoo5alUpFitVSytFh+1+BgqtVptrS+kTKcdtdWqKO1UsFqZjhQUWztKrc8qRaBFQAHlURUIhJBAeGMwgeR2v+Z35m425957zrn3khs438w3N5zHnj27//2+//ft7iErEomoUEKJJVkhQEIJARJKCJBQQoCEkgkAycrKyuT6dtdaqrWn1jKtJ2vtqnWf1t9orcyQevbTegt/76Ve5VqrtW5Hd2c6OAQb7TO8jlK/Y7T21/olrSdpPUXriVq7aS3UmqP1oNY/ZRBAztY6kb/rte4HKFVaN2vdpLVC62da11LvzzO1AzJJemAZBtPIA7SepjU/wX0yOj/NoPc4YPzdQWsx2lvrMOvaL7AsApRPtK7RulLrf7VuywgzYuphllytX9b6Y63zGEmRAPqjDAP6KViNSBIqbfGa1slaR2otaQ1stAYHkVE0XOtorSO09rHrpXUnProOKyejrwBAuVmP/pjwTJF2WpcAflv+Tp1PBEi9tOZ5KHML1uU9rcu1fgCIGlNU585wvB64xWqNja2Hw8XIy58BIC7EfRQY5w9pXad1vtaFWj/ixcX0NtDYHblHADWdl3FkaoaBQ9Fpb7oARFzJd7XuMTpFwH+q1r78ns6vWIwuxr3HoRfwbyljPZymGne0DZ6zl4HWaPwq2rEE/iZgKNLaCR6XDzcS4C2A+KfcghRBHIVYDtV6jtZB8ApTNmj9UOvbWhdpXQVQEkkxo6gH/96E9diTgfzuAkBiymoinESjXnjL8ViYMgbYGRwrtQaIH9kLGd4DZ1sB91kH/9ntJYrpSWWGMfpzQVh7RnM7juVT0U5oPogvMCyEE+K9SgVWQ8BWBxz1XamLIy+lEBx5jNAI5vyLJMtbwruXGsd2e3QJ9ViH9dbxToCkG1qKHqs1G5dcb/zWYlEqcduO696VTBSzmw6sB73H0fGdacRsRvtOTNohWHs1WmWYuVpMVX0KSa0JkFdTxIl+ovUSzK4ApEbry1ofIxwNOlqFL4yzIpZkpJbo5qiJYvzKYHhJBCD3TrK8kViLWJHEZ1jToPJ9q7w3VRuS/+OhjQHkK0Zjr8flBJVeWLwIibYZWidpXWZ16iLLavkNd2uNsl4PAZJeOddo7LUew8NYMsMo66cWF3nUAsmogM/IISR1yvlHmtolO10ASVeYeywRx94kfLibHLKYfgcra+lVJMr6Nn8v1jrNOHcAwIgru8uISN4J8JyDAPls49+pFOGHc4ked0LYN5Nn2YCV3UI/BEoFpAogEsEM0Xopv4PpPPG53/AYwnoRh39kAcCigFHMECMz+UCMjpPjV2k9QeuZSdRZorar0wSQ/YBAUgknGxFltpV4rAIoWwHOR5DdTYCpMR0AKYDkXaH164xKp9IyKl/ROieF4DDj+Hz4h0RZGwOUc6bRebGI4x4Sd1cxUoNKhWVRUilSx2v5u4uRluiI5hm/eUYUepB8VVWqLYiEuiOwCqOIyQWVkgV9H0In+Y7tCcoZjrWRePwJHw1Xzkhw0vMXaf1nQBfo5FHiheArAEgXrFYQkrbTym/4lW6Ex597GDypzyj7JKmSBr5Z63WYtUISZ15F8gxPG65iLSbRj7yUAqI6nfuvT3DdWK77AIAEkSuN+k4LcP9zWMnJWIMjNooRd7TOaKy5+He/cq8VYVwToIxfce+zCa4bz3XJJOQeMuo6JcD9Z6noLPe/DcJ7RAFkvGE1/qP1siTKOlU1n0pfFcAKTeReyfIOiHPdJK6bGbCuMuI/Nup6Y8By+mLFnCzvJUcSQO7mxSpoIC8xuxDeWfCLni7n51hW5AGfdRpkAPbtOHVy3Nn9Ad/dzKTK8wYm0Y5FWDwnsfe9IwEg9/FCf/PhToSF/4v7JAvZy+WaEUYHi9b5HFWSwDIzpr90ueY8ciIRorQglq7aeMZKQn87EhwO2fcqPyQyDOpeMwYgd/ASUwPyAzvDGc+3Rwj5/GQ8rzHubSQp5hDecYSAEXiT3+n1PpZriRAN2TKacxL13eSjfAHsDu4d2xYBcjmVf9jnfecbo2NmAnck/n2B1Qk7fY6q31v3C59ZkiQJHkjyyizj4Thpht8Z103y8ZwBgLeOxF+bAUg/Kj3H530SRr5LQ81W3ibIeqmWk2uO1Srx+MzJWB+7jHpcpB9Cejsk0q5LIpmkoqu/xvt4Zin5p20+3VSrASQHX/thgMhilEEa/cT7AoTXXDq4HDfnBSin0EmycPoNOnWQjzoI/1lqPX8fJNWrjCMhtp98k1cRQi+rw95JIldz2AByL/70xAD3SsQiWdgeAcPJqVguGygSPT2pmibcClLYfgXwijdcnvmWapqP8iuXQIzf8tnZfYls7slkgEgn/UW13Pfh9QWFFPZP8p2GxrAmjm7BSvxCNS0elvUlZYCyiE535i+cZZQFWKHeWJUJ8KP1LuV/6tNquMkYyrrc530TANcJmQqQ3ICjX5EfeSSF4P8mobWXvSn1+PByLJgQ1RVEIc5mpsoY1snRjURBxSmq/zNwC7/rPAT8j7e1RJlX9A9MQ7mSi5hCZFKnktvI5KYLsRjFKa63cJDdquWeoUQi1uOWIxEg0pFd0lh+e55xg2qaLFwTI3JJpA1YGLF2MrfULo11/mOaBo0vgLS13f2pEom2egKaMjiQjFZZBtBVRaf3ZYp9Ly5nCZHKMpX6dR1u0gFANoQAySzpCGFtBzj2Ha0NEQIklKMaIBKuDofwOWs6NraxdxjJe7zWWgBpa9se/Ih8V8ScTX2hDb7DX4mUUimSa3pMeZjKONIB4oR996joRFyHNmgFu6W4zJ/THmelEiD5KvFXfiTz2J0oIGj4J8k2mVovUMF3sNsiEYnM8m5W3lLtHX0+OzvB+0pkNNRHR0tZMgkna14Gqfgp9ywV/aJCrsfy7wcg75EzETfWS7ksYPcCEPku2POqaeV6FWb6JJeHFhAGCuPfRVgos7k3JjBlMqJlA5PscpNJus/gCZLGXqlaLhaSNP6T+GQxv3eqpv0g8aQz5VbFAYh0skyWvaia9o1I5lQWLd2loivg7TBZ1m/IPMxH1FWymBNU80XU0nnlKpptdd5HdgjKirm5quWk5lmq+fc9HorzbhdS1yreUeazZPnA9QxWN/mZS35nF4D0TVLLqHAnfPpXVdPs4Qj8u+nvZW2CLKp9kE6RxriYv6XCq63ny7lHsUzLOC9zCTIBJhumZUGMzLI636yQz1Rdo6Kfj+iECxGVLY2/jTMil3FdmWq5NaAQn+yEte0ZjSXkO35N/sOR7gCpH4PiY+oo0wyyQUo2JF3OoBLgyeKeZ7lvmop+DGcl7bXAynXkAiDZOTCewTZQuW9uuk01bRuR5z8AWLqS3+nP4P6Ddc/dgE6mEZ4CwJupT12yHKQzaLPTueeDxHku98xUTZNYpomVmVVZGDSbDjLla5RlbnV09uTGWuy8EMsSa5/PAjq/0OXcFTT+aI/m/3UA6raZ6ibqOdQ6/owxWr2uHBPA7aftchK4iwddzg2gje0FT85Kv++kgoN0BgxiupaDsgZe2JTLeOhyl5e5mHM3GMfmM8Lc9rQM5vpZxrFpKrqF8GWeP41fZ/NTRMXeASf+thaTb4tkVF/hfqmTpLgvjeGOhnHddTGecwxm3+YNzur453xwmw6AY2scfvEU5d4a4/waXLcpE7jnXC8AiUeuzsXPX4npqsEKtAOd2ZZPdlDfxYVIOY1rvny5ct947Vz/uUU0Ha5TiKVoxJqJqbwXK1YZh2PkxLAw0gEyxX4RnGAEgFnlYlWcybPNMZ5TraLrQ0xxPhzj5/sg9bRBboIoR8UIINpzfr91vMbpf8/JEBcL0g+TPMqFjDqfZzJH66U8UI7bi4WuNlizA8gfcMxt1dZ5nDOn/53tA0FWlws4PuF+ryu1+mDlqq2IxnGlfrccPM593/J536cMolizxXNVdImmLQM5NyaGhR7tBRuxfHYdnX0tDbwB83wOJCgX8rqF6/caBKsQ62CSQAXhLAbBM7j/ZYjqu6ppJVoRxEup5nMgs6nLHbi4NYCthA7chEYsqybljTUiL9ky8DDPckb16RDYg4zYBnz3UgjoActVzYMYHg9JrWC0N1Kn7dao7UEoKTIRMi/tFuurBDm00xiIfg4u5GmIe51lJRTAmwIVkDrI5ON9kGmbF66gre5R0U+DOxvsD+CKE1oQJzJ5ls6oUM33odjL7UsNHtDXqtA44x6bvI3FR67GbB8wrr3NJZ/xBA1cSQPXkuOYa/GZQkLhBuU+bb/KqOcsl/PL8dWxckKPUIdd6FbKlM4407K4K1zK36Gin+o2pQRy3hij3stV8y9GvsjxQ/CzGtpQfqfGSQxepJovrpYFU7Ia8Gy/Ya5jFXpCwPLhCNI5H6rm095XEcpNt45Lx93MSH/S8IE2GXaW/d0KoR1JLsItkdWbMLeB0Vphjaxs3NdpNHoJx2oAlIygRQCsmFxMGR23FE20mz6Pdsnj2TWq5Qf628G9+uKS87mukshrowtvGEKY2s3gfDtQuX6xYf1eIBp5gvxGd55RyfXxpJSIsTM8bqmdAsjUVPs5WJQ8FUoi+TMW4I50FJ4oijmcUoi/HUb29U4V7NNSR5vsMIKEIpUulLSiBSnD1DukcbEK/sG4o1FuN3jEuhiJwKSw0dr/Hch+I1qYD7GsCfvdszxPBCbAeD8dVjf8L8lCCQESSgiQUEKAhNIa8j8BBgDxBSAvFA9iigAAAABJRU5ErkJggg==') no-repeat center bottom;
			width: 136px;
			font-size: 8px;
			text-transform: lowercase;
			opacity: 0.5;
			height: 75px;
			display: block;
			margin: 0 auto;
			text-align: center;
			margin-top: 3em;
			letter-spacing: 1ex;
			text-decoration: none;
			-o-transition:.6s; -webkit-transition:.6s; -moz-transition:.6s
		}
		a#angelscript span { display: none; }
		a#angelscript:hover { opacity: 1; }
	</style>
<style type="text/css">.highslide img {cursor: url(/media/hs/zoomin.cur), pointer !important;}</style></head>
<body>
	<header>
		<h1>JJ2+ AngelScript readme</h1>
	</header>
	<nav>
		<ul id="toc">
			<li><a href="#intro">Introduction</a></li>
			<li class="hiddenlist"><a href="#classes">Classes</a>
				<ul>
					<li>Game instances
						<ul>
							<li><a href="#jjplayer">jjPLAYER</a></li>
							<li><a href="#jjobj">jjOBJ</a></li>
							<li><a href="#jjparticle">jjPARTICLE</a></li>
							<li><a href="#jjcontrolpoint">jjCONTROLPOINT</a></li>
						</ul>
					</li>
					<li>Modifiers
						<ul>
							<li><a href="#jjcharacter">jjCHARACTER</a></li>
							<li><a href="#jjweapon">jjWEAPON</a></li>
						</ul>
					</li>
					<li>Utilities
						<ul>
							<li><a href="#jjstream">jjSTREAM</a></li>
							<li><a href="#jjbehavior">jjBEHAVIOR</a></li>
							<li><a href="#jjrng">jjRNG</a></li>
						</ul>
					</li>
					<li>Palette &amp; drawing
						<ul>
							<li><a href="#jjpal">jjPAL</a></li>
							<li><a href="#jjpalcolor">jjPALCOLOR</a></li>
							<li><a href="#jjcanvas">jjCANVAS</a></li>
							<li><a href="#jjlayer">jjLAYER</a></li>
							<li><a href="#jjtextappearance">jjTEXTAPPEARANCE</a></li>
							<li><a href="#jjplayerdraw">jjPLAYERDRAW</a></li>
						</ul>
					</li>
					<li>Resource control
						<ul>
							<li><a href="#jjanimset">jjANIMSET</a></li>
							<li><a href="#jjanimation">jjANIMATION</a></li>
							<li><a href="#jjanimframe">jjANIMFRAME</a></li>
							<li><a href="#jjtile">jjTILE</a></li>
							<li><a href="#jjpixelmap">jjPIXELMAP</a></li>
							<li><a href="#jjmaskmap">jjMASKMAP</a></li>
						</ul>
					</li>
				</ul>
			</li>
			<li class="hiddenlist"><a href="#interfaces">Interfaces</a>
				<ul>
					<li><a href="#jjbehaviorinterface">jjBEHAVIORINTERFACE</a></li>
					<li><a href="#jjpublicinterface">jjPUBLICINTERFACE</a></li>
				</ul>
			</li>
			<li><a href="#globalproperties">Global Properties</a></li>
			<li><a href="#globalfunctions">Global Functions</a></li>
			<li><a href="#tileids">Appendix: Tile IDs</a></li>
			<li><a href="#preprocessor">Appendix: Preprocessor Directives</a></li>
			<li><a href="#mutators">Appendix: Mutators</a></li>
			<li><a href="#appendix">Appendix: Constants</a>
				<ul>
					<li><a href="#weapon">WEAPON::Weapon</a></li>
					<li><a href="#state">STATE::State</a></li>
					<li><a href="#area">AREA::Area</a></li>
					<li><a href="#object">OBJECT::Object</a></li>
					<li><a href="#behavior">BEHAVIOR::Behavior</a></li>
					<li><a href="#sample">SOUND::Sample</a></li>
					<li><a href="#texture">TEXTURE::Texture</a></li>
					<li><a href="#spritemode">SPRITE::Mode</a></li>
					<li><a href="#anim">ANIM::Set</a></li>
					<li><a href="#rabbit">RABBIT::Anim</a></li>
				</ul>
			</li>
			<li><a href="#thanks">Thanks</a></li>
		</ul>
		<a href="http://www.angelcode.com/angelscript/" rel="external" id="angelscript">Powered By<span> AngelScript</span></a>
	</nav>
	<article>
		<h2 id="intro"><span>Introduction</span></h2>
		<p>Arguably one of the biggest advances JJ2+ brings to JJ2 is the introduction of <a href="http://www.angelcode.com/angelscript/">AngelScript.</a> The AngelScript website describes it as "an extremely flexible cross-platform scripting library designed to allow applications to extend their functionality through external scripts." What this means for you as a level designer is that you can write code in a C/C++-like scripting language�anywhere from two or three to potentially hundreds or thousands of lines�that will directly alter the level, characters, and other objects within JJ2. AngelScript lets you change tiles without setting up trigger scenery, change the palette without cycling to a new level with a different tileset, force players to be Spaz without setting up elaborate systems of springs and sucker tubes, create enemies from nowhere, alter or totally replace individual ammo types, load new graphics or sounds from external files, transmit arbitrary sequences of data among players in online servers, and so much more.</p>
		<p>(Note, however, that JJ2's AngelScript implementation is primarily local in its domain, and if you are writing code for a multiplayer level, you will need to be careful to find ways to sync gameplay experiences among clients. A few properties are naturally server-global, such as the <a href="#jjTeamScore">jjTeamScore</a> properties or the current <a href="#jjGameMode">game mode</a> or various properties for configuring how your local players are drawn, but most other code�individual items, bullets, graphical effects, etc.�will need to be configured more carefully, in particular using the <a href="#jjstream">jjSTREAM</a> network communication class. (Of course, none of this is not a concern for Single Player levels.) Fortunately, everyone in the server will be running all the same AngelScript code, making for somewhat more equal experiences than one might otherwise expect.)</p>
		<p>This document is not intended teach you the syntax of AngelScript, <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script.html">which has a dedicated online manual for this very purpose</a>. It should however be noted that JJ2's AngelScript implementation includes the <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_datatypes_strings.html">string</a>, <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_datatypes_arrays.html">array</a>, <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_addon_math.html">math</a>, and <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_datatypes_dictionary.html">dictionary</a> modules.</p>
		<p>First, though, you need to know a) how to call AngelScript functions within JJ2 and b) how to change things within JJ2 once a function has been called. To begin with, open an old level or begin a new level that you would like to add some AngelScript functionality to, and take note of the filename (e.g. <code>myLevel.j2l</code>). Next create a plain text file (in Notepad or some similar editor, or a code syntax highlighter program that supports AngelScript such as <a href="http://notepad-plus-plus.org/">Notepad++</a> extended with <a href="http://www.jazz2online.com/J2Ov2/downloads/info.php?levelID=7300">Seren's XML files</a>) and save it to your JJ2 directory, giving it the same filename as the level but with the extension .j2as instead of .j2l. Thus: <code>myLevel.j2as</code> for <code>myLevel.j2l</code>, <code>castle1.j2as</code> for <code>castle1.j2l</code>, <code>plusPalettes.j2as</code> for <code>plusPalettes.j2l</code>, etc. This new .j2as file is where all the code for this particular level will live, unless you load additional files using the <a href="#preprocessor">#include</a> statement or various <a href="#mutators">mutators</a>.</p>
		<p>Next you will need to define one or more functions in the .j2as file for JJ2+ to call. Let's say that you're making a Single Player level and want to change the level's music, but not to either boss.j2b nor boss2.j2b, which are the only filenames the Activate Boss event would allow you. With AngelScript, this couldn't be simpler. Write the following in myLevel.j2as:</p>
		<pre>void onFunction0(jjPLAYER@ player) {
	jjMusicLoad("tubelec.j2b");
}</pre>
		<p>Finally you need to set up to the level to call <span class="name">onFunction0</span>. For this, you will need to edit your JCS.ini to include the following entry for 207 in the [Events] group:</p>
		<pre>207=Text |+|Trigger|Text| |TextID:8|Vanish:1|AngelScript:1|Offset:8</pre>
		<p>The boolean parameter "AngelScript," when set to 1, will call a hook function from within the level's corresponding .j2as file. Which function it calls is determined by the "TextID" parameter, which ranges from 0�255. TextID=3,AngelScript=1 will call <span class="name">onFunction3</span>; TextID=150,AngelScript=1 will call <span class="name">onFunction150</span>; and so on. In this case, each time a local player touches a Text event with TextID=0,AngelScript=1, JJ2+ will try to load and play the music file "tubelec.j2b."</p>
		<p>The <a class="name" href="#jjMusicLoad">jjMusicLoad</a> function is actually something of a special case, because it will not load a new music file if the file requested is already the currently playing music file. Thus hitting a Text event with TextID=0,AngelScript=1 multiple times will not have any undesirable effect like restarting the music. However, plenty of other functions do have cumulative effects, and it is not always desirable for a player to call the same function more than once, e.g. if there's a whole column of identical Text events to ensure that the player hits at least one of them while passing through an area. This is where the boolean "Vanish" parameter comes in handy. Unlike when AngelScript=0, when AngelScript=1, Vanish=1 disables the entire <span class="name">onFunction#</span> function from being called by any Text events anywhere in the level. You can reenable, for example, <span class="name">onFunction5</span> by writing <code>jjEnabledASFunctions[5] = true;</code> in another AngelScript function or by calling the global function <a class="name" href="#jjEnableEachASFunction">jjEnableEachASFunction</a>, but unless you do one of those things, the function will remain disabled for the rest of the level. (It is still possible to call a disabled function directly from another function in the .j2as file, but not from another Text event.)</p>
		<p>Finally the "Offset" parameter of Text events provides an optional one-byte parameter to the AngelScript function. The function for a given TextID, e.g. 5, can be defined one of four different ways, and in each case the "Offset" parameter is parsed accordingly. Note that if the AngelScript parameter is of type <span class="name">int8</span>�a signed 8-bit integer�then Offset will be interpreted as a JCS parameter of type -8, instead of type 8. Note also that if you define multiple AngelScript functions with the same name, JJ2+ will not know which one to call. This is undefined behavior and the result may vary across JJ2+ releases, so don't do it.</p>
		<pre>void onFunction5(jjPLAYER@ player) {}
void onFunction5(jjPLAYER@ player, bool paramName) {}
void onFunction5(jjPLAYER@ player, uint8 paramName) {}
void onFunction5(jjPLAYER@ player, int8 paramName) {}</pre>
		<p>The contents of your .j2as file must all be syntactically correct AngelScript. Any error in or outside of any function will prevent any and all AngelScript from running in the level. To get information about such errors, you will need to add a line <code>AngelscriptDebug=True</code> to the [General] group of plus.ini (AngelscriptDebug defaults to false), and information about errors and warnings will then be displayed in the chatlogger window. It is also possible to send your own debugging information using the global function <a class="name" href="#jjDebug">jjDebug</a>(string <span class="param">text</span>, bool <span class="param">timestamp</span> = false), though, as with any other AngelScript function, it will only work if everything is formatted correctly.</p>
		<p class="updated">Besides this, there are a number of hook functions which, if defined in a .j2as file, will be called at various points. More may well be added in subsequent releases, but here are the basic ones available so far. (A few more are described in the <a href="#jjcanvas">jjCANVAS section</a> below; <span class="name">onObjectHit</span> is described in the description for <a href="#jjbehaviorinterface::onObjectHit">jjBEHAVIORINTERFACE::onObjectHit</a>; <span class="name">onReceive</span> in the description for <a class="name" href="#jjSendPacket">jjSendPacket</a>; <span class="name">onGetPublicInterface</span> in the description for <a href="#jjpublicinterface">jjPUBLICINTERFACE</a>; and <span class="name">onPlayerDraw</span> in the description for <a href="#jjplayerdraw">jjPLAYERDRAW</a>.)</p>
		<dl id="eventsList">
			<dt>void <span class="name">onChat</span>(int <span class="param">clientID</span>, string &amp;in <span class="param">stringReceived</span>, CHAT::Type <span class="param">chatType</span>)</dt>
			<dt>bool <span class="name">onLocalChat</span>(string &amp;in <span class="param">stringReceived</span>, CHAT::Type <span class="param">chatType</span>)</dt>
			<dd><span class="name">onChat</span> is called whenever a chat message pops up in game. <span class="name">onLocalChat</span> is called only when chat is received from players on the same machine the script is executing on. A return value of true indicates that the chat message should be suppressed, whereas a return value of false will cause the message to be handled normally. <span class="param">clientID</span> is a unique ID of the game client that sent the chat message. <span class="param">stringReceived</span> is the text of the chat message that was received. <span class="param">chatType</span> can take one of the following values: NORMAL, TEAMCHAT, WHISPER amd ME.</dd>
			<dd>Any message beginning with "/" is interpreted as a command, not as chat, and so will not be passed to either of these hooks. Messages beginning with "!" will, though, as will arguments of commands /whisper (and its aliases, /w and @) and /me.</dd>
			<dt class="updated">bool <span class="name">onCheat</span>(string &amp;in <span class="param">cheat</span>)</dt>
			<dd>This function is called in single player mode when a player attempts to enter a cheat code. It will be called once for each letter appended to the cheat code after jj. For example, in typing jjgod, <span class="name">onCheat</span> will be called three times, with <span class="param">cheat</span> equal to "jjg", "jjgo" and "jjgod". A return value of true indicates the cheat should be suppressed, whereas a return value of false will cause the cheat to be handled normally. If you want to compare <span class="param">cheat</span> to the full list of standard cheat codes, use <a href="#jjIsValidCheat">jjIsValidCheat</a>, which will be updated if JJ2+ adds or changes any cheat codes in future releases.</dd>
			<dd>If the player attempts to enter or exit debug mode by pressing the <kbd>F10</kbd> key, this function will be called with <span class="param">cheat</span> equaling "f10." (This is the only circumstance in which the string will not begin with "jj.") You can test whether the player is attempting to enter or exit by checking <a class="name" href="#jjDebugF10">jjDebugF10</a>.</dd>
			<dt>void <span class="name">onLevelLoad</span>()</dt>
			<dd>This function is called once, at the beginning of the level, and never again. If your level's tileset has a red textured background but you want a blue one, this is the place to change its colors. If you want the level to start with water at a certain height without placing Water Level events all around every start position, this is the place for that. And so on.</dd>
			<dt>void <span class="name">onLevelBegin</span>()</dt>
			<dd>Also called only at the beginning of the level, but a little bit later, once things have had time to be initialized. For example, <span class="name">onLevelLoad</span> is fired before any jjOBJs have been created and before certain jjPLAYER properties have been initialized, so <span class="name">onLevelBegin</span> allows you to modify those things as well.</dd>
			<dt>void <span class="name">onGameStart</span>()</dt>
			<dt>void <span class="name">onGameStart</span>(bool <span class="param">firstTime</span>)</dt>
			<dt>void <span class="name">onGameStop</span>()</dt>
			<dt>void <span class="name">onGameStop</span>(bool <span class="param">firstTime</span>)</dt>
			<dd>In multiplayer games, these functions are called whenever the game gets started or stopped. The <span class="param">firstTime</span> parameter, if defined, is intended to capture starts/stops resulting from the <code>/autostart</code> command, so it should be true for the game being started or stopped at the beginning of the level, and false thereafter. However, it will also be true for clients who join the level partway through.</dd>
			<dt>void <span class="name">onLevelReload</span>()</dt>
			<dd>This function is only ever called in Single Player, where it is called every time the player dies, after everything in the level has been reinitialized. Since a great number of things get reset in Single Player when the player dies, this is your chance to make sure some things stay the same.</dd>
			<dt>void <span class="name">onMain</span>()</dt>
			<dd>Unlike the above functions, which are very rare, this function is called absolutely constantly. It is important to understand that JJ2 measures time in "ticks," which number 70 to a second. (Correspondingly, when setting the duration for a sugar rush or somesuch, you will need to multiply by 70 to get the desired number of seconds.) The global property <a class="name" href="#jjGameTicks">jjGameTicks</a> will tell you how many ticks have elapsed at any given point. <span class="name">onMain</span> is fired once per tick, and allows you to check constantly whether a given property has changed, move an object in a circle, or whatever else you find desirable.</dd>
			<dt>void <span class="name">onPlayer</span>(jjPLAYER@ <span class="param">play</span>)</dt>
			<dd>This function can be called even more often than <span class="name">onMain</span>: it is called once per tick per local player. If you're playing splitscreen with two players, for instance, it will be called two times per tick. This is a useful distinction because of the jjPLAYER@ parameter, which points to the local player every time <span class="name">onPlayer</span> is called. If you want to prevent blaster from ever being used in a level, for instance, <code>void onPlayer(jjPLAYER@ play) { play.noFire = (play.currWeapon == WEAPON::BLASTER); }</code> is one way of doing that, whereas trying to do the same in <span class="name">onMain</span> would at minimum require manually looping through the <a class="name" href="#jjLocalPlayers">jjLocalPlayers</a> array. To check which jjPLAYER is being invoked during any given <span class="name">onPlayer</span>, use the <code>jjPLAYER.localPlayerID</code> property.</dd>
			<dd>(JJ2+ used to encourage use of a global property <span class="name">p</span> (or occasionally <span class="name">jjP</span>), which performed the same function as the jjPLAYER@ argument. This coding style still works in certain cases, to ensure backwards compatibility with older scripts, but can be unclear and is deprecated/stylistically discouraged.)</dd>
			<dt>void <span class="name">onPlayerInput</span>(jjPLAYER@ <span class="param">play</span>)</dt>
			<dd>This function works essentially the same way as <span class="name">onPlayer</span>, and is called very slightly earlier in the tick, but with a caveat: it is only called when the player's input properties, <a class="name" href="#jjplayer::keyRight">keyRight</a> and <a class="name" href="#jjplayer::keyJump">keyJump</a> and so on, have had the potential to change. In particular, it is not called while chatting in a multiplayer game unless the player can be moved by a joystick/controller instead of the keyboard. Because of this unpredictability, it should only be used for situations specifically relating to input, for instance swapping the effects of a player's right and left keys.</dd>
			<dt>void <span class="name">onPlayerTimerEnd</span>(jjPLAYER@ <span class="param">play</span>)</dt>
			<dd>This function is something of a special case. By default, when a Player Timer runs out (see the jjPLAYER section below), this function will be called for the player whose timer just ran out. However, a single level may have multiple timer sections with different purposes -- one where you die for not doing something quickly enough, one where you warp after a certain delay, and so on -- so it is also possible to change the function called using the jjPLAYER method <a class="name" href="#jjplayer::timerFunction">timerFunction</a>. Thus <span class="name">onPlayerTimerEnd</span> is simply the default function name, not the only one you are allowed to use for this purpose.</dd>
			<dt>void <span class="name">onRoast</span>(jjPLAYER@ <span class="param">victim</span>, jjPLAYER@ <span class="param">killer</span>)</dt>
			<dd>This function is called every time a player is roasted, including non-local players, including self-inflicted deaths from pits and other environmental hazards (in which case <code>victim is killer</code> will be <code>true</code>). Note however that not every death counts as a roast, e.g. deaths from the <code>/frustration</code> command or from unspectating.</dd>
		</dl>
		<p>The rest of this document is divided into three sections. First there are sections for all the available <a href="#classes">classes</a> that you may create and manipulate, and also full lists of their properties and methods. Second are two lists, one of <a href="#globalproperties">global properties</a> and one of <a href="#globalfunctions">global functions</a>. Like the classes, all global properties and functions begin with the letters "jj," with the sole exceptions of the deprecated <span class="name">p</span> and the hook functions, all of which begin with the letters "on." This is a guarantee of backwards compatibility from future versions of JJ2+. While new global properties and functions will undoubtedly be added to AngelScript in future releases of JJ2+, as long as you don't begin any of your own properties and functions with "jj" or "on," there will be no naming conflicts and your scripts will continue to function correctly.</p>
		<p>Finally there are a <a href="#tileids">series</a> <a href="#preprocessor">of</a> <a href="#mutators">appendices</a> containing instructions for specific topics, followed by a <a href="#appendix">fourth</a> which contains the various enums used by certain properties, methods, and functions. Each enum is nested within a namespace, often unique to that enum, and both the name of the namespace and all the values of the enum are in all caps. Such enums may be the sole options for the properties and parameters that use them. For example, to configure the level so that water and ambient lighting can coexist, you will need to set the global property <a class="name" href="#jjWaterLighting">jjWaterLighting</a> to WATERLIGHT::GLOBAL. You do not set it to 1 (a number), or GLOBAL (a variable that doesn't exist in the main namespace), or "GLOBAL" (a string), or CHAR::JAZZ (another enum value), etc. As well, certain arrays are indexed by enums rather than (or as well as) by integers; for example, you access a player's number of red gems through <code>jjPLAYER.gems[GEM::RED]</code>, not <code>jjPLAYER.gems[1]</code>, although <code>jjPLAYER.ammo[WEAPON::BOUNCER]</code> and <code>jjPLAYER.ammo[2]</code> are both acceptable. Depending on the commonality of an enum and the number of different values it has, either its values will be listed whenever it comes up in a property/method/function or they will be listed in full in the appendix at the bottom of this file. Like any other data type, enums may be used as parameters in your own defined functions, so long as you remember to attach the namespace to the enum name.</p>
		<p>It is perfectly understandable if much of this seems overwhelming at first. You are advised to look through the example levels provided in your JJ2+ download, many of which include examples of AngelScript in action. Even if the specific properties being affected in a given level do not interest you, that level can still serve as an example as how AngelScript is written generally. The <a href="http://www.jazz2online.com/">Jazz 2 Online</a> website additionally hosts an <a href="http://www.jazz2online.com/snippets/">AngelScript Snippets</a> section, where people share pieces of generally useful (and hopefully well-commented) code. And if all else fails, head to the <a href="http://www.jazz2online.com/jcf/forumdisplay.php?f=5">JazzJackrabbit Community Forums</a> to ask for help. Good luck!</p>

		<h2 id="classes"><span>Classes</span></h2>

		<h3 id="jjplayer"><span>class jjPLAYER</span></h3>
		<p>If you're writing some AngelScript for Jazz Jackrabbit 2, one of the most natural things to want to affect is Jazz Jackrabbit himself! Or Spaz, or Lori, or so on, as the case may be. Many hook functions�all the <span class="name">onFunction#</span> functions, <span class="name">onPlayer</span> and <span class="name">onPlayerInput</span>, <a href="#jjcanvas">all the <span class="name">onDraw#</span> functions</a>, and so on�include <code>jjPLAYER@</code> parameters so that you know which (local) player you should be affecting within a given chunk of code.</p>
		<p>In some cases you'll want access to some player other than the one who triggered a function. For this, there are two global arrays: <a class="name" href="#jjPlayers">jjPlayers[32]</a> and <a class="name" href="#jjLocalPlayers">jjLocalPlayers[4]</a>. While JJ2/AngelScript shouldn't actually crash if you try to access a player that doesn't exist in the game, it may not give you the most useful results. Thankfully, jjPLAYER objects have boolean <a class="name" href="#jjplayer::isActive">isActive</a> and <a class="name" href="#jjplayer::isLocal">isLocal</a> read-only properties to help you figure out which jjPLAYER objects to affect with a given section of code.</p>
		<p>(Of course, since AngelScript is predominantly local in its domain, the <code>isLocal==false</code> jjPLAYER objects are mostly only useful for reading values, not writing, and even then only a few of those values�<a class="name" href="#jjplayer::xPos">xPos</a>, <a class="name" href="#jjplayer::yPos">yPos</a>, <a class="name" href="#jjplayer::currWeapon">currWeapon</a>, and so forth�will actually be locally accurate. Trying to set, say, <a class="name" href="#jjplayer::jumpStrength">jumpStrength</a> for a non-local jjPLAYER won't do you any good. When you encounter a need to change properties of other players, this is possible to achieve with use of custom packets; for that you will need the <a href="#jjstream">jjSTREAM class</a> and the <a class="name" href="#jjSendPacket">jjSendPacket</a> function.)</p>
		<p>For the most part, properties and methods of jjPLAYER objects are familiar from regular JJ2, or at least can be easily understood. What merits discussion is a new feature known as the Player Timer. Put loosely, it is a player-specific on-screen countdown which, once its time runs out, calls a certain AngelScript function (usually <span class="name">onPlayerTimerEnd</span>), passing as an argument the player that it belonged to. The most important jjPLAYER methods are <a class="name" href="#jjplayer::timerStart">timerStart</a> and <a class="name" href="#jjplayer::timerFunction">timerFunction</a>, which respectively begin the Player Timer (and set how long it will last) and set the effect of the Player Timer running out. Explaining the Player Timer in detail is not the function of this document, however, so see <code>plusTimerEx.j2l/.j2as</code> for a fuller explanation and examples.</p>
		<dl class="class" id="jjPLAYERList">
			<dt class="deprecated">bool <span class="name" id="jjplayer::alreadyDoubleJumped">alreadyDoubleJumped</span></dt>
			<dd>Whether it is currently impossible for the player to double jump, assuming they're Spaz and currently in the air. To allow compatibility with multiple air jumps, this was replaced with <a class="name" href="#jjplayer::doubleJumpCount">doubleJumpCount</a>.</dd>
			<dt>int <span class="name" id="jjplayer::ammo">ammo[WEAPON::Weapon]</span></dt>
			<dt>int <span class="name">ammo[9]</span></dt>
			<dd>How much ammo the player has of each ammo type. <a href="#weapon">Possible constants appear in the appendix below</a>, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).</dd>
			<dd>Note that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their <a class="name" href="#jjweapon::allowed">allowed</a> properties to true in the <a class="name" href="#jjWeapons">jjWeapons</a> array.</dd>
			<dt>bool <span class="name" id="jjplayer::antiGrav">antiGrav</span></dt>
			<dd>Whether the player falls up (true) or down (false). Also causes the player to be drawn upside-down.</dd>
			<dd>(For the record, this mode is still a work-in-progress. A handful of objects�bridges, pinball flippers, and rotating poles�don't work very well with it yet. However, future revisions will be backwards compatible with what works already, so don't hold off on using it for that reason unless it truly can't do yet what you need it do.)</dd>
			<dt>int <span class="name" id="jjplayer::ballTime">ballTime</span></dt>
			<dd>If greater than 0, how much longer (in ticks) the player will be tucked into a ball.</dd>
			<dt>int <span class="name" id="jjplayer::blink">blink</span></dt>
			<dd>If greater than 0, how much longer (in ticks) the player will be blinking and invincible and unable to collide with other players, as if recently hurt. Works online.</dd>
			<dt>int <span class="name" id="jjplayer::boss">boss</span></dt>
			<dd>The object ID of the jjOBJ whose <a class="name" href="#jjobj::energy">energy</a> is shown in the boss health meter, or -1 if the health meter is receding off the top of the screen, or 0 if the player is not fighting any boss.</dd>
			<dd>More specifically, the boss health meter will show the <span class="name">energy</span> of the jjOBJ as a percentage of its initial health as described in its entry in <a class="name" href="#jjObjectPresets">jjObjectPresets</a>. If you create a Tuf Turtle enemy, give it 100 health, and assign a jjPLAYER's <span class="name">boss</span> its object ID, JJ2 will still assume the Tuf Turtle started out at 4 health, not 100. On the other hand, if you write <code>jjObjectPresets[OBJECT::TUFTURT].energy = 100;</code> first, then the boss health meter will work as you might want it to.</dd>
			<dt>bool <span class="name" id="jjplayer::bossActivated">bossActivated</span></dt>
			<dd>The bool set by the Activate Boss event or the <a class="name" href="#jjplayer::activateBoss">activateBoss</a> method. In general, you should make sure this property is true for at least one local player when writing behaviors for custom bosses.</dd>
			<dt>int <span class="name" id="jjplayer::buttstomp">buttstomp</span></dt>
			<dd>Buttstomp phase. Values below 41 mean the player is initializing a buttstomp, 41 means the player is currently buttstomping, values between 41 and 121 mean the player is landing on the ground and values of 121 and higher mean the player is not currently buttstomping.</dd>
			<dt>const float <span class="name" id="jjplayer::cameraX">cameraX</span></dt>
			<dt>const float <span class="name" id="jjplayer::cameraY">cameraY</span></dt>
			<dd>The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.</dd>
			<dt>const CHAR::Char <span class="name" id="jjplayer::charCurr">charCurr</span></dt>
			<dd>The player's current character (CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2). This is a read-only value, because you should use <a class="name" href="#jjplayer::morphTo">morphTo</a> or another related method to change it instead.</dd>
			<dt>CHAR::Char <span class="name" id="jjplayer::charOrig">charOrig</span></dt>
			<dd>Which character the player began the level as (CHAR::JAZZ, CHAR::SPAZ, or CHAR::LORI), aka the character that the Revert Morph event switches them to.</dd>
			<dt>const int <span class="name" id="jjplayer::clientID">clientID</span></dt>
			<dd>ID of the game instance controlling the player. This is particularly useful for packet exchange with use of <a class="name" href="#jjSendPacket">jjSendPacket</a> but can also be used to determine whether players are splitscreeners.</dd>
			<dt>int <span class="name" id="jjplayer::coins">coins</span></dt>
			<dd>How many coins the player has.</dd>
			<dd>If you want to require the player to have a certain number of coins to do something, like with coin warps, consider using the more elaborate <a class="name" href="#jjplayer::testForCoins">testForCoins</a> method instead.</dd>
			<dt>const uint16 <span class="name" id="jjplayer::curAnim">curAnim</span></dt>
			<dd>The current animation the player takes its frames from, serving as an index to the <a href="#jjanimset">jjAnimations</a> array. Each animation has a distinct value; for example, Jazz standing in place might be 81, but Spaz standing in place might be 185.</dd>
			<dt>const uint <span class="name" id="jjplayer::curFrame">curFrame</span></dt>
			<dd>The overall current frame displayed to the screen to represent this player, serving as an index to the <a href="#jjanimset">jjAnimFrames</a> array. For any given jjPLAYER@ <code>p</code>, <code>p.curFrame</code> will equal <code>jjAnimations[p.curAnim].firstFrame + p.frameID</code>.</dd>
			<dt>const int <span class="name" id="jjplayer::currTile">currTile</span></dt>
			<dd>A shortcut value, always equalling <code>int(xPos)/32 + int(yPos)/32*65536</code>. Since both <a class="name" href="#jjplayer::xPos">xPos</a> and <a class="name" href="#jjplayer::yPos">yPos</a> are easily accessible properties, it really only makes sense to use <span class="name">currTile</span> to compare against previous values of <span class="name">currTile</span>, i.e. to see if the player has moved or not.</dd>
			<dt>uint8 <span class="name" id="jjplayer::currWeapon">currWeapon</span></dt>
			<dd>Which ammo type the player currently has selected. <a href="#weapon">Possible constants appear in the appendix below</a>, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).</dd>
			<dt>const int <span class="name" id="jjplayer::deaths">deaths</span></dt>
			<dd>In competitive game modes, the number of deaths the player experienced or a negative value if unknown (this is currently the case when the property is checked by clients in XLRS mode).</dd>
			<dt>int8 <span class="name" id="jjplayer::direction">direction</span></dt>
			<dd>Which direction the player is facing. Negative values mean left and non-negative ones mean right.</dd>
			<dt>int <span class="name" id="jjplayer::doubleJumpCount">doubleJumpCount</span></dt>
			<dd>How many times the player used double jump in the air since their last regular jump.</dd>
			<dt>int <span class="name" id="jjplayer::fastfire">fastfire</span></dt>
			<dd>The waiting time between shots, as decreased by Fastfire events or the JJFIRE cheat code. Starts out at 35�half a second�and decreases to a minimum of 6 (from Fastfire events) or 1 (JJFIRE).</dd>
			<dt>const int <span class="name" id="jjplayer::flag">flag</span></dt>
			<dd>The object ID of the flag the player is carrying, or 0 if the player is not carrying a flag.</dd>
			<dt>int <span class="name" id="jjplayer::fly">fly</span></dt>
			<dd>Possible special constant values are FLIGHT::NONE, FLIGHT::FLYCARROT, or FLIGHT::AIRBOARD, from the FLIGHT::Mode enum.</dd>
			<dd>If the player is currently using a copter or Cheshire2 object, <span class="name">fly</span> will equal the object ID of that object plus one, which is to say, the jjOBJ the player is holding will be <code>jjObjects[p.fly - 1]</code>.</dd>
			<dt>int <span class="name" id="jjplayer::food">food</span></dt>
			<dd>How much food the player has eaten.</dd>
			<dd>Setting this to 100 will not cause a sugar rush. Use the <a class="name" href="#jjplayer::startSugarRush">startSugarRush</a> method instead.</dd>
			<dt>const uint8 <span class="name" id="jjplayer::frameID">frameID</span></dt>
			<dd>The index of the current frame displayed to the screen to represent this player within its animation. For example, Jazz's standing animation is only one frame long, so his frameID will always equal 0 while playing that animation, while Spaz's will range from 0 to 4. For any given jjPLAYER@ <code>p</code>, <code>p.curFrame</code> will equal <code>jjAnimations[p.curAnim].firstFrame + p.frameID</code>.</dd>
			<dt>int8 <span class="name" id="jjplayer::frozen">frozen</span></dt>
			<dd>0 if unfrozen; otherwise, constantly counts down towards 0.</dd>
			<dt>uint32 <span class="name" id="jjplayer::fur">fur</span></dt>
			<dd>Palette indexes of the player's fur in the form of 4 colors, 8 bits each. For potentially more intuitive ways of fur color manipulation refer to jjPLAYER methods <a class="name" href="#jjplayer::furGet">furGet</a> and <a class="name" href="#jjplayer::furSet">furSet</a>. Changes to this setting are automatically shared between all clients in the server. Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their <a class="name" href="#jjplayer::isActive">jjPLAYER::isActive</a> is false), which can be useful for drawing sprites using <a href="#spritemode">SPRITE::PLAYER</a>.</dd>
			<dt>int <span class="name" id="jjplayer::gems">gems[GEM::Color]</span></dt>
			<dd>How many gems the player has collected. Possible values of GEM::Color are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.</dd>
			<dt>uint8 <span class="name" id="jjplayer::health">health</span></dt>
			<dd>How many hearts the player has remaining. If you set this in an online server, all other players will be notified of the change.</dd>
			<dt>int <span class="name" id="jjplayer::helicopter">helicopter</span></dt>
			<dd>The amount of time in which player's copter ears will run out or 0 if the player is currently not using copter ears.</dd>
			<dt>int <span class="name" id="jjplayer::helicopterElapsed">helicopterElapsed</span></dt>
			<dd>The amount of time player spent using copter ears since their last jump. If this reaches or exceeds their respective <a class="name" href="#jjcharacter::helicopterDurationMax">jjCHARACTER::helicopterDurationMax</a>, the player will be unable to use helicopter ears again until they have landed, analogous to using up a <a class="name" href="#jjplayer::doubleJumpCount">double jump</a>.</dd>
			<dt>int <span class="name" id="jjplayer::idle">idle</span></dt>
			<dd>The amount of time since the last change of idle animation or 0 if the player is not idle.</dd>
			<dt>int <span class="name" id="jjplayer::invincibility">invincibility</span></dt>
			<dd>How much longer the player will be invincible. (Does not work in servers.) Specifically, the absolute value is the remaining duration of the invincibility; a positive number will display the invincibility effect around the player, but a negative number (or zero) will not.</dd>
			<dt>bool <span class="name" id="jjplayer::invisibility">invisibility</span></dt>
			<dd>Whether the player is invisible. Invisible players don't have their sprites or names drawn. Changes to this setting are automatically shared between all clients in the server.</dd>
			<dt>const bool <span class="name" id="jjplayer::isActive">isActive</span></dt>
			<dd>Does this jjPLAYER object correspond to an actual player in the server, local or otherwise? If not, few if any of this jjPLAYER's other properties will be reliable. This is a fairly weak check and equals true for several types of players who may be present in the server but not actually playing�<a class="name" href="#jjplayer::isInGame">isInGame</a> may often be more useful.</dd>
			<dt>const bool <span class="name" id="jjplayer::isAdmin">isAdmin</span></dt>
			<dd>Whether the player is logged in as a Remote Admin in the current online server. Because admin privileges can vastly differ depending on server and admin group, a more precise tool <a class="name" href="#jjplayer::hasPrivilege">hasPrivilege</a> exists.</dd>
			<dt>const bool <span class="name" id="jjplayer::isConnecting">isConnecting</span></dt>
			<dd>Whether the player is a client who has not finished joining the current online server yet, as represented by a "C" or "D" (if downloading) next to their name on the player list.</dd>
			<dt>const bool <span class="name" id="jjplayer::isIdle">isIdle</span></dt>
			<dd>Whether the player is idle and does not appear in the level or player list. Currently this can only ever be true of the server.</dd>
			<dt>const bool <span class="name" id="jjplayer::isInGame">isInGame</span></dt>
			<dd>Equals true if <a class="name" href="#jjplayer::isActive">isActive</a> is true but <a class="name" href="#jjplayer::isConnecting">isConnecting</a>, <a class="name" href="#jjplayer::isIdle">isIdle</a>, <a class="name" href="#jjplayer::isOut">isOut</a>, and <a class="name" href="#jjplayer::isSpectating">isSpectating</a> are all false. If more such properties need to be added in future revisions of JJ2+, <span class="name">isInGame</span> will be updated to reflect them.</dd>
			<dt>const bool <span class="name" id="jjplayer::isJailed">isJailed</span></dt>
			<dd>In Jailbreak game mode, whether the player is currently in jail. False in all other game modes.</dd>
			<dt>const bool <span class="name" id="jjplayer::isLocal">isLocal</span></dt>
			<dd>Is this jjPLAYER object controlled by this instance of JJ2?</dd>
			<dt>const bool <span class="name" id="jjplayer::isOut">isOut</span></dt>
			<dd>Equals true if the player has lost all their lives (or joined too late) in an LRS-based gamemode.</dd>
			<dt>const bool <span class="name" id="jjplayer::isSpectating">isSpectating</span></dt>
			<dd>Equals true if the player is spectating normally, i.e. not forced into spectating by being out or an idle server.</dd>
			<dt>const bool <span class="name" id="jjplayer::isZombie">isZombie</span></dt>
			<dd>In Pestilence game mode, whether the player is currently a zombie. False in all other game modes.</dd>
			<dt>float <span class="name" id="jjplayer::jumpStrength">jumpStrength</span></dt>
			<dd>Vertical speed gained by the player on jump. Defaults to -10.</dd>
			<dt>bool <span class="name" id="jjplayer::keyDown">keyDown</span></dt>
			<dt>bool <span class="name" id="jjplayer::keyFire">keyFire</span></dt>
			<dt>bool <span class="name" id="jjplayer::keyJump">keyJump</span></dt>
			<dt>bool <span class="name" id="jjplayer::keyLeft">keyLeft</span></dt>
			<dt>bool <span class="name" id="jjplayer::keyRight">keyRight</span></dt>
			<dt>bool <span class="name" id="jjplayer::keyRun">keyRun</span></dt>
			<dt>bool <span class="name" id="jjplayer::keySelect">keySelect</span></dt>
			<dt>bool <span class="name" id="jjplayer::keyUp">keyUp</span></dt>
			<dd>A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting <span class="name">keyFire</span> to true is not the same as making the player constantly fire, unless their <a class="name" href="#jjplayer::fastfire">fastfire</a> property equals 1.</dd>
			<dt>const int <span class="name" id="jjplayer::laps">laps</span></dt>
			<dd>In Race, the number of laps the player has completed so far. 0 for other modes.</dd>
			<dt>const int <span class="name" id="jjplayer::lapTimeBest">lapTimeBest</span></dt>
			<dd>In Race, how many ticks it took for this player to run their fastest lap so far. Note that because <a class="name" href="#jjplayer::lapTimes">lapTimes</a> only counts the five most recent laps, <span class="name">lapTimeBest</span> will not appear in that array if this player's fastest lap was not one of their five most recent laps. Undefined for other modes or if <a class="name" href="#jjplayer::laps">laps</a> is still 0.</dd>
			<dt>const int <span class="name" id="jjplayer::lapTimeCurrent">lapTimeCurrent</span></dt>
			<dd>In Race, how many ticks have elapsed since the player began their current lap. Undefined for other modes.</dd>
			<dt>const int <span class="name" id="jjplayer::lapTimes">lapTimes[5]</span></dt>
			<dd>In Race, how many ticks it took for this player to run the five most recent laps they completed, where <code>lapTimes[0]</code> is the length of the most recent lap and <code>lapTimes[4]</code> the fifth most recent. If the player has not completed a given lap yet�i.e. if the index used for the <span class="name">lapTimes</span> array is greater or equal to <a class="name" href="#jjplayer::laps">laps</a>�the value will be -1. Undefined for other modes or for players for whom <a class="name" href="#jjplayer::isLocal">isLocal</a> is false.</dd>
			<dt>int8 <span class="name" id="jjplayer::light">light</span></dt>
			<dd>The intensity of light emitted by the player. Changes to this setting are automatically shared between all clients in the server.</dd>
			<dt>uint8 <span class="name" id="jjplayer::lighting">lighting</span></dt>
			<dd>The player's current level of ambient lighting, as affected by the Set Light and Reset Light events.</dd>
			<dt>LIGHT::Type <span class="name" id="jjplayer::lightType">lightType</span></dt>
			<dd>The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER (default). Changes to this setting are automatically shared between all clients in the server.</dd>
			<dt class="updated">int <span class="name" id="jjplayer::lives">lives</span></dt>
			<dd>In single player or cooperative mode, how many lives the player has remaining. For LRS-based game modes use <a class="name" href="#jjplayer::lrsLives">lrsLives</a> instead. Lives are not displayed in the HUD when <a href="#jjGameConnection">jjGameConnection</a> != GAME::LOCAL, but this number still goes up and down as appropriate, even into the negatives; it's just that it has no effect on gameplay.</dd>
			<dt>const int <span class="name" id="jjplayer::localPlayerID">localPlayerID</span></dt>
			<dd>Which local player the player is, in case of splitscreen. 0-3.</dd>
			<dt>const int <span class="name" id="jjplayer::lrsLives">lrsLives</span></dt>
			<dd>In LRS-based game modes (LRS, TLRS, XLRS), how many lives the player has remaining, a negative value for other modes. For single player and cooperative modes use <a class="name" href="#jjplayer::lives">lives</a> instead.</dd>
			<dt>const string <span class="name" id="jjplayer::name">name</span></dt>
			<dd>The player's name. This is a constant property; to change it, you can use the <a class="name" href="#jjplayer::setName">setName</a> method.</dd>
			<dt>const string <span class="name" id="jjplayer::nameUnformatted">nameUnformatted</span></dt>
			<dd>The player's name in its most basic form, without any | or * characters added or removed for any gamemode-related reasons.</dd>
			<dt>bool <span class="name" id="jjplayer::noclipMode">noclipMode</span></dt>
			<dd>Whether the player is currently in Noclip Mode, as caused by Sucker Tube events with the "BecomeNoclip" parameter set to 1. Setting this to true could be dangerous if the level design is not prepared for it.</dd>
			<dt>bool <span class="name" id="jjplayer::noFire">noFire</span></dt>
			<dd>Whether the player is currently allowed to shoot bullets. Hides the default current weapon/ammunition display while true.</dd>
			<dt>int <span class="name" id="jjplayer::platform">platform</span></dt>
			<dd>The object ID of the object the player is currently standing on, or 0 if inapplicable.</dd>
			<dt>const int8 <span class="name" id="jjplayer::playerID">playerID</span></dt>
			<dd>In online play, which number the player is in the server's list of players. 0-31.</dd>
			<dt>bool <span class="name" id="jjplayer::powerup">powerup[WEAPON::Weapon]</span></dt>
			<dt>bool <span class="name">powerup[9]</span></dt>
			<dd>Whether each ammo type is powered-up or not. <a href="#weapon">Possible constants appear in the appendix below</a>, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).</dd>
			<dd>Note that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their <a class="name" href="#jjweapon::allowedPowerup">allowedPowerup</a> properties to true in the <a class="name" href="#jjWeapons">jjWeapons</a> array.</dd>
			<dt>const int <span class="name" id="jjplayer::roasts">roasts</span></dt>
			<dd>In competitive game modes, how many kills the player made or a negative value if unknown (this is currently the case when the property is checked by clients in RT, LRS, Pestilence and TLRS modes). If the game mode doesn't allow players to kill other players, as is the case in Single Player, Cooperative, Treasure Hunt and Race, this property will always be equal to 0.</dd>
			<dt>bool <span class="name" id="jjplayer::running">running</span></dt>
			<dd>Is the player currently running? Detects the run key, capslock (if there is only one local player), and the /run &lt;on|off&gt; command. Apparently <span class="name">running</span> is set based on <a class="name" href="#jjplayer::keyRun">keyRun</a>, and then other parts of code query <span class="name">running</span> exclusively.</dd>
			<dt>int <span class="name" id="jjplayer::score">score</span></dt>
			<dd>In single player and cooperative modes, the player's current score. JJ2 only increments this in multiples of 50 (or 10 if you count the unpatched Butterfly enemy), but that's up to you.</dd>
			<dt>int <span class="name" id="jjplayer::scoreDisplayed">scoreDisplayed</span></dt>
			<dd>In single player and cooperative modes, the number currently displayed for the player's score. Whenever <a class="name" href="#jjplayer::score">score</a> increases, <span class="name">scoreDisplayed</span> takes a few moments to catch up to the new value. Unless the level defines an <span class="name">onDrawScore</span> function, in which case this property could mean or do anything.</dd>
			<dt>const ANIM::Set <span class="name" id="jjplayer::setID">setID</span></dt>
			<dd>Which set of animations the player uses, serving as an index to the <a href="#jjanimset">jjAnimSets</a> array. This is nearly a 1:1 mapping with <a href="#jjplayer::charCurr">charCurr</a>, except that the two birds (CHAR::BIRD and CHAR::BIRD2) share a <a href="#jjplayer::setID">setID</a>.</dd>
			<dd>The <a href="#rabbit">RABBIT::Anim</a> enum is a version-independent list of all possible animations a rabbit player might use, expressed as indices of animations within the player's anim set. To see if a rabbit player <code>p</code> is currently standing still, for example, you can check <code>if (p.curAnim - jjAnimSets[p.setID].firstAnim == RABBIT::STAND)</code>.</dd>
			<dt>int <span class="name" id="jjplayer::shieldTime">shieldTime</span></dt>
			<dd>How much longer (in ticks) the player's shield will last, or 0 if the player doesn't have a shield.</dd>
			<dt>int <span class="name" id="jjplayer::shieldType">shieldType</span></dt>
			<dd>Which shield the player currently has, assuming the player has a shield at all. In place of numbers, you may also use the dedicated SHIELD::Shield enum, options being NONE, FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER<!--, OIL, and SHOCKWAVE-->. Using values from outside of the range of existing shields may be a reason of incompatibility with future versions of JJ2+ in case more shields are added.</dd>
			<dt>int <span class="name" id="jjplayer::specialMove">specialMove</span></dt>
			<dd>How long the player has been performing their special move or 0 if the player is currently not using a special move.</dd>
			<dt>SPRITE::Mode <span class="name" id="jjplayer::spriteMode">spriteMode</span></dt>
			<dd>Sprite mode the player's sprite is drawn in. <a href="#spritemode">Possible constants appear in the appendix below.</a> Changes to this setting are automatically shared between all clients in the server.</dd>
			<dt>uint8 <span class="name" id="jjplayer::spriteParam">spriteParam</span></dt>
			<dd>A sprite mode parameter further specifying how the player should be drawn. Changes to this setting are automatically shared between all clients in the server.</dd>
			<dt>int <span class="name" id="jjplayer::stoned">stoned</span></dt>
			<dd>How much longer will the player be stoned, like after touching a smoke ring.</dd>
			<dt>const int <span class="name" id="jjplayer::subscreenX">subscreenX</span></dt>
			<dt>const int <span class="name" id="jjplayer::subscreenY">subscreenY</span></dt>
			<dd>Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with <span class="name">subscreenY</span> equal to 75% of <a class="name" href="#jjResolutionHeight">jjResolutionHeight</a>. Note that the "subscreen" includes any black borders (as measured by <a class="name" href="#jjBorderHeight">jjBorderHeight</a> and <a class="name" href="#jjBorderWidth">jjBorderWidth</a>), so these properties are not necessarily the top left corner of a visible section of the level.</dd>
			<dt>const TEAM::Color <span class="name" id="jjplayer::team">team</span></dt>
			<dd>The player's team in team-based game modes. Possible values are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.</dd>
			<dt class="deprecated">const bool <span class="name" id="jjplayer::teamRed">teamRed</span></dt>
			<dd>Incorrectly equals true whenever the player is not on the blue team, i.e. including if they're on green or yellow. Use the property above instead.</dd>
			<dt>bool <span class="name" id="jjplayer::timerPersists">timerPersists</span></dt>
			<dd>Should dying disable the Player Timer (false) or have no effect on it (true)?</dd>
			<dt>const <span class="ns">TIMER::State</span> <span class="name" id="jjplayer::timerState">timerState</span></dt>
			<dd>The current state of the Player Timer (TIMER::STOPPED, TIMER::STARTED, or TIMER::PAUSED), for comparisons only. Use the corresponding <a class="name" href="#jjplayer::timerStart">timerStart</a>, <a class="name" href="#jjplayer::timerStop">timerStop</a>, <a class="name" href="#jjplayer::timerPause">timerPause</a>, and <a class="name" href="#jjplayer::timerResume">timerResume</a> methods to set this instead.</dd>
			<dt>int <span class="name" id="jjplayer::timerTime">timerTime</span></dt>
			<dd>How many ticks are left on the Player Timer.</dd>
			<dt>const int <span class="name" id="jjplayer::warpID">warpID</span></dt>
			<dd>If this number is higher than 0, the player is currently warping, and it will equal the ID of the Warp event plus one, a range of 1-256.</dd>
			<dd>It is often wise to make sure this property equals 0 before calling a warp method, lest the player be locked into a constant loop of beginning to warp but never finishing it. Something like <code>if (conditionsForWarping &amp;&amp; player.warpID == 0) player.warpToID(25);</code>. Performing this check is however unnecessary for fast warps, or warps triggered by Text events, since that code is only called when the player first enters the tile.</dd>
			<dt>float <span class="name" id="jjplayer::xAcc">xAcc</span></dt>
			<dd>Horizontal acceleration in pixels per game tick squared, positive or negative.</dd>
			<dt>float <span class="name" id="jjplayer::xOrg">xOrg</span></dt>
			<dd>If this or <a class="name" href="#jjplayer::yOrg">yOrg</a> are non-zero, where the player should respawn after death.</dd>
			<dt>float <span class="name" id="jjplayer::xPos">xPos</span></dt>
			<dd>Horizontal location in pixels.</dd>
			<dt>float <span class="name" id="jjplayer::xSpeed">xSpeed</span></dt>
			<dd>Horizontal speed in pixels per game tick, positive or negative.</dd>
			<dt>float <span class="name" id="jjplayer::yAcc">yAcc</span></dt>
			<dd>Vertical acceleration in pixels per game tick squared, positive or negative.</dd>
			<dt>float <span class="name" id="jjplayer::yOrg">yOrg</span></dt>
			<dd>If this or <a class="name" href="#jjplayer::xOrg">xOrg</a> are non-zero, where the player should respawn after death.</dd>
			<dt>float <span class="name" id="jjplayer::yPos">yPos</span></dt>
			<dd>Vertical location in pixels.</dd>
			<dt>float <span class="name" id="jjplayer::ySpeed">ySpeed</span></dt>
			<dd>Vertical speed in pixels per game tick, positive or negative.</dd>



			<dt>void <span class="name" id="jjplayer::activateBoss">activateBoss</span>(bool <span class="param">activate</span> = true)</dt>
			<dd>Activates all bosses and disables the player's sugar rush if applicable. Unlike the Activate Boss event, does not change the music track. (Use <a class="name" href="#jjMusicLoad">jjMusicLoad</a> for that instead.)</dd>
			<dd>Setting <span class="param">activate</span> to false will attempt to deactivate bosses, but this mostly only results in the boss health meter going away. The jjPLAYER object's <a class="name" href="#jjplayer::boss">boss</a> is left unchanged unless you change it manually, and bosses do not stop moving around.</dd>
			<dt>void <span class="name" id="jjplayer::cameraFreeze">cameraFreeze</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, bool <span class="param">centered</span>, bool <span class="param">instant</span>)</dt>
			<dt>void <span class="name">cameraFreeze</span>(bool <span class="param">xUnfreeze</span>, float <span class="param">yPixel</span>, bool <span class="param">centered</span>, bool <span class="param">instant</span>)</dt>
			<dt>void <span class="name">cameraFreeze</span>(float <span class="param">xPixel</span>, bool <span class="param">yUnfreeze</span>, bool <span class="param">centered</span>, bool <span class="param">instant</span>)</dt>
			<dt>void <span class="name">cameraFreeze</span>(bool <span class="param">xUnfreeze</span>, bool <span class="param">yUnfreeze</span>, bool <span class="param">centered</span>, bool <span class="param">instant</span>)</dt>
			<dd>Fixes the camera in place, like when encountering a Robot Boss, until the corresponding <a class="name" href="#jjplayer::cameraUnfreeze">cameraUnfreeze</a> method is called. If <span class="param">instant</span> is left false, the camera will take roughly half a second to scroll to its target. If <span class="param">centered</span> is left false, the camera will position itself so that <span class="param">xPixel,yPixel</span> is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing <span class="param">xUnfreeze</span> or <span class="param">yUnfreeze</span>, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, <code>player.cameraFreeze(true, true)</code> is equivalent to <code>player.cameraUnfreeze()</code>.</dd>
			<dt>void <span class="name" id="jjplayer::cameraUnfreeze">cameraUnfreeze</span>(bool <span class="param">instant</span> = true)</dt>
			<dd>If <a class="name" href="#jjplayer::cameraFreeze">cameraFreeze</a> has been called, undoes the effect and lets the camera freely follow the player once again. If <span class="param">instant</span> is left false, the camera will take roughly half a second to scroll to its target.</dd>
			<dt>bool <span class="name" id="jjplayer::doesCollide">doesCollide</span>(const jjOBJ@ <span class="param">object</span>, bool <span class="param">always</span> = false) const</dt>
			<dd>Returns true if the player's sprite collides with that of the specified <span class="param">object</span>, otherwise false. This is a convenient wrapper for <a class="name" href="#jjanimframe::doesCollide">jjANIMFRAME::doesCollide</a>, using the positions, directions and <span class="name">curFrame</span> properties of the player and object involved. No other variables�including <a class="name" href="#jjobj::playerHandling">playerHandling</a>, <a class="name" href="#jjobj::bulletHandling">bulletHandling</a>, or the scale and rotation their sprites are drawn in�are taken into account.</dd>
			<dt>int <span class="name" id="jjplayer::extendInvincibility">extendInvincibility</span>(int <span class="param">duration</span>)</dt>
			<dd>A convenience method to extend the absolute value of the player's <a class="name" href="#jjplayer::invincibility">invincibility</a> property by the absolute value of the <span class="param">duration</span> parameter, which also makes <span class="name">invincibility</span> positive (visible) if <span class="param">duration</span> is visible. For example, collecting a full energy carrot extends invincibility by +350, whereas buttstomping most enemies extends invincibility by -70.</dd>
			<dt>int <span class="name" id="jjplayer::fireBullet">fireBullet</span>(uint8 <span class="param">gun</span> = <span class="ns">WEAPON::CURRENT</span>, bool <span class="param">depleteAmmo</span> = true, bool <span class="param">requireAmmo</span> = true, <span class="ns">DIRECTION::Dir</span> <span class="param">direction</span> = <span class="ns">DIRECTION::CURRENT</span>)</dt>
			<dt>int <span class="name">fireBullet</span>(uint8 <span class="param">gun</span>, bool <span class="param">depleteAmmo</span>, bool <span class="param">requireAmmo</span>, float <span class="param">angle</span>)</dt>
			<dd>Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.</dd>
			<dd><a href="#weapon">Possible <span class="param">gun</span> constants may be found in the appendix at the bottom of the page</a>, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).</dd>
			<dd>If <span class="param">depleteAmmo</span> is false, the method will not affect how much of the ammo type the player has remaining.</dd>
			<dd>If <span class="param">requireAmmo</span> is false, the player can fire a bullet of that type even if they don't have any ammo of that type.</dd>
			<dd>Possible values for <span class="param">direction</span> are DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the mouse cursor is at, rather than whichever direction the player is physically facing. Alternatively you may pass a float <span class="param">angle</span> argument instead of an orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is down, 1.5 * pi is left, and 2 * pi is up again.</dd>
			<dt>void <span class="name" id="jjplayer::freeze">freeze</span>(bool <span class="param">frozen</span> = true)</dt>
			<dd>Freezes the player for the same length of time as the Freeze Enemies pickup, or unfreezes the player if <span class="param">frozen</span> is set to false. Helper method.</dd>
			<dt>void <span class="name" id="jjplayer::furGet">furGet</span>(uint8 &amp;out a, uint8 &amp;out b, uint8 &amp;out c, uint8 &amp;out d) const</dt>
			<dd>Sets provided parameters' values to palette indexes of the player's fur colors.</dd>
			<dt>void <span class="name" id="jjplayer::furSet">furSet</span>(uint8 a, uint8 b, uint8 c, uint8 d)</dt>
			<dd>Sets player's fur colors to those represented by provided palette indexes. Changes made by this method are automatically shared between all clients in the server.  Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their <a class="name" href="#jjplayer::isActive">jjPLAYER::isActive</a> is false), which can be useful for drawing sprites using <a href="#spritemode">SPRITE::PLAYER</a>.</dd>
			<dt>int <span class="name" id="jjplayer::getObjectHitForce">getObjectHitForce</span>(const jjOBJ@ <span class="param">target</span> = null) const</dt>
			<dd>Returns a value expressing whether the player is currently in a state to harm objects or other players, equivalent to the "force" argument in <a class="name" href="#jjplayer::objectHit">objectHit</a> or the <a class="name" href="#jjbehaviorinterface::onObjectHit">onObjectHit</a> hook/method. Specifically, this method returns -1 if the player is performing a special move and the <a class="name" href="#jjcharacter::canHurt">canHurt</a> property of their respective jjCHARACTER is true, 1 if the player is buttstomping or has a sugar rush, or 0 if none of the above are true. Doesn't work especially well when called on non-local players.</dd>
			<dd>If a non-null jjOBJ@ is specified as <span class="param">target</span>, two additional checks will be performed, returning -101 if the object is frozen and the player is running into it really fast, or -1 if the player is a frog (with a true <span class="name">canHurt</span>) hitting the object with its tongue.</dd>
			<dt>bool <span class="name" id="jjplayer::hasPrivilege">hasPrivilege</span>(const string &amp;in <span class="param">privilege</span>, uint <span class="param">moduleID</span> = jjScriptModuleID) const</dt>
			<dd>Checks whether the player has the specified <span class="param">privilege</span> within the script module <span class="param">moduleID</span>. Privileges are specified in the admin configuration file (typically admin.ini) and serve as a way to determine what actions specific admin groups are allowed to take. You can read more about them in the <a href="http://localhost:8080/plus-readme.html#remoteadmin">Remote Admin</a> section of the JJ2+ readme.</dd>
			<dd>Because privileges are only known to the host, this function will always return false if called client-side. The function will always return false for players who are not logged in, and will always return true if the player is the host or the game is local. If the <span class="param">privilege</span> string contains invalid characters, i.e. anything besides letters, digits, underscores ('_'), full stops ('.'), and hyphens ('-'), or if <span class="param">moduleID</span> is not valid, the function will also return false. In all other cases, i.e. if called server-side for a logged in client and with valid parameters, privileges obtained from the admin configuration file will be tested for a match, and if one is found, the function will return true, otherwise false.</dd>
			<dt>bool <span class="name" id="jjplayer::hurt">hurt</span>(int8 <span class="param">damage</span> = 1, bool <span class="param">forceHurt</span> = false, jjPLAYER@ <span class="param">attacker</span> = null)</dt>
			<dd>Attempts to hurt the player <span class="param">damage</span> hearts, or at least strip the player of their bird or reduce their shield time. If <span class="param">attacker</span> is left null, or if it's the same player as the one getting hurt, the injury will be counted as coming from the level, and if a death results, it will be marked online with the "ate it/you killed yourself" text. This is what you should do for injuries from enemies and other level-based factors. On the other hand, if the player dies from the <span class="name">hurt</span> call and <span class="param">attacker</span> is another player in the server, that player will get credit for the roast. Returns false if neither the hurtee nor the hurter are local players and the method is not called by the host, or if <span class="param">forceHurt</span> (which bypasses traditional safety sources like the <a class="name" href="#jjplayer::invincibility">invincibility</a> and <a class="name" href="#jjplayer::blink">blink</a> properties and buttstomping) is false and something or other prevents the hurting from happening.</dd>
			<dt>bool <span class="name" id="jjplayer::isEnemy">isEnemy</span>(const jjPLAYER &amp;in <span class="param">victim</span>) const</dt>
			<dd>Returns true iff <span class="param">victim</span> is a player who can be hurt by this player's bullets or other attacks, according to the rules of the current gamemode. Potentially useful if you are writing a custom weapon behavior and don't want to use <a class="name" href="#jjobj::playerHandling">HANDLING::PLAYERBULLET</a>.</dd>
			<dd>The following conditions will cause this method to return false: the two jjPLAYER objects are the same player; the gamemode is Single Player or Cooperative; in a team-based game, the two players are on the same team and <a href="#jjFriendlyFire">jjFriendlyFire</a> is false; in Roast Tag, Eva's Ring has been captured, yet neither player is <a href="#jjTokenOwner">jjTokenOwner</a> or <a href="#jjBottomFeeder">jjBottomFeeder</a>; in Pestilence, either both players are zombies or neither are zombies but <a href="#jjDoZombiesAlreadyExist">jjDoZombiesAlreadyExist</a> is false; or in Jailbreak, <span class="param">victim</span> is in jail.</dd>
			<dd>Again, this method checks only gamemode-related conditions. (And if more gamemodes are added in the future, this method will be updated to reflect them.) It does not check <a class="name" href="#jjplayer::isInGame">jjPLAYER::isInGame</a>, <a href="#jjGameState">jjGameState</a>, or anything that might cause <a class="name" href="#jjplayer::hurt">jjPLAYER::hurt</a> to return false if its <span class="param">forceHurt</span> parameter is left false.</dd>
			<dt>void <span class="name" id="jjplayer::kill">kill</span>()</dt>
			<dd>Kills the player instantly. If you want the player to be roasted by some other player in an online server, use <a class="name" href="#jjplayer::hurt">hurt</a> with a high <span class="param">damage</span> value instead.</dd>
			<dt>void <span class="name" id="jjplayer::limitXScroll">limitXScroll</span>(uint16 <span class="param">left</span>, uint16 <span class="param">width</span>)</dt>
			<dd>Works like a Limit X Scroll event with the corresponding Left and Width parameters. Remember that these are measured in tiles, not pixels.</dd>
			<dt><span class="ns">CHAR::Char</span> <span class="name" id="jjplayer::morph">morph</span>(bool <span class="param">rabbitsOnly</span> = false, bool <span class="param">morphEffect</span> = true)</dt>
			<dd>Cycles the player's character to the next on the list, just like the JJMORPH cheat: Jazz-Spaz-(Lori-)Bird-Frog-Bird2. Or if <span class="param">rabbitsOnly</span> is true, skips birds and frog and acts like a morph monitor instead, restricting available morph targets to those whose <a href="#jjcharacter::morphBoxCycle">jjCHARACTER::morphBoxCycle</a> properties equal true. Returns the player's new character: CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.</dd>
			<dt><span class="ns">CHAR::Char</span> <span class="name" id="jjplayer::morphTo">morphTo</span>(<span class="ns">CHAR::Char</span> <span class="param">charNew</span>, bool <span class="param">morphEffect</span> = true)</dt>
			<dd>Sets the player's character to <span class="param">charNew</span>, possible values CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI (in TSF), CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.</dd>
			<dt>bool <span class="name" id="jjplayer::objectHit">objectHit</span>(jjOBJ@ <span class="param">target</span>, int <span class="param">force</span>, <span class="ns">HANDLING::Player</span> <span class="param">playerHandling</span>)</dt>
			<dd>Causes the game to think the player is colliding with object <span class="param">target</span>, even if they are not in the same area, and returns true if (generally speaking) the object is affected somehow. Calling this method on a non-local player will return false unless called by the host of a server.</dd>
			<dd>The <span class="param">force</span> parameter hints at whether the player should be able to damage the object, if the object can be damaged to begin with. A value of 0 means that the player is simply bumping into the object at random; 1 means a buttstomp or sugar rush; -1 means a special move; and -101 means the object is frozen and the player runs into it really fast. If you want this parameter to reflect reality, get the value from jjPLAYER's <a class="name" href="#jjplayer::getObjectHitForce">getObjectHitForce</a> method.</dd>
			<dd>The <span class="param">playerHandling</span> parameter specifies how the player should interact with the object�for example, passing HANDLING::PICKUP will force the player to treat the object as a pickup, even if its actual <a class="name" href="#jjobj::playerHandling">playerHandling</a> property is set to something else. If the value is not HANDLING::ENEMY, HANDLING::SPECIAL, HANDLING::PICKUP, HANDLING::ENEMYBULLET, or HANDLING::PLAYERBULLET, nothing will happen. If the value is one of the first three and the object has <a class="name" href="#jjobj::scriptedCollisions">scriptedCollisions</a> set to true, some version of <a class="name" href="#jjbehaviorinterface::onObjectHit">onObjectHit</a> will be called with a null <span class="param">bullet</span> argument, this jjPLAYER as <span class="param">player</span>, and whatever <span class="param">force</span> you call this method with as <span class="param">force</span>.</dd>
			<dd>The results of this collision will be broadcast to other players in the server exactly as if it had happened naturally through the sprites colliding. For example, collecting a pickup object half the level away will cause other players to see the pickup disappear.</dd>
			<dt>bool <span class="name" id="jjplayer::offsetPosition">offsetPosition</span>(int <span class="param">xPixels</span>, int <span class="param">yPixels</span>)</dt>
			<dd>Instantly moves the player <span class="param">xPixels</span> pixels to the right and <span class="param">yPixels</span> pixels down. The camera instantly readjusts itself to follow, as does the glowing trace following the player while running and any companion bird the player may have. The best way of creating seamlessly looping levels.</dd>
			<dt>void <span class="name" id="jjplayer::poleSpin">poleSpin</span>(float <span class="param">xSpeed</span>, float <span class="param">ySpeed</span>, uint <span class="param">delay</span> = 70)</dt>
			<dd>Causes the player to appear to swing around a pole for <span class="param">delay</span> ticks, then launch off at the specified speed/s. For reference, an H-Pole event increases the absolute value of your existing <a class="name" href="#jjplayer::xSpeed">xSpeed</a> by 8 (but not above 20), while a V-Pole event increases the absolute value of your existing <a class="name" href="#jjplayer::ySpeed">ySpeed</a> by 16, with both using the default <span class="param">delay</span> value of 70 ticks (=one second). An H-Pole passes 0 for <span class="param">ySpeed</span>, and a V-Pole passes 0 for <span class="param">xSpeed</span>, but you may use non-orthogonal directions with this method if you'd rather.</dd>
			<dt>uint8 <span class="name" id="jjplayer::resetLight">resetLight</span>()</dt>
			<dd>Resets player's ambient lighting value to the level's default.</dd>
			<dt><span class="ns">CHAR::Char</span> <span class="name" id="jjplayer::revertMorph">revertMorph</span>(bool <span class="param">morphEffect</span> = true)</dt>
			<dd>Reverts the player to the character they were when they began the level, just like the Revert Morph event. If <span class="param">morphEffect</span> is true, displays the default visual effect. Returns the new character (equal to the player's <a class="name" href="#jjplayer::charOrig">charOrig</a>).</dd>
			<dt>bool <span class="name" id="jjplayer::setName">setName</span>(const string &amp;in <span class="param">name</span>)</dt>
			<dd>Sets the player's <a class="name" href="#jjplayer::name">name</a>. This method will only succeed if called server-side or in a local game, and it will then return true to indicate success. Otherwise no change will occur and the method will return false.</dd>
			<dt>int <span class="name" id="jjplayer::setScore">setScore</span>(int <span class="param">score</span>)</dt>
			<dd>Sets the player's score. While setting the score through the <a class="name" href="#jjplayer::score">score</a> property is slightly delayed as <a class="name" href="#jjplayer::scoreDisplayed">scoreDisplayed</a> increases/decreases to catch up to the new value, this function sets both properties at once. Probably most helpful as a function for quickly showing you debug information.</dd>
			<dt>void <span class="name" id="jjplayer::showText">showText</span>(uint8 <span class="param">textID</span>, uint8 <span class="param">offset</span>, STRING::Size <span class="param">size</span> = STRING::SMALL)</dt>
			<dt>void <span class="name">showText</span>(string <span class="param">text</span>, STRING::Size <span class="param">size</span> = STRING::SMALL)</dt>
			<dd>Displays text on the player's screen either like a Text event, with the corresponding <span class="param">textID</span> and <span class="param">offset</span> parameters, or simply a specified <span class="param">text</span>. Unique <span class="param">size</span> values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use <a class="name" href="#jjHelpStrings">jjHelpStrings</a> instead.</dd>
			<dt class="new">void <span class="name" id="jjplayer::spring">spring</span>(float <span class="param">xSpeed</span>, float <span class="param">ySpeed</span>, bool <span class="param">keepZeroSpeeds</span>, bool <span class="param">sample</span>)</dt>
			<dd>Simulates the player touching and getting bounced by a Spring object. For reference, the absolute values of red, green, and blue springs' speeds are 16, 24, and 32 respectively: for example, an upward-facing red spring uses <span class="param">xSpeed</span> 0 and <span class="param">ySpeed</span> -16.</dd>
			<dd>The <span class="param">keepZeroSpeeds</span> argument affects what happens if either speed axis is left at 0, equivalent to the "Keep X-Speed" and "Keep Y-Speed" event parameters: if <span class="param">keepZeroSpeeds</span> is false, the player's speed on that axis will be set to 0, but if true, it will be left at its value prior to <span class="name">spring</span> being called.</dd>
			<dd>If <span class="param">sample</span> is true, a <a href="#sample">sample</a> will be chosen (from among <code>SOUND::COMMON_SPRING1</code>, <code>SOUND::SPRING_BOING_DOWN</code>, and <code>SOUND::SPRING_SPRING1</code>) and played depending on the <span class="param">xSpeed</span> and <span class="param">ySpeed</span> values, and if the player is Spaz, <code>SOUND::SPAZSOUNDS_YAHOO2</code> may be played as well.</dd>
			<dt>bool <span class="name" id="jjplayer::startSugarRush">startSugarRush</span>(int <span class="param">time</span> = 1400)</dt>
			<dd>Gives the player a sugar rush lasting <span class="param">time</span> ticks, unless their <a class="name" href="#jjplayer::bossActivated">bossActivated</a> property equals true, in which case the method returns false. Otherwise returns true. In online multiplayer, <a href="#jjSugarRushAllowed">jjSugarRushAllowed</a> should be true for the host, or else clients who call this method may be kicked.</dd>
			<dt>void <span class="name" id="jjplayer::suckerTube">suckerTube</span>(int <span class="param">xSpeed</span>, int <span class="param">ySpeed</span>, bool <span class="param">center</span>, bool <span class="param">noclip</span> = false, bool <span class="param">trigSample</span> = false)</dt>
			<dd>Simulates the player touching a Sucker Tube event with the same parameter names and values (with <span class="param">noclip</span> referring to "BecomeNoclip", not "Noclip Only"). For each axis this method instructs the player to move along, the <span class="param">center</span> parameter first puts the player in the center of their current tile on the <em>other</em> axis�therefore, passing true is generally safe, but it will get the player stuck if trying to move diagonally every single tick. In normal JJ2, <span class="param">center</span> is true for the first tick the player spends in the tile with the sucker tube event, and false every tick thereafter.</dd>
			<dt>bool <span class="name" id="jjplayer::testForCoins">testForCoins</span>(int <span class="param">numberOfCoins</span>)</dt>
			<dd>If the player has at least <span class="param">numberOfCoins</span> coins, depletes their coins by <span class="param">numberOfCoins</span> and returns true. Otherwise displays a warning onscreen that they need more coins to continue and returns false. Basically the same as a coin warp event, but you get to choose the result.</dd>
			<dt>bool <span class="name" id="jjplayer::testForGems">testForGems</span>(int <span class="param">numberOfGems</span>, GEM::Color <span class="param">type</span>)</dt>
			<dd>If the player has at least <span class="param">numberOfGems</span> <span class="param">type</span>-colored gems, depletes their <span class="param">type</span> gems by <span class="param">numberOfGems</span> and returns true. Otherwise displays a warning onscreen that they need more gems to continue and returns false. Basically the same as a coin warp event, but you get to choose the result, and it's for gems instead of coins.</dd>
			<dd>Possible values of <span class="param">type</span> are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.</dd>
			<dt>void <span class="name" id="jjplayer::timerFunction">timerFunction</span>(string <span class="param">functionName</span>)</dt>
			<dt>void <span class="name">timerFunction</span>(jjVOIDFUNC@ <span class="param">function</span>)</dt>
			<dt>void <span class="name">timerFunction</span>(jjVOIDFUNCPLAYER@ <span class="param">function</span>)</dt>
			<dd>When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to <span class="name">onPlayerTimerEnd</span>, aka <code>void onPlayerTimerEnd(jjPLAYER@)</code>. It is up to you to define this function and decide what should happen to the player.</dd>
			<dt><span class="ns">TIMER::State</span> <span class="name" id="jjplayer::timerPause">timerPause</span>()</dt>
			<dd>Pauses the Player Timer and returns TIMER::PAUSED.</dd>
			<dt><span class="ns">TIMER::State</span> <span class="name" id="jjplayer::timerResume">timerResume</span>()</dt>
			<dd>Resumes the Player Timer and returns TIMER::STARTED.</dd>
			<dt><span class="ns">TIMER::State</span> <span class="name" id="jjplayer::timerStart">timerStart</span>(int <span class="param">ticks</span>, bool <span class="param">startPaused</span> = false)</dt>
			<dd>Begins the Player Timer (and optionally pauses it) with <span class="param">ticks</span> ticks remaining on the clock. Returns TIMER::STARTED or TIMER::PAUSED, depending.</dd>
			<dt><span class="ns">TIMER::State</span> <span class="name" id="jjplayer::timerStop">timerStop</span>()</dt>
			<dd>Stops the Player Timer and returns TIMER::STOPPED.</dd>
			<dt>bool <span class="name" id="jjplayer::warpToID">warpToID</span>(uint8 <span class="param">warpID</span>, bool <span class="param">fast</span> = false)</dt>
			<dd>Warps the player to a Warp Target event with the specified Warp ID, instantly if <span class="param">fast</span> is true or using the standard warp effect if <span class="param">fast</span> is false.</dd>
			<dt>bool <span class="name" id="jjplayer::warpToTile">warpToTile</span>(int <span class="param">xTile</span>, int <span class="param">yTile</span>, bool <span class="param">fast</span> = false)</dt>
			<dd>Warps the player to the specified tile, instantly if <span class="param">fast</span> is true or using the standard warp effect if <span class="param">fast</span> is false.</dd>
		</dl>

		<h3 id="jjobj"><span>class jjOBJ</span></h3>
		<p>Objects are the enemies, pickups, platforms, light sources, and so forth.</p>
		<p>The most important global property is <a class="name" href="#jjObjects">jjObjects[]</a>, a list of all the potential objects in the game. To obtain a jjOBJ to play with, you'll need to specify one of the entries in <span class="name">jjObjects[]</span>, e.g. <code>jjOBJ@ o = jjObjects[1]</code>. The global property <a class="name" href="#jjObjectCount">jjObjectCount</a> is useful for looping through the contents of <span class="name">jjObjects[]</span>. When performing such a loop, it is important to test that a given jjOBJ has a true <a class="name" href="#jjobj::isActive">isActive</a> property, since deleted objects may leave traces of themselves in memory and these traces can only be distinguished from currently-extant objects using <span class="name">isActive</span>. To narrow your results, comparing the <a class="name" href="#jjobj::eventID">eventID</a> class to specific OBJECT::Object constants is also useful, e.g.</p>
		<pre>for (int i = 1; i &lt; jjObjectCount; i++) { <span class="comment">//jjObjects[0] is never active, so we start the index at 1</span>
	jjOBJ@ o = jjObjects[i];
	if (o.isActive &amp;&amp; o.eventID == OBJECT::NORMTURTLE) {
		o.state = STATE::KILL;
	}
}</pre>
		<p>Besides a loop invoking <span class="name">jjObjectCount</span>, object IDs can also be obtained through the jjPLAYER property <a class="name" href="#jjplayer::platform">platform</a>, which gives the ID of the object the player is standing on (if any), the jjPLAYER property <a class="name" href="#jjplayer::boss">boss</a>, which gives the ID of the object whose health is displayed in the boss health meter on that player's screen (if any), and the jjOBJ properties <a class="name" href="#jjobj::creatorID">creatorID</a> and <a class="name" href="#jjobj::creatorType">creatorType</a>, since if the latter equals CREATOR::OBJECT, the former will refer back to another object which created that one. Usually <span class="name">creatorID</span> equals 0, but occasionally�for example, enemy bullets or objects created by generators�it will point to an object, though you should still remember to check <span class="name">isActive</span> to make sure the object's creator hasn't already been destroyed.</p>
		<p>Another reliable way to obtain an object ID is the global function <a class="name" href="#jjAddObject">jjAddObject</a>, which returns the ID of the object it adds so that you can then look it up in <span class="name">jjObjects</span> and set some of its properties. The last three parameters can be�and usually are�left out, but you're free to do as you like. Both jjPLAYER and jjOBJ additionally have <a class="name" href="#jjplayer::fireBullet">fireBullet</a> methods which will also usually produce object IDs.</p>
		<p>As ever, note that AngelScript's scope is all but exclusively the JJ2 copy on your computer, even if you're in an online server, and <span class="name">jjAddObject</span> and the various jjOBJ properties are no exception to this. If one player fires a slice of AngelScript that creates a morph monitor, the other players will not see any morph monitor until and unless they too fire the same slice of code. Likewise, changing the <a class="name" href="#jjobj::xPos">xPos</a> and <a class="name" href="#jjobj::yPos">yPos</a> of a pinball bumper will only be recognized by the local players, not by anyone else in the server. To allow the script to have this kind of impact on game state of other clients it's necessary to use the <a href="#jjstream">jjSTREAM class</a> and the <a class="name" href="#jjSendPacket">jjSendPacket</a> function. These details are of course of no concern for single player levels, but should be kept in mind for multiplayer design.</p>
		<p>Certain of these properties�<a class="name" href="#jjobj::curFrame">curFrame</a> in particular�will constantly be set by the object itself, so trying to change them manually will have little effect unless you also redefine their <a class="name" href="#jjobj::behavior">behavior</a>. Others, such as <a class="name" href="#jjobj::state">state</a> or <a class="name" href="#jjobj::lightType">lightType</a>, will have immediate and possibly enduring effects. There are also a significant number of properties whose function (if any) varies from object (i.e. <span class="name">eventID</span>) to object; these should be better explained in future iterations of JJ2+, but you're welcome to experiment in the meantime.</p>
		<p>Finally: there are also nearly 256 proto-objects stored in the global array <a class="name" href="#jjObjectPresets">jjObjectPresets[256]</a>. These do not correspond to objects currently active in the game, but are instead the value-collection prototypes from which all in-game objects are initially derived. Whenever <span class="name">jjAddObject</span> is called using, say, <span class="ns">OBJECT::GREENGEM</span>, the created object will get its initial values for <a class="name" href="#jjobj::points">points</a>, <a class="name" href="#jjobj::curAnim">curAnim</a>, <a class="name" href="#jjobj::var">var[0]</a>, and more from <code>jjObjectPresets[OBJECT::GREENGEM]</code>. The contents of <span class="name">jjObjectPresets</span> are reset every level, so it is totally safe for you to decide that, e.g., you'd really rather if all Skeleton enemies were lightning-fast and took nineteen hits to destroy instead of three (<code>jjObjectPresets[OBJECT::SKELETON].energy = 19; jjObjectPresets[OBJECT::SKELETON].xSpeed = 5;</code>).</p>
		<dl class="class" id="jjOBJList">
			<dt>int <span class="name" id="jjobj::age">age</span></dt>
			<dd>A variable totally unused by JJ2. The name comes from its original intended purpose as indicating how long had elapsed since the object was created.</dd>
			<dt>int <span class="name" id="jjobj::animSpeed">animSpeed</span></dt>
			<dd>Intended to determine how fast the object animates. However, only gem rings, speed destruct scenery, and collapse scenery actually use this property for that purpose, and all other non-bullet objects leave it untouched.</dd>
			<dd>BULLETS: This property stores the amount of damage a bullet does to enemies, e.g. 1 for normal blaster, 2 for normal seekers, or 3 for certain shield bullets.</dd>
			<dt>jjBEHAVIOR <span class="name" id="jjobj::behavior">behavior</span></dt>
			<dd>Which function is called for this object's behavior. See <a href="#jjbehaviorinterface">jjBEHAVIORINTERFACE</a>.</dd>
			<dd>In order to avoid common bugs, it's strongly discouraged to modify <span class="name">behavior</span> of objects of <a href="#jjobj::eventID">eventID</a> OBJECT::GENERATOR, and especially of <code>jjObjectPresets[OBJECT::GENERATOR]</code>. Currently a great portion of game code tests it against BEHAVIOR::GENERATOR and if it doesn't succeed, it may take unexpected actions, typically involving kicking and banning clients for invalid weapons. Similarly, replacing BEHAVIOR::DIAMONDSAREFOREVER is liable to break Treasure Hunt or Head Hunters games.</dd>
			<dd>Replacing BEHAVIOR::DESTRUCTSCENERY, BEHAVIOR::TRIGGERSCENERY, or BEHAVIOR::SUPERGEM will normally prevent the states of those objects from being shared with newly joining clients in online servers, but this can be circumvented by replacing them with <span class="name">jjBEHAVIORINTERFACE</span>-implementing classes that define <a class="name" href="#jjbehaviorinterface::onGetActive">onGetActive/onSetActive</a> methods appropriately.</dd>
			<dt><span class="ns">HANDLING::Bullet</span> <span class="name" id="jjobj::bulletHandling">bulletHandling</span></dt>
			<dd>What happens when a bullet (or turtle shell, or TNT blast, or attacking bird) comes into contact with this object, assuming that <a class="name" href="#jjobj::playerHandling">playerHandling</a> is either ENEMY or SPECIAL and <a class="name" href="#jjobj::state">state</a> is anything other than KILL?<ul>
				<li><span class="name">HURTBYBULLET</span>: If this object has a non-zero <a class="name" href="#jjobj::energy">energy</a> property, then hitting it will decrease its energy by the force of the bullet. If the object is frozen, it will be unfrozen. If the object's energy sinks to 0 or less, its state will change to STATE::KILL and the player behind the bullet will receive the object's <a class="name" href="#jjobj::points">points</a>. Otherwise, its <a class="name" href="#jjobj::justHit">justHit</a> property will be set to 5. The bullet will be destroyed unless it has bit 16 set for its <a href="#jjobj::var">var[6]</a>, like fireball bullets do, or if the object has <a class="name" href="#jjobj::causesRicochet">causesRicochet</a> as true. If the object's <span class="name">playerHandling</span> is SPECIAL, other things may happen.</li>
				<li><span class="name">IGNOREBULLET</span>: The object will be unaffected in every way by the collision, and the bullet will not be destroyed.</li>
				<li><span class="name">DESTROYBULLET</span>: The object will be unaffected in every way by the collision, and the bullet will be destroyed no matter what its properties are.</li>
				<li><span class="name">DETECTBULLET</span>: The object is by default unaffected, but the bullet will be destroyed unless it has bit 16 set for its var[6], like fireball bullets do, or if the object has <span class="name">causesRicochet</span> as true. If the object's <span class="name">playerHandling</span> is SPECIAL, other things may happen.</li>
			</ul></dd>
			<dt>bool <span class="name" id="jjobj::causesRicochet">causesRicochet</span></dt>
			<dd>When true, colliding bullets will ricochet off of this object unless <a class="name" href="#jjobj::bulletHandling">bulletHandling</a> is set to DESTROYBULLET.</dd>
			<dt>int <span class="name" id="jjobj::counter">counter</span></dt>
			<dd>A general purpose property, usually used for counting up or down to some future event.</dd>
			<dt>uint8 <span class="name" id="jjobj::counterEnd">counterEnd</span></dt>
			<dd>A general purpose property, usually used for counting up or down to some future event. Only goes up to 255, so not as versatile as <a class="name" href="#jjobj::counter">counter</a>.</dd>
			<dd>BULLETS: how long a bullet will exist before exploding. Used by pretty much every bullet behavior but BEHAVIOR::BOLLYBULLET, although no behavior-external code seems to reference it specifically.</dd>
			<dt class="deprecated">int <span class="name" id="jjobj::creator">creator</span></dt>
			<dd>The sum of the <a class="name" href="#jjobj::creatorID">creatorID</a> and <a class="name" href="#jjobj::creatorType">creatorType</a> properties, which is less useful than you might hope.</dd>
			<dt>int <span class="name" id="jjobj::creatorID">creatorID</span></dt>
			<dd>The object ID or player ID of the object or player that created this object, as usable as the index for <a class="name" href="#jjObjects">jjObjects</a> or <a class="name" href="#jjPlayers">jjPlayers</a>. 0 if no creator is actually known.</dd>
			<dt><span class="ns">CREATOR::Type</span> <span class="name" id="jjobj::creatorType">creatorType</span></dt>
			<dd>CREATOR::OBJECT if the object was created by another object, CREATOR::PLAYER if it was created by a player, or CREATOR::LEVEL if it was added directly from the event map.</dd>
			<dd>If the object was created by a Generator object specifically, then <span class="name">creatorType</span> will equal CREATOR::LEVEL, but <a class="name" href="#jjobj::creatorID">creatorID</a> will equal the object ID of that Generator object rather than 0.</dd>
			<dt>int16 <span class="name" id="jjobj::curAnim">curAnim</span></dt>
			<dd>The current animation the object takes its frames from; an index for the <a class="name" href="#jjAnimations">jjAnimations</a> array. You can obtain useful values for this from the <a class="name" href="#jjobj::determineCurAnim">determineCurAnim</a> method or else any <a class="name" href="#jjanimset::firstAnim">jjANIMSET::firstAnim</a>.</dd>
			<dt>uint <span class="name" id="jjobj::curFrame">curFrame</span></dt>
			<dd>The overall current frame displayed to the screen to represent this object, taking into account both <a class="name" href="#jjobj::curAnim">curAnim</a> and <a class="name" href="#jjobj::frameID">frameID</a>; an index for the <a class="name" href="#jjAnimFrames">jjAnimFrames</a> array. You can obtain useful values for this from the <a class="name" href="#jjobj::determineCurFrame">determineCurFrame</a> method or else any <a class="name" href="#jjanimation::firstFrame">jjANIMATION::firstFrame</a>.</dd>
			<dt>bool <span class="name" id="jjobj::deactivates">deactivates</span></dt>
			<dd>When true, this object will be deleted from memory if the player wanders too far away from it in local single player mode, and all its properties will be reset next time it gets loaded. This property has absolutely no effect in multiplayer, and setting it to false cannot force an object to remain in memory in single player when the player dies.</dd>
			<dt>int8 <span class="name" id="jjobj::direction">direction</span></dt>
			<dd>Which way the object is facing. Generally, direction &gt;= 0 is right and &lt; 0 is left. Some objects may also correctly interpret SPRITE::Direction constants: SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV but the ones involving vertical flip will not be perfectly reliable for objects without custom behavior, except for box objects (crates, barrels, monitors), which will take vertically flipped <span class="name">direction</span> values as a cue to fall upwards instead of downwards.</dd>
			<dt>uint8 <span class="name" id="jjobj::doesHurt">doesHurt</span></dt>
			<dd>A variable totally unused by JJ2. The name comes from its original intended purpose as specifying whether boss objects could hurt the player.</dd>
			<dt>int8 <span class="name" id="jjobj::energy">energy</span></dt>
			<dd>If this object's <a class="name" href="#jjobj::playerHandling">playerHandling</a> value is HANDLING::ENEMY, this number is how many more hits the object can take before it is destroyed, unless it equals 0, in which case the object is invincible to bullets (but not to special attacks). This property is also used to determine the fullness of the boss bar.</dd>
			<dt>uint8 <span class="name" id="jjobj::eventID">eventID</span></dt>
			<dd>e.g. 158 for a peach, 43 for a bomb, 243 for an airboard, 1 for a blaster bullet, and so on. Is a uint8 for maximum flexibility, but you should probably set/compare it to OBJECT::Object constants instead most of the time, if for no other reason than readability.</dd>
			<dd>While this value is not strictly constant/read-only, changing it can lead to unpredictable and undesirable effects, since this is the only truly reliable way of knowing what kind of object a given jjOBJ really is, and JJ2 queries it very frequently. The effects can vary from a food pickup playing the wrong sound effect when collected to, say, a red spring simply not working at all when touched. You have been warned.</dd>
			<dt>int8 <span class="name" id="jjobj::frameID">frameID</span></dt>
			<dd>The object's current frame within a single animation set, e.g. which direction the Tube Turtle faces while it rotates in place.</dd>
			<dt>uint8 <span class="name" id="jjobj::freeze">freeze</span></dt>
			<dd>0 if the object is unfrozen, otherwise counts down to 0 for most <a href="#jjobj::behavior">behaviors</a>, though you'll need to implement that manually if writing your own.</dd>
			<dt>const bool <span class="name" id="jjobj::isActive">isActive</span></dt>
			<dd>Does this jjOBJ correspond to a real object, or is it just the abandoned memory of one? For any jjOBJ <code>o</code>, <code>(o.isActive)</code> is the same as <code>(o.behavior != BEHAVIOR::INACTIVE)</code>, but one is obviously much shorter than the other.</dd>
			<dt>bool <span class="name" id="jjobj::isBlastable">isBlastable</span></dt>
			<dd>When true, nearby TNT explosions will set this object's <a class="name" href="#jjobj::xSpeed">xSpeed</a> and <a class="name" href="#jjobj::ySpeed">ySpeed</a> properties.</dd>
			<dt>bool <span class="name" id="jjobj::isFreezable">isFreezable</span></dt>
			<dd>When false, this object will treat ice bullets just the same as any other bullet with the same properties. This is what Caterpillar and Queen do, for example.</dd>
			<dt>bool <span class="name" id="jjobj::isTarget">isTarget</span></dt>
			<dd>When true, this object will be attacked by birds and seeker missiles.</dd>
			<dt>uint8 <span class="name" id="jjobj::justHit">justHit</span></dt>
			<dd>When this property has a non-zero value, most objects will be drawn as pure white until the property counts back down to 0 one tick at a time. JJ2 deincrements this property for all objects, so you needn't worry about it when defining your own behavior functions.</dd>
			<dt>int16 <span class="name" id="jjobj::killAnim">killAnim</span></dt>
			<dd>Which animation the object uses while being destroyed, in the same format as <a class="name" href="#jjobj::curAnim">curAnim</a>.</dd>
			<dt>int8 <span class="name" id="jjobj::light">light</span></dt>
			<dd>The intensity of the light produced by the object.</dd>
			<dt>LIGHT::Type <span class="name" id="jjobj::lightType">lightType</span></dt>
			<dd>The type of light produced by the object. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER.</dd>
			<dt>STATE::State <span class="name" id="jjobj::oldState">oldState</span></dt>
			<dd>If the object is frozen, what state it was in before it was frozen. <a href="#state">Possible constants are listed in the appendix at the end of this file.</a></dd>
			<dt><span class="ns">HANDLING::Player</span> <span class="name" id="jjobj::playerHandling">playerHandling</span></dt>
			<dd>How does this object interact with the rest of the game, most specifically coming into contact with players, although also bullets?<ul>
				<li><span class="name">ENEMY</span>: If a player touches this object, they will be hurt (barring invincibility and such), unless they are using a special attack, in which case the object's <a class="name" href="#jjobj::energy">energy</a> property will decrease by 4. If energy reaches 0 or lower, the object's <a class="name" href="#jjobj::state">state</a> will be set to KILL and the player will receive its <a class="name" href="#jjobj::points">points</a>. Objects of <span class="name">playerHandling</span> PLAYERBULLET that come into contact with this object have the potential to collide with it, depending on its <a class="name" href="#jjobj::bulletHandling">bulletHandling</a> setting.</li>
				<li><span class="name">PLAYERBULLET</span>: When the object's <a class="name" href="#jjobj::state">state</a> is anything but START or EXPLODE, this object will constantly be checked for collision with players other than its <a class="name" href="#jjobj::creatorID">creatorID</a>, as well as objects with <span class="name">playerHandling</span> ENEMY, PICKUP, or SPECIAL.</li>
				<li><span class="name">ENEMYBULLET</span>: When the object's <span class="name">state</span> is anything but START or EXPLODE, if a player touches this object, they will be hurt (barring invincibility and such).</li>
				<li><span class="name">PARTICLE</span>: Effect unknown (semantic only?)</li>
				<li><span class="name">EXPLOSION</span>: Effect unknown (semantic only?)</li>
				<li><span class="name">PICKUP</span>: If a player touches this object, something special will happen, exactly what depending on its <a class="name" href="#jjobj::eventID">eventID</a> value. Usually if nothing else the player will receive its <span class="name">points</span>, and its <a class="name" href="#jjobj::behavior">behavior</a> will be set to BEHAVIOR::EXPLOSION2, though sometimes (e.g. carrots when touched by a player with full health) nothing will happen at all. If the object has <a class="name" href="#jjobj::scriptedCollisions">scriptedCollisions</a> set to true, that will override the effect of the <span class="name">eventID</span> value. Should it have 0 <a class="name" href="#jjobj::xSpeed">xSpeed</a>/<a class="name" href="#jjobj::ySpeed">ySpeed</a> properties and be overlapped by an object of <span class="name">playerHandling</span> PLAYERBULLET whose <span class="name">state</span> is not START or EXPLODE, the pickup object will partially inherit that bullet object's speed and <a class="name" href="#jjobj::direction">direction</a>.</li>
				<li><span class="name">DELAYEDPICKUP</span>: Effect unknown (semantic only?)</li>
				<li><span class="name">HURT</span>: Effect unknown (semantic only?)</li>
				<li><span class="name">SPECIAL</span>: Whenever this object is overlapped by a player or an object of <span class="name">playerHandling</span> PLAYERBULLET (depending in the latter case on this object's <span class="name">bulletHandling</span> value), something special will happen, exactly what depending on its <span class="name">eventID</span> value. If the object has <span class="name">scriptedCollisions</span> set to true, that will override the effect of the <span class="name">eventID</span> value.</li>
				<li><span class="name">DYING</span>: Effect unknown (semantic only?)</li>
				<li><span class="name">SPECIALDONE</span>: Effect unknown (semantic only?)</li>
				<li><span class="name">SELFCOLLISION</span>: Effect unknown (semantic only?)</li>
			</ul></dd>
			<dt>uint16 <span class="name" id="jjobj::points">points</span></dt>
			<dd>How many points a player will gain for destroying the object.</dd>
			<dt class="deprecated">int8 <span class="name" id="jjobj::noHit">noHit</span></dt>
			<dd>Instead, use the properties <a class="name" href="#jjobj::bulletHandling">bulletHandling</a>, <a class="name" href="#jjobj::causesRicochet">causesRicochet</a>, <a class="name" href="#jjobj::isFreezable">isFreezable</a>, and <a class="name" href="#jjobj::isBlastable">isBlastable</a>.</dd>
			<dt>const uint16 <span class="name" id="jjobj::objectID">objectID</span></dt>
			<dd>For all values of <code>n</code> such that <code>n &lt; jjObjectMax</code>, <code>jjObjects[n].objectID == n</code>.</dd>
			<dt class="deprecated">uint8 <span class="name" id="jjobj::objType">objType</span></dt>
			<dd>Instead, use the properties <a class="name" href="#jjobj::playerHandling">playerHandling</a>, <a class="name" href="#jjobj::isTarget">isTarget</a>, <a class="name" href="#jjobj::triggersTNT">triggersTNT</a>, <a class="name" href="#jjobj::deactivates">deactivates</a>, and <a class="name" href="#jjobj::scriptedCollisions">scriptedCollisions</a>.</dd>
			<dt>bool <span class="name" id="jjobj::scriptedCollisions">scriptedCollisions</span></dt>
			<dd>When true, JJ2 will call some version of <a class="name" href="#jjbehaviorinterface::onObjectHit">onObjectHit</a> to determine what to do if a bullet or player is detected as having collided with this object. See <a href="#jjbehaviorinterface">jjBEHAVIORINTERFACE</a>. This property's effect if <a class="name" href="#jjobj::playerHandling">playerHandling</a> is anything other than ENEMY, PICKUP, or SPECIAL is presently undefined.</dd>
			<dt>int <span class="name" id="jjobj::special">special</span></dt>
			<dd>A general-purpose variable, means different things for different objects.</dd>
			<dd>BULLETS: This property stores the animation (<a class="name" href="#jjobj::curAnim">curAnim</a>-style) that is used if the bullet is shot upwards, not horizontally. If this property equals 0, it will not be possible to shoot the bullet upwards except by mouse aiming; this is how shields work.</dd>
			<dt>STATE::State <span class="name" id="jjobj::state">state</span></dt>
			<dd>The current state of the state machine that is the object. <a href="#state">Possible constants are listed in the appendix at the end of this file.</a></dd>
			<dt>bool <span class="name" id="jjobj::triggersTNT">triggersTNT</span></dt>
			<dd>When true, TNT will explode if this object is nearby.</dd>
			<dt>int <span class="name" id="jjobj::var">var[11]</span></dt>
			<dd>A series of general-purpose variables, used for different things by different objects. In general, earlier values are more likely to be used by the game's native behavior functions than later ones.</dd>
			<dd>BULLETS:<ul>
				<li>var[3] represents what ammo type the bullet is, 1-9, which is primarily used for destroying destruct scenery with a non-zero "Weapon" parameter.</li>
				<li>var[6] is used as a series of boolean flags that specify how the bullet interacts with various objects: bit 2 for fire-based bullets which can melt springs and burn enemies into fire/smoke particles; bit 4 for the laser shield's laser; bit 8 for bullets that do two damage in multiplayer; and bit 16 for bullets that pass through enemies, like the fireball, rather than explode on impact.</li>
				<li>var[7] is the <a class="name" href="#jjplayer::xSpeed">xSpeed</a> that the player who fired this bullet was moving at when the bullet was fired, reduced to a range of -8�8... multiplied by 65536. Sorry about that.</li>
				<li>var[9] is a counter for how many times the bullet has ricocheted in its lifetime, beginning at 0.</li>
				<li>var[10] is a counter for how long it's been since the bullet has last ricocheted; each ricochet resets it to 0, but traditional bullet behaviors constantly increment it, and a bullet cannot ricochet if the value is less than 8.</li>
			</ul></dd>
			<dt>float <span class="name" id="jjobj::xAcc">xAcc</span></dt>
			<dd>Horizontal acceleration in pixels per game tick squared, positive or negative.</dd>
			<dt>float <span class="name" id="jjobj::xOrg">xOrg</span></dt>
			<dd>Original horizontal location in pixels.</dd>
			<dt>float <span class="name" id="jjobj::xPos">xPos</span></dt>
			<dd>Current horizontal location in pixels.</dd>
			<dt>float <span class="name" id="jjobj::xSpeed">xSpeed</span></dt>
			<dd>Horizontal speed in pixels per game tick, positive or negative.</dd>
			<dt>float <span class="name" id="jjobj::yAcc">yAcc</span></dt>
			<dd>Vertical acceleration in pixels per game tick squared, positive or negative.</dd>
			<dt>float <span class="name" id="jjobj::yPos">yPos</span></dt>
			<dd>Current vertical location in pixels.</dd>
			<dt>float <span class="name" id="jjobj::yOrg">yOrg</span></dt>
			<dd>Original vertical location in pixels.</dd>
			<dt>float <span class="name" id="jjobj::ySpeed">ySpeed</span></dt>
			<dd>Vertical speed in pixels per game tick, positive or negative.</dd>
			<dt>void <span class="name" id="jjobj::behave">behave</span>(jjBEHAVIOR <span class="param">behavior</span> = BEHAVIOR::DEFAULT, bool <span class="param">draw</span> = true)</dt>
			<dd>Causes this jjOBJ to perform the specified jjBEHAVIOR function, or its own <a class="name" href="#jjobj::behavior">behavior</a> property if <span class="param">behavior</span> is set to BEHAVIOR::DEFAULT. If <span class="param">draw</span> is false, it will not draw anything to the screen. See <a href="#jjbehaviorinterface">jjBEHAVIORINTERFACE</a>.</dd>
			<dt>void <span class="name" id="jjobj::bePlatform">bePlatform</span>(float <span class="param">xOld</span>, float <span class="param">yOld</span>, int <span class="param">width</span> = 0, int <span class="param">height</span> = 0)</dt>
			<dd>Makes the object act as a platform for players. Unlike <a class="name" href="#jjobj::beSolid">beSolid</a>, this method will only cause interactions with players on top of the object and not on its sides. Additionally, this method better accounts for the object's self-induced movement. The parameters <span class="param">xOld</span> and <span class="param">yOld</span> should be set to horizontal and vertical position of the object in the previous tick, whereas the jjOBJ properties <a class="name" href="#jjobj::xPos">xPos</a> and <a class="name" href="#jjobj::yPos">yPos</a> will be used for its current position. The remaining two parameters, <span class="param">width</span> and <span class="param">height</span>, should indicate the platform's dimensions in pixels. The default value of 0 will result in dimensions chosen automatically based on the size of the object's <a class="name" href="#jjobj::curFrame">curFrame</a>.</dd>
			<dt>int <span class="name" id="jjobj::beSolid">beSolid</span>(bool <span class="param">shouldCheckForStompingLocalPlayers</span> = false)</dt>
			<dd>Causes this jjOBJ to serve as a solid block for players trying to move into it. Used by crates, monitors, etc. Returns -1 if a player is trying to push the object to the left, 1 if a player is trying to push it to the right, or otherwise 0, in case you wish to write some code to make the object pushable.</dd>
			<dd>If <span class="param">shouldCheckForStompingLocalPlayers</span> is true, any local players who are landing on this object while buttstomping get an additional chance to destroy this object before landing, effectively by calling <a class="name" href="#jjplayer::objectHit">jjPLAYER::objectHit</a>. If the collision changes this object's <a class="name" href="#jjobj::state">state</a> to either STATE::ACTION or STATE::KILL, <a class="name" href="#jjobj::behave">jjOBJ::behave()</a> will be called.</dd>
			<dt>void <span class="name" id="jjobj::blast">blast</span>(int <span class="param">maxDistance</span>, bool <span class="param">blastObjects</span>)</dt>
			<dd>Sends all players within <span class="param">maxDistance</span> of the object flying away, like RFs or Bombs do when they explode. If <a href="#jjobj::creatorType">creatorType</a> equals CREATOR::PLAYER and players can currently hurt each other, the blast will hurt nearby players unless their <a href="#jjplayer::playerID">playerID</a> is equal to this object's <a href="#jjobj::creatorID">creatorID</a>. If <span class="param">blastObjects</span> is true, then other jjOBJs within <span class="param">maxDistance</span> whose <a href="#jjobj::isBlastable">isBlastable</a> property equals true will be damaged and/or sent flying, just like when a TNT object explodes.</dd>
			<dt>void <span class="name" id="jjobj::clearPlatform">clearPlatform()</span></dt>
			<dd>Causes all local players that are currently standing on top of this object or pushing it to no longer be standing on top of it or pushing it. Should be called when deleting an object that calls <a class="name" href="#jjobj::bePlatform">bePlatform</a> or <a class="name" href="#jjobj::beSolid">beSolid</a>.</dd>
			<dt>void <span class="name" id="jjobj::deactivate">deactivate</span>()</dt>
			<dd>A wrapper method, called by most objects when their <a class="name" href="#jjobj::state">state</a> property equals DEACTIVATE:
				<pre>obj.delete();
if(obj.creatorType == CREATOR::LEVEL) {
	jjEventSet(obj.xOrg/32, obj.yOrg/32, obj.eventID);
	jjParameterSet(obj.xOrg/32, obj.yOrg/32, -1, 1, 0);
}</pre></dd>
			<dt>void <span class="name" id="jjobj::delete">delete</span>()</dt>
			<dd>Permanently deletes the object. Like <a class="name" href="#jjAddObject">jjAddObject</a>, this method is purely local in its scope.</dd>
			<dt>int16 <span class="name" id="jjobj::determineCurAnim">determineCurAnim</span>(uint8 <span class="param">setID</span>, uint8 <span class="param">animation</span>, bool <span class="param">change</span> = true)</dt>
			<dt>int16 <span class="name">determineCurAnim</span>(ANIM::Set <span class="param">setID</span>, uint8 <span class="param">animation</span>, bool <span class="param">change</span> = true)</dt>
			<dd>Determines the value of the <a class="name" href="#jjobj::curAnim">curAnim</a> corresponding to Set ID <span class="param">setID</span> and Animation <span class="param">animation</span> as seen in <a href="http://www.jazz2online.com/downloads/4041/jazz-sprite-dynamite/">Jazz Sprite Dynamite.</a> (0-indexed.) If <span class="param">change</span> is specified as false, this serves as essentially a static method, calculating the proper <span class="name">curAnim</span> value but not actually setting this particular jjOBJ's <span class="name">curAnim</span> to that value.</dd>
			<dd>You are allowed to use a simple uint8 to specify the <span class="param">setID</span>, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24. <a href="#anim">The full list of constants can be found in the appendix at the bottom of this file.</a></dd>
			<dd>Internally, this method runs the following code:
				<pre>if (jjAnimSets[setID].firstAnim == 0) <span class="comment">//not yet loaded</span>
	jjAnimSets[setID].load(); <span class="comment">//load from anims.j2a or plus.j2a, depending on setID</span>
const int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation;
if (change)
	this.curAnim = newCurAnimValue;
return newCurAnimValue;</pre></dd>
			<dt>uint <span class="name" id="jjobj::determineCurFrame">determineCurFrame</span>(bool <span class="param">change</span> = true)</dt>
			<dd>Determines the value of the <a class="name" href="#jjobj::curFrame">curFrame</a> corresponding to this jjOBJ's current <a class="name" href="#jjobj::curAnim">curAnim</a> and <a class="name" href="#jjobj::frameID">frameID</a> values. If <span class="param">change</span> is specified as false, this calculates the proper value but does not actually set this particular jjOBJ's <span class="name">curFrame</span> property to that value.</dd>
			<dd>Internally, this method runs the following code:
				<pre>const jjANIMATION@ animation = jjAnimations[this.curAnim];
const uint newCurFrameValue = (animation.frameCount == 0) ? 0 : (animation.firstFrame + (this.frameID % animation.frameCount));
if (change)
	this.curFrame = newCurFrameValue;
return newCurFrameValue;</pre></dd>
			<dt>bool <span class="name" id="jjobj::doesCollide">doesCollide</span>(const jjOBJ@ <span class="param">object</span>, bool <span class="param">always</span> = false) const</dt>
			<dt>bool <span class="name">doesCollide</span>(const jjPLAYER@ <span class="param">player</span>, bool <span class="param">always</span> = false) const</dt>
			<dd>Returns true if the object's sprite collides with that of the specified <span class="param">object</span> or <span class="param">player</span>, otherwise false. This is a convenient wrapper for <a class="name" href="#jjanimframe::doesCollide">jjANIMFRAME::doesCollide</a>, using the positions, directions and <span class="name">curFrame</span> properties of the player and object involved. No other variables�including <a class="name" href="#jjobj::playerHandling">playerHandling</a>, <a class="name" href="#jjobj::bulletHandling">bulletHandling</a>, or the scale and rotation their sprites are drawn in�are taken into account.</dd>
			<dt>int <span class="name" id="jjobj::draw">draw</span>()</dt>
			<dd>Essentially a wrapper for <a class="name" href="#jjDrawSpriteFromCurFrame">jjDrawSpriteFromCurFrame</a>; uses the jjOBJ's <a class="name" href="#jjobj::xPos">xPos</a>, <a class="name" href="#jjobj::yPos">yPos</a>, <a class="name" href="#jjobj::direction">direction</a>, <a class="name" href="#jjobj::freeze">freeze</a>, <a class="name" href="#jjobj::justHit">justHit</a>, and <a class="name" href="#jjobj::curFrame">curFrame</a> properties to determine where to draw the sprite and what mode to use. This isn't specific enough for all objects, but it does the job in a high percentage of cases.</dd>
			<dt>int <span class="name" id="jjobj::findNearestPlayer">findNearestPlayer</span>(int <span class="param">maxDistance</span>) const</dt>
			<dt>int <span class="name">findNearestPlayer</span>(int <span class="param">maxDistance</span>, int &amp;out <span class="param">foundDistance</span>) const</dt>
			<dd>Returns the <a class="name" href="#jjplayer::playerID">playerID</a> property of the nearest jjPLAYER object within <span class="param">maxDistance</span>, or a negative number if none exist. If the <span class="param">foundDistance</span> parameter is included, it will be set to the distance of the found jjPLAYER. Both <span class="param">maxDistance</span> and <span class="param">foundDistance</span> are actually squares of the distance expressed in pixels. Used by numerous enemies and other objects in order to react to nearby players.</dd>
			<dt>int <span class="name" id="jjobj::fireBullet">fireBullet</span>(<span class="ns">OBJECT::Object</span> <span class="param">eventID</span>) const</dt>
			<dd>A much-simplified version of <a class="name" href="#jjAddObject">jjAddObject</a>. This method creates a new object of type <span class="param">eventID</span>, directly at the "gunspot" position of the jjOBJ's current <a class="name" href="#jjobj::curFrame">curFrame</a> sprite, and sets its <a class="name" href="#jjobj::direction">direction</a>, <a class="name" href="#jjobj::xSpeed">xSpeed</a>, and <a class="name" href="#jjobj::xAcc">xAcc</a> based on the jjOBJ's direction. The return value is the object ID of the new bullet object, or 0 if the method was unsuccessful. Used by dragons, hatters, Bilsy, and so on.</dd>
			<dt>void <span class="name" id="jjobj::grantPickup">grantPickup</span>(jjPLAYER@ <span class="param">player</span>, int <span class="param">frequency</span>) const</dt>
			<dd>Potentially creates a random pickup (red gem, green gem, blue gem, or carrot) in front of the jjOBJ, the likelihood depending on <span class="param">frequency</span> (higher values are less likely). Traditionally, this method is called when an enemy or crate is destroyed by a bullet, and <span class="param">frequency</span> equals 5 if the bullet was an unpowered-up blaster bullet or otherwise 10.</dd>
			<dd>The <span class="param">player</span> parameter is necessary because one in every eight pickups a player is granted is a fastfire instead, so JJ2 needs to be able to keep track of when each individual player should next receive a fastfire.</dd>
			<dd>Only works if <a class="name" href="#jjobj::creatorType">creatorType</a> equals CREATOR::LEVEL.</dd>
			<dt>void <span class="name" id="jjobj::objectHit">objectHit</span>(jjOBJ@ <span class="param">target</span>, <span class="ns">HANDLING::Player</span> <span class="param">playerHandling</span>)</dt>
			<dd>Assumes that this object is a player bullet colliding with object <span class="param">target</span>, even if they are not in the same area or if this object is not actually HANDLING::PLAYERBULLET. You are allowed to set what HANDLING::Player value the <span class="param">target</span> object will be treated as having�HANDLING::ENEMY, HANDLING::SPECIAL, or HANDLING::PICKUP, with all other values having no effect�but otherwise the code will run exactly as if the two objects really did collide. Effects may or may not be broadcast to other players in the server, and some version of <a class="name" href="#jjbehaviorinterface::onObjectHit">onObjectHit</a> will be called (with <span class="param">force</span> as this object's <a class="name" href="#jjobj::animSpeed">animSpeed</a> property) iff <span class="param">target</span> has <a class="name" href="#jjobj::scriptedCollisions">scriptedCollisions</a> set to true and HANDLING::SPECIAL is passed as <span class="param">playerHandling</span>.</dd>
			<dt>void <span class="name" id="jjobj::particlePixelExplosion">particlePixelExplosion</span>(int <span class="param">style</span>) const</dt>
			<dd>A fast wrapper for <a class="name" href="#jjAddParticlePixelExplosion">jjAddParticlePixelExplosion</a>, using the jjOBJ's own <a class="name" href="#jjobj::xPos">xPos</a>, <a class="name" href="#jjobj::yPos">yPos</a>, <a class="name" href="#jjobj::direction">direction</a>, and <a class="name" href="#jjobj::curFrame">curFrame</a> properties.</dd>
			<dt>void <span class="name" id="jjobj::pathMovement">pathMovement</span>()</dt>
			<dd>Makes the object use the same waypoint-based path movement as the Butterfly and Rocket Turtle objects. The method potentially sets the <a class="name" href="#jjobj::xAcc">xAcc</a>, <a class="name" href="#jjobj::yAcc">yAcc</a>, <a class="name" href="#jjobj::xPos">xPos</a>, <a class="name" href="#jjobj::yPos">yPos</a>, <a class="name" href="#jjobj::xSpeed">xSpeed</a>, <a class="name" href="#jjobj::ySpeed">ySpeed</a>, <a class="name" href="#jjobj::counter">counter</a>, <a class="name" href="#jjobj::direction">direction</a>, <a class="name" href="#jjobj::var">var[6]</a> and <span class="name">var[7]</span> properties in the process.</dd>
			<dt>void <span class="name" id="jjobj::putOnGround">putOnGround</span>(bool <span class="param">precise</span> = false)</dt>
			<dd>Moves the object downward until it's on top of the nearest available masked tile below it, or else the bottom of the level. If <span class="param">precise</span> is left false, the resulting <span class="param">yPos</span> may be off by as much as three pixels either up or down, which is still fine for most objects.</dd>
			<dt>bool <span class="name" id="jjobj::ricochet">ricochet</span>()</dt>
			<dd>To be used on bullet objects. Reverses the bullet's <a class="name" href="#jjobj::xSpeed">xSpeed</a>/<a class="name" href="#jjobj::xAcc">xAcc</a>/<a class="name" href="#jjobj::direction">direction</a>, gives it a randomized <a class="name" href="#jjobj::ySpeed">ySpeed</a>, plays one of the SOUND::AMMO_BUL* samples, and calls <code>jjAddParticle(PARTICLE::SPARK)</code> several times. Returns false if the bullet last ricocheted too recently.</dd>
			<dt>int <span class="name" id="jjobj::unfreeze">unfreeze</span>(int <span class="param">style</span>)</dt>
			<dd>Sets <a class="name" href="#jjobj::freeze">freeze</a> to 0, plays SOUND::COMMON_ICECRUSH, and creates an explosion of ice fragments radiating outward from the object. Unique values for <span class="param">style</span> are 0, 1, or any other number.</dd>
		</dl>

		<h3 id="jjparticle"><span>class jjPARTICLE</span></h3>
		<p>JJ2 doesn't use the <a class="name" href="#jjObjects">jjObjects</a> jjOBJ list for everything: in particular, a number of visual effects are much too simple to require that many values, let alone all the specialized handling for light types, special states, multiplayer packets, and so on. For these, JJ2 employs a series of particle objects whose function is merely to make the screen look prettier without actually interacting with any other object, and disappear upon going offscreen (if not before that). These particles are in fact so very simple that AngelScript is able to give you absolute control over their movements and population.</p>
		<p>Like full objects, particles are listed in a global array, <a class="name" href="#jjParticles">jjParticles[1024]</a>. Since particles are totally capable of taking care of themselves once they've been created, though, this is of only so much use. Most of your time will probably be spent around the <a class="name" href="#jjAddParticle">jjAddParticle</a> function, which takes a sole PARTICLE::Type parameter and returns a newly created jjPARTICLE, or a null pointer if the function was unsuccessful. Sample code:</p>
		<pre>jjPARTICLE@ particle = jjAddParticle(PARTICLE::SNOW);
if (particle !is null) {
	particle.xPos = jjLocalPlayers[0].xPos;
	particle.yPos = jjLocalPlayers[0].yPos + 12;
	particle.xSpeed = -1.66;
	particle.snow.frame = jjRandom() &amp; 7;
}</pre>
		<p>Note the peculiar <code>particle.snow.frame</code> property. Each particle type has its own unique property or properties in addition to the common properties, which will be listed at the end of this section. Since all particles are affected by gravity, if nothing else, setting the <a class="name" href="#jjparticle::xSpeed">xSpeed</a>/<a class="name" href="#jjparticle::ySpeed">ySpeed</a> properties is only so important, but <a class="name" href="#jjparticle::xPos">xPos</a> and <a class="name" href="#jjparticle::yPos">yPos</a> are of course essential.</p>
		<dl class="class" id="jjPARTICLEList">
			<dt>bool <span class="name" id="jjparticle::isActive">isActive</span></dt>
			<dd>The point of this property is somewhat unclear, since JJ2 prefers to check if a given particle is active by testing whether <a class="name" href="#jjparticle::type">type</a> equals PARTICLE::INACTIVE or not, but it does exist and does get set sometimes.</dd>
			<dt><span class="ns">PARTICLE::Type</span> <span class="name" id="jjparticle::type">type</span></dt>
			<dd>Any of the standard type options allowed by <a class="name" href="#jjAddParticle">jjAddParticle</a>: INACTIVE, FIRE, FLOWER, ICETRAIL, LEAF, PIXEL, RAIN, SMOKE, SNOW, SPARK, STAR, STRING, or TILE.</dd>
			<dt>float <span class="name" id="jjparticle::xPos">xPos</span></dt>
			<dd>Horizontal location in pixels.</dd>
			<dt>float <span class="name" id="jjparticle::xSpeed">xSpeed</span></dt>
			<dd>Horizontal speed in pixels, positive or negative.</dd>
			<dt>float <span class="name" id="jjparticle::yPos">yPos</span></dt>
			<dd>Vertical location in pixels.</dd>
			<dt>float <span class="name" id="jjparticle::ySpeed">ySpeed</span></dt>
			<dd>Vertical speed in pixels, positive or negative.</dd>
			<dt><span class="name" id="jjparticle::fire">fire</span></dt>
			<dd>Corresponds to PARTICLE::FIRE. Fire particles are drawn as small horizontal ovals, and before they disappear, may at any time create a smoke particle. Fire particles are usually created when an enemy or other destructible object is destroyed using a fire-based weapon.</dd>
			<dd><code>uint8 fire.color</code> is the color (palette entry) which a fire particle will be drawn as. This property gradually increases as the particle remains active, until it reaches <code>colorStop</code> (default 48, pink), at which point the particle will disappear. The default initial value is 40 (yellow).</dd>
			<dd><code>int8 fire.colorDelta</code> is the rate at which the <code>color</code> property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.</dd>
			<dd><code>uint8 fire.colorStop</code> is the <code>color</code> value which, when reached, will cause the particle to disappear. The default value is 48 (pink).</dd>
			<dd><code>uint8 fire.size</code> decides how large the oval will be, ranging from 0-3. The default value is 3.</dd>
			<dt><span class="name" id="jjparticle::flower">flower</span></dt>
			<dd>Corresponds to PARTICLE::FLOWER. Flower particles are drawn as single color, partially transparent, rotationally symmetric flowers, and drift for a while while getting progressively smaller. They are traditionally created by setting Type=1 on a Snow event.</dd>
			<dd><code>uint8 flower.angle</code> is the current angle of rotation the flower is drawn at.</dd>
			<dd><code>int8 flower.angularSpeed</code> is how much the angle changes every tick, positive or negative. By default they do not rotate at all.</dd>
			<dd><code>uint8 flower.color</code> is the color which a flower particle will be drawn as, and does not change during the particle's lifetime. The default value is 16 (green)</dd>
			<dd><code>uint8 flower.size</code> is how large the flower should be drawn, though this is not equal to its size in actual pixels. Decreases by 1 every tick until it reaches 0, at which point the particle disappears. The default starting value is 64.</dd>
			<dd><code>uint8 flower.petals</code> is the number of petals the flower has. The default value is 5.</dd>
			<dt><span class="name" id="jjparticle::icetrail">icetrail</span></dt>
			<dd>Corresponds to PARTICLE::ICETRAIL. Ice trail particles are drawn as single pixels. In regular JJ2, ice bullets leave them in their wake as they fly.</dd>
			 <dd><code>uint8 icetrail.color</code> is the color (palette entry) which an ice trail particle will be drawn as. This property gradually increases as the particle remains active, until it reaches <code>colorStop</code> (default 40, yellow), at which point the particle will disappear. The default initial value is 32 (light blue).</dd>
			<dd><code>int8 icetrail.colorDelta</code> is the rate at which the <code>color</code> property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.</dd>
			<dd><code>uint8 icetrail.colorStop</code> is the <code>color</code> value which, when reached, will cause the particle to disappear. The default value is 40 (yellow).</dd>
			<dt><span class="name" id="jjparticle::leaf">leaf</span></dt>
			<dd>Corresponds to PARTICLE::LEAF. Leaf particles are drawn as frames of the ANIM::PLUS_SCENERY animation set, and float along based on their speed properties and some random jiggling, until they pass offscreen or hit a wall and fall to the ground. They are traditionally created by setting Type=3 on a Snow event. Note that you will need to load ANIM::PLUS_SCENERY manually in order for leaf particles to display properly.</dd>
			<dd><code>uint8 leaf.countup</code> is set to 1 when the leaf hits a wall, then increments every tick until it hits 140 and the particle is deleted.</dd>
			<dd><code>uint8 leaf.frame</code> specifies which frame of the animation will be drawn. This ranges from 0-31 when the leaf is in motion and 0-2 once the deathcounter property is non-zero. The value of this property does not exactly correspond to frames in the animation in plus.j2a, however, since the leaf animation repeats many frames that are only included once in the file.</dd>
			<dd><code>uint16 leaf.frameBase</code> is ID of the frame the particle will use as a base sprite (<span class="name">curFrame</span>-style), and has the default value of <code>jjAnimations[jjAnimSets[ANIM::PLUS_SCENERY].firstAnim].firstFrame</code>.</dd>
			<dd><code>uint8 leaf.height</code> is the distance from the ground in pixels that the particle must be in order to stop falling after hitting a wall. The default value is 2.</dd>
			<dd><code>bool leaf.noclip</code>, if set to true, makes the leaf pass through walls and floors, making its countup and height properties irrelevant.</dd>
			<dt><span class="name" id="jjparticle::pixel">pixel</span></dt>
			<dd>Corresponds to PARTICLE::PIXEL. Depending on their <span class="name">size</span> value, pixel particles will be drawn as	1x1, 2x2, or 3x3 rectangles of pixels. They move both horizontally and vertically, and will also bounce off of masks. These are the particles created by destroying most enemies.</dd>
			<dd><code>uint8 pixel.color[9]</code> specifies which colors will be drawn at each pixel in the particle's rectangle. Note that if the rectangle is smaller than 3x3, not every number in the array will be used. Values of 0 represent transparent pixels and will therefore not be drawn.</dd>
			<dd><code>uint8 pixel.size</code> specifies the size of the rectangle drawn to the screen. 0 for 1x1, 1 for 2x2, or any other number for 3x3. The default value is 0.</dd>
			<dt><span class="name" id="jjparticle::rain">rain</span></dt>
			<dd>Corresponds to PARTICLE::RAIN. Rain particles are drawn as transparent, resized sprites, and move around according to their <a class="name" href="#jjparticle::xSpeed">xSpeed</a>/<a class="name" href="#jjparticle::ySpeed">ySpeed</a> properties until they hit a masked pixel, at which point they are either deleted (if the pixel is to their side) or begin a splashing animation (if the pixel is above or below). They are traditionally created by setting Type=2 on a Snow event.</dd>
			<dd><code>uint8 rain.frame</code> ranges from 0-7 while the particle is in motion, switches to 8 upon hitting a floor or ceiling, and then increases until it hits 18 and the particle is deleted.</dd>
			<dd><code>uint16 rain.frameBase</code> is the first frame of the animation used by the particle, and has the default value of <code>jjAnimations[jjAnimSets[ANIM::COMMON].firstAnim + 2].firstFrame</code>. The displayed frame will be equal to this property plus the current value of the <code>frame</code> property.</dd>
			<dt><span class="name" id="jjparticle::smoke">smoke</span></dt>
			<dd>Corresponds to PARTICLE::SMOKE. Smoke particles are drawn as small gray rectangles and always move erratically upwards. Traditionally they are created from fire particles or from the BEHAVIOR::BURNING objects created by powered-up toaster or a frozen Bily.</dd>
			 <dd><code>uint8 smoke.countdown</code> gradually decreases until it reaches 64, at which point the particle will disappear. The default value is 71.</dd>
			<dt><span class="name" id="jjparticle::snow">snow</span></dt>
			<dd>Corresponds to PARTICLE::SNOW. Snow particles are drawn as frames of the ANIM::SNOW animation set, and fly slowly around based on their speed properties and a general wind force until they hit a masked tile and slowly fade away. They are, of course, traditionally created by the Snow event. Note that you will need to load ANIM::SNOW manually in order for snow particles to display properly.</dd>
			<dd><code>uint8 snow.countdown</code> specifies how long (in ticks) the particle may pass through masked tiles after first being created before masked tiles cause it to fade away and disappear. The default value is 35.</dd>
			<dd><code>uint8 snow.countup</code> has something unknown to do with the particle disappearing once it hits a masked tile. The default value is 0.</dd>
			<dd><code>uint8 snow.frame</code> specifies which frame of the animation will be drawn. This remains constant until the particle hits a wall, at which point it will increase to 7 before disappearing. The default initial value is 0.</dd>
			<dd><code>uint16 snow.frameBase</code> is ID of the frame the particle will use as a base sprite (<span class="name">curFrame</span>-style), and has the default value of <code>jjAnimations[jjAnimSets[ANIM::SNOW].firstAnim].firstFrame</code>. The displayed frame will be equal to this property plus the current value of the <code>frame</code> property.</dd>
			<dt><span class="name" id="jjparticle::spark">spark</span></dt>
			<dd>Corresponds to PARTICLE::SPARK. Spark particles move around according to their <a class="name" href="#jjparticle::xSpeed">xSpeed</a>/<a class="name" href="#jjparticle::ySpeed">ySpeed</a> properties and also gravity, and are drawn as short trails left behind as they move. They are traditionally created by bullets ricocheting off of turtle shells or metallic surfaces, or by electro-blaster bullets in flight.</dd>
			<dd><code>uint8 spark.color</code> is the color (palette entry) which a spark particle's trail will be drawn as. This property gradually increases as the particle remains active, until it reaches <code>colorStop</code> (default 46, maroon), at which point the particle will disappear. The default initial value is 40 (yellow).</dd>
			<dd><code>int8 spark.colorDelta</code> is the rate at which the <code>color</code> property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.</dd>
			<dd><code>uint8 spark.colorStop</code> is the <code>color</code> value which, when reached, will cause the particle to disappear. The default value is 46 (maroon).</dd>
			<dt><span class="name" id="jjparticle::star">star</span></dt>
			<dd>Corresponds to PARTICLE::STAR. Star particles were added to the game to indicate sugar rush. They are drawn as a rotated star sprite. Besides linear speed they also have angular speed and change colors.</dd>
			<dd><code>uint8 star.angle</code> is the current angle of rotation the star is drawn at.</dd>
			<dd><code>int8 star.angularSpeed</code> is how much the angle changes every tick, positive or negative. By default they do not rotate at all.</dd>
			<dd><code>uint8 star.color</code> is the color the star is drawn as. The default value is 40 (yellow).</dd>
			<dd><code>uint8 star.colorChangeCounter</code> counts down to 0, at which point it resets to the value of the colorChangeInterval property and changes the color property to one of the sprite colors at random.</dd>
			<dd><code>uint8 star.colorChangeInterval</code> is how many ticks the particle goes before changing colors again. If it is set to 0 (the default value), however, the color will never change.</dd>
			<dd><code>uint8 star.frame</code> determines whether the star is filled (0) or only an outline (1). The default value is 0.</dd>
			<dd><code>uint8 star.size</code> is how large the star is. It decreases over time until it hits 0, at which point the particle is deleted. The default value is 16.</dd>
			<dt><span class="name" id="jjparticle::string">string</span></dt>
			<dd>Corresponds to PARTICLE::STRING. String particles move at ever-increasing speeds until they leave the screen, drawing up to eight consecutive characters as they go. They are traditionally used to show many points a player gained for destroying an object.</dd>
		<dd><code>string string.text</code> is the series of characters that will be drawn. Strings longer than eight characters will be truncated.</dd>
			<dt><span class="name" id="jjparticle::tile">tile</span></dt>
			<dd>Corresponds to PARTICLE::TILE. Tile particles move around according to their <a class="name" href="#jjparticle::xSpeed">xSpeed</a>/<a class="name" href="#jjparticle::ySpeed">ySpeed</a> properties and also gravity, and are drawn as single tiles (or quarters of single tiles) from the tileset used by the level. They are traditionally created from the destruction of destruct or collapse scenery blocks.</dd>
			<dd><code>TILE::Quadrant tile.quadrant</code> specifies how much of the tile will be drawn to the screen. Possible values of TILE::Quadrant are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS.</dd>
			<dd><code>uint16 tile.tileID</code> specifies which <a href="#tileids">tile</a> the particle draws in the first place. The default value is 0, so remember to change it.</dd>
		</dl>

		<h3 id="jjcontrolpoint"><span>class jjCONTROLPOINT</span></h3>
		<p>This is a simple class representing a Domination game mode control point. It contains a set of read-only properties that let you obtain information about control points present in the level. Instances of the class can be accessed via the global <a class="name" href="#jjControlPoints">jjControlPoints[16]</a> property.</p>
		<dl class="class" id="jjCONTROLPOINTList">
			<dt>const TEAM::Color <span class="name" id="jjcontrolpoint::controlTeam">controlTeam</span></dt>
			<dd>The team that this point is presently under control of. Possible values are TEAM::NEUTRAL, TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.</dd>
			<dt>const int <span class="name" id="jjcontrolpoint::direction">direction</span></dt>
			<dd>Direction of the gem sprite displayed by the control point. The value has purely visual influence on the game.</dd>
			<dt>const string <span class="name" id="jjcontrolpoint::name">name</span></dt>
			<dd>The control point's name.</dd>
			<dt>const float <span class="name" id="jjcontrolpoint::xPos">xPos</span></dt>
			<dd>Horizontal position in pixels.</dd>
			<dt>const int <span class="name" id="jjcontrolpoint::xTile">xTile</span></dt>
			<dd>Horizontal position in tiles.</dd>
			<dt>const float <span class="name" id="jjcontrolpoint::yPos">yPos</span></dt>
			<dd>Vertical position in pixels.</dd>
			<dt>const int <span class="name" id="jjcontrolpoint::yTile">yTile</span></dt>
			<dd>Vertical position in tiles.</dd>
		</dl>

		<h3 id="jjcharacter"><span>class jjCHARACTER</span></h3>
		<p>This class contains a character profile, that is, a number of character-specific properties that determine various aspects of behavior followed by players who use the characters. Character profiles can be accessed using the <a class="name" href="#jjCharacters">jjCharacters[]</a> array with CHAR::Char constants as its indexes.</p>
		<dl class="class" id="jjCHARACTERList">
			<dt>AIR::Jump <span class="name" id="jjcharacter::airJump">airJump</span></dt>
			<dd>Determines the character's reaction to pressing jump in the air. Possible values are AIR::NONE, AIR::HELICOPTER and AIR::DOUBLEJUMP. No effect for birds or frogs.</dd>
			<dt>bool <span class="name" id="jjcharacter::canHurt">canHurt</span></dt>
			<dd>Whether the character can cause damage by using their special moves. This property also applies to Chuck's beak attack and Frog's tongue attack. Defaults true for all rabbits and false for birds and frogs.</dd>
			<dt>bool <span class="name" id="jjcharacter::canRun">canRun</span></dt>
			<dd>Whether the character is capable of fast movement. Defaults true for all rabbits and false for birds and frogs.</dd>
			<dt>int <span class="name" id="jjcharacter::doubleJumpCountMax">doubleJumpCountMax</span></dt>
			<dd>The maximum number of jumps the character can perform in the air if their <a class="name" href="#jjcharacter::airJump">airJump</a> property allows it. Defaults 1 for Spaz.</dd>
			<dt>float <span class="name" id="jjcharacter::doubleJumpXSpeed">doubleJumpXSpeed</span></dt>
			<dt>float <span class="name" id="jjcharacter::doubleJumpYSpeed">doubleJumpYSpeed</span></dt>
			<dd>What horizontal and vertical speed the character will gain by using double jump. doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is relative to the player's current direction, so for example a negative doubleJumpXSpeed will make the character move backwards.</dd>
			<dt>int <span class="name" id="jjcharacter::helicopterDurationMax">helicopterDurationMax</span></dt>
			<dd>The maximum amount of time the character can keep using helicopter ears if their <a class="name" href="#jjcharacter::airJump">airJump</a> property allows it.</dd>
			<dt>float <span class="name" id="jjcharacter::helicopterXSpeed">helicopterXSpeed</span></dt>
			<dt>float <span class="name" id="jjcharacter::helicopterYSpeed">helicopterYSpeed</span></dt>
			<dd>What horizontal and vertical speed the character will gain by using helicopter ears. helicopterYSpeed defaults 1 for all rabbits; its effects when &lt;= 0 are currently undefined. helicopterXSpeed defaults 0 and is relative to the player's current direction, so for example a negative helicopterXSpeed will make the character move backwards.</dd>
			<dt>GROUND::Jump <span class="name" id="jjcharacter::groundJump">groundJump</span></dt>
			<dd>Determines the character's reaction to pressing jump while crouching. Possible values are GROUND::JAZZ, GROUND::SPAZ, GROUND::LORI (available even in 1.23), GROUND::CROUCH (character remains crouching and does not jump), and GROUND::JUMP (character jumps but does not immediately buttstomp). No effect for birds or frogs. Note that changing this property to any the first three values may look pretty silly if the animations are not edited accordingly.</dd>
			<dt>bool <span class="name" id="jjcharacter::morphBoxCycle">morphBoxCycle</span></dt>
			<dd>Whether the character can be morphed to using the "Jazz&lt;-&gt;Spaz" morph box. Also affects the jjPLAYER function <a class="name" href="#jjplayer::morph">morph</a> when its <span class="param">rabbitsOnly</span> argument is set to true.</dd>
		</dl>

		<h3 id="jjweapon"><span>class jjWEAPON</span></h3>
		<p>This is a fairly simple class, containing several properties allowing for more control over weapons and their ammunition. The class exists solely in the <a class="name" href="#jjWeapons">jjWeapons[9]</a> array.</p>
		<dl class="class" id="jjWEAPONList">
			<dt>bool <span class="name" id="jjweapon::allowed">allowed</span></dt>
			<dt>bool <span class="name" id="jjweapon::allowedPowerup">allowedPowerup</span></dt>
			<dd>Whether the weapon and/or its powerup can be legally used in the level. This value is used by the server to detect attempts of cheating and kick offenders, and by all players to determine which weapons they get upon use of the /ready command.</dd>
			<dd>Between <span class="name">onLevelLoad</span> and <span class="name">onLevelBegin</span>, JJ2+ runs a function to determine the values for these properties for each weapon. <code>jjWeapons[WEAPON::BLASTER].allowed</code> will <em>always</em> be set to true; for the rest, JJ2+ looks at the current contents of <a href="#jjObjects">jjObjects</a> and checks each active object's <a href="#jjobj::eventID">jjOBJ::eventID</a>. Any +3 ammo pickup or +15 ammo crate will set <span class="name">allowed</span> to true for that weapon, and any powerup will set <em>both</em> <span class="name">allowed</span> and <span class="name">allowedPowerup</span> to true. Additionally, <span class="ns">OBJECT::GUNCRATE</span> and <span class="ns">OBJECT::GUNBARREL</span> will both set <code>jjWeapons[WEAPON::BOUNCER].allowed</code> to true, and <span class="ns">OBJECT::GENERATOR</span> and object-spawning crates will behave as if they were the objects they will spawn, e.g. a generator that creates +3 Toaster pickups will set <code>jjWeapons[WEAPON::TOASTER].allowed</code> to true. (Anything <em>not</em> set to true will be set to false, so there is no point in editing these properties in onLevelLoad.)</dd>
			<dd>This system covers most levels, but it is absolutely possible to set up your level to include ammo that JJ2+ was unable to guess based on a single loop through <a href="#jjObjects">jjObjects</a>, e.g. MCEs, or the "Weapon" parameter on +15 Bouncer crates, or any number of scripting changes. If you're at all unsure whether JJ2+ will make the right predictions for your particular level, there is zero harm in explicitly setting as many <span class="name">allowed</span> and <span class="name">allowedPowerup</span> values as you want, to true <em>or</em> to false, although make sure to set them in <span class="name">onLevelBegin</span> at the earliest.</dd>
			<dt>bool <span class="name" id="jjweapon::comesFromBirds">comesFromBirds</span></dt>
			<dt>bool <span class="name" id="jjweapon::comesFromBirdsPowerup">comesFromBirdsPowerup</span></dt>
			<dd>Determines whether or not the red companion bird is allowed to shoot bullets of the specified weapon (<span class="name">comesFromBirds</span>), and, if so, whether they may be powered-up (<span class="name">comesFromBirdsPowerup</span>) if the player currently has a powerup for that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless of the player's <a href="#jjplayer::currWeapon">currWeapon</a>.</dd>
			<dd>Bird bullets do not affect the player's ammo count, regardless of the weapon's <a href="#jjweapon::infinite">infinite</a> property, and will not be replaced by shield bullets (because the bird does not have its own shield), regardless of the weapon's <a href="#jjweapon::replacedByShield">replacedByShield</a> property.
			</dd><dt>bool <span class="name" id="jjweapon::comesFromGunCrates">comesFromGunCrates</span></dt>
			<dd>Determines whether or not the ammo for the specified weapon can drop from Gun Crates and Gun Barrels. Defaults to true for WEAPON::BOUNCER, WEAPON::ICE, WEAPON::SEEKER, WEAPON::RF, WEAPON::TOASTER, and false for WEAPON::TNT, WEAPON::GUN8 and WEAPON::GUN9. Has no effect on WEAPON::BLASTER. In an online server, the pickups dropped will be according to the <span class="name">comesFromGunCrates</span> settings for the player who destroyed the crate/barrel.</dd>
			<dt>bool <span class="name" id="jjweapon::defaultSample">defaultSample</span></dt>
			<dd>When false, the default sample of the bullet will not be played.</dd>
			<dt>int <span class="name" id="jjweapon::gemsLost">gemsLost</span></dt>
			<dt>int <span class="name" id="jjweapon::gemsLostPowerup">gemsLostPowerup</span></dt>
			<dd>How many gems a player shot by this weapon will lose in Treasure Hunt. (If the player has fewer gems than the weapon should cause them to lose, they will lose all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT, WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making no difference by default. Doesn't have any effect when changed by clients, only by the server (or in local games).</dd>
			<dt>bool <span class="name" id="jjweapon::gradualAim">gradualAim</span></dt>
			<dd>Whether it takes a few shots for bullets to adjust their direction to the direction the player is aiming, as is the case with pepper spray. If this weapon's <a class="name" href="#jjweapon::spread">spread</a> property is SPREAD::GUN8 and <a class="name" href="#jjAllowsFireball">jjAllowsFireball</a> is true, this property will be treated as false.</dd>
			<dt>bool <span class="name" id="jjweapon::infinite">infinite</span></dt>
			<dd>When true, ammo displays an infinity symbol for its quantity and can never be deplenished. Defaults to true for WEAPON::BLASTER. When spectating another player, the ammo count will appear according to your <span class="name">infinite</span> setting for their currently chosen weapon, not their own.</dd>
			<dt>int <span class="name" id="jjweapon::maximum">maximum</span></dt>
			<dd>Determines how much of each ammo type a player can hold at a time. Defaults to -1, which is interpreted as "99 in single player or cooperative, otherwise 50," but you may want to change some numbers individually (e.g. limit the number of seekers but not bouncers).</dd>
			<dt>int <span class="name" id="jjweapon::multiplier">multiplier</span></dt>
			<dd>The factor by which ammo pickups/powerups increase a weapon's ammo count, and by which that count is divided to be displayed onscreen. Defaults to 32 for WEAPON::TOASTER and 1 for everything else. When spectating another player, the ammo count will appear according to your <span class="name">multiplier</span> setting for their currently chosen weapon, not their own.</dd>
			<dt>bool <span class="name" id="jjweapon::replacedByBubbles">replacedByBubbles</span></dt>
			<dd>When true, the bullet will be replaced by an air bubble when shot underwater or if it goes underwater subsequent to being shot. Defaults to true for WEAPON::TOASTER (and therefore also for fire shield bullets).</dd>
			<dt>bool <span class="name" id="jjweapon::replacedByShield">replacedByShield</span></dt>
			<dd>When true and a shield is active, shield ammo will replace default weapon ammo. Defaults to true for WEAPON::BLASTER.</dd>
			<dd>Under certain circumstances this setting is used to determine validity of network packets, so keep in mind that if its value is not the same for the host as it is for clients, they may be kicked for cheating.</dd>
			<dt>bool <span class="name" id="jjweapon::replenishes">replenishes</span></dt>
			<dd>When true, ammo jumps back up to 50 or 99 on level (re)load. Should be set in onLevelLoad, rather than onLevelBegin, since it actually takes effect between the two. Defaults to true for WEAPON::BLASTER.</dd>
			<dt>SPREAD::Spread <span class="name" id="jjweapon::spread">spread</span></dt>
			<dd>How many bullets are spawned by a single use of the weapon and in what manner. Possible values are:<ul>
				<li><span class="name">NORMAL</span>: Fires one bullet.</li>
				<li><span class="name">ICEPU</span>: Fires two bullets; one in the direction you face, one in the direction you aim.</li>
				<li><span class="name">ICE</span>: Same as NORMAL when not powered up, and ICEPU when powered up.</li>
				<li><span class="name">RFNORMAL</span>: Fires two bullets.
				</li><li><span class="name">RFPU</span>: Fires three bullets.
				</li><li><span class="name">RF</span>: Same as RFNORMAL when not powered up, and RFPU when powered up.</li>
				<li><span class="name">TOASTER</span>: Fires one bullet with its speed partially determined by how much fastfire the player has.</li>
				<li><span class="name">PEPPERSPRAY</span>: Fires two pepper spray bullets.</li>
				<li><span class="name">GUN8</span>: Same as NORMAL if <a class="name" href="#jjAllowsFireball">jjAllowsFireball</a> is true (but ignoring this weapon's <a class="name" href="#jjweapon::gradualAim">gradualAim</a> property), and PEPPERSPRAY when it's off.</li>
				</ul></dd>
			<dd>Any assignments of GUN8 or PEPPERSPRAY should be shared between clients and server to prevent kicking for invalid gun use.</dd>
			<dt>WEAPON::Style <span class="name" id="jjweapon::style">style</span></dt>
			<dd>Determines how often will the weapon fire a bullet when the player holds the fire button. Possible values are WEAPON::NORMAL (fires continously, respecting the player's <a class="name" href="#jjplayer::fastfire">fastfire</a> property), WEAPON::MISSILE (fires once per press of the button), WEAPON::POPCORN (fires continously and respects the player's <span class="name">fastfire</span> property, but at a capped minimum rate of fire), and WEAPON::CAPPED (like NORMAL, but prevents players from shooting faster than allowed by their <span class="name">fastfire</span> property).</dd>
		</dl>

		<h3 id="jjstream"><span>class jjSTREAM</span></h3>
		<p>The jjSTREAM class is used to save/transfer specific data. Its main functions are <a class="name" href="#jjstream::push">push</a> and <a class="name" href="#jjstream::pop">pop</a>. You can create a jjSTREAM variable, and push any values onto it. Then, when you need to read from it, you pop them. jjSTREAM is a container working on <a href="http://en.wikipedia.org/wiki/FIFO">FIFO</a> basis, i.e. the variables are popped in the same order they were pushed. For example:</p>
		<pre>jjSTREAM myStream; <span class="comment">//create an empty stream</span>
int a = 4;
string b = "TexT";
bool c = false;
myStream.push(a); <span class="comment">//push the int "a" onto the stream</span>
myStream.push(b); <span class="comment">//push the string "b" onto the stream</span>
myStream.push(c); <span class="comment">//push the bool "c" onto the stream</span>
int d;
string e;
bool f;
myStream.pop(d); <span class="comment">//the int "d" will have the same value as pushed "a"</span>
myStream.pop(e); <span class="comment">//the string "e" will have the same value as pushed "b"</span>
myStream.pop(f); <span class="comment">//the bool "f" will have the same value as pushed "c"</span>
<span class="comment">//now the stream is empty again.</span></pre>
		<p>It's very important to keep the order of removing variables from jjSTREAM the same as the order of inserting them into it, as well as keep consistency in use of variable types. Attempts to pop a variable of different type than the pushed type will not be blocked but will generally result in obtaining a wrong section of data.</p>
		<p>As you can imagine, the potential for usage of this class as a container is fairly limited and most of the time you'd prefer to use the built-in <span class="name">array</span> class instead. The real strengths of jjSTREAM show when you implement networking or file manipulation in your script.</p>
		<p>To demonstrate file manipulation capabilities of jjSTREAM, let's assume your single player campaign requires that various items be carried between levels. JJ2+ doesn't currently offer means of transfering custom data between separate levels, but it allows you to save a temporary file in one level that you can then load in another. The following code shows possible implementation of functions that would do so.</p>
		<pre>array&lt;string&gt; items; <span class="comment">//In this example we assume items are stored as text strings, representing their names. However, any other basic type, such as int identifiers, would work as well.</span>
bool saveItems() {
	jjSTREAM file;
	file.push(items.length()); <span class="comment">//The first uint in the file will represent the number of items.</span>
	for (uint i = 0; i &lt; items.length(); i++) {
		file.push(items[i]); <span class="comment">//The rest of the file will consist of elements of the items array.</span>
	}
	return file.save("items.asdat"); <span class="comment">//Return whether successful.</span>
}
bool loadItems() {
	jjSTREAM file("items.asdat");
	uint length;
	if (file.pop(length)) { <span class="comment">//Pop the first uint, assumed to be the number of items. If anything fails, abort the entire operation.</span>
		items.resize(length);
		bool success = true;
		for (int i = 0; i &lt; items.length() &amp;&amp; success; i++) {
			success = file.pop(items[i]); <span class="comment">//Retrieve consecutive elements of the items array from the file in the same order they were saved.</span>
		}
		return success;
	}
	return false;
}</pre>
		<p>The exact way you write and read files will of course vary depending on what information you need to save, but you can expect it to be generally based around this scheme.</p>
		<p>Networking works in a similar way as file manipulation but has its own quirks, especially due to the distinction between a server and clients. We'll demonstrate it using a fragment of a hypothetical script that allows players to press buttons and pull levers, each time informing all players in the server about the performed action. We'll think of a button as of something that doesn't have a state, and each time it's pressed it performs the same action. On the other hand, a lever will be something that at any given time can be either on or off. The fragment assumes that all buttons and levers in the level already have unique IDs assigned to them elsewhere, that are the same for the server and all clients.</p>
		<pre>enum packet_type {packet_button, packet_lever, packet_all_levers}; <span class="comment">//We enumerate possible packet types. You will probably want to do this in almost every script that uses streams, as it simplifies the process of giving them more than one purpose. In our case, we want packets that inform about pressing buttons, pulling levers, and a special packet that informs newly joining clients about states of all levers in the level.</span>
array&lt;bool&gt; leverStates;
void performButtonAction(jjPLAYER@ player, int buttonID) {
   <span class="comment">//...</span>
}
void sendButtonPacket(int8 playerID, int buttonID, int skippedClientID) {
   jjSTREAM packet;
   packet.push(uint8(packet_button));
   packet.push(playerID);
   packet.push(buttonID);
   jjSendPacket(packet, -skippedClientID);
}
void pressButton(int8 playerID, int buttonID) {
   performButtonAction(jjPlayers[playerID], buttonID);
   sendButtonPacket(playerID, buttonID, 0);
}
void sendLeverPacket(int8 playerID, int leverID, int skippedClientID) {
   jjSTREAM packet;
   packet.push(uint8(packet_lever));
   packet.push(playerID);
   packet.push(leverID);
   packet.push(leverStates[leverID]);
   jjSendPacket(packet, -skippedClientID);
}
void pullLever(int8 playerID, int leverID) {
   leverStates[leverID] = !leverStates[leverID];
   sendLeverPacket(playerID, leverID, 0);
}
void onLevelLoad() {
   if (!jjIsServer) {
      jjSTREAM packet;
      packet.push(uint8(packet_all_levers));
      jjSendPacket(packet); <span class="comment">//When the level loads for clients, they request status of all levers from the server by sending a packet_all_levers packet.</span>
   }
}
void onReceive(jjSTREAM &amp;in packet, int clientID) {
   uint8 type;
   packet.pop(type);
   if (jjIsServer) {
      switch (type) {
         case packet_button: <span class="comment">//A client reports having pressed a button.</span>
            {
               int8 playerID;
               packet.pop(playerID);
               if (jjPlayers[playerID].clientID == clientID) { <span class="comment">//Check if the received player ID really belongs to the client who sent the packet. Otherwise we might have to do with a hacking attempt.</span>
                  int buttonID;
                  packet.pop(buttonID);
                  performButtonAction(jjPlayers[playerID], buttonID);
                  sendButtonPacket(playerID, buttonID, clientID);
               }
            }
            break;
         case packet_lever: <span class="comment">//A client reports having pulled a lever.</span>
            {
               int8 playerID;
               packet.pop(playerID);
               if (jjPlayers[playerID].clientID == clientID) { <span class="comment">//Check if the received player ID really belongs to the client who sent the packet. Otherwise we might have to do with a hacking attempt.</span>
                  int leverID;
                  packet.pop(leverID);
                  packet.pop(leverStates[leverID]);
                  sendLeverPacket(playerID, leverID, clientID);
               }
            }
            break;
         case packet_all_levers: <span class="comment">//A client requests states of all levers.</span>
            {
               jjSTREAM response;
               response.push(uint8(packet_all_levers));
               for (uint i = 0; i &lt; leverStates.length(); i++) {
                  response.push(leverStates[i]);
               }
               jjSendPacket(response, clientID);
            }
            break;
         <span class="comment">//A default case might also be in place to react to hacking attempts. To simplify the example it was not included.</span>
      }
   } else {
      switch (type) {
         case packet_button: <span class="comment">//The server informs about a button having been pressed.</span>
            {
               int8 playerID;
               int buttonID;
               packet.pop(playerID);
               packet.pop(buttonID);
               performButtonAction(jjPlayers[playerID], buttonID);
            }
            break;
         case packet_lever: <span class="comment">//The server informs about a lever having been pulled.</span>
            {
               int8 playerID;
               int leverID;
               packet.pop(playerID);
               packet.pop(leverID);
               packet.pop(leverStates[leverID]);
            }
            break;
         case packet_all_levers: <span class="comment">//The server responds to request for all lever states.</span>
            for (uint i = 0; i &lt; leverStates.length(); i++) {
               packet.pop(leverStates[i]);
            }
            break;
      }
   }
}</pre>
		<p>The example may seem arbitrary, but it contains all types of packets you want to send most of the time. Generally all network actions you will want to take are: report an event occurred (analogous to buttons), report a state of something changed (analogous to levers), or request state of the entire level when you join it (analogous to packet_all_levers in the above example).</p>
		<dl class="class constructor">
			<dt><span class="name" id="jjstream::jjSTREAM">jjSTREAM</span>()</dt>
			<dt><span class="name">jjSTREAM</span>(const string &amp;in <span class="param">filename</span>)</dt>
			<dd>Constructs an instance of the class. The default constructor creates an empty stream. If <span class="param">filename</span> is provided, the stream will be built from the file's contents.</dd>
		</dl>
		<dl class="class operator">
			<dt>jjSTREAM&amp; <span class="name" id="jjstream::opAssign">operator = </span>(const jjSTREAM &amp;in <span class="param">stream</span>)</dt>
			<dd>Assigns contents of one stream to another and returns a reference to self.</dd>
		</dl>
		<dl class="class" id="jjSTREAMList">
			<dt>void <span class="name" id="jjstream::clear">clear</span>()</dt>
			<dd>Clears content of the stream leaving it empty.</dd>
			<dt>bool <span class="name" id="jjstream::discard">discard</span>(uint <span class="param">count</span>)</dt>
			<dd>Discards <span class="param">count</span> bytes from the front of the stream. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.</dd>
			<dt>bool <span class="name" id="jjstream::get">get</span>(const string &amp;out <span class="param">value</span>, uint <span class="param">count</span> = 1)</dt>
			<dt>bool <span class="name">get</span>(const jjSTREAM &amp;out <span class="param">value</span>, uint <span class="param">count</span> = 1)</dt>
			<dd>Reads <span class="param">count</span> bytes from the front of the stream, removes them and places their contents into <span class="param">value</span>. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.</dd>
			<dt>bool <span class="name" id="jjstream::getLine">getLine</span>(string &amp;out <span class="param">value</span>, const string &amp;in <span class="param">delim</span> = '\n')</dt>
			<dd>Reads bytes from the stream, interpreting them as text characters, until it finds the character sequence <span class="param">delim</span>. The read bytes are placed into <span class="param">value</span>. All read characters are removed from the stream, including <span class="param">delim</span>; however, the resulting <span class="param">value</span> will not contain <span class="param">delim</span>. Returns true on success and false if <span class="param">delim</span> was not found anywhere in the stream. In the latter case, the behavior is still well-defined and all contents of the stream are placed into <span class="param">value</span>, making the stream empty.</dd>
			<dt>uint <span class="name" id="jjstream::getSize">getSize</span>() const</dt>
			<dd>Returns size of the stream in bytes.</dd>
			<dt>bool <span class="name" id="jjstream::isEmpty">isEmpty</span>() const</dt>
			<dd>Returns whether the stream is empty, i.e. whether getSize() == 0.</dd>
			<dt>bool <span class="name" id="jjstream::pop">pop</span>(T &amp;out <span class="param">value</span>)</dt>
			<dd>Pops value from the stream into <span class="param">value</span>, causing <span class="param">value</span> to be filled and reducing the size of the stream. Returns true on success and false on failure, i.e. if the stream didn't have sufficiently many bytes to perform the operation. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow obtaining data previously inserted using <a class="name" href="#jjstream::push">push</a> (read its documentation for details).</dd>
			<dt>bool <span class="name" id="jjstream::push">push</span>(T <span class="param">value</span>)</dt>
			<dt>bool <span class="name">push</span>(const string &amp;in <span class="param">value</span>)</dt>
			<dt>bool <span class="name">push</span>(const jjSTREAM &amp;in <span class="param">value</span>)</dt>
			<dd>Pushes <span class="param">value</span> onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling <a class="name" href="#jjstream::pop">pop</a>. Different data types are assigned different amount of space of the stream. The following rules apply:
			<ul>
			<li>1 byte for bool, int8 and uint8</li>
			<li>2 bytes for int16 and uint16</li>
			<li>4 bytes for int, uint and float</li>
			<li>8 bytes for int64, uint64 and double</li>
			<li>4 + X bytes for strings and streams, where X is the size of the string or stream</li>
			</ul>
			In that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for <a class="name" href="#jjstream::pop">pop</a> to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: <a class="name" href="#jjstream::write">write</a> and <a class="name" href="#jjstream::get">get</a>.
			</dd>
			<dt class="updated">bool <span class="name" id="jjstream::save">save</span>(const string &amp;in <span class="param">filename</span>) const</dt>
			<dd>Saves contents of the stream to file <span class="param">filename</span> and returns whether successful.</dd>
			<dd>There are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be ".asdat" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with <a class="name" href="#jjanimation::save">jjANIMATION::save</a> and <a class="name" href="#jjpixelmap::save">jjPIXELMAP::save</a>).</dd>
			<dt>bool <span class="name" id="jjstream::write">write</span>(const string &amp;in <span class="param">value</span>)</dt>
			<dt>bool <span class="name">write</span>(const jjSTREAM &amp;in <span class="param">value</span>)</dt>
			<dd>Appends bytes of <span class="param">value</span> at the end of the stream. In contrast to <a class="name" href="#jjstream::push">push</a>, this method doesn't store the size of the provided string or stream, thus making it impossible to <a class="name" href="#jjstream::pop">pop</a>, but it can still be obtained with <a class="name" href="#jjstream::get">get</a> if the size is known or <a class="name" href="#jjstream::getLine">getLine</a> if it ends with a defined delimiter. Returns whether successful, which is always true.</dd>
		</dl>

		<h3 id="jjbehavior"><span>class jjBEHAVIOR</span></h3>
		<p>jjBEHAVIOR is a very simple class that exposes no properties or methods (other than operator overloads) to users. Its sole purpose is to be used as the <a class="name" href="#jjobj::behavior">behavior</a> property of jjOBJ instances and occasionally an argument of their <a class="name" href="#jjobj::behave">behave</a> method. At its core jjBEHAVIOR contains only one value, which is either a BEHAVIOR::Behavior constant or an AngelScript behavior function handle. In terms of C-based programming languages, it can be considered a union.</p>
		<p>As it's based around implicit conversions, you rarely have to keep existence of this class in mind.</p>
		<dl class="class constructor">
			<dt><span class="name" id="jjbehavior::jjBEHAVIOR">jjBEHAVIOR</span>(const BEHAVIOR::Behavior &amp;in <span class="param">behavior</span> = BEHAVIOR::INACTIVE)</dt>
			<dd>Constructs an instance of the class and assigns <span class="param">behavior</span> as its value.</dd>
		</dl>
		<dl class="class operator">
			<dt>jjBEHAVIOR&amp; <span class="name" id="jjbehavior::opAssign">operator = </span>(const jjBEHAVIOR &amp;in <span class="param">behavior</span>)</dt>
			<dt>jjBEHAVIOR&amp; <span class="name">operator = </span>(BEHAVIOR::Behavior <span class="param">behavior</span>)</dt>
			<dt>jjBEHAVIOR&amp; <span class="name">operator = </span>(jjVOIDFUNCOBJ@ <span class="param">behavior</span>)</dt>
			<dt>jjBEHAVIOR&amp; <span class="name">operator = </span>(jjBEHAVIORINTERFACE@ <span class="param">behavior</span>)</dt>
			<dd>Assigns <span class="param">behavior</span> to the instance and returns a reference to self.</dd>
			<dt>bool <span class="name" id="jjbehavior::opEquals">operator == </span>(const jjBEHAVIOR &amp;in <span class="param">behavior</span>) const</dt>
			<dt>bool <span class="name">operator == </span>(BEHAVIOR::Behavior <span class="param">behavior</span>) const</dt>
			<dt>bool <span class="name">operator == </span>(const jjVOIDFUNCOBJ@ <span class="param">behavior</span>) const</dt>
			<dd>Compares the instance with <span class="param">behavior</span> and returns whether they are the same.</dd>
			<dt>explicit <span class="name" id="jjbehavior::opConv">operator BEHAVIOR::Behavior </span>() const</dt>
			<dd>If the object represents a valid BEHAVIOR::Behavior constant, returns that constant, otherwise returns BEHAVIOR::INACTIVE. Usage for a sample jjBEHAVIOR instance <code>behavior</code>:
			<pre>BEHAVIOR::Behavior result = BEHAVIOR::Behavior(behavior);</pre></dd>
			<dt>explicit <span class="name" id="jjbehavior::opCast_jjVOIDFUNCOBJ">operator jjVOIDFUNCOBJ@ </span>() const</dt>
			<dd>If the object represents a behavior function handle, returns that handle. Otherwise, if the object represents a handle to an object implementing jjBEHAVIORINTERFACE, returns a delegate of that object's <a href="#jjbehaviorinterface::onBehave">onBehave</a> method. If neither of those is the case, i.e. if the object represents a BEHAVIOR::Behavior constant, returns null. Usage for a sample jjBEHAVIOR instance <code>behavior</code>:
			<pre>jjVOIDFUNCOBJ@ result = cast&lt;jjVOIDFUNCOBJ&gt;(behavior);</pre></dd>
			<dt>explicit <span class="name" id="jjbehavior::opCast_jjBEHAVIORINTERFACE">operator jjBEHAVIORINTERFACE@ </span>() const</dt>
			<dd>If the object represents a handle to an object implementing jjBEHAVIORINTERFACE, returns a handle to that object. Otherwise returns null. Usage for a sample jjBEHAVIOR instance <code>behavior</code>:
			<pre>jjBEHAVIORINTERFACE@ result = cast&lt;jjBEHAVIORINTERFACE&gt;(behavior);</pre></dd>
		</dl>

		<h3 id="jjrng"><span>class jjRNG</span></h3>
		<p>Every instance of this class represents a pseudo-random number generator. Usually pseudo-random number generation can be handled by the simple function <a class="name" href="#jjRandom">jjRandom</a>, however, it may be found insufficient for some applications. In particular, because jjRandom may be called by any running script and internally by the game itself, it cannot be relied on to always provide the same sequence of numbers on consecutive calls for a given seed. In constrast, each instance of this class contains an independent internal state, allowing the sequence of call results to remain the same for the same seed and uninfluenced by external factors. In particular, if two instances of jjRNG initially compare equal, i.e. have the same internal state, and the call operator of each of them is invoked exactly once, then it is guaranteed that the returned values of both invocations also compare equal, and both instances still compare equal afterwards.</p>
		<dl class="class constructor">
			<dt><span class="name" id="jjrng::jjRNG">jjRNG</span>(uint64 <span class="param">seed</span> = 5489)</dt>
			<dd>Constructs an instance of the class with the provided <span class="param">seed</span>.</dd>
		</dl>
		<dl class="class operator">
			<dt>uint64 <span class="name" id="jjrng::opCall">operator () </span>()</dt>
			<dd>Advances the generator's state and returns the generated value.</dd>
			<dt>jjRNG&amp; <span class="name" id="jjrng::opAssign">operator = </span>(const jjRNG &amp;in <span class="param">other</span>)</dt>
			<dd>Copies the internal state of another instance to this instance.</dd>
			<dt>bool <span class="name" id="jjrng::opEquals">operator == </span>(const jjRNG &amp;in <span class="param">other</span>) const</dt>
			<dd>Tests equality of two instances. Two instances compare equal if their internal states are identical.</dd>
		</dl>
		<dl class="class" id="jjRNGList">
			<dt>void <span class="name" id="jjrng::seed">seed</span>(uint64 <span class="param">value</span> = 5489)</dt>
			<dd>Sets the current state of the generator based on <span class="param">value</span>.</dd>
			<dt>void <span class="name" id="jjrng::discard">discard</span>(uint64 <span class="param">count</span> = 1)</dt>
			<dd>Advances the generator's state by <span class="param">count</span>. The effect is equivalent to invoking the call operator <span class="param">count</span> times and discarding the returned values, but calculated more efficiently.</dd>
		</dl>

		<h3 id="jjpal"><span>class jjPAL</span></h3>
		<p>This is the class used by each level's ingame palette, used for drawing pretty much everything besides 16-bit water and textured background fade colors, which can be changed by the global function groups <a class="name" href="#jjSetWaterGradient">jjSetWaterGradient</a> and <a class="name" href="#jjSetFadeColors">jjSetFadeColors</a> respectively. As such, changes made here can be very far-reaching and dramatic. Palette-editing in AngelScript follows essentially a two step process: first, make all the changes you desire to a (non-const) jjPAL object, and second, call that object's <a class="name" href="#jjpal::apply">apply</a> function to make it be the current palette in use by the game. Here's a basic example:</p>
		<pre>void onLevelLoad() {
	jjPAL newPal;
	newPal.load("Castle1.j2t");
	newPal.gradient(190,0,255, 0,0,147, 112, 8); <span class="comment">//change the colors of the knight statues</span>
	newPal.apply(); <span class="comment">//the game will now use a slightly-modified version of the Castle1 palette</span>
}</pre>
		<p>In the simple example above, it would not actually be needed to declare a new jjPAL object. Instead, you could use <a class="name" href="#jjPalette">jjPalette</a>, which contains the current palette actually in use by the game. When you call <span class="name">apply</span> on any other jjPAL object, you copy its contents to <span class="name">jjPalette</span>. Editing it directly is good for cumulative changes, but if you'd like to revert back to a previous state, you'll need a second jjPAL object. Alternatively, you could save the current state by copying it to a second jjPAL object using the assignment operator, e.g. <code>jjPAL myPal = jjPalette;</code>.</p>
		<p>There is also a const jjPAL, <a class="name" href="#jjBackupPalette">jjBackupPalette</a>, which maintains the palette that came with the tileset and will never change.</p>
		<dl class="class constructor">
			<dt><span class="name" id="jjpal::jjPAL">jjPAL</span>()</dt>
			<dd>Constructs a default instance of the class. The resulting palette has all colors set to black.</dd>
		</dl>
		<dl class="class operator">
			<dt>jjPAL&amp; <span class="name" id="jjpal::opAssign">operator = </span>(const jjPAL &amp;in <span class="param">palette</span>)</dt>
			<dd>Copies contents of one palette to another. Returns a reference to self.</dd>
			<dt>bool <span class="name" id="jjpal::opEquals">operator == </span>(const jjPAL &amp;in <span class="param">palette</span>) const</dt>
			<dd>Compares two palettes and returns true if all pairs of fields on corresponding indexes are identical or false otherwise.</dd>
		</dl>
		<dl class="class" id="jjPALList">
			<dt>jjPALCOLOR <span class="name" id="jjpal::color">color[256]</span></dt>
			<dd>At its heart, a palette is a collection of 256 colors, and you can access them individually through the <span class="name">color</span> array. In fact, you could if you chose reproduce nearly every jjPAL method here by directly altering the colors, but the methods are here to save you time, so don't do that. The details of jjPALCOLOR objects are listed below this section, though most basically you just use their properties <a class="name" href="#jjpalcolor::red">red</a>, <a class="name" href="#jjpalcolor::green">green</a>, and <a class="name" href="#jjpalcolor::blue">blue</a>.</dd>
			<dt>void <span class="name" id="jjpal::apply">apply</span>() const</dt>
			<dd>Causes the contents of this jjPAL object to be the current colors in use by the game, and by extension <a class="name" href="#jjPalette">jjPalette</a>.</dd>
			<dd>Note that this function does a fair bit of housekeeping behind the scenes to make sure everything is propertly converted to the new palette�there's a difference between <code>myPal.apply();</code> and <code>jjPalette = myPal;</code>�and so it should always be called after doing any edits, even if you've been making the edits directly to <span class="name">jjPalette</span>. Failure to do so can have unpredictable consequences.</dd>
			<dt>void <span class="name" id="jjpal::copyFrom">copyFrom</span>(uint8 <span class="param">start</span>, uint8 <span class="param">length</span>, uint8 <span class="param">start2</span>, const jjPAL &amp;in <span class="param">source</span>, float <span class="param">opacity</span>)</dt>
			<dd>Overlays <span class="param">length</span> colors from <span class="param">source</span> onto the current palette, beginning at <span class="param">start</span> on this palette and <span class="param">start2</span> on <span class="param">source</span>. If <span class="param">opacity</span> is below 1.0, the new colors will only partially replace the old.</dd>
			<dt>void <span class="name" id="jjpal::fill">fill</span>(uint8 <span class="param">red</span>, uint8 <span class="param">green</span>, uint8 <span class="param">blue</span>, uint8 <span class="param">start</span>, uint8 <span class="param">length</span>, float <span class="param">opacity</span> = 1.0)</dt>
			<dt>void <span class="name">fill</span>(uint8 <span class="param">red</span>, uint8 <span class="param">green</span>, uint8 <span class="param">blue</span>, float <span class="param">opacity</span> = 1.0)</dt>
			<dt>void <span class="name">fill</span>(jjPALCOLOR <span class="param">color</span>, uint8 <span class="param">start</span>, uint8 <span class="param">length</span>, float <span class="param">opacity</span> = 1.0)</dt>
			<dt>void <span class="name">fill</span>(jjPALCOLOR <span class="param">color</span>, float <span class="param">opacity</span> = 1.0)</dt>
			<dd>Replaces a series of <span class="param">length</span> colors beginning at <span class="param">start</span> with the color <span class="param">red,green,blue</span> or, in the later 2 overloads, <span class="param">color</span>.	If <span class="param">opacity</span> is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the <span class="param">start</span> and <span class="param">length</span> arguments to fill (or tint) the entire palette.</dd>
			<dt>uint8 <span class="name" id="jjpal::findNearestColor">findNearestColor</span>(jjPALCOLOR <span class="param">color</span>) const</dt>
			<dd>Returns index of the palette entry whose components differ the least from those of the provided <span class="param">color</span>. Ensures the result has no special treatment by never returning values from the range of 0-15.</dd>
			<dt class="updated">void <span class="name" id="jjpal::gradient">gradient</span>(uint8 <span class="param">red1</span>, uint8 <span class="param">green1</span>, uint8 <span class="param">blue1</span>, uint8 <span class="param">red2</span>, uint8 <span class="param">green2</span>, uint8 <span class="param">blue2</span>, uint8 <span class="param">start</span> = 176, uint8 <span class="param">length</span> = 32, float <span class="param">opacity</span> = 1.0, bool <span class="param">inclusive</span> = false)</dt>
			<dt>void <span class="name">gradient</span>(jjPALCOLOR <span class="param">color1</span>, jjPALCOLOR <span class="param">color2</span>, uint8 <span class="param">start</span> = 176, uint8 <span class="param">length</span> = 32, float <span class="param">opacity</span> = 1.0, bool <span class="param">inclusive</span> = false)</dt>
			<dd>Replaces a series of <span class="param">length</span> colors beginning at <span class="param">start</span> with a gradient beginning with <span class="param">red1,green1,blue1</span> (or <span class="param">color1</span>) and ending with <span class="param">red2,green2,blue2</span> (or <span class="param">color2</span>). If <span class="param">opacity</span> is specified and below 1.0, the new colors will only partially replace the old, making for a tinting effect.</dd>
			<dd>If <span class="param">inclusive</span> is false (default), the gradient will lead up to the second color but the second color will not itself appear. If true, the second color will appear directly in the palette as the final color of the gradient. For example, a gradient of <span class="param">red1</span>:100, <span class="param">red2</span>:0, and <span class="param">length</span>:3 will produce the red values <code>100,66,33</code> when <span class="param">inclusive</span> is false, but <code>100,50,0</code> when <span class="param">inclusive</span> is true.</dd>
			<dd>The default values for <span class="param">start</span> and <span class="param">length</span> will set a gradient for the colors used by water and (in most tilesets) textured backgrounds.</dd>
			<dt class="updated">bool <span class="name" id="jjpal::load">load</span>(string&amp; <span class="param">filename</span>)</dt>
			<dd>Loads a palette from the specified file. If the file is a tileset with a ".j2t" extension, an 8-bit globally-paletted GIF image/animation with a ".gif" extension, or an 8-bit paletted or grayscale PNG image with a ".png" extension, will try to access the palette stored in the file. Otherwise, tries to treat it as a palette file saved in "Color Table" format in <a href="http://alister.eu/palsuite/">Palette Suite</a>, and if that fails, simply reads the first 1024 bytes of the file. Returns false if the file cannot be found, or if trying to read the file based on its extension fails, or if the file is fewer than 1024 bytes long; otherwise true.</dd>
			<dt>void <span class="name" id="jjpal::reset">reset</span>()</dt>
			<dd>Loads the original colors used by the tileset. There is no non-stylistic difference between <code>myPal.reset();</code> and <code>myPal = jjBackupPalette;</code>.</dd>
		</dl>

		<h3 id="jjpalcolor"><span>class jjPALCOLOR</span></h3>
		<p>The basic units of jjPAL objects. At their heart, they're just tiny collections of RGB values, but methods for playing with the HSL values are also provided in case you don't mind using up a little bit more processing power. You can define and initialize your own jjPALCOLOR instances in two ways: either by using the default constructor and setting each property manually or by using a provided <span class="name">jjPALCOLOR</span>(uint8 <span class="param">red</span>, uint8 <span class="param">green</span>, uint8 <span class="param">blue</span>) constructor. Alphabetical order is ignored in favor of traditional order in the list below</p>
		<dl class="class constructor">
			<dt><span class="name" id="jjpalcolor::jjPALCOLOR">jjPALCOLOR</span>()</dt>
			<dt><span class="name">jjPALCOLOR</span>(uint8 <span class="param">red</span>, uint8 <span class="param">green</span>, uint8 <span class="param">blue</span>)</dt>
			<dd>Constructs an instance of the class. The default constructor results in black color, i.e. one having all component values set to 0. The other constructor builds an instance with the provided RGB values.</dd>
		</dl>
		<dl class="class constructor">
			<dt>jjPALCOLOR&amp; <span class="name" id="jjpalcolor::opAssign">operator = </span>(const jjPALCOLOR &amp;in <span class="param">color</span>)</dt>
			<dd>Does a component-wise assignment of one instance to another. Returns a reference to self.</dd>
			<dt>bool <span class="name" id="jjpalcolor::opEquals">operator == </span>(const jjPALCOLOR &amp;in <span class="param">color</span>) const</dt>
			<dd>Performs a component-wise comparison and returns true if all components of both instances have the same values or false otherwise.</dd>
		</dl>
		<dl class="class" id="jjPALCOLORList">
			<dt>uint8 <span class="name" id="jjpalcolor::red">red</span></dt>
			<dd>How red this palette color is.</dd>
			<dt>uint8 <span class="name" id="jjpalcolor::green">green</span></dt>
			<dd>How green this palette color is.</dd>
			<dt>uint8 <span class="name" id="jjpalcolor::blue">blue</span></dt>
			<dd>How blue this palette color is.</dd>
			<dt>uint8 <span class="name" id="jjpalcolor::getHue">getHue</span>() const</dt>
			<dd>The hue of this palette color.</dd>
			<dt>uint8 <span class="name" id="jjpalcolor::getSat">getSat</span>() const</dt>
			<dd>The saturation of this palette color, where 0 is grayscale and 255 is most saturated.</dd>
			<dt>uint8 <span class="name" id="jjpalcolor::getLight">getLight</span>() const</dt>
			<dd>The lighting of this palette color, where 0 is black and 255 is white.</dd>
			<dt>void <span class="name" id="jjpalcolor::setHSL">setHSL</span>(int <span class="param">hue</span>, uint8 <span class="param">sat</span>, uint8 <span class="param">light</span>)</dt>
			<dd>Changes the entire color to a brand new one derived from the given HSL values. Due to the complexity of the calculations involved, you can only change all three values at a time, so if you want to leave, for instance, saturation constant, you'll need to read the old value through <a class="name" href="#jjpalcolor::getSat">getSat</a> and then use that as the <span class="param">sat</span> parameter.</dd>
			<dd><span class="param">hue</span> is an int instead of a uint8 because it's a loop instead of a scale. 2, 258, 514, -254, etc., are all equally valid and all mean the same hue.</dd>
			<dt>void <span class="name" id="jjpalcolor::swizzle">swizzle</span>(COLOR::Component <span class="param">red</span>, COLOR::Component <span class="param">green</span>, COLOR::Component <span class="param">blue</span>)</dt>
			<dd>Swaps values of selected components of the color. The value of the red component will be replaced with that specified by parameter <span class="param">red</span>, the value of the green component with that specified by <span class="param">green</span> and the value of blue with that specified by <span class="param">blue</span>. Values accepted by the parameters are COLOR::RED, COLOR::GREEN and COLOR::BLUE.</dd>
		</dl>

		<h3 id="jjcanvas"><span>class jjCANVAS</span></h3>
		<p>The <a class="name" href="#jjobj::draw">jjOBJ::draw</a> method is okay, but sometimes you just need to draw things to the screen that aren't jjOBJs. The upper right corner of the player's screen shows how much health they have, for example... how can you get in on that action? The answer is the jjCANVAS class, which presents the JJ2 window as a canvas for you to draw stuff on.</p>
		<p>Probably the most straightforward use of jjCANVAS is for drawing your own HUD elements, for which the following hooks are presently available. Note that these hooks have bool return values: if you return true, JJ2 will not draw the standard visuals for that subject. So if you want to show a player's health in the upper left instead of the upper right, for example, not only will you need to call jjCANVAS methods to draw the health where you want it to go, you'll also need to have <span class="name">onDrawHealth</span> return true.</p>
		<pre>bool onDrawAmmo(jjPLAYER@ player, jjCANVAS@ canvas) {}
bool onDrawHealth(jjPLAYER@ player, jjCANVAS@ canvas) {}
bool onDrawLives(jjPLAYER@ player, jjCANVAS@ canvas) {}
bool onDrawPlayerTimer(jjPLAYER@ player, jjCANVAS@ canvas) {}
bool onDrawScore(jjPLAYER@ player, jjCANVAS@ canvas) {}</pre>
		<p>Each of the above hooks presents you with an entire player screen to draw HUD-style elements upon. If you're curious, the origin of the screen may be determined through the <a class="name" href="#jjplayer::subscreenX">subscreenX</a> and <a class="name" href="#jjplayer::subscreenY">subscreenY</a> properties of the player, and its size by the <a class="name" href="#jjSubscreenWidth">jjSubscreenWidth</a> and <a class="name" href="#jjSubscreenHeight">jjSubscreenHeight</a> global properties. Any (portion of any) graphic to be drawn outside of that rectangle will simply be ignored, so don't worry too much about fitting into the boundaries.</p>
		<pre>bool onDrawGameModeHUD(jjPLAYER@ player, jjCANVAS@ canvas) {}</pre>
		<p>This hook mostly works the same way as the above five, but has a wider range: it covers all gamemode-specific HUD elements for all competitive multiplayer gamemodes (i.e. everything except for SP/Coop). When writing this hook you may therefore wish to consult <a href="#jjGameMode">jjGameMode</a> and/or <a href="#jjGameCustom">jjGameCustom</a> to determine the proper return value and also to decide what to draw. Everything that gets drawn to the top left corner of the screen is covered by this hook�except for score in SP/Coop, which is covered by <span class="name">onDrawScore</span>�as is the "Find Exit" text in Treasure Hunt. (Some future JJ2+ release should introduce more nuanced coverage, for example to allow replacing the control point portion of the Domination HUD but not the team scores portion, but that is not currently available.)</p>
		<p><span class="name">onDrawGameModeHUD</span> is also special because it is the only HUD hook that is called in free camera mode (for an idle server, or while spectating no one as a spectator or as an Out player in an LRS-based gamemode). In this case, the <span class="param">player</span> argument will equal <code>null</code> instead of being a handle to one of the <a href="#jjPlayers">jjPlayers</a> entries.</p>
		<p>There are additionally eight hooks which draw to the level instead of the HUD, as determined by the positions of each of the eight layers, in the format <code>void onDrawLayer#(jjPLAYER@ player, jjCANVAS@ canvas)</code> where # is any number from 1 to 8. These hooks are only called for those layers for which <a class="name" href="#jjlayer::hasTiles">jjLAYER::hasTiles</a> is true, and let you draw tiles not fixed to the 32x32 grid, text in front of sign tiles, or whatever else you may please. Just note that jjCANVAS's drawing methods are just that�drawing methods�and do not actually add tiles or enemies or anything to the level to be interacted with. Additionally, the layer hooks don't care if a layer has 'Tile Width' or 'Tile Height' checked, and will instead only perform each drawing operation once per player subscreen.</p>
		<p>Most of the methods below take a pair of parameters <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> and uint8 <span class="param">param</span>. A full list of options and their explanations can be found in the <a href="#spritemode">appendix</a>, but briefly, the sprite modes control how the basic individual pixel colors of the image (sprite, rectangle, whatever) you're drawing will turn out as colors on the screen. For example, consider drawing the first frame of the powered-up toaster animation:</p>
		<pre>bool onDrawHealth(jjPLAYER@ play, jjCANVAS@ screen) {
	screen.drawSprite(50, 50, ANIM::AMMO, 0, 0, 1, SPRITE::NORMAL, 123); <span class="comment">//if using SPRITE::NORMAL, param's value doesn't actually matter; 123 is as good as any</span>
	return false;
}</pre>
		<p>The method as called above uses SPRITE::NORMAL (the default value), which draws each pixel of the sprite exactly as it appears in anims.j2a, but you have plenty of other options. <code>SPRITE::PALSHIFT, 16</code> will draw the sprite as pink instead of blue (16 colors farther down in the palette). <code>SPRITE::BRIGHTNESS, 64</code> will draw the sprite as dark blue (64 is half of 128, which for SPRITE::BRIGHTNESS is the normal brightness value) instead of bright blue. <code>SPRITE::BLEND_LUMINANCE, 255</code> (the BLEND_ sprite modes use 255 to signify complete opacity) will draw each pixel of the sprite using the colors (but not the brightness) of the pixel that was already there on the screen. JJ2's commonest sprite modes are NORMAL, TRANSLUCENT, FROZEN, PLAYER, and (for coloring text characters) PALSHIFT, but JJ2+ provides you with many more options, so try them all!.</p>
		<p>Alphabetical order is defied slightly while listing the methods of jjCANVAS, in order to present the most fundamental method first and then its variants afterwards.</p>
		<dl class="class" id="jjCANVASList">
			<dt>void <span class="name" id="jjcanvas::drawSprite">drawSprite</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">setID</span>, uint8 <span class="param">animation</span>, uint8 <span class="param">frame</span>, int8 <span class="param">direction</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>Draws a single sprite frame at <span class="param">xPixel,yPixel</span>. The <span class="param">setID, animation</span>, and <span class="param">frame</span> parameters correspond to the "Set ID," "Animation," and "Frame #" sliders respectively in <a href="http://www.jazz2online.com/downloads/4041/jazz-sprite-dynamite/">Jazz Sprite Dynamite</a>, but are 0-indexed. You are allowed to use a simple integer to specify the <span class="param">setID</span>, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24; <a href="#anim">the full list of constants can be found in the appendix at the bottom of this file.</a> For an example, to draw a broken bird cage (9-5-1 in Jazz Sprite Dynamite), you would write <code>ANIM::BIRD, 4, 0</code>.</dd>
			<dd>The <span class="param">direction</span> parameter determines which direction the sprite will be facing; values 0 to 63 will not flip the sprite, -64 to -1 will flip it horizontally, 64 to 127 will flip it vertically, and -128 to -65 will flip it both horizontally and vertically. Alternatively to integer values, you can use constants made for this very purpose that belong to the <span class="ns">SPRITE::Direction</span> enum: <span class="ns">SPRITE::FLIPNONE</span>, <span class="ns">SPRITE::FLIPH</span>, <span class="ns">SPRITE::FLIPV</span>, <span class="ns">SPRITE::FLIPHV</span>.</dd>
			<dt>void <span class="name" id="jjcanvas::drawSpriteFromCurFrame">drawSpriteFromCurFrame</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, uint <span class="param">sprite</span>, int8 <span class="param">direction</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>The same as <a class="name" href="#jjcanvas::drawSprite">drawSprite</a>, but takes a single <span class="param">sprite</span> parameter instead of one each for Set, Animation, and Frame. The name references the <span class="name">curFrame</span> property of <a href="#jjobj::curFrame">jjOBJ</a> and <a href="#jjplayer::curFrame">jjPLAYER</a>, whose real significance is as an index to <a href="#jjAnimFrames">jjAnimFrames[]</a>.</dd>
			<dd>Internally any <span class="name">draw*Sprite</span> method is actually a call to the corresponding <span class="name">draw*SpriteFromCurFrame</span> method, with the following formula applied to find the <span class="param">curFrame</span> value: <code>(jjAnimations[jjAnimSets[setID].firstAnim + animation].firstFrame + frame) % jjAnimations[jjAnimSets[setID].firstAnim + animation].frameCount</code></dd>
			<dt>void <span class="name" id="jjcanvas::drawResizedSprite">drawResizedSprite</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">setID</span>, uint8 <span class="param">animation</span>, uint8 <span class="param">frame</span>, float <span class="param">xScale</span>, float <span class="param">yScale</span>, SPRITE::Mode <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dt>void <span class="name" id="jjcanvas::drawResizedSpriteFromCurFrame">drawResizedSpriteFromCurFrame</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, uint <span class="param">sprite</span>, float <span class="param">xScale</span>, float <span class="param">yScale</span>, SPRITE::Mode <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>Draws a single resized sprite frame at <span class="param">xPixel,yPixel</span>. This swaps out <a href="#jjcanvas::drawSprite">drawSprite</a>'s <span class="param">direction</span> argument with a pair of float arguments, <span class="param">xScale</span> and <span class="param">yScale</span>, which determine how much the sprite is enlarged (or shrunken) on each axis. For example, a 32x32 sprite drawn with <span class="param">xScale</span> 3 and <span class="param">yScale</span> 1.5 would be drawn across a 96�48 area. Making one or both scale values negative will cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing will be performed while resizing the sprite.</dd>
			<dt>void <span class="name" id="jjcanvas::drawRotatedSprite">drawRotatedSprite</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">setID</span>, uint8 <span class="param">animation</span>, uint8 <span class="param">frame</span>, int <span class="param">angle</span>, float <span class="param">xScale</span> = 1, float <span class="param">yScale</span> = 1, SPRITE::Mode <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dt>void <span class="name" id="jjcanvas::drawRotatedSpriteFromCurFrame">drawRotatedSpriteFromCurFrame</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, uint <span class="param">sprite</span>, int <span class="param">angle</span>, float <span class="param">xScale</span> = 1, float <span class="param">yScale</span> = 1, SPRITE::Mode <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>Draws a single resized and rotated sprite frame at <span class="param">xPixel,yPixel</span>. This carries over the <span class="param">xScale</span> and <span class="param">yScale</span> arguments from <a href="#jjcanvas::drawResizedSprite">drawResizedSprite</a>, and adds a new <span class="param">angle</span> parameter with the same 0-1023 domain as <a href="#jjSin">jjSin</a> and <a href="#jjCos">jjCos</a>. (Numbers outside the domain will be seemlessly moduloed.) An <span class="param">angle</span> of 0 will not rotate the sprite at all. Without getting into matrix math, you can think of the sprite as being resized before it is rotated, which in most cases is exactly what you'd want. For example, a 32�32 sprite drawn with <span class="param">angle</span> 256, <span class="param">xScale</span> 2, and <span class="param">yScale</span> 1 would be drawn across an area of 32�64, not 64�32.</dd>
			<dd>Rotated sprites should be no larger (before transformations are applied) than 128 pixels wide or 256 pixels high. The results of drawing larger sprites are, for now, undefined while we decide whether this restriction should or can be removed.</dd>
			<dd>Any sprite that <a class="name" href="#jjcanvas::drawSprite">drawSprite</a> can draw, <a href="#jjcanvas::drawResizedSprite">drawResizedSprite</a> can draw in the same way by setting <span class="param">xScale</span> and <span class="param">yScale</span> each to 1. And any sprite that <a href="#jjcanvas::drawResizedSprite">drawResizedSprite</a> can draw, <a href="#jjcanvas::drawRotatedSprite">drawRotatedSprite</a> can draw unless it's greater than 128�256, by setting <span class="param">angle</span> to 0. As you might imagine, though, the simpler methods (besides being quicker to write) run faster than the more complicated methods, so you might as well use them when you can get away with it.</dd>
			<dt>void <span class="name" id="jjcanvas::drawSwingingVineSpriteFromCurFrame">drawSwingingVineSpriteFromCurFrame</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">sprite</span>, int <span class="param">length</span>, int <span class="param">curvature</span>, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>Draws a single sprite frame at <span class="param">xPixel,yPixel</span> in the style of a Swinging Vine object. The parameters named <span class="param">length</span> and <span class="param">curvature</span> correspond respectively to properties <a class="name" href="#jjobj::var">var[1]</a> (normally always 128) and <a class="name" href="#jjobj::var">var[2]</a> of swinging vines; if the sprite is shorter than the <span class="param">length</span> value, its pixels will be repeated again from the top as necessary.</dd>
			<dd>For boring internal code reasons, this method expects that sprites will have no transparent pixels. Instead, to tell this method not to draw an individual pixel from the frame, its value must be <strong>128</strong> instead of 0. Using normal transparent pixels instead will cause the sprite to be drawn as a jumbled mess.</dd>
			<dt>void <span class="name" id="jjcanvas::drawPixel">drawPixel</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, uint8 <span class="param">color</span>, SPRITE::Mode <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>Changes the color of the pixel at <span class="param">xPixel,yPixel</span> into the palette color corresponding to index <span class="param">color</span>. If you are drawing anything more than a handful of pixels at a time, you should consider creating a new sprite of your own using <a href="#jjpixelmap">jjPIXELMAP</a>, and then drawing that sprite as a single unit with some other drawing method.</dd>
			<dt>void <span class="name" id="jjcanvas::drawRectangle">drawRectangle</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">width</span>, int <span class="param">height</span>, uint8 <span class="param">color</span>, SPRITE::Mode <span class="param">mode</span> = SPRITE::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dd>Draws a rectangle with one of its vertices at <span class="param">xPixel,yPixel</span> of specified <span class="param">width</span> and <span class="param">height</span> in the palette color corresponding to index <span class="param">color</span>.</dd>
			<dt>void <span class="name" id="jjcanvas::drawString">drawString</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, <span class="ns">STRING::Size</span> <span class="param">size</span> = STRING::SMALL,<span class="ns">STRING::Mode</span> <span class="param">mode</span> = STRING::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dt>void <span class="name" id="jjcanvas::drawString">drawString</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, const jjANIMATION &amp;in <span class="param">animation</span>, <span class="ns">STRING::Mode</span> <span class="param">mode</span> = STRING::NORMAL, uint8 <span class="param">param</span> = 0)</dt>
			<dt>void <span class="name">drawString</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, <span class="ns">STRING::Size</span> <span class="param">size</span>, const jjTEXTAPPEARANCE &amp;in <span class="param">appearance</span>, uint8 <span class="param">param1</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">spriteMode</span> = SPRITE::PALSHIFT, uint8 <span class="param">param2</span> = 0)</dt>
			<dt>void <span class="name">drawString</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, const jjANIMATION &amp;in <span class="param">animation</span>, const jjTEXTAPPEARANCE &amp;in <span class="param">appearance</span>, uint8 <span class="param">param1</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">spriteMode</span> = SPRITE::PALSHIFT, uint8 <span class="param">param2</span> = 0)</dt>
			<dd>Draws a string of characters of your choice at position (<span class="param">xPixel</span>, <span class="param">yPixel</span>) on the screen. Unique <span class="param">size</span> values are SMALL, MEDIUM, and LARGE, or you can also specify a different <a href="#jjanimation">jjANIMATION</a> to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is �0�, frame 33 is �A�, and so on. If it helps, you may think of the overloads with <span class="param">size</span> arguments as shorthand for <code>jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size]</code>.</dd>
			<dd>The following options are available for the <span class="param">mode</span> parameter:<ul>
				<li><span class="name">NORMAL</span>: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.</li>
				<li><span class="name">DARK</span>: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.</li>
				<li><span class="name">RIGHTALIGN</span>: Draws a right-aligned string with normal letters. |, @, and # have no effect.</li>
				<li><span class="name">SPIN</span>: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The <span class="param">param</span> value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.</li>
				<li><span class="name">BOUNCE</span>: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The <span class="param">param</span> value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.</li>
				<li><span class="name">PALSHIFT</span>: Draws a left-aligned string with normal letters whose colors are all shifted <span class="param">param</span> palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.</li>
			</ul>
			Most of these modes use alignment of STRING::DEFAULT, meaning that values of <span class="param">xPixel</span> higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for <a class="name" href="#jjtextappearance::align">jjTEXTAPPEARANCE::align</a> for more detail.</dd>
			<dd>In the second prototype of the function, arguments <span class="param">mode</span> and <span class="param">param</span> are split into four arguments <span class="param">appearance</span>, <span class="param">param1</span>, <span class="param">spriteMode</span> and <span class="param">param2</span> for more customizability: <span class="param">appearance</span> controls several different aspects of text discussed in the <a href="#jjtextappearance">jjTEXTAPPEARANCE</a> section, <span class="param">param1</span> is a multiplier applied to amplitude of text determined by <span class="param">appearance</span>, <span class="param">spriteMode</span> is the sprite mode the characters will be drawn in, and <span class="param">param2</span> is the sprite mode parameter. Notice that the choice of <span class="param">spriteMode</span> will also determine the effect of using special characters such as # and | in text (if <span class="param">appearance</span> allows them to take effect).</dd>
			<dt>void <span class="name" id="jjcanvas::drawTile">drawTile</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, uint16 <span class="param">tile</span>, TILE::Quadrant <span class="param">tileQuadrant</span> = TILE::ALLQUADRANTS)</dt>
			<dd>Draws a <a href="#tileids">tile</a> of your choice at some position on the screen. This is purely a drawing operation; using it to draw masked tiles to the screen does not create masked areas for players or other objects to interact with. Possible values of <span class="param">tileQuadrant</span> are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS.</dd>
		</dl>

		<h3 id="jjlayer"><span>class jjLAYER</span></h3>
		<p>As suggested by the name, jjLAYER is the class JJ2+ uses to represent layers of tiles. Normally any given level contains exactly eight jjLAYER objects, numbered 1�8 in JCS. (JCS calls these, in order from front to back, "Foreground layer #2," "Foreground layer #1," "Sprite foreground layer," "Sprite layer," "Background layer #1," "Background layer #2," "Backgound layer #3," and "Background layer." However, common parlance and therefore also this readme call them simply "Layer 1" through "Layer 8.")</p>
		<p>In any level where you do not plan on changing which (or in what order) tile layers are drawn to the screen, you rarely need to worry about the jjLAYER class, because all its major properties have indexed global properties serving as shortcuts to them. For example, to get the width in tiles of Layer 4 (256 by default in JCS), you can use <a class="name" href="#jjLayerWidth">jjLayerWidth</a> and write <code>jjLayerWidth[4]</code> instead of <code>jjLayers[4].width</code>. (Said shortcuts may even be somewhat faster to execute, although you shouldn't need to worry about that.) But if you make any calls to <a class="name" href="#jjLayerOrderSet">jjLayerOrderSet</a>, particularly in conjunction with one or more jjLAYER <a href="#jjlayer::jjLAYER">constructors</a> or else <a class="name" href="#jjLayersFromLevel">jjLayersFromLevel</a>, or if you plan on using any advanced textured layer effects, knowing the class's properties and methods should be helpful.</p>
		<dl class="class constructor">
			<dt class="updated"><span class="name" id="jjlayer::jjLAYER">jjLAYER</span>(const <span class="ns">jjLAYER</span> &amp;in <span class="param">layer</span>)</dt>
			<dd>Copies almost all properties (including tile layout, but excluding <a class="name" href="#jjlayer::spriteMode">spriteMode</a> and <a class="name" href="#jjlayer::spriteParam">spriteParam</a>) of another jjLAYER.</dd>
			<dd>If <span class="param">otherLayer</span> is <code>jjLayers[8]</code> and both <code>jjLayers[8].xSpeedModel</code> and <code>jjLayers[8].ySpeedModel</code> equal <span class="name">LAYERSPEEDMODEL::LAYER8</span>, then the <a class="name" href="#jjlayer::xSpeedModel">xSpeedModel/ySpeedModel</a> properties for this new layer will be set to <span class="name">LAYERSPEEDMODEL::NORMAL</span> instead. Otherwise the property values of <span class="param">otherLayer</span> will be copied faithfully.</dd>
			<dt><span class="name">jjLAYER</span>(uint <span class="param">layerWidth</span>, uint <span class="param">layerHeight</span>)</dt>
			<dd>Creates a new jjLAYER and sets <a class="name" href="#jjlayer::height">height</a> to <span class="param">layerHeight</span> and both <a class="name" href="#jjlayer::width">width</a> and <a class="name" href="#jjlayer::widthReal">widthReal</a> to <span class="param">layerWidth</span>. The tile map will be empty, which to say, entirely composed of word 0 (0,0,0,0), but <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> and <a class="name" href="#jjlayer::hasTiles">hasTiles</a> will be set to true anyway in preparation for your filling in part of the tile map with tiles. Unlike JCS, JJ2+ will not do the work of guaranteeing that layers can tile horizontally for you, so if you plan to set to true your constructed layer's <a class="name" href="#jjlayer::tileWidth">tileWidth</a> property, you should make sure to use a <span class="param">layerWidth</span> divisible by four.</dd>
			<dd>If either <span class="param">layerWidth</span> or <span class="param">layerHeight</span> is an invalid value (i.e. less than 1 or greater than 1023), a default layer size of 8�8 will be used instead.</dd>
		</dl>
		<dl class="class" id="jjLAYERList">
			<dt class="new"><span class="name" id="jjlayer::cylinder">cylinder</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::CYLINDER, which draws <a class="name" href="#jjlayer::texture">texture</a> as the inside of a horizontal cylinder receding a little ways into the distance.</dd>
			<dd><code>bool cylinder.fade</code>, when true, increasingly affects colors closer to the horizon: when <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16, a semitransparent glowing line appears across the horizon using the RGB color chosen by <code>cylinder.setFadeColor</code>, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.</dd>
			<dd><code>float cylinder.fadePositionX</code> and <code>float cylinder.fadePositionY</code> set the location of the center of the horizon, as multiplied by the <a class="name" href="#jjSubscreenHeight">size of the player's screen</a>. The default values are both 0.5. Changing fadePositionY very far from 0.5 tends to look weird, especially when <code>cylinder.halfSize</code> is true.</dd>
			<dd><code>bool cylinder.halfSize</code>, when true, stretches the texture four times across the screen instead of only once and makes the curvature more extreme. The default value is false.</dd>
			<dd><code>jjPALCOLOR cylinder.getFadeColor() const</code> and <code>void cylinder.setFadeColor(jjPALCOLOR)</code> read and write the RGB components of the color drawn over the horizon when <code>cylinder.fade</code> is true and <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16. The default value is 0,0,0.</dd>
			<dt>const bool <span class="name" id="jjlayer::hasTileMap">hasTileMap</span></dt>
			<dd>Layers that contain no tiles at all (other than tile 0) in JCS are saved as defective layers that define size, speed, etc. properties but do not include actual tile maps, meaning that they can never be successfully drawn to the screen. This property is therefore false for those defective layers and true for all other layers.</dd>
			<dt>bool <span class="name" id="jjlayer::hasTiles">hasTiles</span></dt>
			<dd>Simply, whether JJ2 should draw the layer or not. (Defaults to the same value as <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a>.) In addition to the layer's tiles, this also controls whether the layer's <code>onDrawLayer#</code> hook, if any, can be called (see <a href="#jjcanvas">jjCANVAS section</a>), but does not impact sprites drawn by the <a class="name" href="#jjDrawSprite">jjDrawSprite</a> family no matter the value of their <span class="param">layerZ</span> arguments. If <span class="name">hasTileMap</span> is false but <span class="name">hasTiles</span> is true, the <code>onDrawLayer#</code> hook will still work but no tiles will be drawn because there will be no tiles to draw.</dd>
			<dd>As an alternative to setting <span class="name">hasTiles</span> to false, you can also exclude a layer from the drawing order altogether using <a class="name" href="#jjLayerOrderSet">jjLayerOrderSet</a>.</dd>
			<dt>const int <span class="name" id="jjlayer::height">height</span></dt>
			<dd>The height of the layer in tiles.</dd>
			<dt class="updated">bool <span class="name" id="jjlayer::limitVisibleRegion">limitVisibleRegion</span></dt>
			<dd>Assuming the layer's <a class="name" href="#jjlayer::tileHeight">tileHeight</a> is false and its <a class="name" href="#jjlayer::ySpeedModel">ySpeedModel</a> is either LAYERSPEEDMODEL::NORMAL or LAYERSPEEDMODEL::BOTHSPEEDS, whether the layer should be vertically offset some pixels downward (true) or not (false), the exact value depending on the current resolution.</dd>
			<dt class="new"><span class="name" id="jjlayer::menu">menu</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::MENU, which draws the rotating menu effect from the game's main menu. If <a class="name" href="#jjlayer::textureSurface">textureSurface</a> is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then <a class="name" href="#jjlayer::xInnerAutoSpeed">x/yInnerAutoSpeed</a> control the rotating/zooming speeds respectively.</dd>
			<dd><code>bool menu.lightToDark</code> should be set to true if the palette rows are light-to-dark gradients instead of the dark-to-light gradients used by the game's menu palette, but the default value is false.</dd>
			<dd><code>uint8 menu.palrow16</code> and <code>uint8 menu.palrow32</code> and <code>uint8 menu.palrow256</code> pick the 16-color-long palette rows used by the three different rotating sublayers, with the smaller numbers corresponding to the further back sublayers. The default values are all 0.</dd>
			<dd><code>float menu.pivotX</code> and <code>float menu.pivotY</code> are the point that all rotation happens around, as multiplied by the <a class="name" href="#jjSubscreenHeight">size of the player's screen</a>. The default values are both 0.5.</dd>
			<dt class="new"><span class="name" id="jjlayer::reflection">reflection</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::REFLECTION, which draws the bottom part of the screen as a 3D plane stretching into an infinite horizon (similar to <a class="name" href="#jjlayer::warpHorizon">warpHorizon</a>). However, the top part of the screen is not drawn to by this layer at all, and the bottom part (the 3D plane) reflects (i.e. vertically mirrors) all the tiles and sprites that had already been drawn to the top part of the screen prior to this layer being drawn. This texture style does not support <a class="name" href="#jjlayer::spriteMode">sprite modes</a>.</dd>
			<dd><code>uint8 reflection.distance</code> adjusts how close the 3D plane appears to be to the camera view. The default value is 0.</dd>
			<dd><code>uint8 reflection.distortion</code> distorts the reflection away from being a pure vertical mirroring, with higher values being more distorted, as based on the texture image and its internal offset. The default value is 0.</dd>
			<dd><code>float reflection.fadePositionX</code> sets the location of the horizontal center of the horizon, as multiplied by the <a class="name" href="#jjSubscreenWidth">size of the player's screen</a>. The default value is 0.5.</dd>
			<dd><code>uint8 reflection.tintColor</code> and <code>uint8 reflection.tintOpacity</code> combine to draw a constant semitransparent color over the entire reflective plane, similar to <a class="name" href="#jjcanvas::drawRectangle">drawing a rectangle</a> with <a href="#spritemode">SPRITE::BLEND_NORMAL</a> but better optimized. Their default values are 192 (the middle palette index from the 176�207 color gradient used by most textured background images) and 0 (no tint at all) respectively.</dd>
			<dd><code>bool reflection.blur</code>, when true, applies a post-processing horizontal blur effect to the outcome in 16-bit color mode. Has no effect in 8-bit color mode. The default value is false.</dd>
			<dd><code>float reflection.top</code> sets the location of the vertical center of the horizon, as multiplied by the <a class="name" href="#jjSubscreenHeight">size of the player's screen</a>. What this means is that everything below the vertical center reflects everything above the vertical center. When there are more horizontal lines of the screen that are reflecting than there are lines to be reflected�most commonly, when this property is set to a lower number than the default value of 0.5�the top line of the screen is repeated as many times as necessary to make up the difference. When the entire screen is taken up by 3D plane, pure blackness will be reflected</dd>
			<dt>int <span class="name" id="jjlayer::rotationAngle">rotationAngle</span></dt>
			<dd>Not settable in JCS: the offset of the angle at which this layer rotates while a player is <a class="name" href="#jjplayer::stoned">stoned</a>, with a domain of 0�1023 to be passed to <a class="name" href="#jjSin">jjSin</a> and <a class="name" href="#jjCos">jjCos</a>.</dd>
			<dd>Layers 1�8 have values -512, -256, 0, 0, 0, 256, 512, and 768, respectively. A script-created jjLAYER will default to 0.</dd>
			<dt>int <span class="name" id="jjlayer::rotationRadiusMultiplier">rotationRadiusMultiplier</span></dt>
			<dd>Not settable in JCS: the multipler of the distance this layer is offset from its center while rotating while a player is <a class="name" href="#jjplayer::stoned">stoned</a>. A value of 0 means the layer will not rotate at all; <code>jjLayers[5].rotationRadiusMultiplier = 0;</code> might therefore be a useful line of code in levels that give Layer 5 speed values to match Layer 4's.</dd>
			<dd>Layers 1�8 have values 4, 3, 0, 0, 2, 2, 1, and 1, respectively. A script-created jjLAYER will default to 0.</dd>
			<dt class="updated">SPRITE::Mode <span class="name" id="jjlayer::spriteMode">spriteMode</span></dt>
			<dt>uint8 <span class="name" id="jjlayer::spriteParam">spriteParam</span></dt>
			<dd>The sprite mode and sprite mode parameter used to draw this layer's tiles or texture effect. The default values for all layers are SPRITE::NORMAL and 0, but <a href="#spritemode">other possible SPRITE::Mode constants appear with explanations in the appendix below.</a></dd>
			<dd>For non-textured layers, all tiles in this layer whose <a class="name" href="#jjTileType">jjTileType</a> values are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite mode and parameter, while tile types 1, 2, 3, and 6 override this with SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN respectively. Textured layers ignore tile types altogether but have their own caveat: they will be drawn in 8-bit style in order to create a sprite suitable for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is noticeable only when <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16, <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is WARPHORIZON, TUNNEL, or CYLINDER, and <a class="name" href="#jjlayer::fade">fade</a> is true.</dd>
			<dd>These properties do not affect any calls made to any <a class="name" href="#jjcanvas">jjCANVAS</a> methods on an <code>onDrawLayer</code> hook attached to this layer. SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No sprite modes other than SPRITE::NORMAL are supported by textured layers using <a class="name" href="#jjlayer::textureStyle">TEXTURE::REFLECTION</a>.</dd>
			<dt class="new">TEXTURE::Texture <span class="name" id="jjlayer::texture">texture</span></dt>
			<dd>For textured layers, which 256�256 pixel (aka 8�8 tile) texture is used by the layer, unless <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::MENU. Defaults to TEXTURE::FROMTILES (previously named LAYER8 after the only layer that could be reasonably textured), meaning whatever the first 64(=8*8) tiles in the layer are. (If the layer has fewer than 64 tiles, this may cause JJ2 to crash.) If <a class="name" href="#jjpixelmap::makeTexture">jjPIXELMAP::makeTexture</a> was called on this layer, then <span class="name">texture</span> will equal TEXTURE::CUSTOM, but you cannot write that value to this property manually. The other options are listed <a href="#texture">in the appendix at the bottom of this file</a>.</dd>
			<dt class="new">SURFACE::Surface <span class="name" id="jjlayer::textureSurface">textureSurface</span></dt>
			<dd>Whether this layer should be drawn as a texture effect instead of as a regular grid of tiles, and if so, to which parts of the screen it should be drawn. A few enum options are available:
				<ul>
					<li><span class="name">SURFACE::UNTEXTURED</span>: The default, corresponding to leaving the "Texture mode" checkbox for this layer unchecked in JCS. The layer will be drawn as a grid of tiles.</li>
					<li><span class="name">SURFACE::LEGACY</span>: Used by default by layers in levels (either as part of the main level or imported using <a class="name" href="#jjLayersFromLevel">jjLayersFromLevel</a>) that have the "Texture mode" checkbox checked in JCS and use <a class="name" href="#jjlayer::warpHorizon">TEXTURE::WARPHORIZON</a>. When used on layers other than layer 8, this option nevertheless copies many of layer 8's properties when deciding how to draw the texture, and may in some circumstances draw the warp horizon effect to only certain areas of the subscreen. This is included for backwards compatibility but FULLSCREEN should usually be preferable.</li>
					<li><span class="name">SURFACE::FULLSCREEN</span>: New in JJ2+. Used by default by layers with the "Texture mode" checkbox checked that use any <a class="name" href="#jjlayer::textureStyle">textureStyle</a> other than WARPHORIZON. Draws the texture mode to each player's entire subscreen.</li>
					<li><span class="name">SURFACE::INNERWINDOW</span></li>
					<li><span class="name">SURFACE::INNERLAYER</span>: New in JJ2+. The layer will be drawn as some sort of texture effect, but within the same rectangular area that the layer would be drawn were it being drawn as a grid of tiles instead. This allows you to have multiple texture effects on-screen at once or do other cool tricks. The <a class="name" href="#jjlayer::xInnerAutoSpeed">inner speed properties</a> will be used for angling the texture within the layer's area. The difference between the two is that INNERWINDOW acts as if the texture were being drawn to the full size of the subscreen, and provides a layer-sized window to a portion of that full screen effect, whereas INNERLAYER exclusively uses the origin and dimensions of the layer itself. For example, consider a warp horizon texture effect drawn to the top half of the subscreen with <a class="name" href="#jjlayer::fadePositionY">fadePositionY</a> at 0.5. Using INNERWINDOW, the fade effect will be drawn halfway down the subscreen, at the bottom of the layer. Using INNERLAYER, the fade effect will be drawn halfway down the layer, one quarter of the way down the subscreen. On tiled dimensions (using <a class="name" href="#jjlayer::tileHeight">tileHeight</a> and/or <a class="name" href="#jjlayer::tileWidth">tileWidth</a>), there is no difference between INNERWINDOW and INNERLAYER, and if both dimensions are tiled, there is no difference between either and FULLSCREEN, except for the use of the inner speed properties.</li>
				</ul></dd>
			<dt class="new">TEXTURE::Style <span class="name" id="jjlayer::textureStyle">textureStyle</span></dt>
			<dd>The visual effect used by a layer for which <a class="name" href="#jjlayer::textureSurface">textureSurface</a> is not set to SURFACE::UNTEXTURED, defaulting to whichever is specified in the layer's texture dropdown box in JCS. Options are <a class="name" href="#jjlayer::cylinder">TEXTURE::CYLINDER</a>, <a class="name" href="#jjlayer::menu">TEXTURE::MENU</a>, <a class="name" href="#jjlayer::reflection">TEXTURE::REFLECTION</a>, <a class="name" href="#jjlayer::tileMenu">TEXTURE::TILEMENU</a>, <a class="name" href="#jjlayer::tunnel">TEXTURE::TUNNEL</a>, <a class="name" href="#jjlayer::wave">TEXTURE::WAVE</a>, and <a class="name" href="#jjlayer::warpHorizon">TEXTURE::WARPHORIZON</a> (the only such option available in vanilla JJ2)</dd>
			<dd>For all cases but MENU and TILEMENU, the texture's offset is determined by combining the <a class="name" href="#jjlayer::xSpeed">speed</a>, <a class="name" href="#jjlayer::xAutoSpeed">autoSpeed</a>, and <a class="name" href="#jjlayer::xOffset">offset</a> properties of this layer, and/or of <code>jjLayers[5]</code> if the <a class="name" href="#jjlayer::xSpeedModel">speedModel</a> properties equal LAYERSPEEDMODEL::LAYER8, or by the various <a class="name" href="#jjlayer::xInnerAutoSpeed">inner speed properties</a> if <a class="name" href="#jjlayer::textureSurface">textureSurface</a> is SURFACE::INNERLAYER or SURFACE::INNERWINDOW.</dd>
			<dt>bool <span class="name" id="jjlayer::tileHeight">tileHeight</span></dt>
			<dd>Whether the layer should be vertically tiled, as seen in the JCS Layer Properties window.</dd>
			<dt>bool <span class="name" id="jjlayer::tileWidth">tileWidth</span></dt>
			<dd>Whether the layer should be horizontally tiled, as seen in the JCS Layer Properties window.</dd>
			<dd>Setting this to true for a layer that is not saved with Tile Width checked in JCS may lead to unpredictable effects if the layer's <a class="name" href="#jjlayer::width">width</a> and <a class="name" href="#jjlayer::widthReal">widthReal</a> are not equal. If you wish to turn it on partway through the level, it is best to check Tile Width in JCS and then disable it in <span class="name">onLevelLoad</span>.</dd>
			<dt class="new"><span class="name" id="jjlayer::tileMenu">tileMenu</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::TILEMENU, which draws the rotating menu effect from the game's main menu, but with different graphics. <a class="name" href="#jjlayer::texture">texture</a> is used for the frontmost rotating sublayer, then the middle sublayer is filled with the 2�2 square set of tiles in the top left corner of layer 4, from 0,0 to 1,1, and the back sublayer is filled with tile 0,2 in layer 4. If <a class="name" href="#jjlayer::textureSurface">textureSurface</a> is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then <a class="name" href="#jjlayer::xInnerAutoSpeed">x/yInnerAutoSpeed</a> control the rotating/zooming speeds respectively.</dd>
			<dd><code>bool tileMenu.fullSize</code> sets whether the rotating sublayers are drawn at half size (false, default) or full size (true).</dd>
			<dd><code>float tileMenu.pivotX</code> and <code>float tileMenu.pivotY</code> are the point that all rotation happens around, as multiplied by the <a class="name" href="#jjSubscreenHeight">size of the player's screen</a>. The default values are both 0.5.</dd>
			<dt class="new"><span class="name" id="jjlayer::tunnel">tunnel</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::TUNNEL, which draws <a class="name" href="#jjlayer::texture">texture</a> as a series of concentric, ever-smaller circles receding into the distance, though it is repeated horizontally only once..</dd>
			<dd><code>bool tunnel.fade</code>, when true, increasingly affects colors farther into the background: when <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16, a glowing circle appears in the tunnel's center using the RGB color chosen by <code>tunnel.setFadeColor</code>, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the center. The default value is true.</dd>
			<dd><code>float tunnel.fadePositionX</code> and <code>float tunnel.fadePositionY</code> set the location of the center of the tunnel, clamped to a 0�1 range, as multiplied by the <a class="name" href="#jjSubscreenHeight">size of the player's screen</a>. The default values are both 0.5.</dd>
			<dd><code>bool tunnel.spiral</code>, when true, makes the concentric circles gradually spiral inwards into the distance. The default value is false.</dd>
			<dd><code>jjPALCOLOR tunnel.getFadeColor() const</code> and <code>void tunnel.setFadeColor(jjPALCOLOR)</code> read and write the RGB components of the color drawn over the center when <code>tunnel.fade</code> is true and <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16. The default value is 0,0,0.</dd>
			<dt class="new"><span class="name" id="jjlayer::warpHorizon">warpHorizon</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::WARPHORIZON, which draws this layer as two horizontal 3D planes, repeating the same <a class="name" href="#jjlayer::texture">texture</a> several times and stretching to an infinite horizon, with some amount of dithering/antialiasing.</dd>
			<dd><code>bool warpHorizon.fade</code>, when true, increasingly affects colors closer to the horizon: when <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16, a thick glowing line appears across the horizon using the RGB color chosen by <code>warpHorizon.setFadeColor</code>, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.</dd>
			<dd><code>float warpHorizon.fadePositionX</code> and <code>float warpHorizon.fadePositionY</code> set the location of the center of the horizon, as multiplied by the <a class="name" href="#jjSubscreenHeight">size of the player's screen</a>. The default values are both 0.5.</dd>
			<dd><code>bool warpHorizon.stars</code>, when true, draws a series of little white specks appear across the horizon. The default value is false.</dd>
			<dd><code>jjPALCOLOR warpHorizon.getFadeColor() const</code> and <code>void warpHorizon.setFadeColor(jjPALCOLOR)</code> read and write the RGB components of the color drawn over the horizon when <code>warpHorizon.fade</code> is true and <a class="name" href="#jjColorDepth">jjColorDepth</a> is 16. The default value is 0,0,0.</dd>
			<dt class="new"><span class="name" id="jjlayer::wave">wave</span></dt>
			<dd>Properties used by this layer when its <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is TEXTURE::WAVE, which draws <a class="name" href="#jjlayer::texture">texture</a> as a repeating, unrotated 2D image, but applies sine wave distortions at regular intervals. The properties all affect the positions and dimensions of those sine wave distortions.</dd>
			<dd><code>float wave.amplitudeX</code> and <code>float wave.amplitudeY</code> set the distortions' amplitudes as multiples of the texture's width and height (256 pixels). The default values are both 0.5, meaning 128 pixels.</dd>
			<dd><code>bool wave.distortionAngle</code> effectively rotates the movement of the two distortions ninety degrees. The default value is false.</dd>
			<dd><code>uint8 wave.wavelengthX</code> and <code>uint8 wave.wavelengthY</code> set the lengths of the distortions, with powers-of-two-minus-one such as 255 being recommended. Their default values are 0.</dd>
			<dd><code>int8 wave.waveSpeed</code> moves the distortions along the surface of the texture, independent of the texture's movement as set by the regular or inner speed properties. Both distortions move at the same rate as determined by this property's absolute value, with the directions resulting from the sign of this property combined with and <code>wave.distortionAngle</code>. The default value is 0.</dd>
			<dt>const int <span class="name" id="jjlayer::width">width</span></dt>
			<dt>const int <span class="name" id="jjlayer::widthReal">widthReal</span></dt>
			<dd>The width of the layer in tiles. Normally these two values will be equal, but they may differ on layers that were saved with the "Tile Width" checkbox checked in their level editors. The reason for this is that layers are not stored as arrays of <a href="#tileids">tile IDs</a> but rather as arrays of "word" IDs, where each word is defined in the "tile cache" as a row of four adjacent tile IDs. In order to properly tile, therefore, a layer whose <span class="name">width</span> is not a multiple of four is expanded by the level editor to a <span class="name">widthReal</span> that is the lowest common multiple of 4 and <span class="name">width</span>, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.</dd>
			<dt>const int <span class="name" id="jjlayer::widthRounded">widthRounded</span></dt>
			<dd>The width of the layer in "words," always equal to <code>(jjLAYER::widthReal + 3) / 4</code>.</dd>
			<dt>float <span class="name" id="jjlayer::xAutoSpeed">xAutoSpeed</span></dt>
			<dt>float <span class="name" id="jjlayer::yAutoSpeed">yAutoSpeed</span></dt>
			<dd>The auto speed of the layer, as seen in the JCS Layer Properties window.</dd>
			<dt class="new">float <span class="name" id="jjlayer::xInnerAutoSpeed">xInnerAutoSpeed</span></dt>
			<dt>float <span class="name" id="jjlayer::yInnerAutoSpeed">yInnerAutoSpeed</span></dt>
			<dt>float <span class="name" id="jjlayer::xInnerSpeed">xInnerSpeed</span></dt>
			<dt>float <span class="name" id="jjlayer::yInnerSpeed">yInnerSpeed</span></dt>
			<dd>Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose <a class="name" href="#jjlayer::textureSurface">textureSurface</a> property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other <span class="name">textureSurface</span> value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.</dd>
			<dt>float <span class="name" id="jjlayer::xOffset">xOffset</span></dt>
			<dt>float <span class="name" id="jjlayer::yOffset">yOffset</span></dt>
			<dd>Not settable in JCS: constant pixel values added to the position of the layer, regardless of its speed.</dd>
			<dt>float <span class="name" id="jjlayer::xSpeed">xSpeed</span></dt>
			<dt>float <span class="name" id="jjlayer::ySpeed">ySpeed</span></dt>
			<dd>The speed of the layer, as seen in the JCS Layer Properties window.</dd>
			<dt class="new">LAYERSPEEDMODEL::LayerSpeedModel <span class="name" id="jjlayer::xSpeedModel">xSpeedModel</span></dt>
			<dt>LAYERSPEEDMODEL::LayerSpeedModel <span class="name" id="jjlayer::ySpeedModel">ySpeedModel</span></dt>
			<dd>Not settable in JCS: specifies how the layer's position on screen should be determined, based (or not) on its <a class="name" href="#jjlayer::xSpeed">xSpeed/ySpeed</a> and <a class="name" href="#jjlayer::xAutoSpeed">xAutoSpeed/yAutoSpeed</a> properties, the resolution, and so on. There are several options available for the enum, as follows (for each axis):
				<ul>
					<li><span class="name">LAYERSPEEDMODEL::NORMAL</span>: The default. A non-textured layer's position on this axis will be based on the layer's auto speed for this axis, if non-zero, or otherwise its regular speed. Except for <a class="name" href="#jjLayers">jjLayers[8]</a>, only the layers that use this mode for both axes will ever be displayed when <a class="name" href="#jjLowDetail">Low Detail</a> is enabled.</li>
					<li><span class="name">LAYERSPEEDMODEL::LAYER8</span>: The default for <a class="name" href="#jjLayers">jjLayers[8]</a> only, a pair of odd behaviors included for backwards compatibility. A non-textured layer with this setting will ignore all speed and offset settings completely and be tied to the top/left side of the screen. A textured layer will instead base its position for this axis on that of <code>jjLayers[5]</code>.</li>
					<li><span class="name">LAYERSPEEDMODEL::BOTHSPEEDS</span>: The layer's speed and auto speed settings for this axis will both be used in determining the position: for example, a layer of clouds in the background might have an <span class="name">xSpeed</span> of 0.2, an <span class="name">xAutoSpeed</span> of 0.25, and a <span class="name">xSpeedModel</span> of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to scroll constantly to the left but also move left or right in response to the player's camera.</li>
					<li><span class="name">LAYERSPEEDMODEL::FROMSTART</span>: Similar to <code>LAYERSPEEDMODEL::BOTHSPEEDS</code>. Normally a layer's top/left origin depends on the resolution and its speeds, and the top/left side of a layer will only be flush with the top/left side of the level if the layer's speed is 1 or the resolution is 320�200. Using this setting forces the layer's origin to be at the top/left side of the level instead of varying by the resolution. Ignores <a class="name" href="#jjlayer::limitVisibleRegion">limitVisibleRegion</a>.</li>
					<li><span class="name">LAYERSPEEDMODEL::FITLEVEL</span>: Ignores the speed and auto speed properties, and instead ensures that the full extent of this layer will be visible and no blank space outside of it will be shown. The top/left side of the layer will be visible at the top/left edge of the level, and the bottom/right side of the layer will be visible at the bottom/right edge of the level, and the layer will scroll smoothly between those two extremes. Thus, the taller/wider the layer, the faster it will move, though with the exact relative speed dependent on the resolution and level size. If the layer is smaller than the window on this axis, this will effectively result in a negative relative speed.</li>
					<li><span class="name">LAYERSPEEDMODEL::SPEEDMULTIPLIERS</span>: Treats the layer's speed and auto speed properties on this axis as multipliers of the current camera size, rather than camera position. When the camera is at the top/left of the level, the layer will be positioned at the camera size on this axis multiplied by the regular speed, or the auto speed instead when the camera is at the bottom/right, and the layer will scroll smoothly between those two extremes. For example, if the screen is 600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the layer will be 450 pixels from the top of the screen when the camera is at the top of the level, and 300 pixels from the top of the screen when the camera is at the bottom of the level. Ignores limitVisibleRegion.</li>
				</ul></dd>
			<dd>Note that all mentions of "textured" layers in the above descriptions refer to when <a class="name" href="#jjlayer::textureSurface">textureSurface</a> is LEGACY or FULLSCREEN. In these cases, if <a class="name" href="#jjlayer::textureStyle">textureStyle</a> is WARPHORIZON, TUNNEL, WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied to whatever position is determined by the rules above. If such a layer uses MENU or TILEMENU instead, then its speed models are ignored altogether.</dd>
			<dd>For INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they would be for non-textured layers for determining the layer's position within the level, and the <a class="name" href="#jjlayer::xInnerAutoSpeed">inner speed properties</a> are used for determining the texture's position within the layer.</dd>
			<dt>void <span class="name" id="jjlayer::generateSettableTileArea">generateSettableTileArea</span>()</dt>
			<dt>void <span class="name">generateSettableTileArea</span>(int <span class="param">xTile</span>, int <span class="param">yTile</span>, int <span class="param">width</span>, int <span class="param">height</span>)</dt>
			<dd>Makes all tiles in the range of the rectangle with its top left corner at <span class="param">xTile,yTile</span> and specified <span class="param">width</span> and <span class="param">height</span> possible to use <a class="name" href="#jjlayer::tileSet">tileSet</a> on without the potential consequence of changing other occurrences of the tile in the level due to tile cache. The zero-argument version of the method applies to the entire layer, or to be precise, passes 0,0 to <span class="param">xTile,yTile</span>, <a class="name" href="#jjlayer::widthReal">widthReal</a> to <span class="param">width</span>, and <a class="name" href="#jjlayer::height">height</a> to <span class="param">height</span>. Does nothing if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
			<dt>float <span class="name" id="jjlayer::getXPosition">getXPosition</span>(const jjPLAYER &amp;in <span class="param">play</span>) const</dt>
			<dt>float <span class="name" id="jjlayer::getYPosition">getYPosition</span>(const jjPLAYER &amp;in <span class="param">play</span>) const</dt>
			<dd>Gets the last position of this layer for the specified <a class="name" href="#jjplayer">jjPLAYER</a>. (The results of calling this method for players for whom <a class="name" href="#jjplayer::isLocal">isLocal</a> is false are undefined.) For example, given a <span class="name">jjPLAYER@</span> object <code>play</code>, you could <a class="name" href="#jjSetWaterLevel">attach water</a> to the top of layer 7 by continually calling <code>jjSetWaterLevel(play.cameraY - jjLayers[7].getYPosition(play), true);</code> This takes into account everything that could possibly reposition a layer, including its <a class="name" href="#jjlayer::xSpeed">speeds</a> and <a class="name" href="#jjlayer::xOffset">offsets</a>, the <a class="name" href="#jjSubscreenHeight">resolution</a> and <a class="name" href="#jjResolutionMaxHeight">max resolution</a>, the player's <a class="name" href="#jjplayer::cameraX">camera position</a>, and whether the player is <a class="name" href="#jjplayer::stoned">stoned</a>.</dd>
			<dd>Note that these values are not updated for layers while they are not drawn to the screen on account of having been left out in the last call to <a class="name" href="#jjLayerOrderSet">jjLayerOrderSet</a>.</dd>
			<dt>bool <span class="name" id="jjlayer::maskedHLine">maskedHLine</span>(int <span class="param">xPixel</span>, int <span class="param">lineLength</span>, int <span class="param">yPixel</span>) const</dt>
			<dd>Returns true if any pixel from <span class="param">xPixel,yPixel</span> to <span class="param">xPixel+lineLength,yPixel</span> is masked. Returns false if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
			<dt>bool <span class="name" id="jjlayer::maskedPixel">maskedPixel</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>) const</dt>
			<dd>Returns true if pixel <span class="param">xPixel,yPixel</span> is masked. Returns false if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
			<dt>int <span class="name" id="jjlayer::maskedTopVLine">maskedTopVLine</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">lineLength</span>) const</dt>
			<dd>If any pixel from <span class="param">xPixel,yPixel</span> to <span class="param">xPixel,yPixel+lineLength</span> is masked, returns the height of the topmost masked pixel relative to <span class="param">yPixel</span>. (For example, if <span class="param">xPixel,yPixel+2</span> is masked but +1 and +0 weren't, the function returns 2.) If none of the pixels are masked, returns <span class="param">lineLength</span>+1. Used for detecting inclines and the like. Returns 0 if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
			<dt>bool <span class="name" id="jjjlayer::maskedVLine">maskedVLine</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">lineLength</span>) const</dt>
			<dd>Returns true if any pixel from <span class="param">xPixel,yPixel</span> to <span class="param">xPixel,yPixel+lineLength</span> is masked. Returns false if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
			<dt>void <span class="name" id="jjlayer::setXSpeed">setXSpeed</span>(float <span class="param">newspeed</span>, bool <span class="param">newSpeedIsAnAutoSpeed</span>)</dt>
			<dt>void <span class="name" id="jjlayer::setYSpeed">setYSpeed</span>(float <span class="param">newspeed</span>, bool <span class="param">newSpeedIsAnAutoSpeed</span>)</dt>
			<dd>Changes the X or Y speed. Unlike the basic properties like <a class="name" href="#jjlayer::xSpeed">xSpeed</a> and <a class="name" href="#jjlayer::yAutoSpeed">yAutoSpeed</a>, these functions will ensure that the layer remains in the same position it was before its speeds were changed, and can therefore be much more useful.</dd>
			<dt>uint16 <span class="name" id="jjlayer::tileGet">tileGet</span>(int <span class="param">xTile</span>, int <span class="param">yTile</span>) const</dt>
			<dd>Returns the current <a href="#tileids">tile</a> at location <span class="param">xTile,yTile</span>. If the tile is an animated tile, this function will return the tile ID for that animated tile instead of the current frame. Returns 0 if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
			<dt>uint16 <span class="name" id="jjlayer::tileSet">tileSet</span>(int <span class="param">xTile</span>, int <span class="param">yTile</span>, uint16 <span class="param">newTile</span>)</dt>
			<dd>Sets the current <a href="#tileids">tile</a> at location <span class="param">xTile,yTile</span> to be <span class="param">newTile</span>. The same change will be applied to all instances of the same four-tile word that appear elsewhere in the level unless the tiles had had <a class="name" href="#jjlayer::generateSettableTileArea">generateSettableTileArea</a> used on them prior to the change. Returns <span class="param">newTile</span>, or 0 (and does nothing) if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> is false.</dd>
		</dl>

		<h3 id="jjtextappearance"><span>class jjTEXTAPPEARANCE</span></h3>
		<p>jjTEXTAPPEARANCE is a structure used as an argument in functions that draw or otherwise operate on text, determining its traits such as alignment, treatment of special symbols, and amplitude of movement. Functions that currently rely on this class are <a class="name" href="#jjcanvas::drawString">jjCANVAS::drawString</a>, <a class="name" href="#jjDrawString">jjDrawString</a>, and <a class="name" href="#jjGetStringWidth">jjGetStringWidth</a>.</p>
		<p>The majority of jjTEXTAPPEARANCE properties are of type STRING::SignTreatment and determine whether a symbol should be hidden, displayed normally, or have special behavior. These three treatments correspond respectively to constants HIDESIGN, DISPLAYSIGN and SPECIALSIGN.</p>
		<dl class="class constructor">
			<dt><span class="name" id="jjtextappearance::jjTEXTAPPEARANCE">jjTEXTAPPEARANCE</span>()</dt>
			<dt><span class="name">jjTEXTAPPEARANCE</span>(STRING::Mode <span class="param">mode</span>)</dt>
			<dd>Constructs an instance of the class. The default constructor creates an instance with 0 horizontal and vertical amplitude, spacing equal to 1, default alignment, and no special treatment for any symbols. The constructor from STRING::Mode uses values specific for that mode instead, according to the following table, where "H" and "D" and "S" stand for HIDESIGN, DISPLAYSIGN, and SPECIALSIGN respectively:
			<table id="textappearances" class="borderedtable">
	<tbody><tr><th></th><th>align</th><th>@</th><th>^</th><th>#</th><th>\n</th><th>|</th><th>�</th><th>~</th><th>skipInitialHash</th><th>spacing</th><th>xAmp</th><th>yAmp</th></tr>
	<tr><td>NORMAL     </td><td>DEFAULT</td><td>D</td><td>S</td><td>D</td><td>H</td><td>S</td><td>S</td><td>D</td><td>true </td><td>1</td><td>0</td><td>0</td></tr>
	<tr><td>DARK       </td><td>DEFAULT</td><td>D</td><td>S</td><td>D</td><td>H</td><td>H</td><td>S</td><td>D</td><td>true </td><td>1</td><td>0</td><td>0</td></tr>
	<tr><td>RIGHTALIGN </td><td>RIGHT  </td><td>D</td><td>S</td><td>D</td><td>H</td><td>H</td><td>H</td><td>H</td><td>false</td><td>1</td><td>0</td><td>0</td></tr>
	<tr><td>BOUNCE     </td><td>DEFAULT</td><td>D</td><td>S</td><td>D</td><td>H</td><td>H</td><td>H</td><td>H</td><td>false</td><td>0</td><td>0</td><td>1</td></tr>
	<tr><td>SPIN       </td><td>DEFAULT</td><td>S</td><td>S</td><td>S</td><td>H</td><td>H</td><td>S</td><td>S</td><td>false</td><td>1</td><td>1</td><td>1</td></tr>
	<tr><td>PALSHIFT   </td><td>DEFAULT</td><td>D</td><td>S</td><td>D</td><td>H</td><td>H</td><td>H</td><td>D</td><td>false</td><td>1</td><td>0</td><td>0</td></tr>
</tbody></table>No matter the constructor, <a href="#jjtextappearance::monospace">monospace</a> will always be false unless set manually.</dd>
		</dl>
		<dl class="class operator">
			<dt>jjTEXTAPPEARANCE&amp; <span class="name" id="jjtextappearance::opAssign">operator = </span>(STRING::Mode <span class="param">mode</span>)</dt>
			<dd>Assigns text display traits specific to <span class="param">mode</span> to the instance. Returns a reference to self.</dd>
		</dl>
		<dl class="class" id="jjTEXTAPPEARANCEList">
			<dt>STRING::Alignment <span class="name" id="jjtextappearance::align">align</span></dt>
			<dd>Horizontal alignment of text. This can take values of DEFAULT, LEFT, CENTER or RIGHT.</dd>
			<dd>Whereas LEFT, CENTER and RIGHT should be self-explanatory, DEFAULT is the value JJ2 used for all strings originally, defined as follows: if <span class="param">xPixel</span> is less than 0x4000, the string will have its left side aligned to the left side of the screen or layer. If in the range of 0x4000 to 0xFFFF, the string will be center-aligned relative to 0x8000, so for instance 0x8020 would align the center of the string to 0x20 pixels right of the center of the screen. Finally, if <span class="param">xPixel</span> is greater than or equal to 0x10000, it will be drawn with its right side aligned to the right side of the screen instead, with higher values moving farther left. Note that these special cases currently apply only for drawing to the screen; the use of values of 0x4000 or higher for <code>onDrawLayer#</code> hooks is currently undefined.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::at">at</span></dt>
			<dd>Treatment of the at ('@') character. If it's SPECIALSIGN, at will begin a new line of text 20 pixels below the previous one.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::caret">caret</span></dt>
			<dd>Treatment of the caret ('^') character. If it's SPECIALSIGN, caret will be displayed as infinity signs.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::hash">hash</span></dt>
			<dd>Treatment of the hash ('#') character. If it's SPECIALSIGN, characters following hash will use a pattern of colors (or other parameters depending on sprite mode of the string).</dd>
			<dt>bool <span class="name" id="jjtextappearance::monospace">monospace</span></dt>
			<dd>Usually strings achieve naturally looking spacing between characters by placing the next character at <code>character width + spacing</code> relative to the previous one. When this property is set to true, character width is disregarded, and placement is determined only by <code>spacing</code>, i.e. is constant throughout the string (unless modified by special function of section sign). Because, by default, <a href="#jjtextappearance::spacing">spacing</a> is a low value, you may want to modify it if you use this property. This property is compatible with <a href="#jjtextappearance::section">section</a>, although the result of changing the spacing partway through a string may look somewhat bizarre.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::newline">newline</span></dt>
			<dd>Treatment of the line feed character (created by the escape sequence '\n' in AngelScript). If it's either DISPLAYSIGN or SPECIALSIGN, line feed will begin a new line of text below the previous one, with vertical spacing varying depending on font size.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::pipe">pipe</span></dt>
			<dd>Treatment of the pipe ('|') character. If it's SPECIALSIGN, pipe will change text color (or other parameter depending on sprite mode of the string) of the following characters.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::section">section</span></dt>
			<dd>Treatment of the section sign ('�') character. If it's SPECIALSIGN, section sign will use ASCII code of the directly following character to determine spacing used for further text.</dd>
			<dt>bool <span class="name" id="jjtextappearance::skipInitialHash">skipInitialHash</span></dt>
			<dd>Whether or not to ignore the first character of a string if it's a hash ('#'). The ignored hash will not be displayed or otherwise affect the string. If the string is preceded by more than one hash, all but the first one will be displayed.</dd>
			<dd>This property is provided mainly for compatibility with several STRING::Mode values, as it's used by JJ2 wherever strings are meant to be conditionally colored, such as menu items.</dd>
			<dt>int <span class="name" id="jjtextappearance::spacing">spacing</span></dt>
			<dd>Default spacing between characters, in pixels. If <a href="#jjtextappearance::section">section</a> is set to SPECIALSIGN, this value only applies until the first section sign character is found, as the effect of the section sign is absolute rather than relative to this property.</dd>
			<dt>STRING::SignTreatment <span class="name" id="jjtextappearance::tilde">tilde</span></dt>
			<dd>Treatment of the tilde ('~') character. If it's SPECIALSIGN, tilde will cancel the special effect of hash or, if it's already inactive, it will change the color (or other parameter depending on sprite mode) to default.</dd>
			<dt>int <span class="name" id="jjtextappearance::xAmp">xAmp</span></dt>
			<dt>int <span class="name" id="jjtextappearance::yAmp">yAmp</span></dt>
			<dd>Horizontal and vertical amplitudes of text movement.</dd>
		</dl>
		
		<h3 id="jjplayerdraw" class="new"><span>class jjPLAYERDRAW</span></h3>
		<p>The jjPLAYERDRAW class is no more than a series of (mostly boolean) properties used to decide how JJ2+ should draw each active player each tick, local or otherwise. It is used in the following hook signature:</p>
		<pre>void onPlayerDraw(jjPLAYERDRAW&amp;)</pre>
		<p>When your script module receives the jjPLAYERDRAW instance, it will already have all its various properties filled out with however JJ2+ expects the player should be drawn. You may then make any adjustments you wish by changing the values of any or all of the properties on that instance. For example, suppose you really like the invincibility visual effect of the player being followed by blue circles, but you don't actually want the player to be invincible. Setting <a class="name" href="#jjplayerdraw::invincibility">jjPLAYERDRAW::invincibility</a> to true will cause the effect to be drawn anyway and you can associate it with whatever other stimulus you like.</p>
		<p>If <a href="#mutators" <="" a="">multiple script modules</a> each define a <code>onPlayerDraw</code> hook, then the modifications made to the jjPLAYERDRAW object in the first module will persist in the second module, and so on. For example, normally <a class="name" href="#jjplayerdraw::curFrame">jjPLAYERDRAW::curFrame</a> will be some sprite of a rabbit (or frog or bird). But if one mutator uses <code>onPlayerDraw</code> to change it to a sprite of a sandwich, then a second mutator will be passed a jjPLAYERDRAW using that sandwich sprite number, not the original rabbit/frog/bird sprite number.</p>
		<p>Several properties of jjPLAYERDRAW correspond exactly to those of <a class="name" href="#jjplayer">jjPLAYER</a>, e.g. <a class="name" href="#jjplayerdraw::spriteMode">spriteMode</a>. Either one may be used to draw the player as a ghost by using SPRITE::TRANSLUCENTPLAYER instead of SPRITE::PLAYER. The difference is that setting those properties on <span class="name">jjPLAYER</span> is permanent and the change is shared across the whole multiplayer server, but setting those properties on <span class="name">jjPLAYERDRAW</span> only impacts this single drawing operation on this local computer, and any changes you make will already have been forgotten by the next time the hook is called.</p>
		<dl class="class" id="jjPLAYERDRAWList">
			<dt>bool <span class="name" id="jjplayerdraw::airboardBouncingMotion">airboardBouncingMotion</span></dt>
			<dd>When true, causes the player sprite (and some other effects) to rise and fall in a gradual sine wave motion. By default, only true for rabbits whose <a class="name" href="#jjplayer::fly">jjPLAYER::fly</a> is FLIGHT::AIRBOARD.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::airboardPuff">airboardPuff</span></dt>
			<dd>When true, causes little brown explosions to appear behind the player at regular intervals. By default, only true for rabbits whose <a class="name" href="#jjplayer::fly">jjPLAYER::fly</a> is FLIGHT::AIRBOARD.</dd>
			<dt>int <span class="name" id="jjplayerdraw::angle">angle</span></dt>
			<dd>What angle to draw the player sprite at, in the manner of the <span class="param">angle</span> parameter of <a class="name" href="#jjcanvas::drawRotatedSprite">jjCANVAS::drawRotatedSprite</a>. (Only the player sprite itself is affected by this, none of the other elements potentially being drawn.) By default always 0 unless <a class="name" href="#jjplayer::poleSpin">jjPLAYER::poleSpin</a> has been called with both <span class="param">xSpeed</span> and <span class="param">ySpeed</span> using non-zero values.</dd>
			<dt>uint <span class="name" id="jjplayerdraw::curFrame">curFrame</span></dt>
			<dd>The current sprite number, as an index to <a class="name" href="#jjAnimFrames">jjAnimFrames</a>, that should be drawn for this player. Changing this is a purely visual effect and does not affect sprite-based collision with pickups, enemies, and so on. By default, equals the same as <a class="name" href="#jjplayer::curFrame">jjPLAYER::curFrame</a>.</dd>
			<dt>TEAM::COLOR <span class="name" id="jjplayerdraw::flag">flag</span></dt>
			<dd>When not set to TEAM::NEUTRAL, this property causes a flag of the specified color to be drawn behind the player, with its direction based on <a class="name" href="#jjplayerdraw::xScale">xScale</a>/<a class="name" href="#jjplayerdraw::yScale">yScale</a>. If the player is carrying a flag in CTF, DCTF, or Flag Run, this value will be TEAM::BLUE or TEAM::RED as appropriate. Setting this property to TEAM::GREEN or TEAM::YELLOW is also allowed, but the appearance of those flags is somewhat of a placeholder and may change in future JJ2+ revisions if they ever become important for actual gameplay reasons.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::gunFlash">gunFlash</span></dt>
			<dd>When true, a sprite of a small flash is drawn coming out of the player's gun. Has no effect when <a class="name" href="#jjplayerdraw::angle">angle</a> does not equal 0 or either <a class="name" href="#jjplayerdraw::xScale">xScale</a> or <a class="name" href="#jjplayerdraw::yScale">yScale</a> do not equal 1 or -1. By default, only true immediately after the player has fired.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::invincibility">invincibility</span></dt>
			<dd>When true, a series of blue circles are drawn following the player around. By default, only true when <a class="name" href="#jjplayer::invincibility">jjPLAYER::invincibility</a> is greater than 0.</dd>
			<dt>int <span class="name" id="jjplayerdraw::layer">layer</span></dt>
			<dd>What layer to draw the player (and related elements) in front of. By default always 4.</dd>
			<dt>int8 <span class="name" id="jjplayerdraw::light">light</span></dt>
			<dd>The intensity of light emitted by the player. By default, equals the same as <a class="name" href="#jjplayer::light">jjPLAYER::light</a>.<!--</dd-->
			</dd><dt>LIGHT::Type <span class="name" id="jjplayerdraw::lightType">lightType</span></dt>
			<dd>The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER. By default, equals the same as <a class="name" href="#jjplayer::lightType">jjPLAYER::lightType</a>.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::name">name</span></dt>
			<dd>When true, the string <a class="name" href="#jjplayer::name">jjPLAYER::name</a> will be drawn above the player's head. By default, true in non-local games when <a class="name" href="#jjplayer::frozen">jjPLAYER::frozen</a> is 0 and the F8 key has not been pressed.</dd>
			<dt>jjPLAYER@ <span class="name" id="jjplayerdraw::player">player</span></dt>
			<dd>The <a class="name" href="#jjplayer">player</a> being drawn. This is a read-only property, so you can modify properties of the player but you cannot change which jjPLAYER object the jjPLAYERDRAW object has a handle to.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::shield">shield[SHIELD::Shield]</span></dt>
			<dd>Whether each of the possible shields should be drawn around the player: for example, you can set <code>shield[SHIELD::FIRE] = true;</code> to draw the fire shield. Applicable options in the SHIELD::Shield enum are FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. By default, each is only true if it is the value of <a class="name" href="#jjplayer::shieldType">jjPLAYER::shieldType</a>, the player is non-local or <a class="name" href="#jjplayer::shieldTime">jjPLAYER::shieldTime</a> is greater than -128, and <a class="name" href="#jjplayer::frozen">jjPLAYER::frozen</a> is 0.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::sprite">sprite</span></dt>
			<dd>Determines whether the player sprite should be drawn at all. By default, usually true but sometimes false when the player is flashing <a class="name" href="#jjplayer::blink">from being hurt</a> or from timing out in an online server.</dd>
			<dt>SPRITE::Mode <span class="name" id="jjplayerdraw::spriteMode">spriteMode</span></dt>
			<dd>What <a href="#spritemode">sprite mode</a> to use for the player. By default, equals the same as <a class="name" href="#jjplayer::spriteMode">jjPLAYER::spriteMode</a>, or SPRITE::FROZEN if <a class="name" href="#jjplayer::frozen">jjPLAYER::frozen</a> is non-zero.</dd>
			<dt>uint8 <span class="name" id="jjplayerdraw::spriteParam">spriteParam</span></dt>
			<dd>A sprite mode parameter further specifying how the player should be drawn. By default, equals the same as <a class="name" href="#jjplayer::spriteParam">jjPLAYER::spriteParam</a>.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::sugarRush">sugarRush</span></dt>
			<dd>When true, <a class="name" href="#jjplayerdraw::spriteMode">spriteMode</a> and <a class="name" href="#jjplayerdraw::spriteParam">spriteParam</a> will be ignored in favor of drawing the player in random flashing colors with lots of little star-shaped particles appearing nearby. By default, true when the player genuinely has a sugar rush but <a class="name" href="#jjplayer::frozen">jjPLAYER::frozen</a> is 0.</dd>
			<dt>bool <span class="name" id="jjplayerdraw::trail">trail</span></dt>
			<dd>When true, a glowing white trail follows the player around. By default, true when the player is moving at a decent speed.</dd>
			<dt>float <span class="name" id="jjplayerdraw::xOffset">xOffset</span></dt>
			<dt>float <span class="name" id="jjplayerdraw::yOffset">yOffset</span></dt>
			<dd>Allows you to draw most elements of the player at some relative position offset from the player's actual position. This is more powerful and more customizable than <a class="name" href="#jjplayerdraw::airboardBouncingMotion">airboardBouncingMotion</a>, which in particular does not modify the position the player's name is drawn at. By default, both properties equal 0.</dd>
			<dt>float <span class="name" id="jjplayerdraw::xScale">xScale</span></dt>
			<dt>float <span class="name" id="jjplayerdraw::yScale">yScale</span></dt>
			<dd>What scale to draw the player at, in the manner of the corresponding parameters of <a class="name" href="#jjcanvas::drawResizedSprite">jjCANVAS::drawResizedSprite</a>. By default, <span class="name">xScale</span> will equal 1 or -1 depending on <a class="name" href="#jjplayer::direction">jjPLAYER::direction</a>, and <span class="name">yScale</span> will equal 1 if <a class="name" href="#jjplayer::antiGrav">jjPLAYER::antiGrav</a> is false or -1 if it is true.</dd>
		</dl>

		<h3 id="jjanimset"><span>class jjANIMSET</span></h3>
		<p>JJ2's thousands of sprites and animations are accessible through AngelScript as a three-tiered system of classes and matching global arrays. If you're familiar with the contents of anims.j2a from <a href="http://www.jazz2online.com/downloads/4041/jazz-sprite-dynamite/">Jazz Sprite Dynamite</a>, that should make it easier to understand how this works; most simply, the three tiers of classes/arrays (jjANIMSET, jjANIMATION, jjANIMFRAME) correspond to the three scrollbars (Set ID, Animation, Frame #) in JSD, although JSD uses 1-indexed numbers for everything and JJ2+ does not. To take a concrete example, the sprite frame used by the Cake pickup is Set ID=68, Animation=13, and Frame #=1 in JSD. (Or Set ID=72 in 1.24.) In AngelScript terms, this is <code>jjAnimFrames[jjAnimations[jjAnimSets[ANIM::PICKUPS].firstAnim + 12].firstFrame]</code>.</p>
		<p>An image may help to explain the three arrays. The lowest level, <a class="name" href="#jjAnimFrames">jjAnimFrames</a>, is a long series of individual animation frames (sprites) with some basic properties for setting the hotspots, default transparency, and the like. (To edit the actual sprite image, you'll need the <a href="#jjpixelmap">jjPIXELMAP</a> class described below.) Individual frames have no idea where they fit in any given animation; that is handled by the <a class="name" href="#jjAnimations">jjAnimations</a> array, each entry in which defines a single animation by its starting frame (<a class="name" href="#jjanimation::firstFrame">firstFrame</a>) and number of frames (<a class="name" href="#jjanimation::frameCount">frameCount</a>). Finally the <a class="name" href="#jjAnimSets">jjAnimSets</a> array points you to the first animations of each anim set, and additionally carries a few methods for creating new anim sets either from scratch or from specific .j2a files.</p>
		<img width="594" height="168" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlIAAACoCAMAAAAcl/AXAAAALHRFWHRDcmVhdGlvbiBUaW1lAFN1biAyMiBNYXIgMjAxNSAxNzowNTo0NCAtMDgwMK6J2uwAAAAHdElNRQffAxcAMAaT94JqAAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAwBQTFRFAAAAAAAIAAgAAClKADkAAEqUAGvOAIz/AK1CAMZaAOd7AP+lCAAACAAICAgICHMYCIwpEBAQGBgYGBgpISEhKSEYKSkpMTExMTlSOQAAOTk5Oa3/QkJCSkpKUgAAUjEAUko5UlJSWlpaYwAhY2Nja2trcwAAc2tSc3Nze3t7hISEjAAAjIyMlAAxlJSUnBgAnGsAnIxznJycpaWlrQAAra2ttbW1vZQAva2Uvb29xgAAxgDGxgjGxhDGxhjGxsbGziHOzinOzjEAzjHOzjnOzs7O1kLW1krW1lLW1lrW1tbW3mPe3mve3nPe3nve3sYA3s6t3t7e5wAA53vn54zn55Tn55zn56Xn5+fn76Xv763v77Xv773v78bv7+/v98b3987399b399739+f39/f3/wAA/1oA/5QA/8YA/+f//+////fW//f///8A////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8bA6uwAAGTRJREFUeNrtnft32sa2xxVMEtyrikcIvlAwCYf4hWsIRjgmTX3qU7cNPWliVuqw2poVO8LJcrjz//949x4JIYEeI6MH2PONDUJoa2a2PtqzNRpHAuG6RRJmFEEdonYCl5/iSHH5LI4Ul8/iSHEFoehoUosPv8imsI8Fy2rp+NOka40ekdUvxovqGxebDEix+5rIglBR6OLulsaFoG9wlBOKfdbiw2/x01IFC16bNLMEi6VJM7F54+/Gi7LEmWKVASl2X4ODlW3K0mlOMSClbpBrku2nrMWH3mBFOk1jnXf29GauKUTJ6hQJxLhkRIuLSROkvPgaTlkljYvFQ2J2vfo2kFiLD73BcpGUoNLCAE4GrTVbbdKu2EUpadI+LiZNkPLoa7pmr6J9YYxSpe0T9uJDb3C1SZpVLHh3Rz9BquSZuX/f0jvy7VOOlEdNkGLytWxGKpejb9qLtoGynUuzZh7hH6g0VDKDBSu5gdbMQYZk+pZnjrLVJBwpj5ogxeJr7U1H6rC6T8wdnyo5w1p82O09KsJL8QgLbm6NySns54ipmZNgXGryXMqjdKTYfE30XIrkcPGEJvOyfmKjpAE7KqEfqO1deNndpgXnxs3czm4RyyhFSD/b51d83qQjxeRr7Q2v+HbUfOOpTD9Sl2sbPN0mzSJr8VMf1M/y1DDQLHjtoiSkS23jqp2ZVlkVmIXciJxmjQMEAmkL7Ulgmurf5ad8XMqbdKQYfK1Z0A2kqjp6QIObLIxHs1D9opDrshZvubZChzMc1CwcKWTQzu3Z7IpnPxFqEUfPlXQfhzMclBnQt27aZlccqQi1SEjpfU2JlGhHI+xn9QF7XM62tRWSYZiinYP1akMwXEqFE45UpFpEpCpN0lQHvIpdPe8X1rpkRyqoK5oZPbc5yrTh90jbSCZKM8eRilQLiJSSHpAB7fmEk8laAahRhK5m00xnqnuHsIo8xZEjiGv6RvpuOVLRaAGRkjHjL+j5/uROj/FFOdrfyuB9bcreIK2uflbaOVQIRypSLSBSFVqhCnFECqXsZvUGaAGukhGkLkcqUi0gUhmcGdPPEFekoCOErRXzrk73shypSLV4SB2W6Ad6C3uy1oxUWh33UiATr+AtoW7OsCvBHamqMPXtFr6YR1g5kTfUFFJh+9oCqapallx1QGov24RQdlJpwwtc8XUL+4hZn+SayuTWkEM9pb5VPSoFlxFWLhZNIRW2ry2QyqkflJxTx9cupQWJTtbCcakM3kzakSRgS9IHspyQEqxWKNKJywgrF4umkArb19b3+PzZrf2+sL307neJtLNC7pCuIPtF8lSdKi1k2mpt9iSpuSMxT9XhQpmRCt3XhsOuyILi1xQShiiFP9IuSbdJO6PNY9mn41uwWtaGS4Wqsi/BbzYg599OzUapUH1tOOwVQa74dcPf7ZJjPMVQv7UDnwZ47Yg3D3EIXtsAp3T2eabuTdZIhebriA7WZGrFnlTSZhHuUT/sTc/B0/M4LkZZI0XC8nXkSBGlXdqliwW8mXNU4EjNK1ukwvF15EilFW2xr85tzvQ5UnPKFqlwfB05UvhHHJgfDna26TfbOxypOWWLVDi+jhypfkHIneC1wZqaO56scaTmlC1S4fiaH6zbp0W6x8d1K8SR4vJZHCkun8WR4vJZdxWp0cWfF1GVfct1N5G6PPvtx5dvImrzbdcdROr6r9///fLlDz+fjSJq9C2XPVJnr89CKD7s9o7O3/znh5cvf3rzz3XYRd8BCTMyff365esQ6hBqi0cX739+9fLlj7//9SnUcu+M7hpSNIF6+eq3s8sQC71bulNIjROo9x95BhWc7g5SPIFaDN0WpHgCtTC6HUjxBGqBdAuQuv6bJ1CLpGVHavTx/S+veAK1SFpupD7988evP/34b55ALZKWGKnR5d/v37z+7c0HnkAtlJYWqeuLfz78+f7Pvy94ArVgWk6kRteXH8///vv8kvO0eFpGpEbXny4vLi4+cZ4WUsuH1Gh0ff3p0zXnaVG1dEiNqIKvM9dNtYRIBV9frnm0dEhxLbo4Ulw+iyPF5bM4Ulw+iyPF5bM4Ulw+iyPF5bPOz86DL2QJkHKZon/rNFdzF8BXS3B4OFJhGftU//CL9FzFBXBTpO0Nzdin+odfpOcqLoCbIm1vaMY+1T/8Im9WzztB00x7IzCev+oRleu5nhypkIznr3pE5XquJ0cqJOP5qx5RuZ7raXZT1a3esiBk7B+xtDVewMd8L6R8RMovX4Gy2uaOD69aUqRmnoQ5JVmSyUmm69rqZ4vafh+R8stXhOwI6uZo4VB6JA67sZdsn4Q5vTm2ea/q1uqjwqK230ekfPIVIU26S9zc8bGNi+pSGy8Zn4QplwZF6g7j8y4PJXUVbkUfvqOF6fGDLehDMgVBe4L0WndR2+8fUn75ipCcrD8QhAWp8eO1pp7M7WTchN+Se8um15as9wj1r8w8bJf24+00VGk2SgnSbnWfhmDD8y5lYVddpe9WC9NjN+kPyUTtbi/sKTVurmdvIRxB+Gq8K3akdFVKrE/mzri6xbIAwfIpzdgW7flL03vIHMHZYYGUjDWQzc+7FHYJ2RcMpY7DtH7mjR+SCTrNKQuPlGdvHWYFEoCvJiV4RkpJ91mfzC25usWqAGyrnMWQK+xKe7vSrhpusTlwfqnLaCXI0t446MqS9dObwKRqfkbTeCNhug7CzBshT9uL2/Ebxr+9eSsnWyE1t68mW3ju+OQSKdGeT9jP0p5V0JazbW0F2c0JUumU1ojQa/B2IVOAo0PS+zlJoqQLUuHENkpBRN3Cs0GQuxL8wLusd9fjZdxoR9LWCtKhNVLtXHpvyk3GZvUzzm5a5JEuPUp59haxRmpOX0029YxUpUmatOcTit1JFFzrkh2poK7YKZySwXZxsv929hDC7SGErbEJREy9F7ZCSm5K2pPmxw6YuIOMnSQTfa1dlMrIpD/lpn1CulnDVYwezBVTTJ9p/6LJgJRXb1kj5YOvtFWsV3yarZIekAHt+YSTyVrhCL4RuuqKbNewPf6u4SOY94sGkyPDvq2QIukTYnAS0Sraz45X6CffxMbKTdKJUjG7CZKMQXFHTTaOcKxlnHKuNWXJ4KbBdPsXTQakvHrLGikffEW0LIRxXErbhQxkkIJ+aWmow+RFOWxv54y1wzIH0mSLZ6WdQ4U4ISWd7hucJB9lsaLK9rYayiGIj52Eu7FLz/GJ4pl9s5vwUmiP0HfoqrUFesGcEQxnXsV4oi+kjEh58pYdUj74apwbMY6ea7uo0LpUiANSR+m16u7JVO0mIRJelEpGkLpOSDWl7YmTZCHdxorCta1a3V1pfN4V6UloMYhw62VEypO3ZpEKveqTd1zM4OA9HfayRSqHQA8M36RplEqbEDrdyzIkct5dfOeQCt94/qpP3uHnUB26LB06IKUFv8k3RcylmsUphASOlA/tjcB4/qpP3uGnqnaSctUBqeK2osgZWEh3+3TlYQau+DJtQxxrTi4ZOFJztTcC4/mrPnlHGNQPSs4BqdOiIBXaOJogaUMh+1khZ8zouwVJH9LiSM3V3giM56/65N33KnCk5m5vBMbzV52+KrKgyBypBdLSI1UR5IrzYMPNW+bnvjhSwRvPX/XQSywZ2rqlNp+lnncUqRt5664hZZyuwZ7BTSFVFaYMt/wNipFLH+q8ibei9VXoh0B1lFzaldL7+h1Qqwkc5qpNITUznzqIy4soJUzk3VvR+iqCKEXohA3p9CRDG0en7FhM4LB2sV21bylSN/NWtL6KCCmZ7JT2DUPsFhM4LL0k6J/olnKJtLNC7tA4Q5phovUSyISUV29F66uIkIL3o8qu4a7N7AQOSy+Zh9EECPvpNmlnTGee40TrZZEJKa/eitZXkSGVOelLmHxqTpqdwGHppSk3yTgPSF+hfe840XpZNIWUN29F66vIkJLT0t54Oob1BA6n9FzQz7U9CfsE05mHL3YTrZdFU0h581a0vloWL9siRZR2aXfaTfYTrZdFPg51hu2rZXG1LVI4q1mYdpP9ROtlUSBIheOrpUeq2iT0TycGRjfZT7ReFgWCVDi+Wnqk+gUhd2KaIS04TbResvb6YRy2r5bMxctSXb/aG4Hx/FWPqFzP9eRI6Tp7fXZDY1dLX6oegnt8qSdHSpfrMxZsjfnTGbQqzijqGoXc3ukNnMBwNr7NSI0+/nnBXEVWpEIJ68GLI+Vdo4/vf3718g1zFVmRCsVhwYsj5VEqTy9f/XzG+iRkjpSHdt45pHSe3n8M4NHatwSpANt525AKlifCkQrS0oPCQipwnghHKkhLDwoFqTB4IhypIC09KHikRh///CUEnghHKkhLDwoYqdHF2eufXv0QAk+EIxWkpQcFidTo8q83v/7np59+DYMnwpEK0tKDgkPq0/nZf3/75dffz8LhiXCkgrT0oICQGl2ef3j/x3//+HARFk+EIxWkpQcFgdTo+vL8n78+fDi/DJEnwpEK0tKD/EdqdP3p8uP5+cWncHkCnZ+dh11kJLpjSI2urz99ugwfp7ukO4XUaARIjThPweoOITVCuZXnfRrdPFPwvNjm83ntJdxyPds6gOFi64jUPHU27edmZlZiik7BHx4TGey2+Xyt09rIt1q1vMdyp1EM3PbuIMVWXsBITZHBbJsf9jqtTq83HA47eS/lzqIYuC1HyrreNzBhsJ0mgzla9EQQHOEOHGPRQ7kWKAZuy5GaqfdN7dxtrchgsc33avRdpPJQrnWBAdu6DZbY27oPs8xHk7qLOWxvVF6QSNmQwYBUpzZeXPFSrj2Kwdr64KsAbMe7mMP2plV23yo/lrem2pDBgFQLDONxtHtgZsoFC1sUg7V19zFHyqw8ZBiYYNQ2dKrYkLImg8E234rHEymwvHd/xXSAXbCwRTFYW3cfc6SMAqBqorjy3Upt2IP81Twa4GZqRQaD7eONVCKVBMOVlfsPPUQ4WxQDtnX1MUdKUxzO2jj0CCI9dUUaq1qm0QDnvVuT4W4bT6YSnSEc3pX7YPeQPcLZohiwrauPOVKq4uDjeBKIwv4AnIxM9Woic1NtyHC1BbtkZ/iik1q5/+D+w3sP77G62B7FYG3dfcyR0hQDP9eGSSTr0aNHK+TbWksliqmpdmSwRKn48MXDYeLegwf3V8oGopxtHVAMwPbJkyfsPuZIqYoBTKudFjD16NGDh/cha9UvrxmjFJBxb4YMd9sYGH6914kn74nlg7dlwyW9W6SBAr9aochme8+D7ZPnL56zMcWR0hVLxpKrqV6v1QKgHj54CGmrt6ZSMh7MkMFgG0sO4/GWuHK/fFD+vwYzUljgvYdWKLLZPvzKbPt488W7Fxwpmyo7fB1L9VrDGhD13XeQYHhFyoYMFqTikMfFG9AHlQ88IGWPoq+2/7u5+Xjz+bt3PErZVdn6mxgqnkzGO61H9x+A7nscWyJ2ZLDYxlKrSehl76+IZQ8dnz2KvtpuvnuxKW0+f7E5Zmpdk72POVJ4zibgkjqVSCTi+fo9VeyHVt+LFRnWtqYJJbH4ajLeOGiAjWg6um7l2qHop+3mu69fkaknz9U4tb5erx8fX10d162Zih4p/b/BlqceHDqzX7U0SbpBJY2fbBycBA8nVldXU/HN+42Dt423bxsM9+kYyLC0zbfypsLRriyKsNLltjEbij7aPnn3FZjaJI8wP38MRNWPrz5/voKXq2PLQBU9UroqpQr7xt5KYEEKhw5i8VSy3AAvw79GQ4wnYy5NZSHD0lYcmi0hRIpir2OauWRly4iij7ZPvr578fXd803pyeaT+rG4ToH6/PnL5y9fECoLjweGFE1OXHcxWVTS/bTCurGHSposHdNVJGo1EcP7xSL+xpMpN6RYyLBBqmeOGau1Vg92VrOeYumpQH9tH797DlA9eb65KdUhLEGPh0ShbJiyxYKBCEekIDlJxgyy2cWk45NLpER7PmE/qz+IEpezbcMK1eowUySk+XStuNUnpHhYLVaO2qW1tTZ8114DA9wddJGFEw9IQYshX11djdVanVZNhJckhC2XprKQYY1Ub2g2TLVSrU6tM3TBkRFFH22l5y+gx6N5lIidHnR5x5SpAwxVFkzZ+YqFCCekwD6VhPMA70yufpOYHBxbpCpN0qQ9n1Dsqs/TwuW1LtmRCpMVqlVVOSF7T/tksPeMkLXKKWkW4AUf9nYEPB1ljgg+l0uhj5dgRoqQOOZSyVhnOOy1asOeqPd79kgxkDHbAaFhyxwy4onEk04Lbyr2nJFiQ9FPWwm0+eL547p2nYe51BUSZcOUja8MRMRWU6mkJREOSKG9jlQikbRjaoKUkh6QAe35hBP9CyIAHIrQnaxQrXBFDl9IFn5geyWDnyRCnjYJDXjUUqfJFilzEkGRSsVqPWSqN6w550OsZEzb0pRG3OjBFhNT6HRjG3B09RvVFrYeUPTVFj2LvV79uIEhan1dj1KoGaassTAR8T+J2KolUw5IgZ0BqVTsm0TSBSkZujJS0B9AOkbKSIVenFqictjeWUsTkiYqTXQ9hXIAq56Vdg4VN6TElokpihTUtIWzpXrDTs3pqo2ZjNloUQMbsOzkJ1EDrw6g4B4WbDN44QVFP21VpohY1xJzYOhYz6cs4pQ1FiYiVr+BQOURqVgsYUIqseqGVIXuquKIlMEKurj0WnX3RLDDTqlkBKnrhlStY2QKsnM1TOGJOxzWWo4DAaxkzNqKNbCAmNHRo0MMSk6M46PdeJgHFH21Hde63qBEUaZoeFKTqqs6C1ImIlYT8W+8I7VqRAp7ThekMvjs936GHakcJuGDaaQyhovG072sa8fX6hkmXtMoBUhtYGcw7PXcBgLYyLCwRcv8BkCrGcaSanhEw1redoiVHUV/bce1VoMTjUvwXr+qX11dmbo+Ok7FgFRiFWOMN6TIGKmkug/bDH/8c1iin0uHzEipl4nTSFXwUafdnGn3NkjRaQZw9rZ0qMZRKk+RGhpCmHVT2ciwiXCtfGsoqiEjRsdYE7FHOEGr4zB6zoyiz7baHuoYl66QqTrGqvrVly9XxzpTNHNft0/PEwYiVm2IcEcqOe4/7UYRdKSq6si5XGVGqritKHJmGqmTTJt0C8BVrqlMATeFFHR6NRHHn2r6OWpGqifWvnVpKhMZNhGOTu/D0EEz13G5PUMCZ2HLiqLfttoe1mmCDkwdXzUgUn35/PkY4frcwKtB/AKZskPKSETChghHpBKrYIoTveIxHN9xG5fS4oqSY0bqtChIhfY0UqSdEzK78N4tSJPBLOsoVcOZwHABnR8nTXRcCiKy1vG5jYAzkmFzeEScNIrHVwS7BA0YG99PEWWZ2rOg6LutuoO6NoJwpRF19Zl2gZ9Vzj5/Ob6qi7ZIfZNwJ8IRqRTtLV1GOqcedRuEHHIpOKob6jV0R2UKK41XIrVOB1ZtsDSVgQwHW7ja2hDjCQgYCchq8q3O91MH1yK1Z0LRf1tqv17Hzk29ZXz1BWA6xs7QMJgORNlHqdWEKxGOSOF0WwakFBl/bgyMu1zSc+z6NnC8HJZiWpCqtVq12obIOiPAjQwH2283NsThBiSbOA0CgiNjTuOOYiC2tOdToarDNR+mU0AUEoZqNGCtaG/LFGQckYrHk3HN1uHOjlAR5MrUDAR/Za6ilZtaOAK1AZEplYQroERsA0LU9N90OzXVjQwn22/F4fdQbiKJ3W0LDzaTi11RDMgWiMSuTyXqeDycDqsAJv2Plu2QAiBciXBEyjE4TXbhtoHPsnaTWGthTgVEQX+AR7Y3/b8EOCPlTIaj7b+gj4WQkUrFNiDTabHlNO4oBmWr/cH7ev0AicLECru79XXsE12mHDIR4eir5UEK/dTJ1zqbq3EgKtbqDHsbIlu00OVEhmOnOawNO6k4Dq92kGPmaXQuKAZmq1V7PMp5XBcxm6oDU67/rcjcSBEWohYFKZIHjlqUqLLY8nJoVTmS4Wi7DtdgLbg4LouYvZVZJ/u6oRiU7XgXdIQKecKhPfjE1F4GItxOXQYtBlKiSAcTOnA9AQdV9HBox3Iiw8l2fdjZ6Axbj2KNMhwdsXzAWq4LioHZ6h4z/ocvnv4DI9fjcxuQEnF6h5jv9Gqi2KAHVVRfJ05zaaojGQ624vBfeVp4+YAeWJFO2zUcLTtbNxSDsmX18R1HCogSa3htXdMdLOIEWlGdmM3QVGcyHHMp1Y6I6h8UYMgQG1SOV0+uKAZky+zju40UEqUFKqLHp3LjAHgql8dMueUWTmQ4IgV2eBEvvlXLEQ8aB2XEWfsLA9t8yAXFoGxZfXy3kcJMAI4sdHplmkXhOYteLjfevj0oN9iQciLDqeOrwQUX3U7tfTA6lt+CDlzKdUMxKFtWH99xpFB4UCEqQVcn0l9RzaT0PMOl43Mkw8F2He0aNCI2kOwDvQ9yLtcVxYBsmX18x5CyPnXFcvmA/uke8qRfypQnQUawtbUnw8VWpHZlFMTDA5FYpTNWtm4oBmXL7N6QbU37uZnZjWVXXYhNeJZSrxovgESWptqT4YZUTfwWwyJECGNIdLV1RDFAW3b3cqS0gZYbNtWeDDdb7F/1oqfKd8LCCcUAbdndy5Gas6m2ZATlYicUg7T1wVeB2Br1/4GNOmqwdKTyAAAAAElFTkSuQmCC">
		<p>A few examples should make clearer the three arrays' (and classes') uses and relationships. As seen above, the twenty animations and many corresponding frames of ANIM::BIRD are always loaded immediately before the ninety-five animations and many frames of ANIM::PICKUPS. An animation is essentially nothing more than a first frame and a frame count. So if you wanted Extra Life pickups to use the dead bird animation for some reason, there are (at least) three ways to do that:</p>
		<pre>	#1
jjObjectPresets[OBJECT::EXTRALIFE].curAnim = jjAnimSets[ANIM::BIRD].firstAnim + 19;
	#2
jjANIMATION@ extraLifeAnimation = jjAnimations[jjAnimSets[ANIM::PICKUPS].firstAnim];
extraLifeAnimation.frameCount = 1;
extraLifeAnimation.firstFrame -= 1;
	#3
jjAnimations[jjAnimSets[ANIM::PICKUPS].firstAnim] = jjAnimations[jjAnimSets[ANIM::BIRD].firstAnim + 19];</pre>
		<p>Crucially, none of those options would have any effect on what actual birds looked like after being roasted; any frame may be used in any number of animations. Moreover, the boundary lines between animations are completely arbitrary. Consider the following code:</p>
		<pre>jjAnimations[jjAnimSets[ANIM::PICKUPS].firstAnim].firstFrame -= 5;</pre>
		<p>This would cause Extra Lives (and any other objects using the same animation) to display an animation ten frames long: four frames of a bird sitting idly in place, one frame of a roasted bird, and five frames of green "1UP" text. The reason for this is that <code>jjObjectPresets[OBJECT::EXTRALIFE].curAnim</code> is, on level load, exactly equal to <code>jjAnimSets[ANIM::PICKUPS].firstAnim</code>. (Likewise, <code>jjObjectPresets[OBJECT::APPLE].curAnim</code> is equal to <code>jjAnimSets[ANIM::PICKUPS].firstAnim+1</code>, and so on.) Anytime you see a property or argument called <span class="name">curFrame</span>, that means it is an index for <span class="name">jjAnimFrames[]</span>. Likewise, anything called <span class="name">curAnim</span> is an index for <span class="name">jjAnimations[]</span>, and anything called <span class="name">setID</span> is an index for <span class="name">jjAnimSets[]</span>.</p>
		<p>At the top level is the <span class="name">jjAnimSets</span> array, which loads new series of animations and frames from various .j2a files and then points you to where they can be found in the lower two arrays. At the beginning of a level, all three animation arrays are nearly empty (<span class="name">jjAnimFrames</span> and <span class="name">jjAnimations</span> each contain an empty entry at index [0] for various internal purposes). Then JJ2+ runs the following line of code internally:</p>
		<pre>jjAnimSets[ANIM::FONT].load(ANIM::PLUS_FONT, "plus.j2a");</pre>
		<p>This opens up the plus.j2a file and discovers that ANIM::PLUS_FONT is exactly four animations long. It loads those animations (basically their <span class="name">firstFrame</span> and <span class="name">frameCount</span> properties) into jjAnimations[1�4]. Between them, those four animations include 224+224+224+2=<strong>674</strong> frames, so those (images, hotspots, etc.) are loaded into jjAnimFrames[1�674]. And lastly, <code>jjAnimSets[ANIM::FONT].firstAnim</code> (and <code>jjAnimations[jjAnimSets[ANIM::FONT].firstAnim].firstFrame</code>) are set to 1. Next:</p>
		<pre>jjAnimSets[ANIM::JAZZ].load(); <span class="comment">//in full: .load(ANIM::JAZZ, "anims.j2a");</span></pre>
		<p>ANIM::JAZZ has a massive 104 different animations (or 78 in TSF). But jjAnimations[1�4] are already in use, so JJ2+ loads the first ANIM::JAZZ animation into jjAnimations[5], and carries on the rest from there. Likewise the hundreds of individual frames are loaded into <span class="name">jjAnimFrames</span> starting at jjAnimFrames[675], where the last <a class="name" href="#jjanimset::load">jjANIMSET::load</a> call left off. And <code>jjAnimations[jjAnimSets[ANIM::JAZZ].firstAnim].firstFrame</code> is set to 675, and the <span class="name">firstFrame</span> properties of the remaining animations from ANIM::JAZZ are also adjusted accordingly.</p>
		<p>So the process continues, loading first all the animations that every level uses, then a few level-specific ones (mostly enemies), then a few more that JJ2+ thinks might be useful. After that, you are free to mess up the existing order of frames and animations in any way you like, or simply to load or otherwise create all-new ones. Any call to <span class="name">jjANIMSET::load</span> or <a class="name" href="#jjanimset::allocate">jjANIMSET::allocate</a> appends new entries to the ends of <span class="name">jjAnimFrames</span> and <span class="name">jjAnimations</span>, adjusting the animations' <span class="name">firstFrame</span> properties to match their new positions, and then sets <a class="name" href="#jjanimset::firstAnim">jjANIMSET::firstAnim</a> to match. If an anim set has not yet been loaded from any .j2a file (or allocated), its <span class="name">firstAnim</span> will equal 0.</p>
		<p>And now, the list of <span class="name">jjANIMSET</span>'s methods and properties:</p>
		<dl class="class operator">
			<dt><span class="name" id="jjanimset::opImplConv">operator uint </span>() const</dt>
			<dd>Implicit conversion to uint; returns <a class="name" href="#jjanimset::firstAnim">firstAnim</a>.</dd>
		</dl>
		<dl class="class" id="jjANIMSETList">
			<dt>uint <span class="name" id="jjanimset::firstAnim">firstAnim</span></dt>
			<dd>ID of the first animation in the set, to be used with the <a class="name" href="#jjAnimations">jjAnimations</a> array.</dd>
			<dt>jjANIMSET@ <span class="name" id="jjanimset::allocate">allocate</span>(const array&lt;uint&gt; &amp;in <span class="param">frameCounts</span>)</dt>
			<dd>Creates space for an animation set with the number of animations equal to length of <span class="param">frameCounts</span>, each with a number of frames determined by the corresponding <span class="param">frameCounts</span> array element.</dd>
			<dt class="updated">jjANIMSET@ <span class="name" id="jjanimset::load">load</span>(uint <span class="param">fileSetID</span> = 2048, const string &amp;in <span class="param">filename</span> = "", int <span class="param">firstAnimToOverwrite</span> = -1, int <span class="param">firstFrameToOverwrite</span> = -1)</dt>
			<dd>Loads animation set specified by <span class="param">fileSetID</span> from a j2a file specified by <span class="param">filename</span>. Using the default value of <span class="param">fileSetID</span> results in loading the set appropriate for the jjANIMSET it's called on. If <span class="param">filename</span> is left empty, it deduces the file name from <span class="param">fileSetID</span>, using either Anims.j2a or plus.j2a.</dd>
			<dd>By default, any new animations and animframes begin at the first unused entries in <a class="name" href="#jjAnimations">jjAnimations</a> and <a class="name" href="#jjAnimFrames">jjAnimFrames</a> respectively. By passing positive values to the <span class="param">firstAnimToOverwrite</span> and/or <span class="param">firstFrameToOverwrite</span> arguments, however, you may choose specific animations and/or animframes to overwrite instead.</dd>
			<dt class="new">jjANIMSET@ <span class="name">load</span>(const jjPIXELMAP &amp;in <span class="param">spriteSheet</span>, uint <span class="param">frameWidth</span>, uint <span class="param">frameHeight</span>, uint <span class="param">frameSpacingX</span> = 0, uint <span class="param">frameSpacingY</span> = 0, uint <span class="param">startX </span> = 0, uint <span class="param">startY</span> = 0, const array&lt;int&gt; &amp;in <span class="param">coldSpotYOffsets</span> = array&lt;int&gt;(), int <span class="param">firstAnimToOverwrite</span> = -1, int <span class="param">firstFrameToOverwrite</span> = -1)</dt>
			<dd>Loads animation set defined in a sprite sheet image. This method overload is an alternate way to turn your external graphics into JJ2 sprites compared to the above overload which reads from an external j2a file instead. Loading from a sprite sheet is designed to be easier, though less flexible.</dd>
			<dd>For example, suppose you want to replace the sprites used by the Helmut enemy, which is a simple case that only uses two animations: standing and walking. We'll use <a href="https://opengameart.org/content/margery-limited">these public domain sprites</a> from <a href="https://opengameart.org/">opengameart.org</a>. (For best results, you should generally use images that have been manually drawn or edited to use the standard JJ2 sprite palette or else the palette of the specific level you're using the sprites in, but the jjPIXELMAP constructor's automatic color reduction for 24- or 32-bit images is fine for an example.)</dd>
			<dd><img width="154" height="80" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJoAAABQCAYAAADhjGzFAAAALHRFWHRDcmVhdGlvbiBUaW1lAFdlZCAyNCBKdW4gMjAyMCAxNDoxMzozOSAtMDgwMHBW1nEAAAAHdElNRQfkBhgVIQIjkGywAAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAACsVJREFUeNrtXHuIXcUZn12SxaTRSBobMSKBWI0arWY1Ctb8oaig1aAr1hciEYzQVEoFbTXBiK8W8UnSGqEhSpWIrvhAqRVfMYKvXauuNiZuWVu3mEYlMYkrG/H2/ubud5w7d2bOnJlzzr3X+/3g7Jl7HvPN981vvpk5s/N1rRSiIhiMgtHd7AIwOgNRRLuhUvG+53o2D9l559+uaFU7sEdjlIKulRFjNLSeG7u6klaENF1Pg+k9NV89P/UZn9+qHFdZbTKzvGOSpV8zXc9aFlueal6m8vjaxVZ/ej4hmBSbgV5ApPWCm54zvaenY8vjyttXfpbnTBWjPxdaFt+GZrNfHnrFIJpooaSwvWciaRZvFlpWm0FD9YupINu7eZcxr/d9EE20ImAiWxky84KrGwotS2yezUZbTAZa3bCtWr7YcuWpV2EeTR/s6gPWtAFz1nGGSa4tb/266x1f/WwD/Ri7qWXxzdM1MfDR0aVXDKJmnaEI7RZjxmdFd8Vld/VlIS+9WnKMZoPJezULRXwCaAUUpVdTPBqj89AWkwFG+4OJxigFhS2qNzvfrB89Wx22GXvR78a+R2CP1obIOkBvhYlK8Kwzy1qf7bprQd52PTYP28J36EK2z0K0rRwunXxt76uHes/HtiadYpDL542QhVyTwXwX5EPyMKGohWy9q3LJyaMyff85IYtt815cDyJaXh/xsuQRu6Ac85G4iLLrX/ybsb6bpmOeaJsPts2qgDwWsrOWPetyWCw69r832hl5doWtgjx0yky0LAvZIYvV+numBfmsi95ZZLvy8C2va4HdVI4yu01f2+a9uJ55CaodF4/LLnOIvHa0axbwWmcOiFmIdv1b1A8JTDRGKbA2o1vO6akj4Hsvmp97ZMe4sylWJojc5ZDF+OHDOBn45fSeikqsNX+fJlaLXeK6H58vhv75cf3DQ4MJIdNIx+hcNBANJFs+f0Hy++ahQTE08I1Mg2TzDzs4SePe419XxODC3trDVdIx2RgmGBfViUw6Xt76duLR6Jl3bjtLLHhzwPoOgwHUeTSTN/v1bfVOD2SjeytW/ELMOhTe7Gmx6uX1gv8ZhGGDkRnqOOyV57+VB43ZNm7rTsh2zO+fbnb5GW0C42SAiDQ8Xv3zYo2LGIsNjwoxt6dGtuUbB8Qn950vZh4yT97HNR6fMWxo8GhEMhCHAJL99/GVDS/POuEIeR4fWi+fYTBsqPNoNY/UY2TM1o8G6n7vP/KUeGLhhc0uP6NNYB29D49/l6TPndrF4zFGFBpmnervt8e+rXq4SZW5Pd2SbMPj399WPdwB564Ue/bs4fEZw4rU7xEgG7wbjnU3nS3P+KwBgGxMMoYPGghy7JRJ0m3VvJkQ0084vmHM9vXAYJJOIxmvdTKABo9GBANAsgPnHCfm9V0mj0/u2SLPU3sXiF9du1Y+M3nyZJ5uMuIAom3809TK8bf/ubL9jRnyjGs4QLDKR/3ycJENHq3C/4rU8bB2Z+TNgDWL1oqrd98hNvWvE6+dN1vOQLHGieUn+mDbM/8CYzfKXScDcO4Z+HTkLXleKpaIab3mZz7fvCkhG4Nhg9PLoNvE+cwHj5S/4c0I5NUobZsUsEdjAM7KV7tPYHP/GuNzrpknE40BWL+jgWSrrr47+f3C/XeK/3yxWx6H9C0VC269N/lt+gTCYKgwehnVk/2u72J5XjXyj+T+sjlHi1NP7xWL1/wluYaJwo7X3+DJAMMIr1knQBMDwHTdRDKAicYAUsdolJ73v23J9U0/2S9J2whGYKIxAOdaJ0iEY/Znw/L3PlOmiOV9Y2Lhzl3y+OtJ/xaHz5nJ4zNGKry8DMi0d/c+dddAuJv7p8j0zu++Eh+OfM5dJ8MKb6KlPcNEY7jQxeuQjDLA++MYpcDYneUVdwNwdZ0sp3PkGEMilBF3g+V0lpzUnepFxN1gOZ0np2GMVlbcDZbTWXISj1ZW3A2W05lyGq6WFXejVqh0ObFoNX1i5bSrPg2TgTLibpAMnF1yaFtfTHyPVtInj3gl7apPt0lA0XE3KP8HRr+/ZpKD1kItJkROq+kTK6ed9Uk8WhlxN/Sd8GlyoFjofoRW1CcmXkm762McuZURdwOtRd1DWmR8D9an+frUzTrVG0XF3SAjkRJZ5GRBO+iTRU6MPllQlD7OOW/ecTfwPvLUd8Nv+Vmv+Nthx8jDJgdjABwxO+PL0KcIOSaQ3dLkZLFbkfrU3cw77gbgWktD/gixQNg18EHdv4zP2C7El/vWZKrjNdNmZZMcH31UOWn/LZymj6pXEXYjfcYWXyk3dS/dsKTOXjo+vv7sxGbYf2siRKg+KnzsVufRyoy7gfyfufR98dyi6+WBzS0ArkEuKn/xecvkGUDLgbFw+ELXh3RBpePQ5eSxm6tIu5E+IBdIBrJBlkmebjN9IO+rC+mjH6ocCpHh0ssZ5AWKACDC6RtuSciw+o9LoroyqnSEWdjv5zvlQfKolU49+jjx5GOr5BmVhIFoSLcDfdSNNoPXXZWUHftU4ckgB2eUiYwWQoSi7Qa8W60ebORWyUZQ5VHoCtgMh2uTt62OYDM0fBWQC5mqHDTaNL1St9vFxN0ATK6ZPAcVkPLAflFSBvKn9R6RVBI9n3VHvKoLiKV2wdSdYI+q2m1vf+CaoFgiaXYzyc6qDyqSIgSc+NiotBNkze/dS1Y+QDIBmimGRBIgfWAXIhyiFqh1ow9rbHpZY28UGXcDfToMpn4ARBoFhPciRQBVwZ/Ono5/Gc8sT9VH7ULUtPQMi2pysnTPWexmkx0CkAy2OfPBaplHjhTzdl8mr+skgz2xuSjEbiDRpxNpeM9anayr6TjhDDZXn/HRy+pK84i7AaS1zNqCrEjc+0v3TJatMzHoXRdJxWCs2T+aJUZ3bzXuT0hrmepgXC37to17yzS8gerVQveplmE3aowAdZ0kT9UTPUTl9fVRdkO0gj/0P9Swrxekg70A9BRpenlvIA6Ju5GmiNoNoIBrH94glSJvBmBX/LI7fiO39xFMRvOdPcFwSy5aJH+jy1Tx5NLLxfPPDchd+aE774u2G+WPCAKwFYFsRpWPEBYnH3WAJFmI3fRoBSZZVDeqTW16WY1FTKZCE0654rdSECoFOPS0k5zTW1fFYHfVltEdMk2tFEoh3AIB+WPzMvaUhhjMZjhAlUO6AS6v5usBirSbSjZAD1dB13auXhFMNB+bISQGGiQ9Q+M2k15emYfG3XApYtorih3waqEp7zyIBnmj+8+VaV2GqgdAG6azdDVl241spZKXKh8AyfBcHg3UZjN1okaw6ePl/kPjbqQZjFrbV2Nj8oxNyZe8elDd+6h0IiSMFjLW0EmthnTQZcnzRLliPECRdiNdSA/1o7faWPK0m81maqgMwLaZ3DjrnDCAOe6GeEt/Lhog2L3PzqimxmiGlOS7QyospMJEyBBQy0Ye0Ec3CBlV9QBZUabdapECavmrnoXyztNuZDMCbAfoPZIL1s8bVGC5S32iAq4648sqIWqDcqSv/WxmxbZDPSvQ4s663ZwXZMBolI6RQ3pUpyJVeY33qVJCCVeW3dAwl/dV83p0T1Xmvwq1G9miZjeR1BMR2QepwmPibgBprjnWCD5ySJY6MAbU7kTVk1ps1q6m0+zma7OJ/N2Iibvho0he8JFj0kXvPvPSp1Ps5kv6/wOFIopVKVXMAgAAAABJRU5ErkJggg==">
			<pre>void onLevelLoad() {
	jjAnimSets[ANIM::HELMUT].load(
		jjPIXELMAP("Margery.png"),
		frameWidth: 24,
		frameHeight: 26,
		frameSpacingX: 2,
		frameSpacingY: 2,
		startY: 26,
		firstAnimToOverwrite: jjAnimSets[ANIM::HELMUT]
	);
	jjObjectPresets[OBJECT::HELMUT].determineCurFrame();
}</pre></dd>
			<dd>The <span class="param">spriteSheet</span> argument is self-explanatory, and is primarily intended for use in combination with the <a class="name" href="#jjpixelmap::jjPIXELMAP">jjPIXELMAP</a> constructor from filename, as above, so you can load an external PNG image and convert it to an animation set. The sprite sheet must take the form of a grid of equally-sized rectangles, where each row is a separate animation for this animation set and each cell is a separate frame for that animation. A completely blank/transparent cell indicates the end of the animation, so in the above example image, the first animation (standing) has only one frame but the second animation (walking) has six frames. The number of animations in the animation set is inferred from the height of the image in conjunction with the other arguments.</dd>
			<dd><span class="param">frameWidth</span> and <span class="param">frameHeight</span> specify the rectangular areas used by every frame in every animation in the sprite sheet. The largest and smallest sprites in your sheet must each have the same area devoted to them. However, JJ2+ will trim the transparent pixels from around the edges of every frame: in the above example, none of the sprites extend all the way to the left and right sides of their rectangles, so none of the resulting <a class="name" href="#jjANIMFRAME">jjANIMFRAME</a> objects will be the full 24 pixels wide.</dd>
			<dd>The <a class="name" href="#jjanimframe::hotSpotX">hotSpotX/hotSpotY</a> properties of each created jjANIMFRAME will be set to the exact center of its source rectangle, not necessarily the exact center of the opaque pixels inside that rectangle. For example, if <span class="param">frameWidth</span> and <span class="param">frameHeight</span> each equal 64, but only the top left 32�32 pixels in a rectangle are opaque, then the hot spot will be at that frame's bottom right corner.</dd>
			<dd>You (or whoever compiled the sprite sheet) may find it easier to draw some border lines between rows and columns. This can be indicated using the optional <span class="param">frameSpacingX</span> and <span class="param">frameSpacingY</span> arguments: in the above example, all the border lines are 2 pixels thick, so both arguments are 2. JJ2+ skips over these lines and does not draw them in the frames, even if they are opaque. Including the border lines on the far right and bottom of the image is optional.</dd>
			<dd>The optional <span class="param">startX</span> and <span class="param">startY</span> arguments let you specify where in the image the actual sprite sheet content begins, in case there is any header information on the top or far left. In the above example, the first twenty-six pixel rows are dedicated to crediting the sprite artist, so <span class="param">startY</span> is 26, but the sprite sheet starts on the far left of the image, so <span class="param">startX</span> can remain at its default 0.</dd>
			<dd><a class="name" href="#jjanimframe::coldSpotY">jjANIMFRAME::coldSpotY</a> is only relevant to certain objects affected by gravity, which use it to determine how far off the ground their sprites should be. For each animation loaded by this method, coldSpotY will be set to the bottom of the opaque pixels in the first cell of the row, and each subsequent sprite will have its coldSpotY at the same height in the rectangle (not necessarily the same height in the opaque pixels in the rectangle). If this automatic guess isn't quite right for your sprites, and you want to adjust these numbers so the sprites sink into the ground or float above it a little more, you can use the optional <span class="param">coldSpotYOffsets</span> argument to provide an array of vertical offsets, one for each animation row. For example, adding <code>coldSpotYOffsets: array<int>={-10,-10}</int></code> to the above example will cause the enemies to constantly hover 10 pixels above the floor.</dd>
			<dd>By default, any new animations and animframes begin at the first unused entries in <a class="name" href="#jjAnimations">jjAnimations</a> and <a class="name" href="#jjAnimFrames">jjAnimFrames</a> respectively. By passing positive values to the <span class="param">firstAnimToOverwrite</span> and/or <span class="param">firstFrameToOverwrite</span> arguments, however, you may choose specific animations and/or animframes to overwrite instead.</dd>
			<dd>This method always sets <a class="name" href="#jjanimframe::gunSpotX">jjANIMFRAME::gunSpotX</a> and <a class="name" href="#jjanimframe::coldSpotX">jjANIMFRAME::coldSpotX</a> to the same value as <a class="name" href="#jjanimframe::hotSpotX">jjANIMFRAME::hotSpotX</a>, <a class="name" href="#jjanimframe::gunSpotY">jjANIMFRAME::gunSpotY</a> to the same value as <a class="name" href="#jjanimframe::hotSpotY">jjANIMFRAME::hotSpotY</a>, <a class="name" href="#jjanimframe::transparent">jjANIMFRAME::transparent</a> to false, and <a class="name" href="#jjanimation::fps">jjANIMATION::fps</a> to 10. If your script has any more specialized use for those properties you will have to set them manually.</dd>
		</dl>

		<h3 id="jjanimation"><span>class jjANIMATION</span></h3>
		<dl class="class operator">
			<dt>jjANIMATION&amp; <span class="name" id="jjanimation::opAssign">operator = </span>(const jjANIMATION &amp;in <span class="param">animation</span>)</dt>
			<dd>Copies all properties of another jjANIMATION and returns a reference to self. This does not copy any jjANIMFRAME objects refered to by the animation; however, after the assignment, both jjANIMATION objects will have their <a class="name" href="#jjanimation::firstFrame">firstFrame</a> refer to a common jjANIMFRAME.</dd>
			<dt><span class="name" id="jjanimation::opImplConv">operator uint </span>() const</dt>
			<dd>Implicit conversion to uint; returns <a class="name" href="#jjanimation::firstFrame">firstFrame</a>.</dd>
		</dl>
		<dl class="class" id="jjANIMATIONList">
			<dt>uint <span class="name" id="jjanimation::firstFrame">firstFrame</span></dt>
			<dd>ID of the first frame of the animation, to be used with the <a class="name" href="#jjAnimFrames">jjAnimFrames</a> array.</dd>
			<dt>int16 <span class="name" id="jjanimation::fps">fps</span></dt>
			<dd>This property corresponds to the "FPS" number for animations in Jazz Sprite Dynamite, but that name is only a guess, because its value is never referenced by JJ2 at all. Most commonly equals 10.</dd>
			<dt>uint16 <span class="name" id="jjanimation::frameCount">frameCount</span></dt>
			<dd>The number of frames used by the animation.</dd>
			<dt class="new">bool <span class="name" id="jjanimation::save">save</span>(const string &amp;in <span class="param">filename</span>, const jjPAL &amp;in <span class="param">palette</span> = jjPalette) const</dt>
			<dd>Saves all the frames of this animation to an animated GIF image file on the local computer and returns whether successful. The image will be saved with whatever <span class="param">palette</span> is passed to this method, by default <a class="name" href="#jjPalette">the game's current palette</a>. Each frame's delay time will be set to <a class="name" href="#jjanimation::fps">jjANIMATION::fps</a>.</dd>
			<dd>There are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be ".gif" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with <a class="name" href="#jjpixelmap::save">jjPIXELMAP::save</a> and <a class="name" href="#jjstream::save">jjSTREAM::save</a>).</dd>
			<dt class="new">bool <span class="name" id="jjanimation::load">load</span>(const string &amp;in <span class="param">filename</span>, int <span class="param">hotSpotX</span>, int <span class="param">hotSpotY</span>, int <span class="param">coldSpotYOffset</span> = 0, int <span class="param">firstFrameToOverwrite</span> = -1)</dt>
			<dd>Reads all frames of a GIF image on the local computer and outputs them as a series of jjANIMFRAME objects, and adjusts this animation's <a class="name" href="#jjanimation::firstFrame">firstFrame</a> and <a class="name" href="#jjanimation::frameCount">frameCount</a> properties to match the new frames. Each frame in the animation will be <a class="name" href="#jjpixelmap::trim">trimmed</a> to exclude fully transparent rows/columns on the edges. Returns true on success or false if the filename cannot be found or is in some way not a valid GIF.</dd>
			<dd>Each resulting sprite will use the same palette indices as the GIF itself. The GIF's own palette will be ignored. For the easiest to understand results, then, you should use a GIF using an unoptimized palette that is identical or similar (e.g. day vs. night versions) to the one the level is using, or grayscale for use with <a href="#spritemode">SPRITE::ALPHAMAP</a>. Alternatively, you may want to load the GIF's actual palette using <a class="name" href="#jjpal::load">jjPAL::load</a>.</dd>
			<dd><a class="name" href="#jjanimframe::coldSpotY">jjANIMFRAME::coldSpotY</a> is only relevant to certain objects affected by gravity, which use it to determine how far off the ground their sprites should be. For the first frame, coldSpotY will be set to the bottom of the opaque pixels, and each subsequent sprite will have its coldSpotY at the same distance from its hotSpotY as in the first sprite. If this automatic guess isn't quite right for your sprites, and you want to adjust these numbers so the sprites sink into the ground or float above it a little more, you can use the optional <span class="param">coldSpotYOffset</span> argument.</dd>
			<dd>By default, any new animframes begin at the first unused entries in <a class="name" href="#jjAnimFrames">jjAnimFrames</a>. By passing a positive value to the <span class="param">firstFrameToOverwrite</span> argument, however, you may choose specific animframes to overwrite instead.</dd>
			<dd>This method always sets <a class="name" href="#jjanimframe::gunSpotX">jjANIMFRAME::gunSpotX</a> and <a class="name" href="#jjanimframe::coldSpotX">jjANIMFRAME::coldSpotX</a> to the same value as <a class="name" href="#jjanimframe::hotSpotX">jjANIMFRAME::hotSpotX</a>, <a class="name" href="#jjanimframe::gunSpotY">jjANIMFRAME::gunSpotY</a> to the same value as <a class="name" href="#jjanimframe::hotSpotY">jjANIMFRAME::hotSpotY</a>, <a class="name" href="#jjanimframe::transparent">jjANIMFRAME::transparent</a> to false, and <a class="name" href="#jjanimation::fps">jjANIMATION::fps</a> to the first gif frame's delay (or 10 if no delay is specified in the file). If your script has any more specialized use for those properties you will have to set them manually.</dd>
		</dl>

		<h3 id="jjanimframe"><span>class jjANIMFRAME</span></h3>
		<dl class="class operator">
			<dt>jjANIMFRAME&amp; <span class="name" id="jjanimframe::opAssign">operator = </span>(const jjANIMFRAME &amp;in <span class="param">animFrame</span>)</dt>
			<dd>Copies all properties of another jjANIMFRAME including the picture it uses and returns a reference to self.</dd>
		</dl>
		<dl class="class" id="jjANIMFRAMEList">
			<dt>int16 <span class="name" id="jjanimframe::coldSpotX">coldSpotX</span></dt>
			<dt>int16 <span class="name" id="jjanimframe::coldSpotY">coldSpotY</span></dt>
			<dd>Horizontal and vertical position of the frame's cold spot, relative to its hot spot. It is considered to be the point at which the frame would touch the ground. It's mostly used by objects such as walking enemies and pickup crates, as well as players themselves. In particular, the jjOBJ method <a class="name" href="#jjobj::putOnGround">putOnGround</a>, if its argument is set to true, uses <span class="name">coldSpotY</span> to determine the outcome.</dd>
			<dt>int16 <span class="name" id="jjanimframe::gunSpotX">gunSpotX</span></dt>
			<dt>int16 <span class="name" id="jjanimframe::gunSpotY">gunSpotY</span></dt>
			<dd>Horizontal and vertical position of the frame's gun spot, i.e. the point that's used to determine initial position of projectiles, relative to its hot spot. Originally this is only defined for player animations and sprites of enemies that produce projectiles.</dd>
			<dt>const uint16 <span class="name" id="jjanimframe::height">height</span></dt>
			<dd>Frame height in pixels.</dd>
			<dt>int16 <span class="name" id="jjanimframe::hotSpotX">hotSpotX</span></dt>
			<dt>int16 <span class="name" id="jjanimframe::hotSpotY">hotSpotY</span></dt>
			<dd>Horizontal and vertical position of the frame's hot spot, added to the sprite position by all drawing operations and used by collision detection, etc. These properties are analogous to the hot spot coordinates shown by <a href="http://www.jazz2online.com/downloads/4041/jazz-sprite-dynamite/">Jazz Sprite Dynamite</a>, however it should be noted that JSD inverts their values for user convenience, while JJ2 doesn't. This means that you will usually want to use negative values for these properties.</dd>
			<dt>bool <span class="name" id="jjanimframe::transparent">transparent</span></dt>
			<dd>Whether the frame is to be drawn as translucent by default. The only AngelScript function this directly affects is the jjOBJ method <a class="name" href="#jjobj::draw">draw</a> but JJ2 objects often use this property, e.g. to draw freezer ammo pickups as translucent even though they use the same behavior as any other pickup.</dd>
			<dt>const uint16 <span class="name" id="jjanimframe::width">width</span></dt>
			<dd>Frame width in pixels.</dd>
			<dt>bool <span class="name" id="jjanimframe::doesCollide">doesCollide</span>(int <span class="param">xPos</span>, int <span class="param">yPos</span>, int <span class="param">direction</span>, const jjANIMFRAME@ <span class="param">frame2</span>, int <span class="param">xPos2</span>, int <span class="param">yPos2</span>, int <span class="param">direction2</span>, bool <span class="param">always</span> = false) const</dt>
			<dd>Returns true if this sprite (at position <span class="param">xPos</span>,<span class="param">yPos</span> and direction <span class="param">direction</span>) would collide with another sprite with its own specified coordinates and direction, taking both sprites' hotspot positions into account; otherwise false. If <span class="param">always</span> is true, collisions will be registered even if there is only one overlapping pixel (used by bullets); the default value of false will require at least about eight common pixels (used by players), which is probably a better test in most cases. Both <span class="param">direction</span> parameters will be tested for the sprites being horizontally flipped, vertically flipped, or both, and the collision detection will be carried out accordingly.</dd>
		</dl>

		<h3 id="jjtile"><span>class jjTILE</span></h3>
		<p>The primary focus of this class is to provide an interface for interaction with animated tiles, such as obtaining or modifying their animation frames and speed. However, instances of jjTILE in fact exist for every valid <a href="#tileids">tile ID</a> - instances that correspond to static tiles are immutable, i.e. cannot be modified, while instances corresponding to animations are mutable. This distinction is reflected in the existence of two arrays that offer access to jjTILE instances: <a class="name" href="#jjTiles">jjTiles</a> and <a class="name" href="#jjAnimatedTiles">jjAnimatedTiles</a>, the former of which offers read-only access to both static and animated tiles, while the latter allows read-write access, but only to animated tiles.</p>
		<p>Because there can be always only one instance of this class corresponding to a specific tile ID, jjTILE objects cannot be constructed inside a script and may be only accessed via handles, akin to jjOBJ, jjPLAYER, etc.</p>
		<dl class="class" id="jjTILEList">
			<dt>uint8 <span class="name" id="jjtile::fps">fps</span></dt>
			<dd>Animation speed in frames per second. For static tiles this is always 0.</dd>
			<dd>This property is safe to modify, but it is currently undefined which animation frame will be visible immediately after the change.</dd>
			<dt>const uint16 <span class="name" id="jjtile::tileID">tileID</span></dt>
			<dd>Tile ID corresponding to the instance, such that for every non-null jjTILE handle <code>tile</code>, <code>tile is jjTiles[tile.tileID]</code>.</dd>
			<dt>array&lt;uint16&gt;@ <span class="name" id="jjtile::getFrames">getFrames</span>() const</dt>
			<dd>Constructs and returns an array of tile IDs of animation frames of the instance. For static tiles this is an array of size 1 containing this tile's own ID.</dd>
			<dd>The returned array represents animation frames after all transformations selected in animating tile properties, such as ping-pong animation or frames to wait between animation cycles. This means that the result may contain more entries than the animation as viewed in JCS.</dd>
			<dd>Keep in mind that in levels edited by other means than JCS, entries of the array may themselves be animations.</dd>
			<dt class="new">bool <span class="name" id="jjtile::setFrames">setFrames</span>(const array&lt;uint16&gt; &amp;in <span class="param">frames</span>, bool <span class="param">pingPong</span> = false, uint16 <span class="param">wait</span> = 0, uint16 <span class="param">randomWait</span> = 0, uint16 <span class="param">pingPongWait</span> = 0)</dt>
			<dd>Entirely replaces the previous array of animation frames for this animated tile with a new one based on the passed arguments. Returns false if <span class="param">frames</span> is empty (zero frames long) or if this is not a valid animated tile. The results are undefined if <span class="param">frames</span> is more than 64 frames long.</dd>
			<dd>The arguments correspond exactly to the similarly named JCS animated tile properties, respectively: "Ping-Pong animation"; "Frames to wait between two animation cycles"; "Random adder amplitude for frame wait"; and "Frame wait interval between Ping-Pong cycle."</dd>
			<dd>Note that this method is used to replace an existing animated tile. At this time there is no way to expand the number of animated tiles past however many are defined in the level.</dd>
		</dl>

		<h3 id="jjpixelmap"><span>class jjPIXELMAP</span></h3>
		<p>A straightforward, yet very powerful class that lets you manipulate most graphics in the game. A pixel map is a simple two-dimensional array of pixels, represented as <code>uint8</code>s, each an index for <a class="name" href="#jjpal::color">jjPAL::color</a>. A value of 0 is transparent, 24 is (in most tilesets) red, 92 is dark purple, etc. Any pixel in the map may be edited at any time, so the only part that's complicated at all is how to get images from or into various parts of the game, which is accomplished through a handful of constructors and methods. For example, the following code renders a single tile in the tileset completely black, except for the transparent sections:</p>
		<pre>void onLevelLoad() {
	jjPIXELMAP flowerTile(692); <span class="comment">//generate a 32�32 pixel map from tile 692 (the first flower in carrot1.j2t)</span>
	for (uint x = 0; x &lt; flowerTile.width; ++x)
		for (uint y = 0; y &lt; flowerTile.height; ++y)
			if (flowerTile[x,y] != 0) <span class="comment">//non-transparent; also note the special two-dimensional array syntax, [x,y] instead of [x][y] or something</span>
				flowerTile[x,y] = 23; <span class="comment">//very dark color</span>
	flowerTile.save(692, true); <span class="comment">//save to tile 692, whether horizontally flipped or not</span>
}</pre>
		<p>That's pretty much all there is to it! To turn carrot1.j2t's entire flower animation black, you would wrap the above code in a <code>for (uint tileID = 692; tileID &lt;= 699; ++tileID)</code> loop and replace instances of <code>692</code> with <code>tileID</code>. Another simple idea would be to recolor one of the shootable pole sprites (Jungle Pole, Psych Pole, etc.) to use palette indices more in line with the palette of whatever particular tileset you're using. You're also allowed to construct a jjPIXELMAP instance from a tile but save it to a jjANIMFRAME, or vice versa, or construct a jjPIXELMAP from scratch and make it into a textured background... the important thing when saving a pixel map (except to a jjANIMFRAME) is its dimensions, not how it was constructed. If a tileset has some tiles that look like enemies or pickups (many tileset conversions from other games do), by all means create pixel maps from one or more of those tiles and save them as new sprites to liven up your level. Absolutely any 2D 8-bit image may be stored and manipulated in a pixel map and, dimensions allowing, saved to most of JJ2's major drawing components.</p>
		<dl class="class constructor"><dt><span class="name">jjPIXELMAP</span>(uint <span class="param">width</span>, uint <span class="param">height</span>)</dt>
			<dd>Creates a totally transparent pixel map with dimensions <span class="param">width</span>�<span class="param">height</span>.</dd>
			<dt><span class="name">jjPIXELMAP</span>(const jjANIMFRAME@ <span class="param">animFrame</span>)</dt>
			<dd>Creates a pixel map with the same dimensions and image as the specified jjANIMFRAME.</dd>
			<dt><span class="name">jjPIXELMAP</span>(TEXTURE::Texture <span class="param">texture</span>)</dt>
			<dd>Creates a 256�256 pixel map using the graphics of the specified <a href="#texture">texture</a>. Consequently, all pixels will range in color from 176�207 unless you use TEXTURE::LAYER8.</dd>
			<dt class="updated"><span class="name" id="jjpixelmap::jjPIXELMAP">jjPIXELMAP</span>(uint16 <span class="param">tileID</span> = 0)</dt>
			<dd>Creates a 32x32 pixel map using the graphics of the specified tile, with color 0 standing in for transparent pixels. If <code>(tileID &amp; TILE::VFLIPPED) != 0</code>, the tile image will be vertically flipped while creating the pixel map.</dd>
			<dd><a href="#tileids">TILE::HFLIPPED</a> is somewhat more complicated, because JJ2 stores horizontally flipped tiles separately from their non-flipped versions. Trying to construct a jjPIXELMAP from a <span class="param">tileID</span> when  <code>(tileID &amp; TILE::HFLIPPED) != 0</code> will only give you the expected results if the tile's flipped version has been generated, which is typically done by flipping the tile in some layer in JCS. Otherwise you will just get a totally transparent 32x32 map. It may therefore be safer to exclude <code>TILE::HFLIPPED</code>, create a pixel map from the non-flipped tile's image instead, and then call <a class="name" href="#jjpixelmap::flip">flip(SPRITE::FLIPH)</a>.</dd>
			<dt><span class="name">jjPIXELMAP</span>(uint <span class="param">left</span>, uint <span class="param">top</span>, uint <span class="param">width</span>, uint <span class="param">height</span>, uint <span class="param">layer</span> = 4)</dt>
			<dt><span class="name">jjPIXELMAP</span>(uint <span class="param">left</span>, uint <span class="param">top</span>, uint <span class="param">width</span>, uint <span class="param">height</span>, const jjLAYER &amp;in layer)</dt>
			<dd>Creates a pixel map with dimensions <span class="param">width</span>�<span class="param">height</span>, based on a rectangular area with origin <span class="param">left</span>,<span class="param">top</span> and size <span class="param">width</span>�<span class="param">height</span> in layer <span class="param">layer</span>. This allows you put any number of arbitrary tiles next to each other in JCS and then create a single image out of them for use as a jjANIMFRAME or something else. See <code>plusPixelMapEx.j2l/.j2as</code> for several examples of this form.</dd>
			<dt class="new"><span class="name">jjPIXELMAP</span>(const string &amp;in <span class="param">filename</span>, const jjPAL &amp;in <span class="param">palette</span> = jjPalette, uint8 <span class="param">threshold</span> = 1)</dt>
			<dd>Creates a pixel map with the dimensions and image content of a PNG image file on the local computer. The file must use an 8-bit pixel depth, but you're unlikely to encounter a file that doesn't unless you intentionally create one or seek one out. Otherwise, the following details apply:<ul>
				<li>If the file uses a palette or is grayscale, each pixel's palette index will be imported directly, without regard for the actual palette colors of either the file or the <span class="param">palette</span> argument. For the easiest to understand results, then, you should use a PNG using a palette that is identical or similar (e.g. day vs. night versions) to the one the level is using, or a grayscale PNG for use with <a href="#spritemode">SPRITE::ALPHAMAP</a>. Alternatively, you may want to load the PNG's actual palette using <a class="name" href="#jjpal::load">jjPAL::load</a>.</li>
				<li>If the file uses full 24- or 32-bit color, each individual color will be passed to the <a class="name" href="#jjpal::findNearestColor">findNearestColor</a> method of the <span class="param">palette</span> argument. By default this is <a class="name" href="#jjPalette">the game's current palette</a>, but if you plan to display the contents of a pixel map only when another palette is applied, that might be a reason to pass that other palette instead.</li>
				<li>If the file has any alpha channel, pixels with alpha less than the <span class="param">threshold</span> argument will be left at 0, and pixels with alpha greater or equal to <span class="param">threshold</span> will be set to colors as determined by the two previous bullet points. The most distinct values for <span class="param">threshold</span> are, therefore, 0 (the entire pixel map will be fully opaque, except for index 0 in paletted/grayscale files), 1 (only 100% transparent pixels in the file will be transparent in the pixel map), and 255 (only 100% opaque pixels in the file will be opaque in the pixel map), with all other numbers somewhere between those extremes.</li>
				</ul></dd>
			<dd>If the file cannot be found, is not a valid PNG image, does not use an 8-bit pixel depth, or produces any other error while being read, the resulting pixel map will be only 1�1.</dd>
		</dl>
		<dl class="class operator">
			<dt>uint8&amp; <span class="name" id="jjpixelmap::opIndex">operator [] </span>(uint <span class="param">x</span>, uint <span class="param">y</span>)</dt>
			<dt>const uint8&amp; <span class="name">operator [] </span>(uint <span class="param">x</span>, uint <span class="param">y</span>) const</dt>
			<dd>Gets and (if non-const) sets any pixel anywhere in the pixel map, provided <span class="param">x</span> is less than <a class="name" href="#jjpixelmap::width">width</a> and <span class="param">y</span> is less than <a class="name" href="#jjpixelmap::height">height</a>. These are <code>uint8</code>s, so acceptable values are 0�255, with 0 being transparent. Caution: colors 1�9 and 246�254 may appear different in 8 bit vs. 16 bit color modes and so should be used rarely at best.</dd>
		</dl>
		<dl class="class" id="jjPIXELMAPList">
			<dt class="updated">const uint <span class="name" id="jjpixelmap::height">height</span></dt>
			<dt>const uint <span class="name" id="jjpixelmap::width">width</span></dt>
			<dd>Dimensions of the map in pixels, set by the map's constructor. These properties are read-only but may be modified using the <a class="name" href="#jjpixelmap::addBorders">addBorders</a>, <a class="name" href="#jjpixelmap::crop">crop</a>, <a class="name" href="#jjpixelmap::resize">resize</a>, or <a class="name" href="#jjpixelmap::trim">trim</a> methods, or swapped using the <a class="name" href="#jjpixelmap::rotate">rotate</a> method.</dd>
			<dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::addBorders">addBorders</span>(int <span class="param">left</span>, int <span class="param">top</span>, int <span class="param">right</span>, int <span class="param">bottom</span>, uint8 <span class="param">borderColor</span> = 0)</dt>
			<dd>For each of the four edges of the current image, this method either extends the image outwards by a number of pixels (positive number, filling in the new empty space with <span class="param">borderColor</span>) or crops the image inwards (negative number). Returns a reference to self. If the resulting image would be size 0 on either axis, or if you try to crop out more of the original image than exists (e.g. <a class="name" href="#jjpixelmap::width">width</a> equals 9 and both <span class="param">left</span> and <span class="param">right</span> equal -5), no change wil occur.
			</dd><dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::crop">crop</span>(uint <span class="param">left</span>, uint <span class="param">top</span>, uint <span class="param">width</span>, uint <span class="param">height</span>)</dt>
			<dd>Crops the pixel map to the specified coordinates and dimensions and returns a reference to self. If the arguments are invalid (<span class="param">width</span> and/or <span class="param">height</span> equals zero, or any point of the cropped rectangle is outside the current bounds), no change will occur.</dd>
			<dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::flip">flip</span>(<span class="ns">SPRITE::Direction</span> <span class="param">directions</span>)</dt>
			<dd>Flips the pixel map's image across one or both axes and returns a reference to self. Useful argument values are SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV.</dd>
			<dt class="updated">bool <span class="name" id="jjpixelmap::makeTexture">makeTexture</span>(jjLAYER@ <span class="param">layer</span> = null)</dt>
			<dd>Changes the specified layer's <a class="name" href="#jjlayer::texture">texture</a> to the contents of the pixel map. If you leave <span class="param">layer</span> as null it will default to the background layer,  i.e. <a class="name" href="#jjLayers">jjLayers</a>[8]. The map has to be exactly 256�256 to allow this action and if that is not the case, the function will report failure by returning false. On success returns true.</dd>
			<dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::recolor">recolor</span>(const array&lt;uint8&gt; &amp;in <span class="param">colorMapping</span>)</dt>
			<dd>If <span class="param">colorMapping</span> is length 256 or greater, replaces each index in the pixel map with the value in <span class="param">colorMapping</span> at that index, e.g. pixels of color 10 will be changed to <code>paletteColorMapping[10]</code> instead. Returns a reference to self.</dd>
			<dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::resize">resize</span>(uint <span class="param">width</span>, uint <span class="param">height</span>)</dt>
			<dd>If neither the old dimensions nor the new dimensions are zero on either axis, resizes the pixel map's image to use the new dimensions using primitive <a href="https://en.wikipedia.org/wiki/Comparison_gallery_of_image_scaling_algorithms#Nearest-neighbor_interpolation">nearest neighbor interpolation</a>. Returns a reference to self.</dd>
			<dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::rotate">rotate</span>()</dt>
			<dd>Rotates the pixel map's image ninety degrees clockwise and returns a reference to self.</dd>
			<dt>bool <span class="name" id="jjpixelmap::save">save</span>(uint16 <span class="param">tileID</span>, bool <span class="param">hFlip</span> = false) const</dt>
			<dd>Overwrites tileset tile selected by <span class="param">tileID</span> with contents of the pixel map. The map has to be exactly 32�32 to allow this action and if that is not the case, the function will report failure by returning false. On success returns true.</dd>
			<dd>If <code>(tileID &amp; TILE::VFLIPPED) != 0</code>, the pixel map image will be vertically flipped while saving the tile. <a href="#tileids">TILE::HFLIPPED</a> is somewhat more complicated, because JJ2 stores horizontally flipped tiles separately from their non-flipped versions. By default, and to avoid unnecessary memory usage, <a class="name" href="#jjpixelmap::save">jjPIXELMAP::save</a> will only save to either the regular version of the tile or the horizontally flipped version, depending on whether <code>(tileID &amp; TILE::HFLIPPED) != 0</code>. By setting <span class="param">hFlip</span> to true, though, you can ensure that both the regular and the horizontally flipped version of the tile will be overwritten.</dd>
			<dd>The results of saving when <code>(tileID &amp; TILE::ANIMATED) != 0 || (tileID &amp; TILE::RAWRANGE) == 0</code> are undefined.</dd>
			<dt>bool <span class="name">save</span>(jjANIMFRAME@ <span class="param">frame</span>) const</dt>
			<dd>Overwrites the image used by <span class="param">frame</span> with contents of the pixel map. Returns true on success and false on failure.</dd>
			<dt class="new">bool <span class="name">save</span>(const string &amp;in <span class="param">filename</span>, const jjPAL &amp;in <span class="param">palette</span> = jjPalette) const</dt>
			<dd>Saves the contents of the pixel map to an 8-bit PNG image file on the local computer and returns whether successful. The image will be saved with whatever <span class="param">palette</span> is passed to this method, by default <a class="name" href="#jjPalette">the game's current palette</a>.</dd>
			<dd>There are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be ".png" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with <a class="name" href="#jjanimation::save">jjANIMATION::save</a> and <a class="name" href="#jjstream::save">jjSTREAM::save</a>).</dd>
			<dt class="new">jjPIXELMAP&amp; <span class="name" id="jjpixelmap::trim">trim</span>(uint8 <span class="param">trimColor</span> = 0)</dt>
			<dt>jjPIXELMAP&amp; <span class="name">trim</span>(uint <span class="param">left</span> &amp;out, uint <span class="param">top</span> &amp;out, uint <span class="param">right</span> &amp;out, uint <span class="param">bottom</span> &amp;out, uint8 <span class="param">trimColor</span> = 0)</dt>
			<dd>Trims away all totally empty rows and columns�i.e. lines containing no colors other than <span class="param">trimColor</span>, which defaults to 0, or transparent�from the four sides of the current image and returns a reference to self. If there are no colors other than <span class="param">trimColor</span> anywhere in the image, as a special case, the resulting image will be cropped to 1�1 instead of 0�0.</dd>
			<dd>The method overload with four <code>uint &amp;out</code> arguments lets you know how many rows/columns were trimmed from each of the four sides. If no cropping occurs, they will all equal 0, and if the image was fully <span class="param">trimColor</span>, <span class="param">left</span> and <span class="param">right</span> will equal <a class="name" href="#jjpixelmap::width">width</a> (prior to the method being called) and <span class="param">top</span> and <span class="param">bottom</span> will equal <a class="name" href="#jjpixelmap::height">height</a>.</dd>
		</dl>

		<h3 id="jjmaskmap"><span>class jjMASKMAP</span></h3>
		<p>The simpler cousin of jjPIXELMAP, used only for editing the clipping masks of tiles in the tileset. As such, it uses <code>bool</code> instead of <code>uint8</code>, is always 32�32, and can only be constructed from or saved to <a href="#tileids">tiles</a>.
		</p><dl class="class constructor">
			<dt><span class="name" id="jjmaskmap::jjMASKMAP">jjMASKMAP</span>(bool <span class="param">filled</span> = false)</dt>
			<dd>Creates a mask map where every pixel's value matches <span class="param">filled</span>, either masked (true) or unmasked (false).
			</dd><dt><span class="name">jjMASKMAP</span>(uint16 <span class="param">tileID</span>)</dt>
			<dd>Creates a mask map using on the mask of the specified tile. All notes mentioned for <a class="name" href="#jjpixelmap::jjPIXELMAP">jjPIXELMAP::jjPIXELMAP(uint16)</a> apply in exactly the same way here.</dd>
		</dl>
		<dl class="class operator">
			<dt>bool&amp; <span class="name" id="jjmaskmap::opIndex">operator [] </span>(uint <span class="param">x</span>, uint <span class="param">y</span>)</dt>
			<dt>const bool&amp; <span class="name">operator [] </span>(uint <span class="param">x</span>, uint <span class="param">y</span>) const</dt>
			<dd>Gets and (if non-const) sets any pixel anywhere in the mask map, masked pixels equalling true and unmasked pixels false.</dd>
		</dl>
		<dl class="class" id="jjMASKMAPList">
			<dt>bool <span class="name" id="jjmaskmap::save">save</span>(uint16 <span class="param">tileID</span>, bool <span class="param">hFlip</span> = false) const</dt>
			<dd>Overwrites mask of tileset tile selected by <span class="param">tileID</span> with contents of the mask map. All notes mentioned for <a class="name" href="#jjpixelmap::save">jjPIXELMAP::save</a> apply in exactly the same way here, although you don't have to worry about dimensions, since mask maps are always 32�32.</dd>
		</dl>

		<h2 id="interfaces"><span>Interfaces</span></h2>
		<p>JJ2+ uses <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_global_interface.html">interfaces</a> as a way for you, the scriptwriter, to define your own script objects that perform partially in ways that JJ2+ expects and partially in ways that are completely up to you. In this, they can be thought of as microcosms of JJ2+'s AngelScript API in general, and in fact they follow similar naming conventions: any properties or methods of an interface that are directly accessed by internal JJ2+ code (optional or not) will begin with the letters "jj" or "on"�any other name is available for you to do as you please with.</p>

		<h3 id="jjbehaviorinterface"><span>jjBEHAVIORINTERFACE</span></h3>
		<p>An instance of a class implementing jjBEHAVIORINTERFACE lets you redefine nearly every aspect of how an individual <a class="name" href="#jjobj">jjOBJ</a>, or set of them, behaves and interacts with the game around it. You could almost think of them as extending the <span class="name">jjOBJ</span> class directly, in fact, but the API isn't quite set up right to make that possible. Still, they're very closely linked.</p>
		<p>To begin with, it is important to have some understanding of how JJ2 handles its objects. Every active object contains a pointer to a function that defines its behavior. To take a simple example: the Pulze Light object sits in place, constantly adjusting its <a class="name" href="#jjobj::light">light</a> property, and removes itself from memory when it goes too far offscreen or when the player dies in single player. Most objects have significantly more complicated behaviors than that, but they all come down to one thing: a function that is called by the object, every single tick. What AngelScript does is allow you to write your own object behaviors, either based on JJ2's native ones or else totally from scratch.</p>
		<p>The starting point for any object customization is the jjOBJ property <a class="name" href="#jjobj::behavior">behavior</a>. JJ2 (and by extension AngelScript) has a massive inventory of possible values, <a href="#behavior">all grouped together for you in the BEHAVIOR namespace.</a> Most of the behaviors correspond to individual JJ2 objects�BEHAVIOR::QUEEN for OBJECT::QUEEN, BEHAVIOR::CHESHIRE1 for OBJECT::CHESHIRE1, and so on�but there are also a lot of more generic behaviors that get recycled for multiple objects, such as BEHAVIOR::PICKUP (food, gems, ammo, coins, and so on), BEHAVIOR::WALKINGENEMY (lizards, hatters, doggy doggs, and several more), and BEHAVIOR::SHARD (various particle effects). To make the Norm Turtle enemy behave like its JJ1 counterpart, i.e. walk back and forth and never do anything else, we need only change its <span class="name">behavior</span> from BEHAVIOR::NORMTURTLE to BEHAVIOR::WALKINGENEMY. (And by giving it a generic enemy-type <a class="name" href="#jjobj::playerHandling">playerHandling</a> value, we can also remove its behavior of creating turtle shells when defeated.)</p>
		<pre>void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = BEHAVIOR::WALKINGENEMY;
	jjObjectPresets[OBJECT::NORMTURTLE].playerHandling = HANDLING::ENEMY;
}</pre>
		<p>Still, that's not very exciting. How about a Norm Turtle that walks back and forth and changes direction every second, regardless of whether it's about to hit a wall? For this, instead of setting <span class="name">behavior</span> to a BEHAVIOR::Behavior constant, we use an instance of a script-defined class that implements <span class="name">jjBEHAVIORINTERFACE</span>:</p>
		<pre>void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = TurnAround(); <span class="comment">//jjOBJ::behavior must be set to an instance of a class, not to a class itself. This means that instead of BEHAVIOR::WALKINGENEMY or BEHAVIOR::NORMTURTLE, Norm Turtles will call the method named "onBehave" on this class instance.</span>
	jjObjectPresets[OBJECT::NORMTURTLE].playerHandling = HANDLING::ENEMY;
}

class TurnAround : jjBEHAVIORINTERFACE { <span class="comment">//The full list of methods for jjBEHAVIORINTERFACE is given below, but the only required one is "void onBehave(jjOBJ@)"</span>
	void onBehave(jjOBJ@ obj) { <span class="comment">//called once per tick, like any other behavior</span>
		if ((jjGameTicks % 70) == 0) <span class="comment">//a second is 70 ticks long, so this means "once per second"</span>
			obj.xSpeed *= -1; <span class="comment">//reverses xSpeed and therefore direction</span>
		obj.behave(BEHAVIOR::WALKINGENEMY); <span class="comment">//jjOBJ::behave tells the object to spend a tick as if its jjOBJ::behavior equalled the method's first argument, in this case, BEHAVIOR::WALKINGENEMY. Without the xSpeed code, therefore, this would be functionally identical to the previous ".behavior = BEHAVIOR::WALKINGENEMY;" example.</span>
	}
}</pre>
		<p>Another fun trick is that <a class="name" href="#jjobj::behave">behave</a> takes an optional boolean parameter (defaults true), to specify whether JJ2 should actually follow any instructions within the native behavior function to draw the object. By setting this parameter to false, we gain the opportunity to draw the object however we like using AngelScript's various drawing functions, for example, tinted red:</p>
		<pre>void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = TurnAroundTintedRed();
	jjObjectPresets[OBJECT::NORMTURTLE].playerHandling = HANDLING::ENEMY;
}

class TurnAroundTintedRed : jjBEHAVIORINTERFACE {
	void onBehave(jjOBJ@ obj) {
		if ((jjGameTicks % 70) == 0)
			obj.xSpeed *= -1;
		obj.behave(BEHAVIOR::WALKINGENEMY, false);
	}
	void onDraw(jjOBJ@ obj) { <span class="comment">//usually also called once per tick</span>
		jjDrawSpriteFromCurFrame(obj.xPos, obj.yPos, obj.curFrame, obj.direction, SPRITE::TINTED, 24);
	}
}</pre>
		<p>In the above examples, we've been using the default argumentless constructor for our jjBEHAVIORINTERFACE classes, but that's only scratching the surface. You have the power to define your own classes, and with that comes the power to define any number of properties or methods not included in the fairly limited jjOBJ class. A jjOBJ has no string properties, for example, but you can add one to a jjBEHAVIORINTERFACE:</p>
		<pre>void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = DescribedWalker("turtle");
	jjObjectPresets[OBJECT::NORMTURTLE].playerHandling = HANDLING::ENEMY;
	jjObjectPresets[OBJECT::LIZARD].behavior = DescribedWalker("lizard");<span class="comment">//note that both turtles and lizards use the exact same class, DescribedWalker, but pass different strings to its constructor</span>
}

class DescribedWalker : jjBEHAVIORINTERFACE {
	private string enemyType; <span class="comment">//jjOBJs don't have string properties, but we can put one in here</span>
	DescribedWalker(const string &amp;in et) {
		enemyType = et;
	}
	void onBehave(jjOBJ@ obj) {
		obj.behave(BEHAVIOR::WALKINGENEMY, true);
		jjDrawString(obj.xPos, obj.yPos - 40, "I'm a " + enemyType + "!");
	}
}</pre>
		<p>Or, taking the power of constructors to their extreme, you can give each object its own individual class instance. The most convenient way to do this is often using <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_anonfunc.html">anonymous functions.</a> The following example once again uses a string property on the jjBEHAVIORINTERFACE class, but you can use any other types too, from uints and floats all the way to arrays or dictionaries.</p>
		<pre>uint NumberOfTurtles = 0;
void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = function(obj) { obj.behavior = CountTurtles(); };
}

class CountTurtles : jjBEHAVIORINTERFACE {
	string description;
	CountTurtles() {
		description = "Turtle #" + (++NumberOfTurtles);
	}
	void onBehave(jjOBJ@ obj) {
		obj.behave(BEHAVIOR::NORMTURTLE, true);
		jjDrawString(obj.xPos, obj.yPos - 40, description);
	}
}</pre>
		<p>(In addition to constructors, you may also give your class a destructor; it should however be noted that the AngelScript library <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_class_desc.html#doc_script_class_destruct">does not guarantee</a> that an object's destructor will be called the exact moment there are no more references to it, only that it will be called <em>eventually</em>. Therefore, you should not rely on a destructor to notify you instantly when a jjOBJ's behavior changes due to e.g. <a class="name" href="#jjobj::delete">jjOBJ::delete</a>.)</p>
		<p>At some point, though, you'll want to break away from the crutch that is <span class="name">jjOBJ::behave</span> and write your own object behavior from start (literally) to finish. The most important jjOBJ property to consider when defining a custom object behavior is <a class="name" href="#jjobj::state">state</a>, since JJ2 objects are basically state machines. When an object is first created�barring bizarre <a class="name" href="#jjObjectPresets">jjObjectPresets</a> fiddling�its state will equal STATE::START. Traditionally, objects take this opportunity to initialize a few properties not already set in <span class="name">jjObjectPresets</span>, perhaps read some parameters from the event map, and then change their state to something else, e.g. STATE::IDLE or STATE::STILL or STATE::DELAYEDSTART. A red spring, for instance, learns during STATE::START whether it's supposed to be a ceiling spring or a floor spring, and never bothers checking to find out ever again. If you're defining a bullet object, changing state to something else (usually STATE::FLY) is mandatory, since bullets of STATE::START are not checked for collision with other objects/players; otherwise there's nothing in the game code that forces you to do it, but it certainly seems like it should be a good idea.</p>
		<p>On the opposite side of an object's lifespan is STATE::KILL. Not all objects need to have this state, but anything that uses JJ2's normal shootable-object code will be set to STATE::KILL when the <a class="name" href="#jjobj::energy">energy</a> property reaches 0. In most cases, STATE::KILL is a sign to call <a class="name" href="#jjobj::delete">jjOBJ::delete</a>, although you may want to do other things as well, e.g. add an explosion. Bullets are a bit different, using STATE::EXPLODE instead, but the outcome is pretty much the same.</p>
		<p>Somewhat related is STATE::DEACTIVATE, the only state besides STATE::START that is essentially guaranteed to apply to every single object, albeit only in Single Player. (In multiplayer, it can of course be invoked manually, but will never be triggered from the game itself.) STATE::DEACTIVATE occurs under one of two circumstances: the player dies, causing every object to deactivate, or the object was active but is now more than about thirty tiles distant from the player and thus no longer belongs in active memory. Objects whose <a class="name" href="#jjobj::deactivates">deactivates</a> property is set to false, e.g. Rotating Rock, are immune from the latter case, but all objects get STATE::DEACTIVATE when the player dies in SP. Like STATE::KILL and <span class="name">jjOBJ::delete</span>, you can usually just get away with calling <a class="name" href="#jjobj::deactivate">jjOBJ::deactivate</a>, which deletes the object and (if it was created directly from the level map) makes a note that the object is no longer active and can be recreated later.</p>
		<p>Finally, many objects will need some code for STATE::FREEZE. The usual pattern is to decrease the <a class="name" href="#jjobj::freeze">freeze</a> property by one every tick, and once it hits 0, restore <span class="name">state</span> to <a class="name" href="#jjobj::oldState">oldState</a>. This is an also an opportunity to use the SPRITE::FROZEN mode for drawing sprites, although <a class="name" href="#jjobj::draw">jjOBJ::draw</a> will take care of that for you automatically, along with flashing the object white if it's recently been shot. Here, then, is some sample code for a very basic enemy that sits in place and does absolutely nothing but animate:</p>
		<pre>void onLevelLoad() {
	jjOBJ@ presetObject = jjObjectPresets[OBJECT::NORMTURTLE]; <span class="comment">//at this point, it doesn't matter so much which jjObjectPresets you choose, since you'll be editing most or all of its relevant properties</span>
	presetObject.behavior = StationaryEnemy();
	presetObject.determineCurAnim(ANIM::SUCKER, 4);
	presetObject.playerHandling = HANDLING::ENEMY;
	presetObject.bulletHandling = HANDLING::HURTBYBULLET; <span class="comment">//some of these values will already be used by whichever jjObjectPresets slot you choose, but it can't hurt to make sure</span>
	presetObject.isTarget = true;
	presetObject.isFreezable = true;
	presetObject.triggersTNT = true;
	presetObject.deactivates = true;
	presetObject.energy = 1;
	presetObject.points = 300;
}
class StationaryEnemy : jjBEHAVIORINTERFACE {
	void onBehave(jjOBJ@ obj) {
		switch (obj.state) {
			case STATE::START: <span class="comment">//always used</span>
				obj.state = STATE::IDLE;
			case STATE::IDLE: <span class="comment">//arbitarily chosen state</span>
				obj.frameID = (jjGameTicks/5) &amp; 7;
				obj.determineCurFrame(); <span class="comment">//remember to do this after changing frameID, since by the time you're writing your own behavior, JJ2 won't do it for you anymore</span>
				break;
			case STATE::FREEZE: <span class="comment">//can be left out if object can't be shot, or if isFreezable equals false, or if there's no ice in the level, or if you don't mind object never unfreezing</span>
				if (--obj.freeze == 0) obj.state = obj.oldState;
				<span class="comment">//consider calling jjOBJ::unfreeze() here</span>
				break;
			case STATE::DEACTIVATE: <span class="comment">//can be left out if level is MP-only</span>
				obj.deactivate();
				break;
			case STATE::KILL: <span class="comment">//can be left out if not using normal object energy handling</span>
				obj.delete();
				break;
		}
	}
	void onDraw(jjOBJ@ obj) {
		obj.draw();
	}
}</pre>
		<p>Naturally there's a lot more that an enemy can do�move around, change animations, fire bullets�but that's the basic structure right there. Draw the sprite to the screen somehow, remember to delete the object when it gets killed or deactivated, and pretty much everything else is optional or bonus. You don't even need to worry about its energy, since the HANDLING::ENEMY and HANDLING::HURTBYBULLET settings make JJ2 take care of all that stuff for you. Then there's the basic form of a bullet, which might look something like this:</p>
		<pre>void onLevelLoad() {
	jjObjectPresets[OBJECT::BLASTERBULLET].behavior = DullBullet(); <span class="comment">//for the sake of example, let's just use blaster's existing values for curAnim and xSpeed and so on</span>
}
class DullBullet : jjBEHAVIORINTERFACE {
	void onBehave(jjOBJ@ obj) {
		if (obj.state == STATE::START) {
			obj.state = STATE::FLY;
			if (obj.creatorType == CREATOR::PLAYER) obj.xSpeed += obj.var[7] / 65536.0; <span class="comment">//xSpeed of the player when firing the bullet</span>
		} else if (obj.state == STATE::DEACTIVATE) {
			obj.delete();
		} else if (obj.state == STATE::EXPLODE) {
			obj.behavior = BEHAVIOR::EXPLOSION2;
			obj.frameID = 0; <span class="comment">//display the full .killAnim animation</span>
		} else {
			obj.xSpeed += obj.xAcc;
			obj.ySpeed += obj.yAcc;
			if ((--obj.counterEnd == 0) || (jjMaskedPixel(obj.xPos + obj.xSpeed, obj.yPos + obj.ySpeed))) {
				obj.state = STATE::EXPLODE;
			} else {
				obj.xPos += obj.xSpeed;
				obj.yPos += obj.ySpeed;
				obj.draw();
			}
		}
	}
}
		</pre>
		<p>The most important things about defining a bullet are a) changing the state from STATE::START and b) changing the state to STATE::EXPLODE, because those states are referenced by various bits of external code. Bullets with either of those two states will not be checked for collision with other objects or players. Moreover, setting the state to STATE::EXPLODE in an online server may potentially tell other clients that their own copies of that bullet object need to be destroyed.</p>
		<p>To illustrate one way in which bullet behaviors may be made more complicated, using the following code instead will cause the bullet to recognize ricochet events:</p>
		<pre>			if (--obj.counterEnd == 0) {
				obj.state = STATE::EXPLODE;
			} else if (
				jjMaskedPixel(obj.xPos + obj.xSpeed, obj.yPos + obj.ySpeed) &amp;&amp; ((jjEventAtLastMaskedPixel != AREA::RICOCHET) || !obj.ricochet())) {
				obj.state = STATE::EXPLODE;
			} else {
				obj.xPos += obj.xSpeed;
				obj.yPos += obj.ySpeed;
				obj.draw();
			}
		</pre>
		<p>Not all objects are enemies and bullets, of course, but you can get by for quite a while by pretending they are while making ever more inventive use of the various sprite-drawing functions. Still, what if you want to add a new pickup instead? For example, say you want the Fast Feet pickup to increase how high a player can jump. For that you'll need the most complicated jjBEHAVIORINTERFACE method of them all: <a class="name" href="#jjbehaviorinterface::onObjectHit">onObjectHit</a>.</p>
		<pre>void onLevelLoad() {
	jjObjectPresets[OBJECT::FASTFEET].points = 100;
	jjObjectPresets[OBJECT::FASTFEET].scriptedCollisions = true;
	jjObjectPresets[OBJECT::FASTFEET].behavior = FastFeet();
}

class FastFeet : jjBEHAVIORINTERFACE {
	void onBehave(jjOBJ@ obj) {
		obj.behave(BEHAVIOR::PICKUP);
	}
	bool onObjectHit(jjOBJ@ obj, jjOBJ@, jjPLAYER@ player, int) {
		player.jumpStrength -= 1;
		obj.behavior = BEHAVIOR::EXPLOSION2; <span class="comment">//this is _essential_. just like enemies die by getting their states set to STATE::KILL, and bullets die by getting their states set to STATE::EXPLODE, pickups die by getting their behavior set to BEHAVIOR::EXPLOSION2. yes, sometimes a little consistency is in fact too much to ask for.</span>
		obj.scriptedCollisions = false; <span class="comment">//or obj.playerHandling = HANDLING::EXPLOSION; or something like that</span>
		obj.frameID = 0;
		<span class="comment">//you should probably play a sound here too, using jjSample. <a href="#sample">pick one!</a> it'll be an adventure!</span>
		return true; <span class="comment">//for details, see discussion in the onObjectHit item in the method list below, but basically you should almost always return "true" here</span>
	}
}</pre>
		<p>The short version of the story is that <span class="name">onObjectHit</span> is what gets called for objects for which <a class="name" href="#jjobj::scriptedCollisions">scriptedCollisions</a> equals true, if their <a class="name" href="#jjobj::playerHandling">playerHandling</a> value is HANDLING::PICKUP (called for collisions with players only), or HANDLING::SPECIAL (called for collisions with either players or bullets). The above case, HANDLING::PICKUP, is pretty straightforward: the third argument points to the jjPLAYER who collided with the pickup object, and the second and fourth arguments may be totally ignored. For the details of working with HANDLING::SPECIAL, which is rather more complicated, refer to the <a href="#jjbehaviorinterface::onObjectHit">onObjectHit method description</a> below.</p>
		<p>And now, the list of <span class="name">jjBEHAVIORINTERFACE</span>'s methods:</p>

		<dl class="class interface">
			<dt>void <span class="name" id="jjbehaviorinterface::onBehave">onBehave</span>(jjOBJ@ <span class="param">obj</span>)</dt>
			<dd>For every <a href="#jjOBJ">jjOBJ</a> whose <a class="name" href="#jjobj::behavior">behavior</a> is an instance of the class defining this method, this method will be called once per gametick with that <span class="name">jjOBJ</span> passed as its argument. (See above discussion for several examples.) This is the only method that must absolutely be defined in any class implementing jjBEHAVIORINTERFACE or else the script will fail to compile.</dd>
			<dd>There are also two other ways to give a method or function this role for a <span class="name">jjOBJ</span> without implementing jjBEHAVIORINTERFACE or naming it "onBehave". The following three code snippets all accomplish much the same effect, but with varying syntactic complexity and other options:
			<pre><span class="comment">/******************************************
	Version 1: jjBEHAVIORINTERFACE
	The approach described above: define a class that implements jjBEHAVIORINTERFACE, assign an instance of that class to jjOBJ::behavior, and write the main behavior code in jjBEHAVIORINTERFACE::onBehave.
	(It is also possible to define a class that inherits from a different class which in turn implements jjBEHAVIORINTERFACE, which lets you write some standard object-handling code (e.g. a function to unfreeze frozen objects) without polluting the global namespace; one possible gotcha here is that any standard jjBEHAVIORINTERFACE method name (e.g. onDraw) must be registered directly on the class that implements jjBEHAVIORINTERFACE, even though the method JJ2+ will actually call is its final override. So if you have a generic "abstract class GenericObjectClass : jjBEHAVIORINTERFACE", and then a specific "class SolidBox : GenericObjectClass" which you want to define the onIsSolid method for, you will need to define that method for both of them, even if GenericObjectClass::onIsSolid is never directly called.)
/******************************************/</span>
void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = ClassName();
}
class ClassName : jjBEHAVIORINTERFACE {
	void onBehave(jjOBJ@ obj) {
		obj.behave(BEHAVIOR::NORMTURTLE);
	}
}
<span class="comment">/******************************************
	Version 2: Global Function
	Using a global function is faster both to write and to execute than the jjBEHAVIORINTERFACE setup, and requires only that the function assigned to jjOBJ::behavior is of funcdef jjVOIDFUNCOBJ: a void-returning function with a sole jjOBJ@ argument. The only drawback of its speed is that you lose access to all the benefits of defining your own class, and must instead use global properties/functions or jjOBJ properties for everything.
	(Prior to JJ2+ version 5.2, this was the _only_ way to define a behavior function, so you will see a lot of it in older scripts. The above examples all used the full jjBEHAVIORINTERFACE syntax for the purpose of making it easy to remember and understand.)
/******************************************/</span>
void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = BehaviorFunction;
}
void BehaviorFunction(jjOBJ@ obj) {
	obj.behave(BEHAVIOR::NORMTURTLE);
}
<span class="comment">/******************************************
	Version 3: Delegate Method
	You can also create a jjVOIDFUNCOBJ as a delegate of an object method with the proper signature, even if that object method is not named "onBehave". This gains you back the ability to define your own class with its own properties, but you lose access to every standard jjBEHAVIORINTERFACE method. The most obvious reason you might want to use this odd in-between style is that you can define multiple jjVOIDFUNCOBJ-patterned methods on a single class and switch an object's behavior from one to another at will while retaining access to all the class instance's properties.
/******************************************/</span>
void onLevelLoad() {
	jjObjectPresets[OBJECT::NORMTURTLE].behavior = jjVOIDFUNCOBJ(ClassName().behaviorMethod);
}
class ClassName {
	void behaviorMethod(jjOBJ@ obj) {
		obj.behave(BEHAVIOR::NORMTURTLE);
	}
}</pre></dd>
			<dt>void <span class="name" id="jjbehaviorinterface::onDraw">onDraw</span>(jjOBJ@ <span class="param">obj</span>)</dt>
			<dd>An optional addition to <a class="name" href="#jjbehaviorinterface::onBehave">onBehave</a> where you can put code that runs nearly every gametick but is strictly related to drawing the jjOBJ to the screen. You can simply put all this code in <span class="name">onBehave</span> with no noticeable difference in results, but you may find this division to be more tidy.</dd>
			<dd>In particular, <span class="name">onDraw</span> will not be called under circumstances when sprites are never drawn, e.g. if the game is minimized in a multiplayer game, or if a <a href="#jjbehavior">jjBEHAVIOR</a> that is set to an instance of the class defining this method is passed as an argument to <a class="name" href="#jjobj::behave">jjOBJ::behave</a> and the <span class="param">draw</span> argument is set to false.</dd>
			<dt>bool <span class="name" id="jjbehaviorinterface::onGetActive">onGetActive</span>(jjOBJ@ <span class="param">obj</span>)</dt>
			<dt>void <span class="name" id="jjbehaviorinterface::onSetActive">onSetActive</span>(jjOBJ@ <span class="param">obj</span>, bool <span class="param">setTo</span>)</dt>
			<dd>A pair of methods, one returning a bool and one taking one, for saying/learning whether an object is "active" for the server when the client joins. This is the area of code that specifies the starting status of pickups, generators, trigger scenery, destruct scenery, etc. for newly joining clients, but extended to the AS world.</dd>
			<dd>By default, i.e. if they are not defined in your class, the <span class="name">onGetActive</span> equivalent simply checks <a class="name" href="#jjobj::isActive">jjOBJ::isActive</a>, and the <span class="name">onSetActive</span> equivalent calls <a class="name" href="#jjobj::delete">jjOBJ::delete</a> if passed false, or does nothing if passed true.</dd>
			<dd>Only applies to objects placed in JCS, i.e. <a href="#jjobj::creator">jjOBJ::creator</a> == CREATOR::LEVEL.</dd>
			<dt>bool <span class="name" id="jjbehaviorinterface::onIsSolid">onIsSolid</span>(jjOBJ@ <span class="param">obj</span>)</dt>
			<dd>When <a href="#jjGameConnection">jjGameConnection</a> == GAME::LOCAL, all box objects (objects with <a class="name" href="#jjobj::behavior">behavior</a> BEHAVIOR::CRATE, BEHAVIOR::AMMO15, BEHAVIOR::MONITOR, or BEHAVIOR::BIGOBJECT) can sit on top of other box objects and cannot be pushed through other box objects. Return true from this method to add objects with this class (instance) as their behavior onto that list. (This has no impact on whether players treat the object as solid, only whether crates and such do.)</dd>
			<dd>By default, i.e. if <span class="name">onIsSolid</span> is not defined in your class, it is assumed to return false.</dd>
			<dd>This method can be simulated on global jjVOIDFUNCOBJ behavior functions by use of the <code>[SOLID]</code> metadata string (the equivalent of <span class="name">onIsSolid</span> always returning true), e.g. <pre>[SOLID]
void Crate(jjOBJ@ obj) {
	obj.behave(BEHAVIOR::CRATE);
}</pre></dd>
			<dt>bool <span class="name" id="jjbehaviorinterface::onIsRFBullet">onIsRFBullet</span>(jjOBJ@ <span class="param">obj</span>)</dt>
			<dd>Most standard bullet behaviors handle speed and acceleration pretty much the same way, but RFs need a lot of special treatment, and messing with them at all tends to make them not fly fast enough and stuff like that. If you write a behavior class or function that's supposed to serve as a wrapper around BEHAVIOR::RFBULLET (i.e. you set it as the <a href="#jjobj::behavior">behavior</a> for one or more bullets in <a href="#jjObjectPresets">jjObjectPresets</a> and it calls <code>jjOBJ::behave(BEHAVIOR::RFBULLET)</code>), it's important for <span class="name">onIsRFBullet</span> to return true in order to receive that same special treatment and thus get the right speeds assigned at firing time.</dd>
			<dd>By default, i.e. if <span class="name">onIsRFBullet</span> is not defined in your class, it is assumed to return false.</dd>
			<dd>This method can be simulated on global jjVOIDFUNCOBJ behavior functions by use of the <code>[RFBULLET]</code> metadata string (the equivalent of <span class="name">onIsRFBullet</span> always returning true), e.g. <pre>[RFBULLET]
void Missile(jjOBJ@ obj) {
	obj.behave(BEHAVIOR::RFBULLET);
}</pre></dd>
			<dd>Here's a sample snippet highlighting the use of class constructors to reuse the same method for multiple underlying behavior functions:<pre>void onLevelLoad() {
    for (int eventID = OBJECT::BLASTERBULLET; eventID &lt;= OBJECT::ELECTROBULLETPU; ++eventID) {
        jjObjectPresets[eventID].behavior = BulletWrapper(jjObjectPresets[eventID].behavior);
    }
}

class BulletWrapper : jjBEHAVIORINTERFACE {
    private jjBEHAVIOR nativeBehavior;
    BulletWrapper(const jjBEHAVIOR &amp;in nb) { nativeBehavior = nb; }

    void onBehave(jjOBJ@ obj) {
        obj.behave(nativeBehavior);
    }
    bool onIsRFBullet(jjOBJ@ obj) {
        return nativeBehavior == BEHAVIOR::RFBULLET;
    }
}</pre></dd>
			<dt>bool <span class="name" id="jjbehaviorinterface::onObjectHit">onObjectHit</span>(jjOBJ@ <span class="param">obj</span>, jjOBJ@ <span class="param">bullet</span>, jjPLAYER@ <span class="param">player</span>, int <span class="param">force</span>)</dt>
			<dd>JJ2 contains a lot of code for figuring out how each object should behave when collided with by either a player or a bullet, most of which it bases on <a class="name" href="#jjobj::eventID">jjOBJ::eventID</a>. For instance, Silver Coin and Banana objects use the same <a href="#jjobj::behavior">jjOBJ::behavior</a> (BEHAVIOR::PICKUP), but react differently to being touched by a player based on their <span class="name">eventID</span> properties (OBJECT::SILVERCOIN and OBJECT::BANANA). This works perfectly well for vanilla JJ2 but is not enough for scripted levels, where you might want objects to react in ways that the original game never intended. For this you need <span class="name">onObjectHit</span>.</dd>
			<dd>In order for <span class="name">onObjectHit</span> to called at all, two requirements must be met by the object: it must have <a class="name" href="#jjobj::scriptedCollisions">jjOBJ::scriptedCollisions</a> set to true, and <a class="name" href="#jjobj::playerHandling">jjOBJ::playerHandling</a> to either HANDLING::PICKUP or HANDLING::SPECIAL. In either case, assuming that the <span class="name">onObjectHit</span> method is properly defined in the class, that method will be called whenever the object needs to react to being hit.</dd>
			<dd>In the first case, HANDLING::PICKUP, <span class="name">onObjectHit</span> will only be called when a player object comes into contact with the pickup. The first argument will be the pickup itself, the third argument the player object, and the second and fourth may be totally ignored. If the result of the collision is that the pickup is collected, you should set the pickup's <span class="name">behavior</span> to BEHAVIOR::EXPLOSION2; this is traditional in local single player, and mandatory in online multiplayer in order for the results of the collision (the pickup getting collected) to be broadcast to other players in the server.</dd>

			<dd>HANDLING::SPECIAL is unfortunately a lot more complicated, because it has to handle not only a player bumping into the object, but also a player attacking the object with a physical special move, a bullet hitting the object, and a handful of special cases besides. The following table indicates what the values of the second through fourth arguments of the method will be under those circumstances, so that when writing an <span class="name">onObjectHit</span> method of your own, you'll be able to figure out why it was called:
		<table id="onobjecthit" class="borderedtable">
			<tbody><tr>
				<th>&nbsp;</th>
	<th>jjOBJ@ <span class="param">bullet</span></th>
	<th>jjPLAYER@ <span class="param">player</span></th>
	<th>int <span class="param">force</span></th>
			</tr>
			<tr>
				<th>Collision</th>
	<td>null</td>
	<td>non-null</td>
	<td>0</td>
			</tr>
			<tr>
				<th>Sugar rush</th>
	<td>null</td>
	<td>non-null</td>
	<td>1</td>
			</tr>
			<tr>
				<th>Special move</th>
	<td>null</td>
	<td>non-null</td>
	<td>-1</td>
			</tr>
			<tr>
				<th>Frozen+running</th>
	<td>null</td>
	<td>non-null</td>
	<td>-101</td>
			</tr>
			<tr>
				<th>Bullet</th>
	<td>non-null</td>
	<td>maybe null</td>
	<td>variable</td>
			</tr>
			<tr>
				<th>Turtle shell</th>
	<td>non-null, but objectID=0</td>
	<td>maybe null</td>
	<td>1</td>
			</tr>
			<tr>
				<th>Blue+orange bird</th>
	<td>non-null, but objectID=0</td>
	<td>maybe null</td>
	<td>4</td>
			</tr>
			<tr>
				<th>TNT explosion</th>
	<td>non-null, but objectID=0</td>
	<td>maybe null</td>
	<td>variable</td>
			</tr>
		</tbody></table>
		As you can see, the various collisions that may call <span class="name">onObjectHit</span> for HANDLING::SPECIAL objects may be broken into two main types, or three if you want to consider bullets on their own. The first four categories result from a player rabbit directly colliding with the object, and the <span class="param">force</span> parameter hinting at whether the object should consider taking damage from the collision or not. Of course, something like the Cheshire2 object doesn't pay any attention to <span class="param">force</span> here; it's pretty much just for destructable objects like enemies or crates.</dd>
		<dd>Bullets are the main alternate cause, and <span class="param">force</span> should correspond to their <a class="name" href="#jjobj::animSpeed">animSpeed</a> property. In this case, <span class="param">player</span> may or may not be null, depending on whether the bullet was fired by a player (not null) or by a generator object/crate object/whatever (null). Or to put it in AngelScript terms, whether the bullet's <a class="name" href="#jjobj::creatorType">creatorType</a> property equals CREATOR::PLAYER.</dd>
		<dd>The remaining three categories�turtle shells, impacts with the blue and orange bird's beak, and being caught in a TNT object's blast radius� all employ the curious strategy of setting <span class="param">bullet</span> to <code>jjObjects[0]</code>. To distinguish them from true bullets, thus all you need to do is compare the jjOBJ's <a class="name" href="#jjobj::objectID">objectID</a> property to 0, but since JJ2 never really reads any of object 0's properties, it's generally safe to treat such collisions exactly as if they were truly bullets: for example, setting the <span class="param">bullet</span> jjOBJ's state to STATE::EXPLODE when that jjOBJ is object 0 is an action totally without consequences. Like bullets, turtle shell collisions may or may not set the <span class="param">player</span> parameter, depending on whether they've been shot by a player or not prior to calling <span class="name">onObjectHit</span>.</dd>
		<dd>If you are scripting a multiplayer level and wish to ensure that the results of the HANDLING::SPECIAL collision are received by other players in the server, changing its <span class="name">state</span> to STATE::KILL, STATE::EXPLODE, or STATE::ACTION will be announced to other players; any other state change will remain local.</dd>
		<dd>Notice that <span class="name">onObjectHit</span> has a bool return value. This follows the pattern established by the various global bool-returning hook functions: return true to signify that the hook has dealt with the situation, or false to let JJ2+ carry out the default behavior. In this particular case, the default behavior is to look for a global hook function with nearly the same signature, differing only in return value:
		<pre>void onObjectHit(jjOBJ@ obj, jjOBJ@ bullet, jjPLAYER@ player, int force)</pre>
		The <span class="name">onObjectHit</span> global function is called for any object with <span class="name">scriptedCollisions</span> true and <span class="name">playerHandling</span> PICKUP or SPECIAL if that object's behavior class does not define its own <span class="name">onObjectHit</span> method, or if it does define such a method but it happens to return false. (More accurately, every such global function across <a href="#mutators">every script module</a> is called.) The global hook option remains open primarily for backwards compatibility, but defining a class-specific method is almost invariably the better idea, because it greatly reduces the chances of one object accidentally using some code meant for another one.</dd>
		</dl>


		<h3 id="jjpublicinterface"><span>jjPUBLICINTERFACE</span></h3>
		<p>Typically, different script modules, i.e. mutators and level scripts, are designed as separate entities that don't directly interact with each other and instead only interact with the game. This is usually desirable, but in other circumstances limits functionality, leads to repetition in code, or causes conflicts between scripts. jjPUBLICINTERFACE is a tool designed to allow communication and interaction between simultaneously running scripts.</p>
		<p>Communication using jjPUBLICINTERFACE is asymmetric: when two modules interact, one of them is an <dfn>exporter</dfn> and the other is an <dfn>importer</dfn>. The <dfn>exporter</dfn> is a module that exposes some of its functionality to other modules. It doesn't have to know their names or be in any way aware of their existence. All it has to do is register a class that implements jjPUBLICINTERFACE and a special hook function named <span class="name">onGetPublicInterface</span>. It's far more common for the exporter to be a mutator than a level script, but in theory it may be either. The <dfn>importer</dfn> is a module that is aware the exporter exists and refers to it by name to gain access to its functionality. It does so by calling the <a class="name" href="#jjGetPublicInterface">jjGetPublicInterface</a> function. The importer may equally well be a mutator as a level script.</p>
		<p>jjPUBLICINTERFACE only defines one method that serves the purpose of obtaining version of the exporter, thus, on its own, it cannot perform meaningful communication. In order to expose other methods, the interface handle obtained from <a class="name" href="#jjGetPublicInterface">jjGetPublicInterface</a> has to be cast to an underlying type that is known to both script modules. This generates certain restrictions: the underlying type needs to be defined identically in both modules, and it needs to be defined as shared. The most convenient way to meet those requirements is to use a so-called header file to contain the type. Below you can see an example of a structure of three files: a header, an exporter, and an importer, that demonstrates basic module interaction:</p>
		<pre><span class="comment">//header.asc

//This file will be shared between the exporter and the importer so that PublicInterface is a common type for both of them.
//The shared type is an interface, but could also be a class or an abstract class.</span>
shared interface PublicInterface : jjPUBLICINTERFACE {
    int getProperty();
    void setProperty(int);
    <span class="comment">//getVersion inherited from jjPUBLICINTERFACE, may be omitted.</span>
    string getVersion() const;
}</pre>
		<pre><span class="comment">//exporter.mut</span>

#pragma require "header.asc"
#include "header.asc"
int property = 0;
<span class="comment">//Create a type that implements PublicInterface. This class doesn't have to be shared, so it can refer to module-local entities, such as property in this example.</span>
class PublicClass : PublicInterface {
    int getProperty() {
        return property;
    }
    void setProperty(int value) {
        property = value;
    }
    string getVersion() const {
        return "1.0";
    }
}
<span class="comment">//Create an instance of the class to return from onGetPublicInterface.</span>
PublicClass publicInstance;
<span class="comment">//The hook. Notice that the return type doesn't have to be jjPUBLICINTERFACE@. This is discussed below.</span>
PublicClass@ onGetPublicInterface() {
    return publicInstance;
}
void onMain() {
    property++;
}</pre>
		<pre><span class="comment">//importer.mut</span>

#pragma require "header.asc"
#include "header.asc"
PublicInterface@ publicInstance;
void onLevelLoad() {
    <span class="comment">//Calls onGetPublicInterface of exporter.mut, if that mutator is running.</span>
    jjPUBLICINTERFACE@ pi = jjGetPublicInterface("exporter.mut");
    <span class="comment">//If pi is null, exporter.mut is not running or doesn't register onGetPublicInterface, so no interaction will be possible.</span>
    if (pi !is null) {
        <span class="comment">//Attempt a cast to the underlying type.</span>
        @publicInstance = cast&lt;PublicInterface&gt;(pi);
        <span class="comment">//If pi is not null but the cast fails, the underlying type is not what we expected. Perhaps exporter.mut changed the underlying type in a newer version. Here's an example of how getVersion may be used even if the underlying type is unknown:</span>
        if (publicInstance is null)
            jjAlert("Incompatible exporter.mut version: " + pi.getVersion());
    }
}
void onMain() {
    if (publicInstance !is null) {
        <span class="comment">//Through the exposed functions, importer.mut can now access and modify variables of exporter.mut.</span>
        int exporterProperty = publicInstance.getProperty();
        publicInstance.setProperty(exporterProperty + 1);
    }
}</pre>
		<p>A few things are worth paying attention to about this example. In particular, as pointed out, the <span class="name">onGetPublicInterface</span> hook returns a type that is local to the script module. Indeed, although the default signature of this hook is</p>
		<pre>jjPUBLICINTERFACE@ onGetPublicInterface()</pre>
		<p>other signatures are also accepted, as long as the hook is registered to take no arguments and return a handle of a type that implements jjPUBLICINTERFACE. Another thing worth bringing up is that although this example may seem complicated to a beginner, most of the burden of implementation is on the side of the person creating the exporting module; creating an importing module is relatively easy. In fact, a well-designed header file may provide convenience functions that immensely reduce nuances of importing functionality from a module.</p>
		<p>Below is the sole method of jjPUBLICINTERFACE:</p>
		<dl class="class interface">
			<dt>string <span class="name" id="jjbehaviorinterface::getVersion">getVersion</span>() const</dt>
			<dd>Should be defined to return a constant string denoting the module version, or the version of its public interface. The format of this string is unspecified but it is recommended that it be descriptive, e.g. the first released version of the module may define this to return "1.0".</dd>
		</dl>


		<h2 id="globalproperties"><span>Global Properties</span></h2>
		<dl id="globalpropertiesList">
			<dt>const uint <span class="name" id="jjActiveGameTicks">jjActiveGameTicks</span></dt>
			<dd>How long the game has been actively running, at a rate of 70 ticks per second. Unlike <a class="name" href="#jjGameTicks">jjGameTicks</a>, this value is not incremented when the game is paused, stopped, or in pregame. This is a local value that counts up from 0 except in online Race games, where it is used to track lap times and is therefore synced between server and clients.</dd>
			<dt>const bool <span class="name" id="jjAllowsFireball">jjAllowsFireball</span></dt>
			<dd>Whether weapon 8 is fireball instead pepper spray, as set by the /fireball command.</dd>
			<dt>const bool <span class="name" id="jjAllowsMouseAim">jjAllowsMouseAim</span></dt>
			<dd>Whether the server (or the SP level) allows mouse aim, as set by the /allowmouseaim command.</dd>
			<dt>const bool <span class="name" id="jjAllowsReady">jjAllowsReady</span></dt>
			<dd>Whether the server allows players to use the /ready command, as set by the /allowready command.</dd>
			<dt>const bool <span class="name" id="jjAllowsWalljump">jjAllowsWalljump</span></dt>
			<dd>Whether the server allows players to use the �walljumping� bug, as set by the /allowwalljump command.</dd>
			<dt>const bool <span class="name" id="jjAlwaysRunning">jjAlwaysRunning</span></dt>
			<dd>Whether always running is enabled, as set by the /run command.</dd>
			<dt>jjTILE@ <span class="name" id="jjAnimatedTiles">jjAnimatedTiles[0x10000]</span></dt>
			<dd>Animated tiles defined by the level. For every <code>tileID</code>,<code>jjAnimatedTiles[tileID] is jjTiles[tileID | TILE::ANIMATED]</code>.</dd>
			<dd>See also <a class="name" href="#jjTiles">jjTiles</a>.</dd>
			<dt>jjANIMATION@ <span class="name" id="jjAnimations">jjAnimations[1500]</span></dt>
			<dd>Loaded animations. See the <a href="#jjanimation">jjANIMATION class description</a> for more information.</dd>
			<dt>jjANIMFRAME@ <span class="name" id="jjAnimFrames">jjAnimFrames[15000]</span></dt>
			<dd>Loaded animation frames. See the <a href="#jjanimframe">jjANIMFRAME class description</a> for more information.</dd>
			<dt>jjANIMSET@ <span class="name" id="jjAnimSets">jjAnimSets[ANIM::Set]</span></dt>
			<dd>Loaded animation sets. See the <a href="#jjanimset">jjANIMSET class description</a> for more information.</dd>
			<dt>const bool <span class="name" id="jjAutoWeaponChange">jjAutoWeaponChange</span></dt>
			<dd>Whether automatic weapon change is locally enabled, as set by the /weaponchange command.</dd>
			<dt>const <span class="ns">jjPAL</span> <span class="name" id="jjBackupPalette">jjBackupPalette</span></dt>
			<dd>The tileset's original palette. See the jjPAL documentation above for further details.</dd>
			<dt>const int <span class="name" id="jjBorderHeight">jjBorderHeight</span></dt>
			<dt>const int <span class="name" id="jjBorderWidth">jjBorderWidth</span></dt>
			<dd>The size of the black borders that appear at the edges of each local player's subscreen when a subscreen is larger than the level/server's maximum resolution, when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile Width/Tile Height checked), and/or when the F3 key has been used. Useful for deciding where to draw HUD/UI elements. Note that these values refer to the size of each border, not the overall size of the black space, so for instance if <span class="name">jjBorderWidth</span> is 80, there will be 80 columns of black pixels on the left side of the subscreen and an additional 80 columns on the right side.</dd>
			<dt>jjPLAYER@ <span class="name" id="jjBottomFeeder">jjBottomFeeder</span></dt>
			<dd>In Roast Tag game mode, the player who is currently the bottom feeder or null if none. For the other special role in Roast Tag, see <a class="name" href="#jjTokenOwner">jjTokenOwner</a>.</dd>
			<dt>jjCHARACTER@ <span class="name" id="jjCharacters">jjCharacters[CHAR::Char]</span></dt>
			<dd>Character profiles. Use either CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2 as an index. Refer to the <a href="#jjcharacter">jjCHARACTER section</a> for more information.</dd>
			<dt>const int <span class="name" id="jjColorDepth">jjColorDepth</span></dt>
			<dd>Color depth in bits per pixel. Either 8 or 16.</dd>
			<dt>const jjCONTROLPOINT@ <span class="name" id="jjControlPoints">jjControlPoints[16]</span></dt>
			<dd>An array containing all Domination control points in the level. See the <a href="#jjcontrolpoint">jjCONTROLPOINT section</a> for further details.</dd>
			<dt>const bool <span class="name" id="jjDeactivatingBecauseOfDeath">jjDeactivatingBecauseOfDeath</span></dt>
			<dd>When the player dies in Single Player mode, this property is set to true before all jjOBJs have their <a class="name" href="#jjobj::state">state</a> property set to DEACTIVATE. Since DEACTIVATE is also used for when an object goes too far off-screen, this property is how to discover the reason for the state change. In practice, is probably only ever consulted by destruct scenery and trigger scenery.</dd>
			<dt class="new"> const bool <span class="name" id="jjDebugF10">jjDebugF10</span></dt>
			<dd>Only ever true in single player, specifically when the player has pressed the <kbd>F10</kbd> key to enable debug mode. Among other peculiarities during this time, neither <span class="name">onPlayer</span> nor <span class="name">onPlayerInput</span> nor any of the various non-layer-based <a href="#jjcanvas">jjCANVAS</a> onDraw hook functions will be called, because JJ2+ will be ignoring all normal player interactions.</dd>
			<dt>bool <span class="name" id="jjDelayGeneratedCrateOrigins">jjDelayGeneratedCrateOrigins</span></dt>
			<dd>If set to true, box objects (trigger crates, all wooden crates, bird morph monitors, and also bird cages) spawned from Generator objects will derive their parameters from the tile they begin at, not the tile they are created at. If the Generator object is in the air, the crate will appear on top of the nearest solid tile below the Generator, and will get its parameters from the tile there.</dd>
			<dt class="updated">int <span class="name" id="jjDifficulty">jjDifficulty</span></dt>
			<dd>The current difficulty level. 1 for Normal difficulty; 0 and below for Easy; 2 for Hard; 3 and above for Turbo. Numerous enemies base their speeds at least partially on the difficulty, so numbers outside of the well-tested 0-3 range may have unexpected or undesirable effects with certain enemies; still, it's worth a try! This property cannot be used to determine whether to load events specified in JCS as Easy or Hard, since that has already been checked by the time AngelScript starts running in a level.</dd>
			<dd>When you set this property, <a class="name" href="#jjDifficultyNext">jjDifficultyNext</a> will also be set to the new value. So for example, if you want to make enemies move a little faster in this level without affecting the difficulty of the next level in the series, try: <code>jjDifficulty += 1; jjDifficultyNext = jjDifficultyOrig;</code></dd>
			<dt class="new">int <span class="name" id="jjDifficultyNext">jjDifficultyNext</span></dt>
			<dd>The difficulty for the next level. Normally this will be the same as <a class="name" href="#jjDifficulty">jjDifficulty</a>, but the <code>/difficulty</code> command can set this property independently. Setting this does not accomplish anything for clients, because clients will have their difficulty updated by the server upon cycling.</dd>
			<dt class="new">const int <span class="name" id="jjDifficultyOrig">jjDifficultyOrig</span></dt>
			<dd>The difficulty at the start of the level, prior to it being potentially changed by scripts setting <a class="name" href="#jjDifficulty">jjDifficulty</a>. In online servers, clients who join this level partway through will be sent this value for their difficulty, so they will remove the same events from the event map that everyone else in the server did.</dd>
			<dt>const bool <span class="name" id="jjDoZombiesAlreadyExist">jjDoZombiesAlreadyExist</span></dt>
			<dd>In Pestilence game mode, whether any player is already a zombie.</dd>
			<dt>int <span class="name" id="jjEcho">jjEcho</span></dt>
			<dd>The current degree of echo, as set by the "Echo" event.</dd>
			<dt>bool <span class="name" id="jjEnabledASFunctions">jjEnabledASFunctions[256]</span></dt>
			<dd>Usually all true. When a Text event is touched with AngelScript=1,Vanish=1, the <span class="name">jjEnabledASFunctions[#]</span> bool for that Text event's TextID value will be set to false and the corresponding <span class="name">onFunction#</span> will be uncallable by other Text events until the bool is set to true again.</dd>
			<dt>const bool <span class="name" id="jjEnabledTeams">jjEnabledTeams[TEAM::Color]</span></dt>
			<dt>const bool <span class="name">jjEnabledTeams[4]</span></dt>
			<dd>Currently enabled teams. Possible indices are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.</dd>
			<dt>LIGHT::Enforce <span class="name" id="jjEnforceLighting">jjEnforceLighting</span></dt>
			<dd>This setting defines the minimal ambient lighting options required from the game. It will not change game settings if they don't fulfill the requirements but it will display lights as if the settings were changed. Allowed values are:<ul>
				<li><span class="name">OPTIONAL</span>: The default value; ambient lighting can be freely disabled and enabled with no limits.</li>
				<li><span class="name">BASIC</span>: Ambient lighting can be disabled but basic lights, such as those emitted by objects, players and laser shields, have to be drawn. This only affects the game if ambient lighting is disabled and low detail is enabled, because that's when basic lights stop being drawn.</li>
				<li><span class="name">COMPLETE</span>: Ambient lighting cannot be disabled, all lights have to be drawn.</li>
				</ul></dd>
			<dt>uint8 <span class="name" id="jjEventAtLastMaskedPixel">jjEventAtLastMaskedPixel</span></dt>
			<dd>Whenever one of the mask-detection functions, e.g. <a class="name" href="#jjMaskedHLine">jjMaskedHLine</a>, finds a masked pixel in layer 4, this property will be set to the event at the tile containing that pixel. This allows you to write code for object like seeker missiles, which ignore masked pixels on tiles with the AREA::ONEWAY, AREA::HOOK, or AREA::VINE events. There's not much reason to edit it manually, since JJ2 changes its value all but constantly, but you can if you want.</dd>
			<dt>const int <span class="name" id="jjFPS">jjFPS</span></dt>
			<dd>The current frames per second rate, as viewable by pressing F9 twice.</dd>
			<dt>const bool <span class="name" id="jjFriendlyFire">jjFriendlyFire</span></dt>
			<dd>Whether friendly fire is enabled, as set by the /friendlyfire command.</dd>
			<dt>const <span class="ns">GAME::Connection</span> <span class="name" id="jjGameConnection">jjGameConnection</span></dt>
			<dd>Is this game joinable by players from other computers, and if so, must they be connected to the same network or just the internet? Options are LOCAL, ONLINE, and LAN.</dd>
			<dt>const <span class="ns">GAME::Custom</span> <span class="name" id="jjGameCustom">jjGameCustom</span></dt>
			<dd>If using a custom gamemode, what is it? Options are NOCUSTOM, RT, LRS, XLRS, PEST, TB, JB, DCTF, FR, TLRS, DOM, and HEAD.</dd>
			<dt>const <span class="ns">GAME::Mode</span> <span class="name" id="jjGameMode">jjGameMode</span></dt>
			<dd>What is the current base gamemode, irrespective of whether there is a custom gamemode or not? Options are SP, COOP, BATTLE, CTF, TREASURE, and RACE.</dd>
			<dt>const <span class="ns">GAME::State</span> <span class="name" id="jjGameState">jjGameState</span></dt>
			<dd>In an online/network server, is the game started, stopped, or some other variation? Options are. STOPPED, STARTED, PAUSED (only possible if there is a time limit), PREGAME, and OVERTIME.</dd>
			<dt>const int <span class="name" id="jjGameTicks">jjGameTicks</span></dt>
			<dd>How long the game has been actively running, at a rate of 70 ticks per second.</dd>
			<dt>string <span class="name" id="jjHelpStrings">jjHelpStrings[16]</span></dt>
			<dd>Help strings as set in level properties and used by Text events and end bosses. These can be modified but are limited to 511 characters each, so longer strings will be truncated. For the standard function to display these strings, see <a class="name" href="#jjplayer::showText">showText</a>.</dd>
			<dt>const bool <span class="name" id="jjIsAdmin">jjIsAdmin</span></dt>
			<dd>Whether the current game executable is logged in as a Remote Admin in the current online server. To check this property for any client in the server, use jjPLAYER property <a class="name" href="#jjplayer::isAdmin">isAdmin</a> instead.</dd>
			<dt>const bool <span class="name" id="jjIsServer">jjIsServer</span></dt>
			<dd>Whether the current game executable is hosting an online server.</dd>
			<dt>bool <span class="name" id="jjIsSnowing">jjIsSnowing</span></dt>
			<dd>Whether there's any active weather effect. The type of the effect is determined by <a class="name" href="#jjSnowingType">jjSnowingType</a>.</dd>
			<dt>bool <span class="name" id="jjIsSnowingOutdoorsOnly">jjIsSnowingOutdoorsOnly</span></dt>
			<dd>Whether the current weather effect is specified to only take effect on transparent tiles, i.e. appear to be limited to outdoors areas.</dd>
			<dt>const bool <span class="name" id="jjIsTSF">jjIsTSF</span></dt>
			<dd>Whether the current game executable is 1.23+ or 1.24+. Useful for Lori, XMas enemies, etc.</dd>
			<dt>const bool <span class="name" id="jjKey">jjKey[256]</span></dt>
			<dd>Whether any given key on the keyboard is currently pressed, assuming JJ2 is able to check it, including the left and right mouse buttons. Uses <a href="http://msdn.microsoft.com/en-us/library/dd375731(VS.85).aspx">virtual key codes</a> for indexation. Note that <span class="name">jjKey[1]</span> and <span class="name">jjKey[2]</span> refer to the primary and secondary mouse buttons respectively, rather than left and right.</dd>
			<dt>uint8 <span class="name" id="jjKeyChat">jjKeyChat</span></dt>
			<dd>The current <a href="http://msdn.microsoft.com/en-us/library/dd375731(VS.85).aspx">virtual key</a> used to open the chat prompt in a multiplayer game, default value 0x54 ('T'). No matter the key (or mouse button), pressing the Shift key at the same time will open the chat prompt in Team Chat mode (in CTF games). Note that as a workaround to allow players to cycle and whatnot, pressing Ctrl+T will always open the chat prompt, even if <span class="name">jjKeyChat</span> is set to 0 or something similarly inaccessible.</dd>
			<dt>bool <span class="name" id="jjLayerHasTiles">jjLayerHasTiles[8]</span></dt>
			<dt>const int <span class="name" id="jjLayerHeight">jjLayerHeight[8]</span></dt>
			<dt>bool <span class="name" id="jjLayerLimitVisibleRegion">jjLayerLimitVisibleRegion[8]</span></dt>
			<dt>bool <span class="name" id="jjLayerTileHeight">jjLayerTileHeight[8]</span></dt>
			<dt>bool <span class="name" id="jjLayerTileWidth">jjLayerTileWidth[8]</span></dt>
			<dt>const int <span class="name" id="jjLayerWidth">jjLayerWidth[8]</span></dt>
			<dt>const int <span class="name" id="jjLayerWidthReal">jjLayerWidthReal[8]</span></dt>
			<dt>const int <span class="name" id="jjLayerWidthRounded">jjLayerWidthRounded[8]</span></dt>
			<dt>float <span class="name" id="jjLayerXAutoSpeed">jjLayerXAutoSpeed[8]</span></dt>
			<dt>float <span class="name" id="jjLayerYAutoSpeed">jjLayerYAutoSpeed[8]</span></dt>
			<dt>float <span class="name" id="jjLayerXOffset">jjLayerXOffset[8]</span></dt>
			<dt>float <span class="name" id="jjLayerYOffset">jjLayerYOffset[8]</span></dt>
			<dt>float <span class="name" id="jjLayerXSpeed">jjLayerXSpeed[8]</span></dt>
			<dt>float <span class="name" id="jjLayerYSpeed">jjLayerYSpeed[8]</span></dt>
			<dd>Shortcut global properties for the same-named <a href="#jjlayer">jjLAYER</a> properties on the same-indexed <a class="name" href="#jjLayers">jjLayers</a> objects.</dd>
			<dt><span class="ns">jjLAYER</span>@ <span class="name" id="jjLayers">jjLayers[8]</span></dt>
			<dd>The original eight layers placed in this level (i.e. <a class="name" href="#jjLevelFileName">jjLevelFileName</a>) in JCS or some other level editor, 1-indexed to match the JCS numbers, e.g. <code>jjLayers[4]</code> for the main sprite layer or <code>jjLayers[8]</code> for the final background layer, regardless of what other code may have done to create new layers or alter their order. See the <a href="#jjlayer">jjLAYER documentation</a> above for further details.</dd>
			<dt class="updated">const string <span class="name" id="jjLevelFileName">jjLevelFileName</span></dt>
			<dd>File name of the current level, e.g. <code>castle1.j2l</code>, all lowercase. The file extension (.j2l) will be included, but not the folder structure.</dd>
			<dt>string <span class="name" id="jjLevelName">jjLevelName</span></dt>
			<dd>Title of the current level, e.g. <code>Dungeon Dilemma</code>.</dd>
			<dt>const int <span class="name" id="jjLocalPlayerCount">jjLocalPlayerCount</span></dt>
			<dd>The number of local players.</dd>
			<dt>const <span class="ns">jjPLAYER</span>@ <span class="name" id="jjLocalPlayers">jjLocalPlayers[4]</span></dt>
			<dd>The local players.</dd>
			<dt class="updated">const bool <span class="name" id="jjLowDetail">jjLowDetail</span></dt>
			<dd>Whether the Low Detail video setting is enabled. When true, only <a class="name" href="#jjLayers">jjLayers[8]</a> and layers whose <a class="name" href="#jjlayer::xSpeed">xSpeed/ySpeed</a> both equal exactly 1 and whose <a class="name" href="#jjlayer::xSpeedModel">xSpeedModel/ySpeedModel</a> both equal LAYERSPEEDMODEL::NORMAL will be drawn, and even those only if <a class="name" href="#jjlayer::hasTileMap">hasTileMap</a> and <a class="name" href="#jjlayer::hasTiles">hasTiles</a> are both true.</dd>
			<dt>const int <span class="name" id="jjMaxHealth">jjMaxHealth</span></dt>
			<dd>The most health a player can ever have, as set by the /maxhealth command. Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.</dd>
			<dt>const int <span class="name" id="jjMaxScore">jjMaxScore</span></dt>
			<dd>In competitive game modes, the score required to win, as set by the /maxscore command.</dd>
			<dt>const bool <span class="name" id="jjMouseAim">jjMouseAim</span></dt>
			<dd>Whether mouse aim is locally enabled, as set by the /mouseaim command.</dd>
			<dt>const int <span class="name" id="jjMouseX">jjMouseX</span></dt>
			<dt>const int <span class="name" id="jjMouseY">jjMouseY</span></dt>
			<dd>The current position of the mouse cursor relative to the top left corner of the game window. To convert these coordinates to coordinates within layer 4, you'll need to use the jjPLAYER <a class="name" href="#jjplayer::cameraX">cameraX</a> and <a class="name" href="#jjplayer::cameraY">cameraY</a> properties.</dd>
			<dt>const bool <span class="name" id="jjMusicActive">jjMusicActive</span></dt>
			<dd>Mute Music, as seen in the Sound &amp; Music Properties window.</dd>
			<dt class="updated">const string <span class="name" id="jjMusicFileName">jjMusicFileName</span></dt>
			<dd>File name of the music file currently playing, e.g. <code>3ddemo.mod</code>, all lowercase. The file extension will be included (even if not included by the level or user, e.g. this string will be "castle.j2b" if "castle" was written in Level Properties), but not the folder structure.</dd>
			<dd>This is a const property. To change it, use <a href="#jjMusicLoad">jjMusicLoad</a>.</dd>
			<dt>const int <span class="name" id="jjMusicVolume">jjMusicVolume</span></dt>
			<dd>Music Volume, as seen in the Sound &amp; Music Properties window.</dd>
			<dt>const bool <span class="name" id="jjNoBlink">jjNoBlink</span></dt>
			<dd>Whether the no blink mode is enabled, as set by the /noblink command.</dd>
			<dt>const bool <span class="name" id="jjNoMovement">jjNoMovement</span></dt>
			<dd>Whether the game blocks movement during stopped games, as set by the /nomovement command.</dd>
			<dt>const int <span class="name" id="jjObjectCount">jjObjectCount</span></dt>
			<dd>When looping through <a class="name" href="#jjObjects">jjObjects</a>, this is the endpoint; there should never exist a jjOBJ with an object ID higher than <span class="name">jjObjectCount</span>. It is not however the number of distinct jjOBJs in existence at any given time, since for instance <code>jjObjects[1]</code> and <code>jjObjects[3]</code> may both be active but <code>jjObjects[2]</code> inactive, but <span class="name">jjObjectCount</span> would still equal 4.</dd>
			<dt>const int <span class="name" id="jjObjectMax">jjObjectMax</span></dt>
			<dd>The most jjOBJs that can ever exist at the same time. This equals 2048 in local Single Player/Coop, or 4096 otherwise.</dd>
			<dt><span class="ns">jjOBJ</span>@ <span class="name" id="jjObjectPresets">jjObjectPresets[256]</span></dt>
			<dd>The templates from which each object is built. Tends to contain default <a class="name" href="#jjobj::xSpeed">xSpeed</a>, <a class="name" href="#jjobj::ySpeed">ySpeed</a>, <a class="name" href="#jjobj::points">points</a>, <a class="name" href="#jjobj::curAnim">curAnim</a>, and so on. Make changes here in <span class="name">onLevelLoad</span> for maximum efficiency.</dd>
			<dt><span class="ns">jjOBJ</span>@ <span class="name" id="jjObjects">jjObjects[jjObjectMax]</span></dt>
			<dd>All the objects currently in memory.</dd>
			<dt class="deprecated"><span class="ns">jjPLAYER</span>@ <span class="name" id="jjP">jjP</span></dt>
			<dd>The current player.</dd>
			<dt><span class="ns">jjPAL</span> <span class="name" id="jjPalette">jjPalette</span></dt>
			<dd>The current palette. See the jjPAL documentation above for further details.</dd>
			<dt>jjPARTICLE@ <span class="name" id="jjParticles">jjParticles[1024]</span></dt>
			<dd>All the particles currently in memory. See the <a href="#jjparticle">jjPARTICLE documentation</a> above for further details.</dd>
			<dt class="deprecated">const int <span class="name" id="jjPlayerCount">jjPlayerCount</span></dt>
			<dd>Doesn't work! Check back later.</dd>
			<dt>const <span class="ns">jjPLAYER</span>@ <span class="name" id="jjPlayers">jjPlayers[32]</span></dt>
			<dd>All the players in the game, local or otherwise.</dd>
			<dt>const bool <span class="name" id="jjQuirks">jjQuirks</span></dt>
			<dd>Whether the quirks mode is enabled, as set by the /quirks command.</dd>
			<dt>const int <span class="name" id="jjRenderFrame">jjRenderFrame</span></dt>
			<dd>How long the game has been running. Unlike <a class="name" href="#jjGameTicks">jjGameTicks</a>, <span class="name">jjRenderFrame</span> updates when the game is paused. This is the value used for drawing layers with automatic x/y speeds.</dd>
			<dt>const int <span class="name" id="jjResolutionHeight">jjResolutionHeight</span></dt>
			<dt>const int <span class="name" id="jjResolutionWidth">jjResolutionWidth</span></dt>
			<dd>The size of the current game window in pixels, usually 640 by 480.</dd>
			<dt>const int <span class="name" id="jjResolutionMaxHeight">jjResolutionMaxHeight</span></dt>
			<dt>const int <span class="name" id="jjResolutionMaxWidth">jjResolutionMaxWidth</span></dt>
			<dd>The maximum size the game window is allowed to be in the current level/server.</dd>
			<dt>const uint <span class="name" id="jjScriptModuleID">jjScriptModuleID</span></dt>
			<dd>Each script module (including mutators) will see this property as equalling a different value: 0 for the .j2as script (if any), and 1 or higher for all mutators (loaded in alphabetical order). For use only as parameters of function <a class="name" href="#jjSendPacket">jjSendPacket</a> and jjPLAYER method <a class="name" href="#jjplayer::hasPrivilege">hasPrivilege</a>.</dd>
			<dt>const bool <span class="name" id="jjShowMaxHealth">jjShowMaxHealth</span></dt>
			<dd>Whether the show max health option from the Plus menu is enabled.</dd>
			<dt>uint8 <span class="name" id="jjSnowingIntensity">jjSnowingIntensity</span></dt>
			<dd>Intensity of the current weather effect. Note that that this setting only influences the game if <a class="name" href="#jjIsSnowing">jjIsSnowing</a> is true.</dd>
			<dt><span class="ns">SNOWING::Type</span> <span class="name" id="jjSnowingType">jjSnowingType</span></dt>
			<dd>Type of the current weather effect. Note that that this setting only influences the game if <a class="name" href="#jjIsSnowing">jjIsSnowing</a> is true. Possible values are SNOW, FLOWER, RAIN, and LEAF, each spawning particles of the corresponding <a href="#jjparticle::type">PARTICLE::Type</a>.</dd>
			<dt>const bool <span class="name" id="jjSoundEnabled">jjSoundEnabled</span></dt>
			<dd>Whether JJ2 should produce any form of audio at all.</dd>
			<dt>const bool <span class="name" id="jjSoundFXActive">jjSoundFXActive</span></dt>
			<dd>Mute Sound, as seen in the Sound &amp; Music Properties window.</dd>
			<dt>const int <span class="name" id="jjSoundFXVolume">jjSoundFXVolume</span></dt>
			<dd>Sound Volume, as seen in the Sound &amp; Music Properties window.</dd>
			<dt>const int <span class="name" id="jjStartHealth">jjStartHealth</span></dt>
			<dd>How much health a player starts with, as set by the /starthealth command. Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.</dd>
			<dt>const bool <span class="name" id="jjStrongPowerups">jjStrongPowerups</span></dt>
			<dd>Whether strong powerups is enabled, as set by the /strongpowerups command.</dd>
			<dt>const int <span class="name" id="jjSubscreenHeight">jjSubscreenHeight</span></dt>
			<dt>const int <span class="name" id="jjSubscreenWidth">jjSubscreenWidth</span></dt>
			<dd>The size of a player's subscreen in pixels. If there is only one local player and the game is not being viewed in 3D, these will be equal to <a class="name" href="#jjResolutionHeight">jjResolutionHeight</a> and <a class="name" href="#jjResolutionWidth">jjResolutionWidth</a> -- otherwise, either or both may be cut in half. The subscreen size includes, and is therefore not changed by the values of, <a class="name" href="#jjBorderHeight">jjBorderHeight</a> and <a class="name" href="#jjBorderWidth">jjBorderWidth</a>.</dd>
			<dt>bool <span class="name" id="jjSugarRushAllowed">jjSugarRushAllowed</span></dt>
			<dd>In online multiplayer levels where this is false for the host, clients with sugar rushes will be kicked for hacking. This property is set to true between <span class="name">onLevelLoad</span> and <span class="name">onLevelBegin</span> if there are any events in the level that will spawn food objects. If you need to allow sugar rushes for another reason, e.g. <a class="name" href="#jjplayer::startSugarRush">jjPLAYER::startSugarRush</a>, your script should set this property to true in <span class="name">onLevelBegin</span> at the earliest. (See the description of <a class="name" href="#jjweapon::allowed">jjWEAPON::allowed</a> for more technical details, but as applied to the list of food events instead.)</dd>
			<dt>const int <span class="name" id="jjTeamScore">jjTeamScore[TEAM::Color]</span></dt>
			<dd>Each team's current score in team-based game modes and undefined value in other modes. Available indexes are BLUE, RED, GREEN and YELLOW.</dd>
			<dt class="updated">float <span class="name" id="jjTexturedBGFadePositionX">jjTexturedBGFadePositionX</span></dt>
			<dt>float <span class="name" id="jjTexturedBGFadePositionY">jjTexturedBGFadePositionY</span></dt>
			<dt>bool <span class="name" id="jjTexturedBGStars">jjTexturedBGStars</span></dt>
			<dt><span class="ns">TEXTURE::Style</span> <span class="name" id="jjTexturedBGStyle">jjTexturedBGStyle</span></dt>
			<dt><span class="ns">TEXTURE::Texture</span> <span class="name" id="jjTexturedBGTexture">jjTexturedBGTexture</span></dt>
			<dd>Shortcut global properties for corresponding <a class="name" href="#jjlayer">jjLAYER</a> or <a class="name" href="#jjlayer::warpHorizon">jjLAYER::warpHorizon</a> properties of the background layer, i.e. <a class="name" href="#jjLayers">jjLayers</a>[8].</dd>
			<dt class="updated">bool <span class="name" id="jjTexturedBGUsed">jjTexturedBGUsed</span></dt>
			<dd>A shortcut property for <code>jjLayers[8]</code>'s <a class="name" href="#jjlayer::textureSurface">textureSurface</a> property. Returns true iff the property is anything other than SURFACE::UNTEXTURED. Set <span class="name">jjTexturedBGUsed</span> to true to set to SURFACE::LEGACY, or to false to set to SURFACE::UNTEXTURED.</dd>
			<dt>const uint <span class="name" id="jjTileCount">jjTileCount</span></dt>
			<dd>The number of (non-animated, non-flipped) tiles currently defined in the level, usually a multiple of 10. Can be increased using <a class="name" href="#jjTilesFromTileset">jjTilesFromTileset</a>.</dd>
			<dt>const jjTILE@ <span class="name" id="jjTiles">jjTiles[0x10000]</span></dt>
			<dd>Static and animated tiles corresponding to <a href="#tileids">tile IDs</a>.</dd>
			<dd>See also <a class="name" href="#jjAnimatedTiles">jjAnimatedTiles</a>.</dd>
			<dt class="updated">const string <span class="name" id="jjTilesetFileName">jjTilesetFileName</span></dt>
			<dd>File name of the tileset used by the current level, e.g. <code>castle1.j2t</code>, all lowercase. The file extension (.j2t) will be included, but not the folder structure.</dd>
			<dt>uint8 <span class="name" id="jjTileType">jjTileType[4096]</span></dt>
			<dd>Each tile's tile type: 0 for normal, 1 for translucent, 3 for invisible, and so on. Refer to your JCS.ini for the full list.</dd>
			<dt>bool <span class="name" id="jjTriggers">jjTriggers[32]</span></dt>
			<dd>The triggers, as set by the Trigger Zone and Trigger Crate events.</dd>
			<dt>jjPLAYER@ <span class="name" id="jjTokenOwner">jjTokenOwner</span></dt>
			<dd>In Roast Tag game mode, the player who is currently "it" or null if none. For the other special role in Roast Tag, see <a class="name" href="#jjBottomFeeder">jjBottomFeeder</a>.</dd>
			<dt class="updated">bool <span class="name" id="jjUseLayer8Speeds">jjUseLayer8Speeds</span></dt>
			<dd>A shortcut property for <code>jjLayers[8]</code>'s <a class="name" href="#jjlayer::xSpeedModel">xSpeedModel/ySpeedModel</a> properties. Returns true iff at least one of the two properties is anything other than LAYERSPEEDMODEL::LAYER8. Set <span class="name">jjUseLayer8Speeds</span> to true to set both properties to LAYERSPEEDMODEL::NORMAL, or to false to set both properties to LAYERSPEEDMODEL::LAYER8.</dd>
			<dt>bool <span class="name" id="jjVerticalSplitscreen">jjVerticalSplitscreen</span></dt>
			<dd>If there are exactly two local players, how the window is divided into their two subscreens.</dd>
			<dt>bool <span class="name" id="jjWarpsTransmuteCoins">jjWarpsTransmuteCoins</span></dt>
			<dd>If set to false, using a coin warp in Single Player mode will not turn all remaining coins into red and green gems.</dd>
			<dt>float <span class="name" id="jjWaterChangeSpeed">jjWaterChangeSpeed</span></dt>
			<dd>How fast water moves up or down when the water level is set (by event or function) with the "Instant" parameter set to false. Defaults to 1.</dd>
			<dt><span class="ns">WATERINTERACTION::WaterInteraction</span> <span class="name" id="jjWaterInteraction">jjWaterInteraction</span></dt>
			<dd>How local players react to being underwater. If this property is set to SWIM, they will swim; if LOWGRAVITY, they will use regular physics but will fall more slowly than usual. If this property is set to POSITIONBASED (the default), the game will choose between the effects of SWIM or LOWGRAVITY depending on whether <a class="name" href="#jjWaterLevel">jjWaterLevel</a> is lower or greater than 32*128. This property has no effects on other objects or on sound effects, which always move more slowly/sound different underwater.</dd>
			<dt>int <span class="name" id="jjWaterLayer">jjWaterLayer</span></dt>
			<dd>Which layer, 1-8, water is drawn in front of when visible. Defaults to 1. Set to any non-existing layer number to make water invisible. Note that this is a purely visual setting, and putting water behind the sprite layer will not prevent players from swimming in it.</dd>
			<dd>If the <a class="name" href="#jjLayerOrderSet">order of layers has been changed</a>, this property's distance from 4 is its distance from the sprite layer, e.g. leaving it at 1 means that it will be drawn in front of the third layer in front of the sprite layer. (And therefore, if the sprite layer is the first, second, or third layer in the drawing order, water will not be drawn at all.)</dd>
			<dt>const float <span class="name" id="jjWaterLevel">jjWaterLevel</span></dt>
			<dd>How high the water currently is, in pixels.</dd>
			<dd>This is a constant value; use the <a class="name" href="#jjSetWaterLevel">jjSetWaterLevel</a> helper function instead for changing it.</dd>
			<dt><span class="ns">WATERLIGHT::wl</span> <span class="name" id="jjWaterLighting">jjWaterLighting</span></dt>
			<dd>The current way that water and ambient lighting interact in the level. (Ambient lighting varies by local player and as such is a <span class="name">jjPLAYER</span> property.) The following constants are permissible values:
				<ul>
					<li><strong>WATERLIGHT::NONE</strong>: The default. When water is activated, the level will display at lighting 100, regardless of the current settings.</li>
					<li><strong>WATERLIGHT::GLOBAL</strong>: The entire level will be lit according to the current ambient lighting settings, both above and below the water line.</li>
					<li><strong>WATERLIGHT::LAGUNICUS</strong>: The current ambient lighting setting is ignored. Above the water, the level will display at lighting 100. Below the water, the level will display darker and darker depending on how far below the water line the player is.</li>
				</ul></dd>
			<dt>const float <span class="name" id="jjWaterTarget">jjWaterTarget</span></dt>
			<dd>The height the water is moving towards, in pixels. If the water level is set (by event or function) with the "Instant" parameter set to false, there will be a period in which <a class="name" href="#jjWaterLevel">jjWaterLevel</a> and <span class="name">jjWaterTarget</span> are two distinct values.</dd>
			<dd>This is a constant value; use the <a class="name" href="#jjSetWaterLevel">jjSetWaterLevel</a> helper function instead for changing it.</dd>
			<dt>jjWEAPON <span class="name" id="jjWeapons">jjWeapons[WEAPON::Weapon]</span></dt>
			<dt>jjWEAPON <span class="name">jjWeapons[9]</span></dt>
			<dd>Various properties of the nine different weapons available to a player; see the <a href="#jjweapon">jjWEAPON section</a>. <a href="#weapon">Possible constants appear in the appendix below</a>, or you may use simple 1-indexed numbers instead.</dd>
			<dt class="deprecated"><span class="ns">jjPLAYER@</span> <span class="name" id="p">p</span></dt>
			<dd>The current player; an alias of <span class="name">jjP</span>, and the only property not to begin with the jj prefix, provided solely for convenience value.</dd>
		</dl>

		<h2 id="globalfunctions"><span>Global Functions</span></h2>
		<dl id="globalfunctionsList">
			<dt>int <span class="name" id="jjAddObject">jjAddObject</span>(uint8 <span class="param">eventID</span>, float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint16 <span class="param">creatorID</span> = 0, <span class="ns">CREATOR::Type</span> <span class="param">creatorType</span> = CREATOR::OBJECT, <span class="ns">jjBEHAVIOR</span> behavior = BEHAVIOR::DEFAULT)</dt>
			<dd>Adds and initiates an object of type <span class="param">eventID</span> at xOrg <span class="param">xPixel</span> and <span class="param">yOrg</span> yPixel. Possible values for <span class="param">creatorType</span> are CREATOR::OBJECT, CREATOR::LEVEL, and CREATOR::PLAYER. Useful values for <span class="param">eventID</span> can be found <a href="#object">in the appendix at the bottom of the page</a>. Returns the object ID of the new object, or 0 if the function fails for whatever reason.</dd>
			<dd>The difference between <code>jjAddObject(1, 0, 0, CREATOR::OBJECT, 0, BEHAVIOR::BOUNCERBULLET);</code> and <code>jjObjects[jjAddObject(1, 0, 0)].behavior = BEHAVIOR::BOUNCERBULLET;</code> is that <span class="name">jjAddObject</span> calls the object's behavior function as part of creating it. The first version will call BEHAVIOR::BOUNCERBULLET while the object's <a class="name" href="#jjobj::state">state</a> is still STATE::START; the second version will call <code>jjObjectPresets[1].behavior</code> and only switch the object's behavior to BEHAVIOR::BOUNCERBULLET after it has already been initialized and its <span class="name">state</span> likely changed to something else. The same distinction applies to setting the object's <a class="name" href="#jjobj::xOrg">xOrg</a>/<a class="name" href="#jjobj::yOrg">yOrg</a>, <a class="name" href="#jjobj::creatorType">creatorType</a>, and <a class="name" href="#jjobj::creatorID">creatorID</a> properties as parameters to the function or later on. See <a href="#jjbehaviorinterface">jjBEHAVIORINTERFACE</a>.</dd>
			<dt>jjPARTICLE@ <span class="name" id="jjAddParticle">jjAddParticle</span>(<span class="ns">PARTICLE::Type</span> <span class="param">type</span>)</dt>
			<dd>Creates and returns a new particle object, or a null pointer if unsuccessful. See the jjPARTICLE documentation above for full details.</dd>
			<dt>void <span class="name" id="jjAddParticlePixelExplosion">jjAddParticlePixelExplosion</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, int <span class="param">curFrame</span>, int <span class="param">direction</span>, int <span class="param">mode</span>)</dt>
			<dd>Creates an explosion of particles based on the shape and possibly colors of the specified <span class="param">curFrame</span>. Use a <span class="param">mode</span> value of 0 for a normal explosion, 1 for a fire explosion caused by a toaster or fire shield bullet, or 2 for an explosion caused by a special move. Values in the range of 15-255 will create fire explosions whose particles will use palette index equal to <span class="param">mode</span> - this effect is currently used by weapons such as powered-up toaster and laser shield to create blue explosions. Value 14 creates a fire explosion whose particles use individually random colors. Values in the range of 3-13 and higher than 255 are undefined and - to preserve backward compatibility - shouldn't be used.</dd>
			<dt>void <span class="name" id="jjAddParticleTileExplosion">jjAddParticleTileExplosion</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>, uint16 <span class="param">tile</span>, bool <span class="param">collapseSceneryStyle</span>)</dt>
			<dd>Creates four fragments of a <a href="#tileids">tile</a> falling from a specified location, like when destroying a destructable scenery block. Does not produce a sound effect; use <a class="name" href="#jjSample">jjSample</a> or <a class="name" href="#jjSamplePriority">jjSamplePriority</a> for that instead. The fragments will continue to be drawn until they fall off the screen. If you want more control over the fragments' positions, speeds, etc., use <a class="name" href="#jjAddParticle">jjAddParticle</a> instead.</dd>
			<dt>void <span class="name" id="jjAlert">jjAlert</span>(const string &amp;in <span class="param">text</span>, bool <span class="param">sendToAll</span> = false, STRING::Size <span class="param">size</span> = STRING::SMALL)</dt>
			<dd>Writes <span class="param">text</span> to the chatlogger window, and also displays it ingame for the local player. Uses <span class="param">size</span> to determine size and positioning of text. If <span class="param">sendToAll</span> is true and the function is called by the server, <span class="param">text</span> will be sent to all clients as well.</dd>
			<dt>void <span class="name" id="jjChat">jjChat</span>(const string &amp;in <span class="param">text</span>, bool <span class="param">teamchat</span> = false)</dt>
			<dd>In online play, sends <span class="param">text</span> to the server as a line of chat. If <span class="param">text</span> is a command (e.g. "/spectate on" or "/ready"), it will be interpreted as such to the extent that the local player is allowed to use that command in the server.</dd>
			<dd>In offline play, JJ2+ will try to parse <span class="param">text</span> as a command but will not display it as chat because there is no chat in offline mode. If you want to simulate chatting in a local game, use <a class="name" href="#jjAlert">jjAlert</a> instead.</dd>
			<dt>void <span class="name" id="jjConsole">jjConsole</span>(const string &amp;in <span class="param">text</span>, bool <span class="param">sendToAll</span> = false)</dt>
			<dd>Writes <span class="param">text</span> as a console message to the chatlogger window, and also displays it ingame for the local player. If <span class="param">sendToAll</span> is true and the function is called by the server, <span class="param">text</span> will be sent to all clients as well.</dd>
			<dt>float <span class="name" id="jjCos">jjCos</span>(uint <span class="param">angle</span>)</dt>
			<dd>Returns the cosine of <span class="param">angle</span> with a range of 0.0-1.0 and a domain of 0-1023. Numbers outside the domain will be seemlessly moduloed. You may prefer <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_addon_math.html">AngelScript's native cos function.</a></dd>
			<dt>uint <span class="name" id="jjCRC32">jjCRC32</span>(const jjSTREAM &amp;in <span class="param">input</span>, uint <span class="param">crc</span> = 0)</dt>
			<dd>Computes <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">cyclic redundancy check</a> of <span class="param">input</span> with optional initial value <span class="param">crc</span>. The checksum is computed according to the CRC-32 standard (as used in the zlib library and all JJ2 data files that use CRC).</dd>
			<dt>void <span class="name" id="jjDebug">jjDebug</span>(const string &amp;in <span class="param">text</span>, bool <span class="param">timestamp</span> = false)</dt>
			<dd>Writes <span class="param">text</span> to the chatlogger window (but not ingame), but only if <code>[General]AngelscriptDebug</code> equals True in plus.ini. If <span class="param">timestamp</span> is true, adds a timestamp before the text.</dd>
			<dt>void <span class="name" id="jjDeleteObject">jjDeleteObject</span>(int <span class="param">objectID</span>)</dt>
			<dd>Permanently deletes an object. Like <a class="name" href="#jjAddObject">jjAddObject</a>, this function is purely local in its scope.</dd>
			<dt>void <span class="name" id="jjDrawPixel">jjDrawPixel</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint8 <span class="param">color</span>, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawRectangle">jjDrawRectangle</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, int <span class="param">width</span>, int <span class="param">height</span>, uint8 <span class="param">color</span>, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawResizedSprite">jjDrawResizedSprite</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, int <span class="param">setID</span>, uint8 <span class="param">animation</span>, uint8 <span class="param">frame</span>, float <span class="param">xScale</span>, float <span class="param">yScale</span>, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawResizedSpriteFromCurFrame">jjDrawResizedSpriteFromCurFrame</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint <span class="param">sprite</span>, float <span class="param">xScale</span>, float <span class="param">yScale</span>, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawRotatedSprite">jjDrawRotatedSprite</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, int <span class="param">setID</span>, uint8 <span class="param">animation</span>, uint8 <span class="param">frame</span>, int <span class="param">angle</span>, float <span class="param">xScale</span> = 1, float <span class="param">yScale</span> = 1, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawRotatedSpriteFromCurFrame">jjDrawRotatedSpriteFromCurFrame</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint <span class="param">sprite</span>, int <span class="param">angle</span>, float <span class="param">xScale</span> = 1, float <span class="param">yScale</span> = 1, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawSprite">jjDrawSprite</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, int <span class="param">setID</span>, uint8 <span class="param">animation</span>, uint8 <span class="param">frame</span>, int <span class="param">direction</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawSpriteFromCurFrame">jjDrawSpriteFromCurFrame</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint <span class="param">sprite</span>, int <span class="param">direction</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawString">jjDrawString</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, STRING::SIZE <span class="param">size</span> = STRING::SMALL, <span class="ns">STRING::Mode</span> <span class="param">mode</span> = STRING::NORMAL, uint8 <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawString">jjDrawString</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, const jjANIMATION &amp;in <span class="param">animation</span>, <span class="ns">STRING::Mode</span> <span class="param">mode</span> = STRING::NORMAL, uint8 <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name">jjDrawString</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, STRING::SIZE <span class="param">size</span>, const jjTEXTAPPEARANCE &amp;in <span class="param">appearance</span>, uint8 <span class="param">param1</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">spriteMode</span> = SPRITE::PALSHIFT, uint8 <span class="param">param2</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name">jjDrawString</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, const string &amp;in <span class="param">text</span>, const jjANIMATION &amp;in <span class="param">animation</span>, const jjTEXTAPPEARANCE &amp;in <span class="param">appearance</span>, uint8 <span class="param">param1</span> = 0, <span class="ns">SPRITE::Mode</span> <span class="param">spriteMode</span> = SPRITE::PALSHIFT, uint8 <span class="param">param2</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawSwingingVineSpriteFromCurFrame">jjDrawSwingingVineSpriteFromCurFrame</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint <span class="param">sprite</span>, int <span class="param">length</span>, int <span class="param">curvature</span>, <span class="ns">SPRITE::Mode</span> <span class="param">mode</span> = SPRITE::NORMAL, int <span class="param">param</span> = 0, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dt>void <span class="name" id="jjDrawTile">jjDrawTile</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, uint16 <span class="param">tile</span>, <span class="ns">TILE::Quadrant</span> <span class="param">tileQuadrant</span> = TILE::ALLQUADRANTS, int8 <span class="param">layerZ</span> = 4, uint8 <span class="param">layerXY</span> = 4, int8 <span class="param">playerID</span> = -1)</dt>
			<dd>Global function versions of the <a href="#jjcanvas">jjCANVAS methods</a> as applied to <span class="name">onDrawLayer#</span> hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call <span class="name">jjDrawSpriteFromCurFrame</span> many times over, once for each of its chain links, in the middle of its <a class="name" href="#jjobj::behavior">behavior</a> function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.</dd>
			<dd>The <span class="param">layerZ</span> parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.</dd>
			<dd>The <span class="param">layerXY</span> parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.</dd>
			<dd>If the <a class="name" href="#jjLayerOrderSet">order of layers has been changed</a>, then <span class="param">layerZ</span> and <span class="param">layerXY</span>'s distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily <code>jjLayers[3]</code>, but rather 4-1, the first layer in front of the sprite layer, whichever <a class="name" href="#jjlayer">jjLAYER</a> that happens to be.</dd>
			<dd>The <span class="param">playerID</span> parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true <a class="name" href="#jjplayer::isLocal">isLocal</a>). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the <a class="name" href="#jjplayer::charCurr">charCurr</a> and <a class="name" href="#jjplayer::powerup">powerup[1]</a> values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.</dd>
			<dt>void <span class="name" id="jjEnableEachASFunction">jjEnableEachASFunction</span>()</dt>
			<dd>Resets all 256 bools in <a class="name" href="#jjEnabledASFunctions">jjEnabledASFunctions</a> to true.
			</dd><dt>int <span class="name" id="jjEventGet">jjEventGet</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>)</dt>
			<dd>Gets the Event ID at tile <span class="param">xTile,yTile</span>, as seen in JCS.ini. This number can also be compared to the <a href="#object">OBJECT</a> or <a href="#area">AREA</a> constants listed in the appendix at the bottom of this file.</dd>
			<dt>void <span class="name" id="jjEventSet">jjEventSet</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>, uint8 <span class="param">newEventID</span>)</dt>
			<dt>void <span class="name">jjEventSet</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>, <span class="ns">OBJECT::Object</span> <span class="param">newEventID</span>)</dt>
			<dt>void <span class="name">jjEventSet</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>, <span class="ns">AREA::Area</span> <span class="param">newEventID</span>)</dt>
			<dd>Sets the event at tile <span class="param">xTile,yTile</span> to <span class="param">newEventID</span>. Possible <a href="#object">OBJECT</a> or <a href="#area">AREA</a> constants are listed in the appendix at the bottom of this file.</dd>
			<dd>Caution: this is a permanent change and will subsist even after death in offline play.</dd>
			<dt>void <span class="name" id="jjGenerateSettableTileArea">jjGenerateSettableTileArea</span>(uint8 <span class="param">layer</span>, int <span class="param">xTile</span>, int <span class="param">yTile</span>, int <span class="param">width</span>, int <span class="param">height</span>)</dt>
			<dd>Shortcut global function for <a href="#jjlayer::generateSettableTileArea">jjLAYER::generateSettableTileArea</a> on the same-indexed <a class="name" href="#jjLayers">jjLayers</a> objects.</dd>
			<dt class="new">jjPALCOLOR <span class="name" id="jjGetFadeColors">jjGetFadeColors</span>()</dt>
			<dd>Calls and returns the result of <code><a class="name" href="#jjLayers">jjLayers</a>[8].<a class="name" href="#jjlayer::getFadeColor">getFadeColor</a>()</code>.</dd>
			<dt>int <span class="name" id="jjGetModOrder">jjGetModOrder</span>()</dt>
			<dd>Returns the current order in the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.</dd>
			<dt>int <span class="name" id="jjGetModRow">jjGetModRow</span>()</dt>
			<dd>Returns the current row in the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.</dd>
			<dt>int <span class="name" id="jjGetModSpeed">jjGetModSpeed</span>()</dt>
			<dd>Returns the "speed" parameter (ticks per row) of the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.</dd>
			<dt>int <span class="name" id="jjGetModTempo">jjGetModTempo</span>()</dt>
			<dd>Returns the tempo of the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.</dd>
			<dt>jjPUBLICINTERFACE@ <span class="name" id="jjGetPublicInterface">jjGetPublicInterface</span>(const string &amp;in <span class="param">moduleName</span>)</dt>
			<dd>If <span class="param">moduleName</span> is a name of a currently running script module that registers the <span class="name">onGetPublicInterface</span> hook, calls that hook and returns its result, otherwise returns null. Module names are the same as names of files that contain the modules, including the file extension ".j2as" or ".mut", and the comparison is not case sensitive. In the target module, <span class="name">onGetPublicInterface</span> must be a global function with the following signature:
			<pre>jjPUBLICINTERFACE@ onGetPublicInterface()</pre>
			The exact return type may differ as long as it is a handle to a class or interface that implements jjPUBLICINTERFACE. This function should not be called earlier than in <span class="name">onLevelLoad</span>, i.e. it should not be used to initialize a global variable, as the target module may not be available at that point yet. More details about usage of this function may be found in the <a href="#jjpublicinterface">dedicated section of this document</a>.</dd>
			<dt>uint16 <span class="name" id="jjGetStaticTile">jjGetStaticTile</span>(uint16 <span class="param">tileID</span>)</dt>
			<dd>If <span class="param">tileID</span> is animated, i.e. <code>(tileID &amp; TILE::ANIMATED) != 0</code>, returns tile ID of the current animation frame of the tile corresponding to <span class="param">tileID</span>. Otherwise returns <span class="param">tileID</span>.</dd>
			<dd>Like animated tiles themselves, this function relies on system time rather than game ticks, which means that subsequent calls during the same frame may return different results, and that results may insignificantly differ compared to the effective state of the animation. This behavior may change in the future.</dd>
			<dd>This function never returns tile ID of animated tiles. If its result would be animated, which may happen in levels edited by other means than JCS, the function is called recursively on the result until a static tile is obtained.</dd>
			<dt>int <span class="name" id="jjGetStringWidth">jjGetStringWidth</span>(const string &amp;in <span class="param">text</span>, STRING::Size <span class="param">size</span>, const jjTEXTAPPEARANCE &amp;in <span class="param">style</span>)</dt>
			<dt>int <span class="name" id="jjGetStringWidth">jjGetStringWidth</span>(const string &amp;in <span class="param">text</span>, const jjANIMATION &amp;in <span class="param">animation</span>, const jjTEXTAPPEARANCE &amp;in <span class="param">style</span>)</dt>
			<dd>Returns width, in pixels, that <span class="param">text</span> would have if it was drawn in specified <span class="param">size</span> (or <span class="param">animation</span>) and <span class="param">style</span>. If <span class="param">style</span> allows multi-line text and <span class="param">text</span> is multi-line, width of the longest line is returned.</dd>
			<dt>bool <span class="name" id="jjIsValidCheat">jjIsValidCheat</span>(const string &amp;in <span class="param">text</span>)</dt>
			<dd>Returns true if <span class="param">text</span> is interpreted by the game as a cheat code.</dd>
			<dt>void <span class="name" id="jjKillObject">jjKillObject</span>(int <span class="param">objectID</span>)</dt>
			<dd>Permanently deletes an object, but first calls its native STATE::KILL code (if any). Probably functionally identical to <a class="name" href="#jjDeleteObject">jjDeleteObject</a> in most cases, but might work a little better sometimes.</dd>
			<dt>array&lt;<span class="ns">jjLAYER</span>@&gt;@ <span class="name" id="jjLayerOrderGet">jjLayerOrderGet</span>()</dt>
			<dt>bool <span class="name" id="jjLayerOrderSet">jjLayerOrderSet</span>(const array&lt;<span class="ns">jjLAYER</span>@&gt;&amp; in <span class="param">order</span>)</dt>
			<dd>A pair of functions for accessing or changing the ordered list of layers drawn to the screen. (In most cases it should be simpler to keep the <a href="#jjlayer">jjLAYER</a>@ array around in your script as a variable, rather than retrieving it using <span class="name">jjLayerOrderGet</span>, but that function is there just in case you need it.) The arrays are ordered so that the first <span class="name">jjLAYER</span> is in front and the last is in back, meaning that writing <code>jjLayerOrderSet(array&lt;jjLAYER@&gt; = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]});</code> should have no visible effect in a previously unaltered level.</dd>
			<dd>The array passed to <span class="name">jjLayerOrderSet</span> <em>must</em> include <code>jjLayers[4]</code> (the gameplay/sprite layer) as one of its entries and must not include any null handles, or else the function will return false and cause a debug error. Including multiple handles to the same <span class="name">jjLAYER</span> is allowed but not very useful.</dd>
			<dd>Following a call to <span class="name">jjLayerOrderSet</span>, it takes some extra thought and understanding to figure out how to refer to individual layers in other sections of the code. Specifically there are two different patterns (which happen to come to the same thing if the layer order is never changed at all):</dd>
			<dd>All global properties or functions with a 1-indexed layer argument�e.g. <a class="name" href="#jjLayers">jjLayers</a>, <a class="name" href="#jjLayerYSpeed">jjLayerYSpeed</a>, or <a class="name" href="#jjTileGet">jjTileGet</a>� refer exclusively to the level's original eight layers as defined in the level editor. <code>jjLayers[1]</code> will always refer to the same layer no matter which layer ends up being drawn foremost in the foreground. To read or write the size, speeds, etc. of any layer besides those eight, use the properties and methods of its <span class="name">jjLAYER</span> instance. Similarly, the <a href="#jjcanvas">jjCANVAS</a> <code>onDrawLayer#</code> hooks are (currently) only available for those original eight layers, and <code>jjLayers[1]</code> will always call <code>onDrawLayer1</code> (if defined) no matter its position in the drawing order.</dd>
			<dd>When calling <a href="#jjDrawSprite">jjDrawSprite</a> or any of its related functions with their <span class="param">layerZ</span> and <span class="param">layerXY</span> arguments, those arguments refer to the list of layers from <span class="name">jjLayerOrderGet</span>, relative to Layer 4's position in that list. The default <span class="param">layerZ</span> value is 4 and will always draw sprites to <code>jjLayers[4]</code>. If <span class="param">layerZ</span> equals 3, 4-1, the sprite will be drawn to whichever <span class="name">jjLAYER</span> is ordered one in front of <code>jjLayers[4]</code>. If 6, 4+2, the layer two behind <code>jjLayers[4]</code>. And so on. The same principle applies to <a class="name" href="#jjWaterLayer">jjWaterLayer</a>.</dd>
			<dt>array&lt;<span class="ns">jjLAYER</span>@&gt;@ <span class="name" id="jjLayersFromLevel">jjLayersFromLevel</span>(const string &amp;in <span class="param">filename</span>, const array&lt;uint&gt; &amp;in <span class="param">layerIDs</span>, int tileIDAdjustmentFactor = 0)</dt>
			<dd>Returns an array containing a number of handles of new <a href="#jjlayer">jjLAYER</a> instances built from the layers defined in the level <span class="param">filename</span>, specifically those requested in the 1-indexed <span class="param">layerIDs</span>. (Passing numbers not in the range of 1�8 in <span class="param">layerIDs</span> is undefined behavior.) For example, <code>jjLayersFromLevel("castle1.j2l", array&lt;uint&gt; = {5,6});</code> returns an array with two layers, one of <a class="name" href="#jjlayer::width">width</a> 23 and <a class="name" href="#jjlayer::height">height</a> 25 and the other of <span class="name">width</span> 20 and <span class="name">height</span> 11, containing different sets of pillars as defined in Layer 5 and Layer 6 of castle1.j2l. These new layer objects may then be inserted into the set of layers drawn to the screen by use of <a class="name" href="#jjLayerOrderSet">jjLayerOrderSet</a>.</dd>
			<dd>By default, the <a href="#tileids">tile IDs</a> of the tiles in these layers will be unchanged, meaning that unless the tileset used by the level <span class="param">filename</span> is the same as is used by this level, the results will likely look very peculiar. (Similarly, any animated tiles used in those layers should probably match those used in this level.) In fact, you may want to make a special unplayable level just for the sake of taking its miscellaneous background or foreground layers into this one (and if you do, remember to tick "Hide level in Home Cooked Levels list" in its level properties). Alternatively, the optional <span class="param">tileIDAdjustmentFactor</span> parameter is a value added to the tile IDs of any non-zero, non-animated tiles in the layer/s imported from <span class="param">filename</span>, so for instance, if <span class="param">tileIDAdjustmentFactor</span> equals 10, then a series of tiles 5,6,0,0,3 would become 15,16,0,0,13. (This option is intended for use in conjunction with <a class="name" href="#jjTilesFromTileset">jjTilesFromTileset</a>, though you may find other uses for it as well.)</dd>
			<dd>Like in other sections of JJ2+ code, levels saved in either the TSF or regular JCSes work equally well. It does not matter whether the level is passworded. If the file does not exist or does not have the file extension ".j2l" then the returned array will have zero length. If the file is not a valid level then the game may or may not crash. As with other dependent files, it is recommended to use <a href="#preprocessor">#pragma require</a> if the level being mined for layers is not a default level.</dd>
			<dt>bool <span class="name" id="jjMaskedHLine">jjMaskedHLine</span>(int <span class="param">xPixel</span>, int <span class="param">lineLength</span>, int <span class="param">yPixel</span>)</dt>
			<dd>Returns true if any pixel from <span class="param">xPixel,yPixel</span> to <span class="param">xPixel+lineLength,yPixel</span> is masked.</dd>
			<dt>bool <span class="name" id="jjMaskedPixel">jjMaskedPixel</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>)</dt>
			<dd>Returns true if pixel <span class="param">xPixel,yPixel</span> is masked.</dd>
			<dt>int <span class="name" id="jjMaskedTopVLine">jjMaskedTopVLine</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">lineLength</span>)</dt>
			<dd>If any pixel from <span class="param">xPixel,yPixel</span> to <span class="param">xPixel,yPixel+lineLength</span> is masked, returns the height of the topmost masked pixel relative to <span class="param">yPixel</span>. (For example, if <span class="param">xPixel,yPixel+2</span> is masked but +1 and +0 weren't, the function returns 2.) If none of the pixels are masked, returns <span class="param">lineLength</span>+1. Used for detecting inclines and the like.</dd>
			<dt>bool <span class="name" id="jjMaskedVLine">jjMaskedVLine</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">lineLength</span>)</dt>
			<dd>Returns true if any pixel from <span class="param">xPixel,yPixel</span> to <span class="param">xPixel,yPixel+lineLength</span> is masked.</dd>
			<dt>bool <span class="name" id="jjMaskedHLine">jjMaskedHLine</span>(int <span class="param">xPixel</span>, int <span class="param">lineLength</span>, int <span class="param">yPixel</span>, uint8 <span class="param">layer</span>)</dt>
			<dt>bool <span class="name" id="jjMaskedPixel">jjMaskedPixel</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, uint8 <span class="param">layer</span>)</dt>
			<dt>int <span class="name" id="jjMaskedTopVLine">jjMaskedTopVLine</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">lineLength</span>, uint8 <span class="param">layer</span>)</dt>
			<dt>bool <span class="name" id="jjMaskedVLine">jjMaskedVLine</span>(int <span class="param">xPixel</span>, int <span class="param">yPixel</span>, int <span class="param">lineLength</span>, uint8 <span class="param">layer</span>)</dt>
			<dd>Shortcut global functions for the same-named <a href="#jjlayer">jjLAYER</a> methods on the same-indexed <a class="name" href="#jjLayers">jjLayers</a> objects.</dd>
			<dt class="updated">bool <span class="name" id="jjMusicLoad">jjMusicLoad</span>(string <span class="param">filename</span>, bool <span class="param">forceReload</span> = false, bool <span class="param">temporary</span> = false)</dt>
			<dd>Loads and starts playing a new music file, of any type supported by JJ2+. Returns false if the file cannot be found in either the main game folder or the cache subfolder, or if the specified music file is already playing and <span class="param">forceReload</span> is false. The <span class="param">temporary</span> parameter is useful only in local single player games, where it is used to load a music file only until the player's death, at which point the non-temporary music file will resume playing: this is how the Activate Boss event works.</dd>
			<dt>void <span class="name" id="jjMusicPause">jjMusicPause</span>()</dt>
			<dd>Pauses the current music track. May not work with .mp3 files.</dd>
			<dt>void <span class="name" id="jjMusicPlay">jjMusicPlay</span>()</dt>
			<dd>(Re)starts the current music track.</dd>
			<dt>void <span class="name" id="jjMusicResume">jjMusicResume</span>()</dt>
			<dd>Resumes the current music track, once paused. May not work with .mp3 files.</dd>
			<dt>void <span class="name" id="jjMusicStop">jjMusicStop</span>()</dt>
			<dd>Stops the current music track.</dd>
			<dt>void <span class="name" id="jjNxt">jjNxt</span>(bool <span class="param">warp</span> = false, bool <span class="param">fast</span> = false)</dt>
			<dt>void <span class="name" id="jjNxt">jjNxt</span>(const string&amp; <span class="param">filename</span> = "", bool <span class="param">warp</span> = false, bool <span class="param">fast</span> = false)</dt>
			<dd>Ends the level and skips to the next one, or to <span class="param">filename</span> if specified and of length&gt;0. Only works in Single Player and Cooperative.</dd>
			<dt>int <span class="name" id="jjParameterGet">jjParameterGet</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>, int8 <span class="param">offset</span>, int8 <span class="param">length</span>)</dt>
			<dd>Gets one of the parameters at tile <span class="param">xTile,yTile</span>. Follow JCS.ini's lead in figuring out how to write the <span class="param">offset</span> and <span class="param">length</span> parameters.</dd>
			<dd><span class="param">length</span> is the simplest: use the exact same formatting JCS.ini does. To get the speed of a belt event, for instance, <span class="param">length</span> should be -8. To get the number of blue gems in a gem crate, <span class="param">length</span> should be 4. And so on.</dd>
			<dd><span class="param">offset</span> is calculated by adding the absolute values of every parameter on the tile prior to the one you want. The first (bottommost) parameter will always have <span class="param">offset</span> 0. To get the parameter "Blue" in Gem Crate, <span class="param">offset</span> should be 8 (4+4). To get the Y-Speed of a Rotating Rock, <span class="param">offset</span> should be 12 (8+abs(-4)). And so on.</dd>
			<dd>Set <span class="param">length</span> to 2 and <span class="param">offset</span> to -4 to get the difficulty of an event (normal, easy, hard, multiplayer-only).</dd>
			<dt>void <span class="name" id="jjParameterSet">jjParameterSet</span>(uint16 <span class="param">xTile</span>, uint16 <span class="param">yTile</span>, int8 <span class="param">offset</span>, int8 <span class="param">length</span>, int <span class="param">newValue</span>)</dt>
			<dd>Sets one of the parameters at tile <span class="param">xTile,yTile</span>. <span class="param">length</span> and <span class="param">offset</span> work exactly as they do for <a class="name" href="#jjParameterGet">jjParameterGet</a>; the only change is <span class="param">newValue</span>, which should be a valid number for the <span class="param">length</span> setting. Trying to assign a negative number to an unsigned <span class="param">length</span> parameter doesn't really make sense, for example, nor can you reasonably assign a <span class="param">newValue</span> of 100 to a <span class="param">length</span> of 3.</dd>
			<dd>Note that this is not quite as powerful as it may seem, since some objects read and process their parameters into memory when they are first created, rather than continually reading them again and again as the game continues. The function will however work fine for zones that affect the player, such as Warp or Sucker Tube or Wind, and it will also successfully set parameters for any such new objects created after the function is called.</dd>
			<dd>Caution: this is a permanent change and will subsist even after death in offline play.</dd>
			<dt>array&lt;jjPLAYER@&gt;@ <span class="name" id="jjPlayersWithClientID">jjPlayersWithClientID</span>(int <span class="param">clientID</span>)</dt>
			<dd>Convenience function; creates and returns an array containing handles of all active players with a given <a href="#jjplayer::clientID">clientID</a>. The result is an empty array if the client is not connected or if <span class="param">clientID</span> is not a valid ID. The result is a null handle if the function is called by a client.</dd>
			<dt>void <span class="name" id="jjPrint">jjPrint</span>(const string &amp;in <span class="param">text</span>, bool <span class="param">timestamp</span> = false)</dt>
			<dd>Writes <span class="param">text</span> to the chatlogger window but does not display it ingame. If <span class="param">timestamp</span> is true, adds a timestamp before the text.</dd>
			<dt>uint <span class="name" id="jjRandom">jjRandom</span>()</dt>
			<dd>Provides a random number.</dd>
			<dt>bool <span class="name" id="jjRegexIsValid">jjRegexIsValid</span>(const string &amp;in <span class="param">expression</span>)</dt>
			<dd>Returns true if <span class="param">expression</span> is a valid <a href="http://en.wikipedia.org/wiki/Regular_expression">regular expression</a> and false otherwise. This is the only regex function that doesn't cause debug errors when the input is an invalid expression and as such it should be always used before calling other regex functions when <span class="param">expression</span> comes from an untrusted source (such as from user input rather than from a constant string in the script). Expressions will be parsed according to modified ECMAScript regular expression grammar.</dd>
			<dt>bool <span class="name" id="jjRegexMatch">jjRegexMatch</span>(const string &amp;in <span class="param">text</span>, const string &amp;in <span class="param">expression</span>, bool <span class="param">ignoreCase</span> = false)</dt>
			<dt>bool <span class="name">jjRegexMatch</span>(const string &amp;in <span class="param">text</span>, const string &amp;in <span class="param">expression</span>, array&lt;string&gt; &amp;out <span class="param">results</span>, bool <span class="param">ignoreCase</span> = false)</dt>
			<dd>Returns true if <span class="param">expression</span> is a valid regular expression that matches <span class="param">text</span> entirely and false if no match is found. Where the second overload is used, <span class="param">results</span> will contain match results in a standard order. If <span class="param">ignoreCase</span> is true, the matching will be case insensitive. If <span class="param">expression</span> is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, <a class="name" href="#jjRegexIsValid">jjRegexIsValid</a> should always be used to validate untrusted input. Note that this function only returns true if <span class="param">expression</span> matches the entire string, whereas <a class="name" href="#jjRegexSearch">jjRegexSearch</a> accepts substring matches.</dd>
			<dt>string <span class="name" id="jjRegexReplace">jjRegexReplace</span>(const string &amp;in <span class="param">text</span>, const string &amp;in <span class="param">expression</span>, const string &amp;in <span class="param">replacement</span>, bool <span class="param">ignoreCase</span> = false)</dt>
			<dd>Returns a string that is the result of replacement of all substrings of <span class="param">text</span> that are matched by <span class="param">expression</span> with <span class="param">replacement</span>. If <span class="param">ignoreCase</span> is true, the matching will be case insensitive. Capture results ($1, $2, etc., $0 always being the entire matched substring) can be successfully used in the <span class="param">replacement</span> string. If <span class="param">expression</span> is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, <a class="name" href="#jjRegexIsValid">jjRegexIsValid</a> should always be used to validate untrusted input.</dd>
			<dt>bool <span class="name" id="jjRegexSearch">jjRegexSearch</span>(const string &amp;in <span class="param">text</span>, const string &amp;in <span class="param">expression</span>, bool <span class="param">ignoreCase</span> = false)</dt>
			<dt>bool <span class="name">jjRegexSearch</span>(const string &amp;in <span class="param">text</span>, const string &amp;in <span class="param">expression</span>, array&lt;string&gt; &amp;out <span class="param">results</span>, bool <span class="param">ignoreCase</span> = false)</dt>
			<dd>Returns true if <span class="param">expression</span> is a valid regular expression that matches any substring of <span class="param">text</span> and false if no match is found. Where the second overload is used, <span class="param">results</span> will contain match results in a standard order. If <span class="param">ignoreCase</span> is true, the matching will be case insensitive. If <span class="param">expression</span> is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, <a class="name" href="#jjRegexIsValid">jjRegexIsValid</a> should always be used to validate untrusted input. Note that this function returns true if <span class="param">expression</span> matches any character subsequence of <span class="param">text</span>, whereas <a class="name" href="#jjRegexMatch">jjRegexMatch</a> will only look for matches with the entire string.</dd>
			<dt>void <span class="name" id="jjResetWaterGradient">jjResetWaterGradient</span>()</dt>
			<dd>Restores 16-bit water to its natural colors.</dd>
			<dt>void <span class="name" id="jjSample">jjSample</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, <span class="ns">SOUND::Sample</span> <span class="param">sample</span>, int <span class="param">volume</span> = 63, int <span class="param">frequency</span> = 0)</dt>
			<dd>Plays a sound from anims.j2a at pixel <span class="param">xPixel, yPixel</span>. Possible values for <span class="param">sample</span> are listed <a href="#sample">in the appendix at the bottom of this file</a>.</dd>
			<dd><span class="param">volume</span> ranges from 1-63, and 0 will default to 63. Higher values of <span class="param">frequency</span> result in higher frequencies, or leaving it at 0 will use the sample's unique default frequency.</dd>
			<dt>bool <span class="name" id="jjSampleIsLoaded">jjSampleIsLoaded</span>(<span class="ns">SOUND::Sample</span> <span class="param">sample</span>)</dt>
			<dd>Returns whether <span class="param">sample</span> is loaded or not.</dd>
			<dt class="updated">bool <span class="name" id="jjSampleLoad">jjSampleLoad</span>(<span class="ns">SOUND::Sample</span> <span class="param">sample</span>, string &amp;in <span class="param">filename</span>)</dt>
			<dd>Attempts to load <span class="param">sample</span> from a .wav or .ogg file <span class="param">filename</span> and returns true on success or false otherwise. If there is already a loaded sample corresponding to this <span class="ns">SOUND::Sample</span> constant, it will be overwritten. JJ2 assumes samples are mono and will not correctly play stereo samples, so for the best results, only use mono files.</dd>
			<dt>int <span class="name" id="jjSampleLooped">jjSampleLooped</span>(float <span class="param">xPixel</span>, float <span class="param">yPixel</span>, <span class="ns">SOUND::Sample</span> <span class="param">sample</span>, int <span class="param">channel</span>, int <span class="param">volume</span> = 63, int <span class="param">frequency</span> = 0)</dt>
			<dd>Plays a looped sound from anims.j2a at pixel <span class="param">xPixel, yPixel</span>. For every source of sound (e.g. a jjOBJ instance), <span class="param">channel</span> should be 0 on the first call and in later calls should be replaced with the value returned from the previous call of this function.</dd>
			<dd><span class="param">volume</span> ranges from 1-63, and 0 will default to 63. Higher values of <span class="param">frequency</span> result in higher frequencies, or leaving it at 0 will use the sample's unique default frequency.</dd>
			<dt>void <span class="name" id="jjSamplePriority">jjSamplePriority</span>(<span class="ns">SOUND::Sample</span> <span class="param">sample</span>)</dt>
			<dd>Plays a sound from anims.j2a, no matter what any local players' positions are. This is the function used to play the sugar rush jingle. Possible values for <span class="param">sample</span> are listed <a href="#sample">in the appendix at the bottom of this file</a>.</dd>
			<dt>bool <span class="name" id="jjSendPacket">jjSendPacket</span>(jjSTREAM &amp;in <span class="param">packet</span>, int <span class="param">toClientID</span> = 0, uint <span class="param">toScriptModuleID</span> = jjScriptModuleID)</dt>
			<dd>Sends <span class="param">packet</span> from client to server (in case if you're a client) or from server to client (in case if you're a server). Returns true on success and false on failure. If <span class="param">toClientID</span> is a positive value, the packet will be sent only to the client with the appropriate <a class="name" href="#jjplayer::clientID">jjPLAYER::clientID</a>. If it's negative, it will be sent to all clients with the exception of the one indicated by <span class="param">toClientID</span>. Using the default value of 0 results in sending the packet to all clients. For a script to receive <span class="param">packet</span>, you will need to declare an <span class="name">onReceive</span> hook, which has the following signature:
			<pre>void onReceive(jjSTREAM &amp;in packet, int fromClientID)</pre>
			Notice that packets can't be sent between two clients but only between the server and a client; if the function is called client-side, the <span class="param">toClientID</span> argument is completely ignored. If a client is meant to send a packet to another client, they have to send the packet to the server first and the server should resend it to the other client from <span class="name">onReceive</span>.</dd>
			<dd>If there are multiple distinct script modules running (two or more mutators, or one mutator and a level's primary script), the packet will only be received by the module whose <a class="name" href="#jjScriptModuleID">jjScriptModuleID</a> global value matches the <span class="param">toScriptModuleID</span> parameter. By leaving this parameter as the default value, you can ensure that a packet sent from <code>foo.j2mut</code> will always be read by (the <span class="name">onReceive</span> hook defined in) <code>foo.j2mut</code>, rather than another, simultaneously running module that wouldn't know what to do with the data. Passing 0 instead will send the packet to the level's primary script (if any), and is rarely a good idea. Other values are even more rarely a good idea.</dd>
			<dt>void <span class="name" id="jjSetDarknessColor">jjSetDarknessColor</span>(jjPALCOLOR <span class="param">color</span> = jjPALCOLOR(0, 0, 0))</dt>
			<dd>Sets the color of darkness used with ambient lighting.</dd>
			<dt class="updated">void <span class="name" id="jjSetFadeColors">jjSetFadeColors</span>(uint8 <span class="param">red</span>, uint8 <span class="param">green</span>, uint8 <span class="param">blue</span>)</dt>
			<dt>void <span class="name">jjSetFadeColors</span>(jjPALCOLOR <span class="param">color</span>)</dt>
			<dt>void <span class="name">jjSetFadeColors</span>(uint8 <span class="param">paletteColorID</span> = 207)</dt>
			<dd>Sets the fade colors of the level's textured background, as seen in the Layer properties window for layer 8 in JCS. Has no effect if there is no textured background on layer 8.</dd>
			<dd>Exactly equivalent to <code><a class="name" href="#jjLayers">jjLayers</a>[8].<a class="name" href="#jjlayer::setFadeColor">setFadeColor</a>(<span class="param">color</span>)</code>.</dd>
			<dd>A simpler one (or zero!) parameter version of the function also exists to set the fade colors to the same RGB values as used by one of the entries in <a class="name" href="#jjPalette">jjPalette</a>. This defaults to 207, which is the last color of the most common textured background gradient and thus, not infrequently, the fade color used in 8-bit color.</dd>
			<dt>void <span class="name" id="jjSetLayerXSpeed">jjSetLayerXSpeed</span>(uint8 <span class="param">layerID</span>, float <span class="param">newspeed</span>, bool <span class="param">newSpeedIsAnAutoSpeed</span>)</dt>
			<dt>void <span class="name" id="jjSetLayerYSpeed">jjSetLayerYSpeed</span>(uint8 <span class="param">layerID</span>, float <span class="param">newspeed</span>, bool <span class="param">newSpeedIsAnAutoSpeed</span>)</dt>
			<dd>Shortcut global functions for <a class="name" href="#jjlayer::setXSpeed">setXSpeed</a> and <a class="name" href="#jjlayer::setYSpeed">setYSpeed</a> on the same-indexed <a class="name" href="#jjLayers">jjLayers</a> objects.</dd>
			<dt>void <span class="name" id="jjSetModPosition">jjSetModPosition</span>(int <span class="param">order</span>, int <span class="param">row</span>, bool <span class="param">reset</span>)</dt>
			<dd>Jumps to a specific <span class="param">row</span> of a specific <span class="param">order</span> in the currently playing module file. If <span class="param">reset</span> is true, also stops all notes and resets the module's global volume, tempo, etc. to their original values.</dd>
			<dd>Calling this function with an invalid order or row number, or while BASS is not playing a module file, will have no effect.</dd>
			<dt>void <span class="name" id="jjSetModSpeed">jjSetModSpeed</span>(uint8 <span class="param">speed</span>)</dt>
			<dd>Sets the "speed" of the currently playing module music file. Does nothing if BASS is not currently playing a module file. Note that the module may change its own speed, overwriting your change.</dd>
			<dt>void <span class="name" id="jjSetModTempo">jjSetModTempo</span>(uint8 <span class="param">tempo</span>)</dt>
			<dd>Sets the tempo of the currently playing module music file. Does nothing if BASS is not currently playing a module file. Note that the module may change its own tempo, overwriting your change.</dd>
			<dt>void <span class="name" id="jjSetWaterGradient">jjSetWaterGradient</span>(uint8 <span class="param">red1</span>, uint8 <span class="param">green1</span>, uint8 <span class="param">blue1</span>, uint8 <span class="param">red2</span>, uint8 <span class="param">green2</span>, uint8 <span class="param">blue2</span>)</dt>
			<dt>void <span class="name">jjSetWaterGradient</span>(jjPALCOLOR <span class="param">color1</span>, jjPALCOLOR <span class="param">color2</span>)</dt>
			<dt>void <span class="name">jjSetWaterGradient</span>()</dt>
			<dd>Changes the colors used by water in 16-bit color. If no parameters are included, the gradient will be generated from palette entries 176 and 207 instead, the most typical textured background colors (and <a href="http://www.jazz2online.com/jcsref/node.php?menu=&amp;node=Underwater%20Ambient%20Lighting">most</a> of the colors used by 8-bit water).</dd>
			<dt>void <span class="name" id="jjSetWaterLevel">jjSetWaterLevel</span>(float <span class="param">yPixel</span>, bool <span class="param">instant</span>)</dt>
			<dd>Sets <a class="name" href="#jjWaterTarget">jjWaterTarget</a> to <span class="param">yPixel</span>. If <span class="param">instant</span> is true, <a class="name" href="#jjWaterLevel">jjWaterLevel</a> will also be set to <span class="param">yPixel</span>; otherwise, it will move slowly up or down from its current height until it reaches its new target.</dd>
			<dd>Caution: this function is not identical to the Water Level event in JCS. The event measures in tiles, but this function measures in pixels. Multiply by thirty-two to get the same effect.</dd>
			<dt>float <span class="name" id="jjSin">jjSin</span>(uint <span class="param">angle</span>)</dt>
			<dd>Returns the sine of <span class="param">angle</span> with a range of 0.0-1.0 and a domain of 0-1023. Numbers outside the domain will be seemlessly moduloed. This is the sine function used by JJ2 for spinning platforms and the like, though you may prefer <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_addon_math.html">AngelScript's native sin function.</a></dd>
			<dt>void <span class="name" id="jjSlideModChannelVolume">jjSlideModChannelVolume</span>(int <span class="param">channel</span>, float <span class="param">volume</span>, int <span class="param">milliseconds</span>)</dt>
			<dd>In currently playing module music, slide the volume of <span class="param">channel</span> to <span class="param">volume</span> over a chosen number of <span class="param">milliseconds</span>. Does nothing if BASS is not currently playing a module file or <span class="param">channel</span> does not exist. <span class="param">volume</span> is 1.0 for the module's channel volume, 0.0 for silent. If you give a higher or lower value, the slide will stop when it reaches one of these boundaries. Volume slides continue while the music is paused. If you begin sliding the volume of a channel that is already sliding, the old slide will immediately stop.</dd>
			
			<dt class="new">int <span class="name" id="jjSpriteModeFirstFreeMapping">jjSpriteModeFirstFreeMapping</span>()</dt>
			<dd>Returns the minimum index from the range 0�255 such that <a class="name" href="#jjSpriteModeIsMappingUsed">jjSpriteModeIsMappingUsed</a>(index) is false, or -1 if none exist.</dd>
			
			<dt class="new">jjPAL@ <span class="name" id="jjSpriteModeGetColorMapping">jjSpriteModeGetColorMapping</span>(uint8 <span class="param">index</span>)</dt>
			<dd>Returns a copy of the mapping provided as the <span class="param">rgbMapping</span> argument during the most recent call to <a class="name" href="#jjSpriteModeSetMapping">jjSpriteModeSetMapping</a> with the same value of <span class="param">index</span>. If the most recent call didn't provide the <span class="param">rgbMapping</span> argument, instead the <span class="param">indexMapping</span> argument is used in conjunction with <a href="#jjPalette">jjPalette</a> to determine the result. The returned handle is never null�even if the mapping corresponding to <span class="param">index</span> is unused, the returned handle is still a valid palette but all its colors are black.</dd>
			
			<dt class="new">array&lt;uint8&gt;@ <span class="name" id="jjSpriteModeGetIndexMapping">jjSpriteModeGetIndexMapping</span>(uint8 <span class="param">index</span>)</dt>
			<dd>Returns a copy of the mapping provided as the <span class="param">indexMapping</span> argument during the most recent call to <a class="name" href="#jjSpriteModeSetMapping">jjSpriteModeSetMapping</a> with the same value of <span class="param">index</span>. The returned handle is never null and the array it holds is always of size 256. If the mapping corresponding to <span class="param">index</span> is unused, all elements of the array will be 0.</dd>
			
			<dt class="new">bool <span class="name" id="jjSpriteModeIsMappingUsed">jjSpriteModeIsMappingUsed</span>(uint8 <span class="param">index</span>)</dt>
			<dd>Returns whether a mapping with the given <span class="param">index</span> (as used by <span class="ns">SPRITE::MAPPING</span> and <span class="ns">SPRITE::TRANSLUCENTMAPPING</span>) has been previously successfully registered with use of <a class="name" href="#jjSpriteModeSetMapping">jjSpriteModeSetMapping</a>.</dd>
			
			<dt class="new">void <span class="name" id="jjSpriteModeSetMapping">jjSpriteModeSetMapping</span>(uint8 <span class="param">index</span>, const array&lt;uint8&gt; &amp;in <span class="param">indexMapping</span>, const jjPAL &amp;in <span class="param">rgbMapping</span>)</dt>
			<dt>void <span class="name">jjSpriteModeSetMapping</span>(uint8 <span class="param">index</span>, const array&lt;uint8&gt; &amp;in <span class="param">indexMapping</span>)</dt>
			<dd>Sets a mapping with the given <span class="param">index</span> (as used by <span class="ns">SPRITE::MAPPING</span> and <span class="ns">SPRITE::TRANSLUCENTMAPPING</span>) to the provided values. <span class="param">indexMapping</span> will be used in 8-bit color mode. If it is shorter than 256 elements, it will be padded with values corresponding to their indices (i.e., if an empty array is provided, the corresponding <span class="ns">SPRITE::MAPPING</span> will act exactly like <span class="ns">SPRITE::NORMAL</span> in 8-bit color mode). <span class="param">rgbMapping</span>, if provided, will be used in 16-bit color mode, ignoring the level's palette�otherwise <span class="param">indexMapping</span> will be used, to the same effect as in 8-bit color mode.</dd>
			
			<dt>void <span class="name" id="jjSpy">jjSpy</span>(const string &amp;in <span class="param">text</span>)</dt>
			<dd>Prints <span class="param">text</span> to the game's built-in spy window activated by running it with the -spy command line parameter, and also writes it to your jazz2.log file.</dd>
			<dt>bool <span class="name" id="jjSwitchTrigger">jjSwitchTrigger</span>(uint8 <span class="param">id</span>)</dt>
			<dd>Toggles <a class="name" href="#jjTriggers">jjTriggers</a>[<span class="param">id</span>] from true to false, or vice versa, like the "switch" parameter on the Trigger Zone and Trigger Crate events.</dd>
			<dt>bool <span class="name" id="jjTakeScreenshot">jjTakeScreenshot</span>(const string &amp;in <span class="param">filename = ""</span>)</dt>
			<dd>Takes a screenshot of the game as if F12 was pressed. Returns true if the screenshot request was successfully handled without being dismissed by timing or other restrictions, otherwise returns false.</dd>
			<dd>The optional parameter <span class="param">filename</span> can be used to define a custom filename for the screenshot file to be saved. When a custom filename is passed as a parameter, the <code>.png</code> suffix can be omitted, since the suffix will be always ensured. Omitting the custom filename parameter or defining it as an empty string will make the game use the default pattern for screenshot filenames, like <code>Jazz2-[level_filename]-001.png</code>, etc.</dd>
			<dd>Note that this feature has restrictions on how often it can be used effectively. Calling it more often than once a second won't do anything and will cause the function to return false, as an indicator that the call to take a screenshot was dismissed. There is also a one second delay for using this function successfully after the user presses F12. This is due to the possibility of this feature being able to fill up available diskspace on the calling machine rapidly (and making the game too sluggish to play anyway).</dd>
			<dd>Note that this feature may only be used to save screenshots into the folder running JJ2 itself. Also, to avoid conflict with system reserved filenames, etc. all custom filenames receive an enforced prefix in their filename as <code>Jazz2_as-</code>, which also helps to differentiate custom screenshot filenames from the default ones (<code>Jazz2-</code>).</dd>
			<dd>Note that only legal characters for <a href="https://en.wikipedia.org/wiki/Filename">filenames</a> may be used in the custom screenshot filenames to ensure their integrity. Using any illegal characters in the filename will result in the screenshot saving to fail and making this function return false.</dd>
			<dt>uint16 <span class="name" id="jjTileGet">jjTileGet</span>(uint8 <span class="param">layer</span>, int <span class="param">xTile</span>, int <span class="param">yTile</span>)</dt>
			<dt>uint16 <span class="name" id="jjTileSet">jjTileSet</span>(uint8 <span class="param">layer</span>, int <span class="param">xTile</span>, int <span class="param">yTile</span>, uint16 <span class="param">newTile</span>)</dt>
			<dd>Shortcut global functions for the same-named <a href="#jjlayer">jjLAYER</a> methods on the same-indexed <a class="name" href="#jjLayers">jjLayers</a> objects.</dd>
			<dt>bool <span class="name" id="jjTilesFromTileset">jjTilesFromTileset</span>(const string &amp;in <span class="param">filename</span>, uint <span class="param">firstTileID</span>, uint <span class="param">tileCount</span>, const array&lt;uint8&gt;@ <span class="param">paletteColorMapping</span> = null)</dt>
			<dd>Opens the tileset <span class="param">filename</span>, extracts <span class="param">tileCount</span> tiles from it starting at tile ID <span class="param">firstTileID</span>, and appends them to the end of the currently loaded tileset, increasing <a class="name" href="#jjTileCount">jjTileCount</a> by <span class="param">tileCount</span>. If <span class="param">paletteColorMapping</span> is not null and is of length 256 or greater, it will be used to recolor the imported tiles in a way that better fits the palette you are currently using, e.g. pixels of color 10 will be changed to <code>paletteColorMapping[10]</code> instead. Returns false upon various reasons for failure.</dd>
			<dd><span class="name">jjTilesFromTileset</span> is primarily intended to be combined with <a class="name" href="#jjLayersFromLevel">jjLayersFromLevel</a> and <a class="name" href="#jjLayerOrderSet">jjLayerOrderSet</a>, and the three should ideally be called in that order, so that <span class="name">jjLayersFromLevel</span> has the right tiles to use in its new layers. Here is a sample script that imports the background pillars from Dungeon Dilemma (into any level using any tileset) and recolors them to use colors from the textured background:
			<pre>void onLevelLoad() {
	const int oldTileCount = jjTileCount; <span class="comment">//the number of tiles in the level's tileset before jjTilesFromTileset increases the number</span>
	array&lt;uint8&gt; pillarColorMapping(256);
	for (int i = 0; i &lt; 16; ++i)
		pillarColorMapping[i + 128] = i + 192; <span class="comment">//map pillars' colors (stored in palette indices 128 through 143) to the (second row of) textured background colors</span>
	jjTilesFromTileset( <span class="comment">//appends tiles to the end of the internal copy of the tileset used by the current level</span>
		"Castle1.j2t", <span class="comment">//filename to take tiles from</span>
		420, <span class="comment">//first tile ID in tileset to take</span>
		60, <span class="comment">//number of tiles to take</span>
		pillarColorMapping <span class="comment">//an array&lt;uint8&gt;(256) that maps colors in the source tileset to colors in the destination tileset, here only working on a single 16-color gradient because that's all that is used in those particular two layers</span>
	);
	array&lt;jjLAYER@&gt; castleLayers = jjLayersFromLevel( <span class="comment">//builds new jjLAYER instances from the layers defined in this level</span>
		"Castle1.j2l", <span class="comment">//filename to take layers from</span>
		array&lt;uint&gt; = {5,6}, <span class="comment">//which layers to grab</span>
		oldTileCount - 420 <span class="comment">//a number to offset the non-zero tileIDs by: the pillars started at tile 420 in castle1.j2t, but here start at the end of the old tileset, aka oldTileCount</span>
	);
	jjLayerOrderSet(array&lt;jjLAYER@&gt; = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], castleLayers[0], castleLayers[1], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); <span class="comment">//insert the two layers from castle1.j2l between Layer 4 and Layer 5</span>
}</pre></dd>

			<!--Returns an array containing a number of handles of new <a href="#jjlayer">jjLAYER</a> instances built from the layers defined in the level <span class="param">filename</span>, specifically those requested in the 1-indexed <span class="param">layerIDs</span>. (Passing numbers not in the range of 1&ndash;8 in <span class="param">layerIDs</span> is undefined behavior.) For example, <code>jjLayersFromLevel("castle1.j2l", array&lt;uint&gt; = {5,6});</code> returns an array with two layers, one of <a class="name" href="#jjlayer::width">width</a> 23 and <a class="name" href="#jjlayer::height">height</a> 25 and the other of <span class="name">width</span> 20 and <span class="name">height</span> 11, containing different sets of pillars as defined in Layer 5 and Layer 6 of castle1.j2l. These new layer objects may then be inserted into the set of layers drawn to the screen by use of <a class="name" href="#jjLayerOrderSet">jjLayerOrderSet</a>.-->
			<dt>void <span class="name" id="jjTriggerRock">jjTriggerRock</span>(uint8 <span class="param">id</span>)</dt>
			<dd>Activates all Rotating Rock events with the "RockID" parameter set to <span class="param">id</span>, exactly like the Trigger Rock event.</dd>
			<dt>uint64 <span class="name" id="jjUnixTimeMs">jjUnixTimeMs</span>()</dt>
			<dd>Returns unix time in milliseconds, i.e. the number of milliseconds that have elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.</dd>
			<dt>uint64 <span class="name" id="jjUnixTimeSec">jjUnixTimeSec</span>()</dt>
			<dd>Returns unix time in seconds, i.e. the number of seconds that have elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.</dd>
			<dt class="deprecated">void <span class="name" id="jjUpdateTexturedBG">jjUpdateTexturedBG</span>()</dt>
			<dd>Forces JJ2+ to reconstruct the textured background from its relevant properties. This should be handled automatically now.</dd>
			<dt>bool <span class="name" id="jjZlibCompress">jjZlibCompress</span>(const jjSTREAM &amp;in <span class="param">input</span>, jjSTREAM &amp;out <span class="param">output</span>)</dt>
			<dd>Compresses data in <span class="param">input</span> using the zlib library. The compression result is placed into <span class="param">output</span>. Returns whether successful, which should almost always be true.</dd>
			<dt>bool <span class="name" id="jjZlibUncompress">jjZlibUncompress</span>(const jjSTREAM &amp;in <span class="param">input</span>, jjSTREAM &amp;out <span class="param">output</span>, uint <span class="param">size</span>)</dt>
			<dd>Attempts to uncompresses data in <span class="param">input</span> using the zlib library. The decompression result is placed into <span class="param">output</span>. For successful decompression, <span class="param">size</span> must be at least the same value as the amount of bytes of the predicted <span class="param">output</span>. Returns whether successful. The function can fail if <span class="param">input</span> is not a valid compressed stream or <span class="param">size</span> is too small to accomodate the <span class="param">output</span> or too large to allocate memory required for performing the operation, as well as, rarely, for other reasons.</dd>
		</dl>

		<h2 id="tileids"><span>Appendix: Tile IDS</span></h2>
		<p>Tile IDs are stored in uint16 variables, and while it's perfectly all right for you to figure them out on your own, JJ2+ does provide you with a few helpful constants.</p>
		<p>There are a maximum of 4095 unique tiles in any given level, and you can get any ordinary tile's ID in JCS. The "1*" destruct block in the Tubelectric tileset, for example, is at position 5,31 within the tileset. Since those numbers are 1-indexed, you need to subtract 1 from each of them. Then multiply the Y position by 10, add it to the X position, and you've got the tile ID: 304. One row below it, the "2*" block is tile ID 314, and so on. If you've gotten a tile ID from <a class="name" href="#jjTileGet">jjTileGet</a> and want to know which basic tile it is, you can bitwise AND the number with the constant TILE::RAWRANGE (=0xFFF): if <code>uint16 foo</code> is a vertically-flipped version of tile 715, then <code>foo &amp; TILE::RAWRANGE</code> will equal 715 exactly.</p>
		<p>Horizontally and vertically flipped tiles are marked by the 0x1000 and 0x2000 bits respectively, or more helpfully, TILE::HFLIPPED and TILE::VFLIPPED. Thus to get the tile ID for the horizontally flipped version of tile 443, type <code>443 + TILE::HFLIPPED</code>. (Or <code>|</code> instead of <code>+</code>, to be safe.) Note that JJ2 may crash if asked to horizontally flip a tile that was not placed horizontally flipped somewhere in the level in JCS; the same issue does not apply to vertically flipped tiles.</p>
		<p>Similarly, to place or otherwise use animated tiles, add the TILE::ANIMATED constant (=0x8000). <code>0 + TILE::ANIMATED</code> will be the topmost animated tile in the list, <code>1 + TILE::ANIMATED</code> will be the second from the top, and so on. You can add TILE::HFLIPPED and/or TILE::VFLIPPED at the same time as TILE::ANIMATED�<code>1 + TILE::VFLIPPED + TILE::ANIMATED</code> is the second animated tile from the top, flipped vertically�and ANDing by TILE::RAWRANGE will get rid of the TILE::ANIMATED flag just like it does the other two.</p>
		<p>(These constants all belong to the TILE::Flags enum, in case you need to know that for any arcane reason.)</p>

		<h2 id="preprocessor"><span>Appendix: Preprocessor Directives</span></h2>
		<p>A preprocessor directive is a line included in an Angelscript file that does not obey standard AS syntax rules and is in fact not processed in the course of ordinary code running but is instead <em>preprocessed</em>�evaluated before anything else in the script runs, even <span class="name">onLevelLoad</span>. They each begin with a pound sign (#) and should take up an entire line of the file; AngelScript's handling of preprocessor directives is pretty flexible, but it's best to put them all at the top of the file, outside of any code blocks, each given its own line. Though all the below examples use double quotes (") to surround directive arguments, single quotes (') may be used instead if so desired, so long as the same symbol is used on both sides.</p>
		<dl>
			<dt><span class="name" id="include">#include</span> "&lt;filename&gt;"</dt>
			<dd>Similar to include directives/functions in other programming languages, #include loads another AngelScript file and adds all the code inside of it to the same module that the #include directive was written in. JJ2+ will treat everything in the included script exactly as if it were written directly in the including script, meaning that e.g. functions from one script may call functions from the other, but the same function name/return type may not be defined in both. A simple example use case might be a convenient single function to add a particle of a specific type at a specific location with specific initial speeds. Such a function would be useful enough that you might want to use it in multiple scripts, and this could be accomplished by placing it in its own file (<code>addparticle.asc</code>) and having those other scripts #include the file.</dd>
			<dd>It's worth emphasizing that #include adds all the code of the included file to the global scope, no matter where the directive appeared in the including file. Writing an #include directive inside of a namespace, for example, will not cause everything in the included file to be defined within that namespace.</dd>
			<dd>An included file may have any number of preprocessor directives of its own, including more #include directives. Any given file will only be #included at most once per script module, however, and JJ2+ will simply ignore attempts to the contrary; for example, if <code>foo.j2as</code> #includes both <code>bar.asc</code> and <code>baz.asc</code> but <code>baz.asc</code> also #includes <code>bar.asc</code>, then <code>bar.asc</code> will only be included the once. No error message is produced in this scenario.</dd>
			<dt><span class="name" id="pragma_require">#pragma require</span> "&lt;filename&gt;"</dt>
			<dd>Unlike #include, the require directive is not interpreted by the AngelScript section of JJ2+ at all but instead is used in netcode. (As such, it is unnecessary in levels made exclusively for local play.) When an online server cycles to a new level or gets a new joiner, clients are forced to download the .j2l, .j2t, and (if any) .j2as file the server is hosting, unless they already have an identical version of that same file conveniently located on their harddrive. The same treatment is also applied to any files that are #pragma required, unless the server's host doesn't have the file to begin with.</dd>
			<dd>You should #pragma require any external file that your script uses unless you have a good reason not to. This includes tilesets or palettes used by <a class="name" href="#jjpal::load">jjPAL::load</a>, custom sounds or animation files used by <a class="name" href="#jjSampleLoad">jjSampleLoad</a> or <a class="name" href="#jjanimset::load">jjANIMSET::load</a>, and of course script files that you #include.</dd>
			<dt><span class="name" id="pragma_offer">#pragma offer</span> "&lt;filename&gt;"</dt>
			<dd>Offering files is the less forceful version of requiring them: the server will still attempt to send all clients any files that have been #pragma offered, but the clients may decline to accept those files by pressing Esc at the downloading screen. This is the same treatment that is given to music files (unless the server has turned <code>/uploadmusic</code> off), and music files (as loaded by <a class="name" href="#jjMusicLoad">jjMusicLoad</a>) are basically the archetypal kind of file that should be offered (at best), not required, due to their comparatively large filesizes.</dd>
			<dd>(The overall order of files the client may attempt to download is, in case you're curious: the .j2l itself; the .j2t; any .j2as or <a href="#mutators">.mut</a> files; any #pragma required files; any #pragma offered files; the level's music.)</dd>
			<dd>If the same file appears in both a #pragma require and a #pragma offer, across any number of different script files, it will be required instead of offered.</dd>
			<dt><span class="name" id="pragma_name">#pragma name</span> "&lt;mutator name&gt;"</dt>
			<dd>The #pragma name directive is only currently used by <a href="#mutators">mutators</a>, and must be included in the first ten lines of the file in order to be noticed. It serves no other purpose than to provide a human-readable name for JJ2+ to display in place of the mutator's filename in certain contexts, e.g. while listing active mutators.</dd>
			<dt><span class="name" id="pragma_description">#pragma description</span> "&lt;description&gt;"</dt>
			<dd>This directive is not currently read by anything at all, but JJ2+ will not complain if you use it. Recommended for future use as a way to provide human-readable descriptions for mutators or levels, for display in hypothetical menu systems. Assume any context displaying these descriptions will use automatic wrapping instead of manual line breaks. Include somewhere in the first ten lines of the file.</dd>
		</dl>

		<h2 id="mutators"><span>Appendix: Mutators</span></h2>
		<p>Mutators are special AngelScript files that differ from the ones described in the <a href="#intro">introduction</a> in three key ways:</p>
		<ol>
			<li>Instead of being connected to individual .j2l files, any mutator can be run in <em>any level at all</em>. (This is not always a good idea�for example, a mutator script designed solely for Treasure Hunt games wouldn't be much help run in a Race level�but it is allowed.) Mutators are enabled or disabled using the <code>/mutators</code> command in chat messages, and clients joining a server with one or more mutators running will download those scripts and run them just like they would an ordinary script file.</li>
			<li>To signify this and to make for easier organization, mutators use the file extension <strong>.mut</strong> instead of <strong>.j2as</strong>.</li>
			<li>Mutators may not define the <span class="name">onFunction#</span> or <span class="name">onPlayerTimerEnd</span> hook functions, because they are too closely tied to specific level designs. Mutators may define functions that happen to use those names, but they will not be called by JJ2 under normal circumstances. (Mutators can however use the jjPLAYER method <a class="name" href="#jjplayer::timerFunction">timerFunction</a> to make a player use a timer end function defined inside a mutator script, as well as access the global array <a class="name" href="#jjEnabledASFunctions">jjEnabledASFunctions</a> or the global function <a class="name" href="#jjEnableEachASFunction">jjEnableEachASFunction</a>.)</li>
		</ol>
		<p>Otherwise, mutators have all the same options available to them that a level's primary script does, are run concurrently by both clients and servers, and may be written for any number of purposes. You could write a mutator that acts like an IRC bot and reacts to certain chat phrases, or a mutator to replace JJ2's normal health system with a new one of your devising, or a mutator to draw a minimap of players to some corner of the screen, or plenty of other things. Since any number of different mutators may be loaded at once, you should try to make each one do as few distinct tasks as possible.</p>
		<p>To be specific about how exactly mutators work: each one is loaded by JJ2+'s AngelScript engine as a <a href="http://www.angelcode.com/angelscript/sdk/docs/manual/doc_module.html">script module</a>, meaning each has access to the same set of JJ2+-defined global variables, functions, classes, etc., but cannot access the other modules' locally defined variables or functions. Two mutators may each define a function <code>void foo()</code>, but since they live in separate modules, there will be no naming conflict. (The primary .j2as script of a level is also loaded as a distinct script module.)</p>
		<p>Because mutators do not need to worry about naming conflicts with other mutators (or the primary script), individual hooks may be multiply defined across different modules. Three different mutators may all define a <code>void onMain()</code> function, for example, and JJ2+ will run all three of them every tick. Specifically, for any multiply defined hook, the version (if any) in the primary script will be run first, followed by the versions (if any) in each active mutator, in alphabetical order. It becomes the job of the server host (or remote admins) to pick a list of mutators that do not run code at cross purposes with one another.</p>
		<p>For example, suppose that <code>foo.j2l</code> has a primary script <code>foo.j2as</code> with the function <code>void onPlayer(jjPLAYER@ p) { p.coins = 5; }</code>. The server is running <code>bar.mut</code>, containing <code>void onPlayer(jjPLAYER@ p) { ++p.coins; }</code>, and <code>baz.mut</code>, containing <code>void onPlayer(jjPLAYER@ p) { jjDrawString(p.xPos, p.yPos - 40, "" + p.coins); }</code>. The net result of the three script modules will be that the number 6 (5+1) will always be drawn above each local player's head.</p>
		<p>Certain hooks�e.g. <span class="name">onLocalChat</span> and <span class="name">onDrawHealth</span>�have bool return values, where "true" means roughly "this script has performed all necessary actions relevant to this event," e.g. if <span class="name">onDrawHealth</span> returns true then JJ2 will not run its normal health-drawing code but instead assumes the script is somehow doing the job of presenting that information to the player. If two different mutators each define <span class="name">onDrawHealth</span>, and the first mutator's version returns true, the second mutator's version will still be run, but JJ2 will not draw the normal hearts no matter what value the second mutator's version returns. The return values are ORed together and it only matters that at least <em>one</em> of them (no matter which one) returns true.</p>
		<p>Besides <span class="name">onFunction#</span> and <span class="name">onPlayerTimerEnd</span>, the only exception to the above rule is <span class="name">onReceive</span>, which is only run at most once per jjSTREAM packet received. The global function <a class="name" href="#jjSendPacket">jjSendPacket</a> has an argument <span class="param">toScriptModuleID</span> specifying which script module should receive the packet, defaulting to <a class="name" href="#jjScriptModuleID">jjScriptModuleID</a>, which is the index of the script module calling the function. The values of <span class="name">jjScriptModuleID</span> match up with the order of modules that a multiply defined hook will be called in, so for example, in a server running <code>foo.j2as</code> and <code>baz.mut</code> and <code>bar.mut</code>, <span class="name">jjScriptModuleID</span> will equal 0 within foo (primary script is always 0), 1 within bar, and 2 within baz (alphabetically later than bar). Therefore if <span class="name">jjScriptModuleID</span> is passed as the value for <span class="param">toScriptModuleID</span>, the packet will be received by the <span class="name">onReceive</span> hook defined in the same module as <span class="name">jjSendPacket</span> was called in�but if <span class="param">toScriptModuleID</span> equals 0, the packet will be received by <span class="name">onReceive</span> defined in the primary script instead. This is rarely a good idea but could be used by mutators designed to extend specific scripts.</p>
		<p>Mutators can use all the same <a href="#preprocessor">preprocessor directives</a> that a primary script can, including or requiring or offering any supplementary files relevant to their execution. In fact, they are (currently) the only kind of script that can use <code>#pragma name</code>.</p>
		<p>Even if you are not writing a mutator, it is important to be aware that they exist and might be run in parallel with your level's primary script (assuming you are creating a multiplayer level). For example, it might be tempting to repurpose <a class="name" href="#jjplayer::coins">jjPLAYER::coins</a> to keep track of some other player-related property in a level with no coins in it, but it's better to declare your own non-member variable for that, in order to avoid potential conflicts with a mutator using <span class="name">jjPLAYER::coins</span> for something else. Certainly there will always be scripts that simply cannot functionally coexist with each other (a primary script where everyone has airboards; a mutator that disables all flight), but you might as well do your best to restrict such cases to times when the basic purposes of the scripts are in conflict, instead of just when one of them isn't coded carefully enough.</p>
		<h2 id="appendix"><span>Appendix: Constants</span></h2>
		<h3 id="weapon"><span>WEAPON::Weapon</span></h3>
		<p>Weapons are named pretty intuitively, using the common names for each one instead of necessarily the JCS names or official manual names. The exceptions are Pepper Spray and Electro-Blaster, which are simply GUN8 and GUN9 (a la JCS) to allow for situations in which those constants refer to the Fireball and Blade Guns instead.</p>
		<ul>
			<li>BLASTER</li>
			<li>BOUNCER</li>
			<li>ICE</li>
			<li>SEEKER</li>
			<li>RF</li>
			<li>TOASTER</li>
			<li>TNT</li>
			<li>GUN8</li>
			<li>GUN9</li>
			<li>CURRENT</li>
		</ul>
		<h3 id="state"><span>STATE::State</span></h3>
		<p>These are the different modes, or states, that a jjOBJ object can be in at any given time. The important ones are START, which is the initial state of an object that's just been created; KILL, for when an object gets destroyed; DEACTIVATE, for when an object passes out of memory in single player mode; EXPLODE, for dying bullets; ACTION, for collisions between players/bullets and some more complicated objects; and FREEZE, for when an object gets shot with ice. The rest are largely arbitrary.</p>
		<ul>
			<li>START</li>
			<li>SLEEP</li>
			<li>WAKE</li>
			<li>KILL</li>
			<li>DEACTIVATE</li>
			<li>WALK</li>
			<li>JUMP</li>
			<li>FIRE</li>
			<li>FLY</li>
			<li>BOUNCE</li>
			<li>EXPLODE</li>
			<li>ROCKETFLY</li>
			<li>STILL</li>
			<li>FLOAT</li>
			<li>HIT</li>
			<li>SPRING</li>
			<li>ACTION</li>
			<li>DONE</li>
			<li>PUSH</li>
			<li>FALL</li>
			<li>FLOATFALL</li>
			<li>CIRCLE</li>
			<li>ATTACK</li>
			<li>FREEZE</li>
			<li>FADEIN</li>
			<li>FADEOUT</li>
			<li>HIDE</li>
			<li>TURN</li>
			<li>IDLE</li>
			<li>EXTRA</li>
			<li>STOP</li>
			<li>WAIT</li>
			<li>LAND</li>
			<li>DELAYEDSTART</li>
			<li>ROTATE</li>
			<li>DUCK</li>
		</ul>
		<h3 id="area"><span>AREA::Area</span></h3>
		<p>Indented constants are alternate aliases for the non-indented constants directly above them. They evaluate to exactly the same results�the only difference between, say, AREA::JAZZLEVELSTART and AREA::JAZZSTART is which you'd rather type.</p>
		<ul>
			<li>ONEWAY</li>
			<li>HURT</li>
			<li>VINE</li>
			<li>HOOK</li>
			<li>SLIDE</li>
			<li>HPOLE</li>
			<li>VPOLE</li>
			<li>FLYOFF</li>
			<li>RICOCHET</li>
			<li>BELTRIGHT</li>
			<li>BELTLEFT</li>
			<li>ACCBELTRIGHT</li>
			<li>ACCBELTLEFT</li>
			<li>STOPENEMY</li>
			<li>WINDLEFT</li>
			<li>WINDRIGHT</li>
			<li>EOL</li>
			<li>WARPEOL</li>
			<li>REVERTMORPH</li>
			<li>FLOATUP</li>
			<li>TRIGGERROCK</li>
			<li>DIMLIGHT</li>
			<li>SETLIGHT</li>
			<li>LIMITXSCROLL</li>
			<li>RESETLIGHT</li>
			<li>WARPSECRET</li>
			<li>ECHO</li>
			<li>ACTIVATEBOSS</li>
			<li>JAZZLEVELSTART</li>
			<li class="alt">JAZZSTART</li>
			<li>SPAZLEVELSTART</li>
			<li class="alt">SPAZSTART</li>
			<li>MPLEVELSTART</li>
			<li class="alt">MPSTART</li>
			<li>LORILEVELSTART</li>
			<li class="alt">LORISTART</li>
			<li>WARP</li>
			<li>WARPTARGET</li>
			<li>PATH</li>
			<li class="alt">AREAID</li>
			<li>NOFIREZONE</li>
			<li>TRIGGERZONE</li>
			<li>SUCKERTUBE</li>
			<li>TEXT</li>
			<li>WATERLEVEL</li>
			<li>MORPHFROG</li>
			<li>WATERBLOCK</li>
		</ul>
		<h3 id="object"><span>OBJECT::Object</span></h3>
		<p>Indented constants are alternate aliases for the non-indented constants directly above them. They evaluate to exactly the same results�the only difference between, say, OBJECT::SAVEPOST and OBJECT::CHECKPOINT is which you'd rather type.</p>
		<ul>
			<li>BLASTERBULLET</li>
			<li>BOUNCERBULLET</li>
			<li>ICEBULLET</li>
			<li>SEEKERBULLET</li>
			<li>RFBULLET</li>
			<li>TOASTERBULLET</li>
			<li>FIREBALLBULLET</li>
			<li>ELECTROBULLET</li>
			<li>BLASTERBULLETPU</li>
			<li>BOUNCERBULLETPU</li>
			<li>ICEBULLETPU</li>
			<li>SEEKERBULLETPU</li>
			<li>RFBULLETPU</li>
			<li>TOASTERBULLETPU</li>
			<li>FIREBALLBULLETPU</li>
			<li>ELECTROBULLETPU</li>
			<li>FIRESHIELDBULLET</li>
			<li>WATERSHIELDBULLET</li>
			<li class="alt">BUBBLESHIELDBULLET</li>
			<li>LIGHTNINGSHIELDBULLET</li>
			<li class="alt">PLASMASHIELDBULLET</li>
			<li>BULLET</li>
			<li>SMOKERING</li>
			<li>SHARD</li>
			<li>EXPLOSION</li>
			<li>BOUNCEONCE</li>
			<li>FLICKERGEM</li>
			<li>LASER</li>
			<li>UTERUSSPIKEBALL</li>
			<li>BIRD</li>
			<li>BUBBLE</li>
			<li>ICEAMMO3</li>
			<li>BOUNCERAMMO3</li>
			<li>SEEKERAMMO3</li>
			<li>RFAMMO3</li>
			<li>TOASTERAMMO3</li>
			<li>TNTAMMO3</li>
			<li>GUN8AMMO3</li>
			<li>GUN9AMMO3</li>
			<li>TURTLESHELL</li>
			<li>SWINGINGVINE</li>
			<li>BOMB</li>
			<li>SILVERCOIN</li>
			<li>GOLDCOIN</li>
			<li>GUNCRATE</li>
			<li>CARROTCRATE</li>
			<li>ONEUPCRATE</li>
			<li>GEMBARREL</li>
			<li>CARROTBARREL</li>
			<li>ONEUPBARREL</li>
			<li>BOMBCRATE</li>
			<li>ICEAMMO15</li>
			<li>BOUNCERAMMO15</li>
			<li>SEEKERAMMO15</li>
			<li>RFAMMO15</li>
			<li>TOASTERAMMO15</li>
			<li>TNT</li>
			<li>AIRBOARDGENERATOR</li>
			<li>FROZENSPRING</li>
			<li>FASTFIRE</li>
			<li>SPRINGCRATE</li>
			<li>REDGEM</li>
			<li>GREENGEM</li>
			<li>BLUEGEM</li>
			<li>PURPLEGEM</li>
			<li>SUPERGEM</li>
			<li>BIRDCAGE</li>
			<li>GUNBARREL</li>
			<li>GEMCRATE</li>
			<li>MORPH</li>
			<li>CARROT</li>
			<li>FULLENERGY</li>
			<li>FIRESHIELD</li>
			<li>WATERSHIELD</li>
			<li class="alt">BUBBLESHIELD</li>
			<li>LIGHTNINGSHIELD</li>
			<li class="alt">PLASMASHIELD</li>
			<li>FASTFEET</li>
			<li>ONEUP</li>
			<li class="alt">EXTRALIFE</li>
			<li class="alt">EXTRALIVE</li>
			<li>EOLPOST</li>
			<li>SAVEPOST</li>
			<li class="alt">CHECKPOINT</li>
			<li>BONUSPOST</li>
			<li>REDSPRING</li>
			<li>GREENSPRING</li>
			<li>BLUESPRING</li>
			<li>INVINCIBILITY</li>
			<li>EXTRATIME</li>
			<li>FREEZER</li>
			<li class="alt">FREEZEENEMIES</li>
			<li>HORREDSPRING</li>
			<li>HORGREENSPRING</li>
			<li>HORBLUESPRING</li>
			<li>BIRDMORPH</li>
			<li>TRIGGERCRATE</li>
			<li>FLYCARROT</li>
			<li>RECTREDGEM</li>
			<li>RECTGREENGEM</li>
			<li>RECTBLUEGEM</li>
			<li>TUFTURT</li>
			<li>TUFBOSS</li>
			<li>LABRAT</li>
			<li>DRAGON</li>
			<li>LIZARD</li>
			<li>BEE</li>
			<li class="alt">BUMBEE</li>
			<li>RAPIER</li>
			<li>SPARK</li>
			<li>BAT</li>
			<li>SUCKER</li>
			<li>CATERPILLAR</li>
			<li>CHESHIRE1</li>
			<li>CHESHIRE2</li>
			<li>HATTER</li>
			<li>BILSY</li>
			<li>SKELETON</li>
			<li>DOGGYDOGG</li>
			<li>NORMTURTLE</li>
			<li>HELMUT</li>
			<li>DEMON</li>
			<li>DRAGONFLY</li>
			<li>MONKEY</li>
			<li>FATCHICK</li>
			<li>FENCER</li>
			<li>FISH</li>
			<li>MOTH</li>
			<li>STEAM</li>
			<li>ROTATINGROCK</li>
			<li>BLASTERPOWERUP</li>
			<li>BOUNCERPOWERUP</li>
			<li>ICEPOWERUP</li>
			<li>SEEKERPOWERUP</li>
			<li>RFPOWERUP</li>
			<li>TOASTERPOWERUP</li>
			<li>LEFTPADDLE</li>
			<li>RIGHTPADDLE</li>
			<li>FIVEHUNDREDBUMP</li>
			<li>CARROTBUMP</li>
			<li>APPLE</li>
			<li>BANANA</li>
			<li>CHERRY</li>
			<li>ORANGE</li>
			<li>PEAR</li>
			<li>PRETZEL</li>
			<li>STRAWBERRY</li>
			<li>STEADYLIGHT</li>
			<li>PULZELIGHT</li>
			<li class="alt">PULSELIGHT</li>
			<li>FLICKERLIGHT</li>
			<li>QUEEN</li>
			<li>FLOATSUCKER</li>
			<li>BRIDGE</li>
			<li>LEMON</li>
			<li>LIME</li>
			<li>THING</li>
			<li>WATERMELON</li>
			<li>PEACH</li>
			<li>GRAPES</li>
			<li>LETTUCE</li>
			<li>EGGPLANT</li>
			<li>CUCUMB</li>
			<li class="alt">CUCUMBER</li>
			<li>COKE</li>
			<li class="alt">SOFTDRINK</li>
			<li>PEPSI</li>
			<li class="alt">SODAPOP</li>
			<li>MILK</li>
			<li>PIE</li>
			<li>CAKE</li>
			<li>DONUT</li>
			<li>CUPCAKE</li>
			<li>CHIPS</li>
			<li>CANDY</li>
			<li>CHOCBAR</li>
			<li class="alt">CHOCOLATEBAR</li>
			<li>ICECREAM</li>
			<li>BURGER</li>
			<li>PIZZA</li>
			<li>FRIES</li>
			<li>CHICKENLEG</li>
			<li>SANDWICH</li>
			<li>TACO</li>
			<li>WEENIE</li>
			<li>HAM</li>
			<li>CHEESE</li>
			<li>FLOATLIZARD</li>
			<li>STANDMONKEY</li>
			<li>DESTRUCTSCENERY</li>
			<li>DESTRUCTSCENERYBOMB</li>
			<li class="alt">TNTDESTRUCTSCENERY</li>
			<li>COLLAPSESCENERY</li>
			<li>STOMPSCENERY</li>
			<li>GEMSTOMP</li>
			<li>RAVEN</li>
			<li>TUBETURTLE</li>
			<li>GEMRING</li>
			<li>SMALLTREE</li>
			<li>AMBIENTSOUND</li>
			<li>UTERUS</li>
			<li>CRAB</li>
			<li>WITCH</li>
			<li>ROCKETTURTLE</li>
			<li>BUBBA</li>
			<li>DEVILDEVAN</li>
			<li>DEVANROBOT</li>
			<li>ROBOT</li>
			<li>CARROTUSPOLE</li>
			<li>PSYCHPOLE</li>
			<li>DIAMONDUSPOLE</li>
			<li>FRUITPLATFORM</li>
			<li>BOLLPLATFORM</li>
			<li>GRASSPLATFORM</li>
			<li>PINKPLATFORM</li>
			<li>SONICPLATFORM</li>
			<li>SPIKEPLATFORM</li>
			<li>SPIKEBOLL</li>
			<li>GENERATOR</li>
			<li>EVA</li>
			<li>BUBBLER</li>
			<li>TNTPOWERUP</li>
			<li>GUN8POWERUP</li>
			<li>GUN9POWERUP</li>
			<li>SPIKEBOLL3D</li>
			<li>SPRINGCORD</li>
			<li>BEES</li>
			<li>COPTER</li>
			<li>LASERSHIELD</li>
			<li>STOPWATCH</li>
			<li>JUNGLEPOLE</li>
			<li>WARP</li>
			<li>BIGROCK</li>
			<li>BIGBOX</li>
			<li>TRIGGERSCENERY</li>
			<li>BOLLY</li>
			<li>BUTTERFLY</li>
			<li>BEEBOY</li>
			<li>SNOW</li>
			<li>TWEEDLEBOSS</li>
			<li>AIRBOARD</li>
			<li>CTFBASE</li>
			<li>XMASNORMTURTLE</li>
			<li>XMASLIZARD</li>
			<li>XMASFLOATLIZARD</li>
			<li>XMASBILSY</li>
			<li>CAT</li>
			<li>PACMANGHOST</li>
		</ul>
		<h3 id="behavior"><span>BEHAVIOR::Behavior</span></h3>
		<p>Most of these constants share the same names as their corresponding OBJECT::Object constants�BEHAVIOR::SHARD for OBJECT::SHARD, BEHAVIOR::UTERUS for OBJECT::UTERUS, and so on�but there are a few exceptions. To save space, only the BEHAVIOR::Behavior values that do not align perfectly with OBJECT::Object values will be listed.</p>
		<ul class="textual">
			<li><span class="name">OBJECT::BLASTERBULLET</span>, <span class="name">OBJECT::ICEBULLET</span>, <span class="name">OBJECT::FIREBALLBULLET</span>, <span class="name">OBJECT::BLASTERBULLETPU</span>, <span class="name">OBJECT::FIREBALLBULLETPU</span>, <span class="name">OBJECT::FIRESHIELDBULLET</span>, and <span class="name">OBJECT::PLASMASHIELDBULLET/LIGHTNINGSHIELDBULLET</span> all use <span class="name">BEHAVIOR::BULLET</span>.</li>
			<li>Both Seeker bullets use <span class="name">BEHAVIOR::SEEKERBULLET</span>.</li>
			<li>Both RF bullets use <span class="name">BEHAVIOR::RFBULLET</span>.</li>
			<li>Both Toaster bullets use <span class="name">BEHAVIOR::TOASTERBULLET</span>.</li>
			<li>Both Pepper Spray bullets use <span class="name">BEHAVIOR::PEPPERBULLET</span>.</li>
			<li>Both ElectroBlaster bullets use <span class="name">BEHAVIOR::ELECTROBULLET</span>.</li>
			<li>Both pinball bumpers use <span class="name">BEHAVIOR::BUMP</span>.</li>
			<li>Both pinball paddles use <span class="name">BEHAVIOR::PADDLE</span>.</li>
			<li>Both Big Box and Big Rock use <span class="name">BEHAVIOR::BIGOBJECT</span>.</li>
			<li>Tuf Turtle and Lizard both use <span class="name">BEHAVIOR::WALKINGENEMY</span>. (A large number of other behaviors call it from within themselves, but those are the only two that use it directly.)</li>
			<li>Destruct, buttstomp, collapse, speed destruct, and TNT destruct scenery all use <span class="name">BEHAVIOR::DESTRUCTSCENERY</span>.</li>
			<li>Rocket Turtles are divided into <span class="name">BEHAVIOR::ROCKETTURTLE</span> and <span class="name">BEHAVIOR::ROCKETTURTLEPLUS</span>. The second is used by rocket turtle bosses that have a non-zero Velocity parameter; the first by old rocket turtles that use the normal JJ2 code.</li>
			<li>Bolly bosses are divided into <span class="name">BEHAVIOR::BOLLYTOP</span> and <span class="name">BEHAVIOR::BOLLYBOTTOM</span>, the former being the value used by <code>jjObjectPresets[OBJECT::BOLLY]</code>.</li>
			<li>All swinging platforms (including the 2D spike boll) use <span class="name">BEHAVIOR::PLATFORM</span>.</li>
			<li>All springs (including horizontal springs) use <span class="name">BEHAVIOR::SPRING</span>.</li>
			<li>All +15 Ammo boxes use <span class="name">BEHAVIOR::AMMO15</span>.</li>
			<li>All powerups, shields, and morph monitors use <span class="name">BEHAVIOR::MONITOR</span>.</li>
			<li>All barrels and crates (including trigger crates) use <span class="name">BEHAVIOR::CRATE</span>.</li>
			<li>All floating pickups (food, ammo, carrots, gems, fast feet, and so on) use <span class="name">BEHAVIOR::PICKUP</span>, except for <span class="name">OBJECT/BEHAVIOR::FLICKERGEM</span> and its close relative <span class="name">BEHAVIOR::DIAMONDSAREFOREVER</span>.</li>
			<li><span class="name">OBJECT::CTFBASE</span> uses <span class="name">BEHAVIOR::FLAG</span>, to emphasize which part does the actual moving around.</li>
			<li>Enemies exclusive to TSF, i.e. Xmas enemies, Cat and Pacman Ghost don't have their own behaviors and instead use those of, respectively: their original versions, Doggy Dog and Sparks.</li>
		<li><span class="name">BEHAVIOR::INACTIVE</span> exists for inactive objects, which definitionally don't have any actual behavior functions; it's possible to delete an object by setting its behavior to INACTIVE, but you shouldn't, since <a class="name" href="#jjDeleteObject">jjDeleteObject</a> or <a class="name" href="#jjobj::delete">jjOBJ::delete</a> does some additional cleanup work. <span class="name">BEHAVIOR::DEFAULT</span> is used for special purposes by <a class="name" href="#jjAddObject">jjAddObject</a> and <a class="name" href="#jjobj::behave">jjOBJ::behave</a>, but otherwise doesn't do anything.</li>
			<li>Finally, the following names exist only as behaviors, not as dedicated objects: <span class="name">MONKEYBULLET, BILSYBULLET, BOLLYBULLET, BOLLYSPIKEBALL, WITCHBULLET, TUFBOSSBULLET, ROBOTSHARD, BONE, EXPLOSION2</span> (used by pickup objects once they've been collected), <span class="name">BURNING</span> (creates lots of particles), <span class="name">AIRBOARDFALL, BIRDFEATHER, UFO, CORPSE<!--, OILBULLET, SHOCKWAVE--></span>.</li>
		</ul>
		<h3 id="sample"><span>SOUND::Sample</span></h3>
		<p>Preview samples at the invaluable <a href="http://www.jazz2online.com/soundboard/">JJ2 Soundboard.</a> All LORISOUNDS_* samples are naturally only available in TSF, but the X* and Z* samples (for HH98 and TSF enemies) will evaluate in 1.23 to their ordinary equivalents, e.g. BILSBOSS_THUNDER for XBILSY_THUNDER or DOG_WAF1 for ZDOG_WAF1.</p>
		<ul>
			<li>AMMO_BLUB1</li>
			<li>AMMO_BLUB2</li>
			<li>AMMO_BMP1</li>
			<li>AMMO_BMP2</li>
			<li>AMMO_BMP3</li>
			<li>AMMO_BMP4</li>
			<li>AMMO_BMP5</li>
			<li>AMMO_BMP6</li>
			<li>AMMO_BOEM1</li>
			<li>AMMO_BUL1</li>
			<li>AMMO_BULFL1</li>
			<li>AMMO_BULFL2</li>
			<li>AMMO_BULFL3</li>
			<li>AMMO_FIREGUN1A</li>
			<li>AMMO_FIREGUN2A</li>
			<li>AMMO_FUMP</li>
			<li>AMMO_GUN1</li>
			<li>AMMO_GUN2</li>
			<li>AMMO_GUN3PLOP</li>
			<li>AMMO_GUNFLP</li>
			<li>AMMO_GUNFLP1</li>
			<li>AMMO_GUNFLP2</li>
			<li>AMMO_GUNFLP3</li>
			<li>AMMO_GUNFLP4</li>
			<li>AMMO_GUNFLPL</li>
			<li>AMMO_GUNJAZZ</li>
			<li>AMMO_GUNVELOCITY</li>
			<li>AMMO_ICEGUN</li>
			<li>AMMO_ICEGUN2</li>
			<li>AMMO_ICEGUNPU</li>
			<li>AMMO_ICEPU1</li>
			<li>AMMO_ICEPU2</li>
			<li>AMMO_ICEPU3</li>
			<li>AMMO_ICEPU4</li>
			<li>AMMO_LASER</li>
			<li>AMMO_LASER2</li>
			<li>AMMO_LASER3</li>
			<li>AMMO_LAZRAYS</li>
			<li>AMMO_MISSILE</li>
			<li>AMMO_SPZBL1</li>
			<li>AMMO_SPZBL2</li>
			<li>AMMO_SPZBL3</li>
			<li>BAT_BATFLY1</li>
			<li>BILSBOSS_BILLAPPEAR</li>
			<li>BILSBOSS_FINGERSNAP</li>
			<li>BILSBOSS_FIRE</li>
			<li>BILSBOSS_FIRESTART</li>
			<li>BILSBOSS_SCARY3</li>
			<li>BILSBOSS_THUNDER</li>
			<li>BILSBOSS_ZIP</li>
			<li>BONUS_BONUS1</li>
			<li>BONUS_BONUSBLUB</li>
			<li>BUBBA_BUBBABOUNCE1</li>
			<li>BUBBA_BUBBABOUNCE2</li>
			<li>BUBBA_BUBBAEXPLO</li>
			<li>BUBBA_FROG2</li>
			<li>BUBBA_FROG3</li>
			<li>BUBBA_FROG4</li>
			<li>BUBBA_FROG5</li>
			<li>BUBBA_SNEEZE2</li>
			<li>BUBBA_TORNADOATTACK2</li>
			<li>BUMBEE_BEELOOP</li>
			<li>CATERPIL_RIDOE</li>
			<li>COMMON_AIRBOARD</li>
			<li>COMMON_AIRBTURN</li>
			<li>COMMON_AIRBTURN2</li>
			<li>COMMON_BASE1</li>
			<li>COMMON_BELL_FIRE</li>
			<li>COMMON_BELL_FIRE2</li>
			<li>COMMON_BENZIN1</li>
			<li>COMMON_BIRDFLY</li>
			<li>COMMON_BIRDFLY2</li>
			<li>COMMON_BLOKPLOP</li>
			<li>COMMON_BLUB1</li>
			<li>COMMON_BUBBLGN1</li>
			<li>COMMON_BURN</li>
			<li>COMMON_BURNIN</li>
			<li>COMMON_CANSPS</li>
			<li>COMMON_CLOCK</li>
			<li>COMMON_COIN</li>
			<li>COMMON_COLLAPS</li>
			<li>COMMON_CUP</li>
			<li>COMMON_DAMPED1</li>
			<li>COMMON_DOWN</li>
			<li>COMMON_DOWNFL2</li>
			<li>COMMON_DRINKSPAZZ1</li>
			<li>COMMON_DRINKSPAZZ2</li>
			<li>COMMON_DRINKSPAZZ3</li>
			<li>COMMON_DRINKSPAZZ4</li>
			<li>COMMON_EAT1</li>
			<li>COMMON_EAT2</li>
			<li>COMMON_EAT3</li>
			<li>COMMON_EAT4</li>
			<li>COMMON_ELECTRIC1</li>
			<li>COMMON_ELECTRIC2</li>
			<li>COMMON_ELECTRICHIT</li>
			<li>COMMON_EXPL_TNT</li>
			<li>COMMON_EXPSM1</li>
			<li>COMMON_FLAMER</li>
			<li>COMMON_FLAP</li>
			<li>COMMON_FOEW1</li>
			<li>COMMON_FOEW2</li>
			<li>COMMON_FOEW3</li>
			<li>COMMON_FOEW4</li>
			<li>COMMON_FOEW5</li>
			<li>COMMON_GEMSMSH1</li>
			<li>COMMON_GLASS2</li>
			<li>COMMON_GUNSM1</li>
			<li>COMMON_HARP1</li>
			<li>COMMON_HEAD</li>
			<li>COMMON_HELI1</li>
			<li>COMMON_HIBELL</li>
			<li>COMMON_HOLYFLUT</li>
			<li>COMMON_HORN1</li>
			<li>COMMON_ICECRUSH</li>
			<li>COMMON_IMPACT1</li>
			<li>COMMON_IMPACT2</li>
			<li>COMMON_IMPACT3</li>
			<li>COMMON_IMPACT4</li>
			<li>COMMON_IMPACT5</li>
			<li>COMMON_IMPACT6</li>
			<li>COMMON_IMPACT7</li>
			<li>COMMON_IMPACT8</li>
			<li>COMMON_IMPACT9</li>
			<li>COMMON_ITEMTRE</li>
			<li>COMMON_JUMP</li>
			<li>COMMON_JUMP2</li>
			<li>COMMON_LAND</li>
			<li>COMMON_LAND1</li>
			<li>COMMON_LAND2</li>
			<li>COMMON_LANDCAN1</li>
			<li>COMMON_LANDCAN2</li>
			<li>COMMON_LANDPOP</li>
			<li>COMMON_LOADJAZZ</li>
			<li>COMMON_LOADSPAZ</li>
			<li>COMMON_METALHIT</li>
			<li>COMMON_MONITOR</li>
			<li>COMMON_NOCOIN</li>
			<li>COMMON_PICKUP1</li>
			<li>COMMON_PICKUPW1</li>
			<li>COMMON_PISTOL1</li>
			<li>COMMON_PLOOP1</li>
			<li>COMMON_PLOP1</li>
			<li>COMMON_PLOP2</li>
			<li>COMMON_PLOP3</li>
			<li>COMMON_PLOP4</li>
			<li>COMMON_PLOPKORK</li>
			<li>COMMON_PREEXPL1</li>
			<li>COMMON_PREHELI</li>
			<li>COMMON_REVUP</li>
			<li>COMMON_RINGGUN</li>
			<li>COMMON_RINGGUN2</li>
			<li>COMMON_SHIELD1</li>
			<li>COMMON_SHIELD4</li>
			<li>COMMON_SHIELD_ELEC</li>
			<li>COMMON_SHLDOF3</li>
			<li>COMMON_SLIP</li>
			<li>COMMON_SMASH</li>
			<li>COMMON_SPLAT1</li>
			<li>COMMON_SPLAT2</li>
			<li>COMMON_SPLAT3</li>
			<li>COMMON_SPLAT4</li>
			<li>COMMON_SPLUT</li>
			<li>COMMON_SPRING1</li>
			<li>COMMON_STEAM</li>
			<li>COMMON_STEP</li>
			<li>COMMON_STRETCH</li>
			<li>COMMON_SWISH1</li>
			<li>COMMON_SWISH2</li>
			<li>COMMON_SWISH3</li>
			<li>COMMON_SWISH4</li>
			<li>COMMON_SWISH5</li>
			<li>COMMON_SWISH6</li>
			<li>COMMON_SWISH7</li>
			<li>COMMON_SWISH8</li>
			<li>COMMON_TELPORT1</li>
			<li>COMMON_TELPORT2</li>
			<li>COMMON_UP</li>
			<li>COMMON_WATER</li>
			<li>COMMON_WOOD1</li>
			<li>DEMON_RUN</li>
			<li>DEVILDEVAN_DRAGONFIRE</li>
			<li>DEVILDEVAN_FLAP</li>
			<li>DEVILDEVAN_FROG4</li>
			<li>DEVILDEVAN_JUMPUP</li>
			<li>DEVILDEVAN_LAUGH</li>
			<li>DEVILDEVAN_PHASER2</li>
			<li>DEVILDEVAN_STRECh3</li>
			<li>DEVILDEVAN_STRECHTAIL</li>
			<li>DEVILDEVAN_STRETCH1</li>
			<li>DEVILDEVAN_STRETCH3</li>
			<li>DEVILDEVAN_VANISH1</li>
			<li>DEVILDEVAN_WHISTLEDESCENDING2</li>
			<li>DEVILDEVAN_WINGSOUT</li>
			<li>DOG_AGRESSIV</li>
			<li>DOG_SNIF1</li>
			<li>DOG_WAF1</li>
			<li>DOG_WAF2</li>
			<li>DOG_WAF3</li>
			<li>DRAGFLY_BEELOOP</li>
			<li>ENDING_OHTHANK</li>
			<li>ENDTUNEJAZZ_TUNE</li>
			<li>ENDTUNELORI_CAKE</li>
			<li>ENDTUNESPAZ_TUNE</li>
			<li>EPICLOGO_EPIC1</li>
			<li>EPICLOGO_EPIC2</li>
			<li>EVA_KISS1</li>
			<li>EVA_KISS2</li>
			<li>EVA_KISS3</li>
			<li>EVA_KISS4</li>
			<li>FAN_FAN</li>
			<li>FATCHK_HIT1</li>
			<li>FATCHK_HIT2</li>
			<li>FATCHK_HIT3</li>
			<li>FENCER_FENCE1</li>
			<li>FROG_FROG</li>
			<li>FROG_FROG1</li>
			<li>FROG_FROG2</li>
			<li>FROG_FROG3</li>
			<li>FROG_FROG4</li>
			<li>FROG_FROG5</li>
			<li>FROG_JAZZ2FROG</li>
			<li>FROG_TONG</li>
			<li>GLOVE_HIT</li>
			<li>HATTER_CUP</li>
			<li>HATTER_HAT</li>
			<li>HATTER_PTOEI</li>
			<li>HATTER_SPLIN</li>
			<li>HATTER_SPLOUT</li>
			<li>INTRO_BLOW</li>
			<li>INTRO_BOEM1</li>
			<li>INTRO_BOEM2</li>
			<li>INTRO_BRAKE</li>
			<li>INTRO_END</li>
			<li>INTRO_GRAB</li>
			<li>INTRO_GREN1</li>
			<li>INTRO_GREN2</li>
			<li>INTRO_GREN3</li>
			<li>INTRO_GUNM0</li>
			<li>INTRO_GUNM1</li>
			<li>INTRO_GUNM2</li>
			<li>INTRO_HELI</li>
			<li>INTRO_HITSPAZ</li>
			<li>INTRO_HITTURT</li>
			<li>INTRO_IFEEL</li>
			<li>INTRO_INHALE</li>
			<li>INTRO_INSECT</li>
			<li>INTRO_KATROL</li>
			<li>INTRO_LAND</li>
			<li>INTRO_MONSTER</li>
			<li>INTRO_MONSTER2</li>
			<li>INTRO_ROCK</li>
			<li>INTRO_ROPE1</li>
			<li>INTRO_ROPE2</li>
			<li>INTRO_RUN</li>
			<li>INTRO_SHOT1</li>
			<li>INTRO_SHOTGRN</li>
			<li>INTRO_SKI</li>
			<li>INTRO_STRING</li>
			<li>INTRO_SWISH1</li>
			<li>INTRO_SWISH2</li>
			<li>INTRO_SWISH3</li>
			<li>INTRO_SWISH4</li>
			<li>INTRO_UHTURT</li>
			<li>INTRO_UP1</li>
			<li>INTRO_UP2</li>
			<li>INTRO_WIND_01</li>
			<li>JAZZSOUNDS_BALANCE</li>
			<li>JAZZSOUNDS_HEY1</li>
			<li>JAZZSOUNDS_HEY2</li>
			<li>JAZZSOUNDS_HEY3</li>
			<li>JAZZSOUNDS_HEY4</li>
			<li>JAZZSOUNDS_IDLE</li>
			<li>JAZZSOUNDS_JAZZV1</li>
			<li>JAZZSOUNDS_JAZZV2</li>
			<li>JAZZSOUNDS_JAZZV3</li>
			<li>JAZZSOUNDS_JAZZV4</li>
			<li>JAZZSOUNDS_JUMMY</li>
			<li>JAZZSOUNDS_PFOE</li>
			<li>LABRAT_BITE</li>
			<li>LABRAT_EYE2</li>
			<li>LABRAT_EYE3</li>
			<li>LABRAT_MOUSE1</li>
			<li>LABRAT_MOUSE2</li>
			<li>LABRAT_MOUSE3</li>
			<li>LIZARD_LIZ1</li>
			<li>LIZARD_LIZ2</li>
			<li>LIZARD_LIZ4</li>
			<li>LIZARD_LIZ6</li>
			<li>LORISOUNDS_DIE1</li>
			<li>LORISOUNDS_HURT0</li>
			<li>LORISOUNDS_HURT1</li>
			<li>LORISOUNDS_HURT2</li>
			<li>LORISOUNDS_HURT3</li>
			<li>LORISOUNDS_HURT4</li>
			<li>LORISOUNDS_HURT5</li>
			<li>LORISOUNDS_HURT6</li>
			<li>LORISOUNDS_HURT7</li>
			<li>LORISOUNDS_LORI1</li>
			<li>LORISOUNDS_LORI2</li>
			<li>LORISOUNDS_LORIBOOM</li>
			<li>LORISOUNDS_LORIFALL</li>
			<li>LORISOUNDS_LORIJUMP</li>
			<li>LORISOUNDS_LORIJUMP2</li>
			<li>LORISOUNDS_LORIJUMP3</li>
			<li>LORISOUNDS_LORIJUMP4</li>
			<li>LORISOUNDS_TOUCH</li>
			<li>LORISOUNDS_WEHOO</li>
			<li>MENUSOUNDS_SELECT0</li>
			<li>MENUSOUNDS_SELECT1</li>
			<li>MENUSOUNDS_SELECT2</li>
			<li>MENUSOUNDS_SELECT3</li>
			<li>MENUSOUNDS_SELECT4</li>
			<li>MENUSOUNDS_SELECT5</li>
			<li>MENUSOUNDS_SELECT6</li>
			<li>MENUSOUNDS_TYPE</li>
			<li>MENUSOUNDS_TYPEENTER</li>
			<li>MONKEY_SPLUT</li>
			<li>MONKEY_THROW</li>
			<li>MOTH_FLAPMOTH</li>
			<li>ORANGE_BOEML</li>
			<li>ORANGE_BOEMR</li>
			<li>ORANGE_BUBBELSL</li>
			<li>ORANGE_BUBBELSR</li>
			<li>ORANGE_GLAS1L</li>
			<li>ORANGE_GLAS1R</li>
			<li>ORANGE_GLAS2L</li>
			<li>ORANGE_GLAS2R</li>
			<li>ORANGE_MERGE</li>
			<li>ORANGE_SWEEP0L</li>
			<li>ORANGE_SWEEP0R</li>
			<li>ORANGE_SWEEP1L</li>
			<li>ORANGE_SWEEP1R</li>
			<li>ORANGE_SWEEP2L</li>
			<li>ORANGE_SWEEP2R</li>
			<li>P2_CRUNCH</li>
			<li>P2_FART</li>
			<li>P2_FOEW1</li>
			<li>P2_FOEW4</li>
			<li>P2_FOEW5</li>
			<li>P2_FROG1</li>
			<li>P2_FROG2</li>
			<li>P2_FROG3</li>
			<li>P2_FROG4</li>
			<li>P2_FROG5</li>
			<li>P2_KISS4</li>
			<li>P2_OPEN</li>
			<li>P2_PINCH1</li>
			<li>P2_PINCH2</li>
			<li>P2_PLOPSEQ1</li>
			<li>P2_PLOPSEQ2</li>
			<li>P2_PLOPSEQ3</li>
			<li>P2_PLOPSEQ4</li>
			<li>P2_POEP</li>
			<li>P2_PTOEI</li>
			<li>P2_SPLOUT</li>
			<li>P2_SPLUT</li>
			<li>P2_THROW</li>
			<li>P2_TONG</li>
			<li>PICKUPS_BOING_CHECK</li>
			<li>PICKUPS_HELI2</li>
			<li>PICKUPS_STRETCH1A</li>
			<li>PINBALL_BELL</li>
			<li>PINBALL_FLIP1</li>
			<li>PINBALL_FLIP2</li>
			<li>PINBALL_FLIP3</li>
			<li>PINBALL_FLIP4</li>
			<li>QUEEN_LADYUP</li>
			<li>QUEEN_SCREAM</li>
			<li>RAPIER_GOSTDIE</li>
			<li>RAPIER_GOSTLOOP</li>
			<li>RAPIER_GOSTOOOH</li>
			<li>RAPIER_GOSTRIP</li>
			<li>RAPIER_HITCHAR</li>
			<li>ROBOT_BIG1</li>
			<li>ROBOT_BIG2</li>
			<li>ROBOT_CAN1</li>
			<li>ROBOT_CAN2</li>
			<li>ROBOT_HYDRO</li>
			<li>ROBOT_HYDRO2</li>
			<li>ROBOT_HYDROFIL</li>
			<li>ROBOT_HYDROPUF</li>
			<li>ROBOT_IDLE1</li>
			<li>ROBOT_IDLE2</li>
			<li>ROBOT_JMPCAN1</li>
			<li>ROBOT_JMPCAN10</li>
			<li>ROBOT_JMPCAN2</li>
			<li>ROBOT_JMPCAN3</li>
			<li>ROBOT_JMPCAN4</li>
			<li>ROBOT_JMPCAN5</li>
			<li>ROBOT_JMPCAN6</li>
			<li>ROBOT_JMPCAN7</li>
			<li>ROBOT_JMPCAN8</li>
			<li>ROBOT_JMPCAN9</li>
			<li>ROBOT_METAL1</li>
			<li>ROBOT_METAL2</li>
			<li>ROBOT_METAL3</li>
			<li>ROBOT_METAL4</li>
			<li>ROBOT_METAL5</li>
			<li>ROBOT_OPEN</li>
			<li>ROBOT_OUT</li>
			<li>ROBOT_POEP</li>
			<li>ROBOT_POLE</li>
			<li>ROBOT_SHOOT</li>
			<li>ROBOT_STEP1</li>
			<li>ROBOT_STEP2</li>
			<li>ROBOT_STEP3</li>
			<li>ROCK_ROCK1</li>
			<li>RUSH_RUSH</li>
			<li>SCIENCE_PLOPKAOS</li>
			<li>SKELETON_BONE1</li>
			<li>SKELETON_BONE2</li>
			<li>SKELETON_BONE3</li>
			<li>SKELETON_BONE5</li>
			<li>SKELETON_BONE6</li>
			<li>SKELETON_BONE7</li>
			<li>SMALTREE_FALL</li>
			<li>SMALTREE_GROUND</li>
			<li>SMALTREE_HEAD</li>
			<li>SONCSHIP_METAL1</li>
			<li>SONCSHIP_MISSILE2</li>
			<li>SONCSHIP_SCRAPE</li>
			<li>SONCSHIP_SHIPLOOP</li>
			<li>SONCSHIP_TARGETLOCK</li>
			<li>SPAZSOUNDS_AUTSCH1</li>
			<li>SPAZSOUNDS_AUTSCH2</li>
			<li>SPAZSOUNDS_BIRDSIT</li>
			<li>SPAZSOUNDS_BURP</li>
			<li>SPAZSOUNDS_CHIRP</li>
			<li>SPAZSOUNDS_EATBIRD</li>
			<li>SPAZSOUNDS_HAHAHA</li>
			<li>SPAZSOUNDS_HAHAHA2</li>
			<li>SPAZSOUNDS_HAPPY</li>
			<li>SPAZSOUNDS_HIHI</li>
			<li>SPAZSOUNDS_HOHOHO1</li>
			<li>SPAZSOUNDS_HOOO</li>
			<li>SPAZSOUNDS_KARATE7</li>
			<li>SPAZSOUNDS_KARATE8</li>
			<li>SPAZSOUNDS_OHOH</li>
			<li>SPAZSOUNDS_OOOH</li>
			<li>SPAZSOUNDS_WOOHOO</li>
			<li>SPAZSOUNDS_YAHOO</li>
			<li>SPAZSOUNDS_YAHOO2</li>
			<li>SPRING_BOING_DOWN</li>
			<li>SPRING_SPRING1</li>
			<li>STEAM_STEAM</li>
			<li>STONED_STONED</li>
			<li>SUCKER_FART</li>
			<li>SUCKER_PINCH1</li>
			<li>SUCKER_PINCH2</li>
			<li>SUCKER_PINCH3</li>
			<li>SUCKER_PLOPSEQ1</li>
			<li>SUCKER_PLOPSEQ2</li>
			<li>SUCKER_PLOPSEQ3</li>
			<li>SUCKER_PLOPSEQ4</li>
			<li>SUCKER_UP</li>
			<li>TUFBOSS_CATCH</li>
			<li>TUFBOSS_RELEASE</li>
			<li>TUFBOSS_SWING</li>
			<li>TURTLE_BITE3</li>
			<li>TURTLE_HIDE</li>
			<li>TURTLE_HITSHELL</li>
			<li>TURTLE_IDLE1</li>
			<li>TURTLE_IDLE2</li>
			<li>TURTLE_NECK</li>
			<li>TURTLE_SPK1TURT</li>
			<li>TURTLE_SPK2TURT</li>
			<li>TURTLE_SPK3TURT</li>
			<li>TURTLE_SPK4TURT</li>
			<li>TURTLE_TURN</li>
			<li>UTERUS_CRABCLOSE</li>
			<li>UTERUS_CRABOPEN2</li>
			<li>UTERUS_SCISSORS1</li>
			<li>UTERUS_SCISSORS2</li>
			<li>UTERUS_SCISSORS3</li>
			<li>UTERUS_SCISSORS4</li>
			<li>UTERUS_SCISSORS5</li>
			<li>UTERUS_SCISSORS6</li>
			<li>UTERUS_SCISSORS7</li>
			<li>UTERUS_SCISSORS8</li>
			<li>UTERUS_SCREAM1</li>
			<li>UTERUS_STEP1</li>
			<li>UTERUS_STEP2</li>
			<li>WIND_WIND2A</li>
			<li>WITCH_LAUGH</li>
			<li>WITCH_MAGIC</li>
			<li>XBILSY_BILLAPPEAR</li>
			<li>XBILSY_FINGERSNAP</li>
			<li>XBILSY_FIRE</li>
			<li>XBILSY_FIRESTART</li>
			<li>XBILSY_SCARY3</li>
			<li>XBILSY_THUNDER</li>
			<li>XBILSY_ZIP</li>
			<li>XLIZARD_LIZ1</li>
			<li>XLIZARD_LIZ2</li>
			<li>XLIZARD_LIZ4</li>
			<li>XLIZARD_LIZ6</li>
			<li>XTURTLE_BITE3</li>
			<li>XTURTLE_HIDE</li>
			<li>XTURTLE_HITSHELL</li>
			<li>XTURTLE_IDLE1</li>
			<li>XTURTLE_IDLE2</li>
			<li>XTURTLE_NECK</li>
			<li>XTURTLE_SPK1TURT</li>
			<li>XTURTLE_SPK2TURT</li>
			<li>XTURTLE_SPK3TURT</li>
			<li>XTURTLE_SPK4TURT</li>
			<li>XTURTLE_TURN</li>
			<li>ZDOG_AGRESSIV</li>
			<li>ZDOG_SNIF1</li>
			<li>ZDOG_WAF1</li>
			<li>ZDOG_WAF2</li>
			<li>ZDOG_WAF3</li>
		</ul>
		<h3 id="texture"><span>TEXTURE::Texture</span></h3>
		<p>With the exception of TEXTURE::FROMTILES, all textures listed below were drawn from their respective tilesets (without asking permission from their artists).</p>
		<table id="textures">
			<tbody><tr>
				<td>
					<a href="http://localhost:8080/textures/normal.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/normal-thumb.png" alt="NORMAL"></a>
					<div class="highslide-caption">TEXTURE::NORMAL is the default JJ2 background texture, drawn by Nick Stadler.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/blade.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/blade-thumb.png" alt="BLADE"></a>
					<div class="highslide-caption">TEXTURE::BLADE, drawn by <a href="http://www.jazz2online.com/downloads/692/-/">Blade</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/corruptedsanctuary.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/corruptedsanctuary-thumb.png" alt="CORRUPTEDSANCTUARY"></a>
					<div class="highslide-caption">TEXTURE::CORRUPTEDSANCTUARY, drawn by <a href="http://www.jazz2online.com/downloads/1224/-/">Disguise</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/desolation.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/desolation-thumb.png" alt="DESOLATION"></a>
					<div class="highslide-caption">TEXTURE::DESOLATION, drawn by <a href="http://www.jazz2online.com/downloads/4918/-/">BlurredD</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/diamondusbeta.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/diamondusbeta-thumb.png" alt="DIAMONDUSBETA"></a>
					<div class="highslide-caption">TEXTURE::DIAMONDUSBETA, drawn by <a href="http://www.jazz2online.com/downloads/3477/-/">Pyromanus</a>.</div>
				</td>
			</tr>
			<tr>
				<td>
					<a href="http://localhost:8080/textures/ictubelectric.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/ictubelectric-thumb.png" alt="ICTUBELECTRIC"></a>
					<div class="highslide-caption">TEXTURE::ICTUBELECTRIC, drawn by <a href="http://www.jazz2online.com/downloads/4800/-/">P4ul</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/medivo.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/medivo-thumb.png" alt="MEDIVO"></a>
					<div class="highslide-caption">TEXTURE::MEDIVO, drawn by Nick Stadler.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/mez02.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/mez02-thumb.png" alt="MEZ02"></a>
					<div class="highslide-caption">TEXTURE::MEZ02, drawn by Mez.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/muckamoknight.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/muckamoknight-thumb.png" alt="MUCKAMOKNIGHT"></a>
					<div class="highslide-caption">TEXTURE::MUCKAMOKNIGHT, drawn by <a href="http://www.jazz2online.com/downloads/973/-/">Haze</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/psych.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/psych-thumb.png" alt="PSYCH"></a>
					<div class="highslide-caption">TEXTURE::PSYCH, drawn by Nick Stadler.</div>
				</td>
			</tr>
			<tr>
				<td>
					<a href="http://localhost:8080/textures/raneforusv.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/raneforusv-thumb.png" alt="RANEFORUSV"></a>
					<div class="highslide-caption">TEXTURE::RANEFORUSV, drawn by <a href="http://www.jazz2online.com/downloads/6173/-/">Violet CLM</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/windstormfortress.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/windstormfortress-thumb.png" alt="WINDSTORMFORTRESS"></a>
					<div class="highslide-caption">TEXTURE::WINDSTORMFORTRESS, drawn by <a href="http://www.jazz2online.com/downloads/3135/-/">BlurredD</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/wisetyness.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/wisetyness-thumb.png" alt="WISETYNESS"></a>
					<div class="highslide-caption">TEXTURE::WISETYNESS, drawn by <a href="http://www.jazz2online.com/downloads/2472/-/">Toxic Bunny</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/wtf.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/wtf-thumb.png" alt="WTF"></a>
					<div class="highslide-caption">TEXTURE::WTF, drawn by <a href="http://www.jazz2online.com/downloads/5017/-/">cooba</a>.</div>
				</td>
				<td>
					<a href="http://localhost:8080/textures/xargon.png" class="highslide" onclick="return hs.expand(this)"><img src="./JJ2+ AngelScript readme_files/xargon-thumb.png" alt="XARGON"></a>
					<div class="highslide-caption">TEXTURE::XARGON, drawn by <a href="http://www.jazz2online.com/downloads/3265/-/">Spaztic</a>.</div>
				</td>
			</tr>
		</tbody></table>
		<h3 id="spritemode" class="updated"><span>SPRITE::Mode</span></h3>
		<p>Sprite modes dictate the result of the combination of three factors: the basic pixel being drawn (e.g. an individual color in a sprite, or the overall color of a rectangle); the background pixel it is being drawn onto, and a uint8 <span class="param">param</span> value that dicates opacity, amount of palette shifting, or other such effects depending on the sprite mode in question. The simplest cases are modes like SPRITE::NORMAL, which draws the basic pixel without any modification, or SPRITE::TRANSLUCENT, which partially blends the basic pixel with the background pixel, but there are many others, and you are encouraged to try them all and decide for yourself which is best for your situation. (Hint: Usually SPRITE::NORMAL.)</p>
		<ul>
			<li>
					<a href="http://localhost:8080/spritemodes/alphamap.png" class="highslide" onclick="return hs.expand(this)">ALPHAMAP</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 24 is used; on the right it's 88. The difference between 8-bit and 16-bit color modes is severe but inevitable due to the nature of this mode.</span><span class="name">ALPHAMAP</span> is a special mode that draws a sprite in a single palette color whose index is determined by the parameter, however, it uses sprite data to determine translucency of each pixel - 0 is completely transparent and 255 is entirely opaque. This unique mode only makes sense to use with custom sprites designed with it in mind and it will not look good applied to regular JJ2 sprites. This mode was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_normal.png" class="highslide" onclick="return hs.expand(this)">BLEND_NORMAL</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 192 is used; on the right it's 64. The difference between 8-bit and 16-bit color modes is not very noticable for constant values but more for transitions.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. All of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_dissolve.png" class="highslide" onclick="return hs.expand(this)">BLEND_DISSOLVE</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 192 is used; on the right it's 64. The conversion between 8-bit and 16-bit color modes is seamless.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity. This mode is not supported by textured layers.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_darken.png" class="highslide" onclick="return hs.expand(this)">BLEND_DARKEN</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_multiply.png" class="highslide" onclick="return hs.expand(this)">BLEND_MULTIPLY</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_burn.png" class="highslide" onclick="return hs.expand(this)">BLEND_BURN</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_lighten.png" class="highslide" onclick="return hs.expand(this)">BLEND_LIGHTEN</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_screen.png" class="highslide" onclick="return hs.expand(this)">BLEND_SCREEN</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_dodge.png" class="highslide" onclick="return hs.expand(this)">BLEND_DODGE</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_overlay.png" class="highslide" onclick="return hs.expand(this)">BLEND_OVERLAY</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_softlight.png" class="highslide" onclick="return hs.expand(this)">BLEND_SOFTLIGHT</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_hardlight.png" class="highslide" onclick="return hs.expand(this)">BLEND_HARDLIGHT</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_difference.png" class="highslide" onclick="return hs.expand(this)">BLEND_DIFFERENCE</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_exclusion.png" class="highslide" onclick="return hs.expand(this)">BLEND_EXCLUSION</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_color.png" class="highslide" onclick="return hs.expand(this)">BLEND_COLOR</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_hue.png" class="highslide" onclick="return hs.expand(this)">BLEND_HUE</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is not very noticeable. A different background was used for the pictures on the right since the formula is ineffective when backgrounds with no saturation are used.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_saturation.png" class="highslide" onclick="return hs.expand(this)">BLEND_SATURATION</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is noticeable but inevitable due to the nature of this mode.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/blend_luminance.png" class="highslide" onclick="return hs.expand(this)">BLEND_LUMINANCE</a>
					<div class="highslide-caption"><span class="imagedesc">The conversion between 8-bit and 16-bit color modes is very nearly seamless.</span>There are a wide variety of <span class="name">BLEND_</span> sprite modes, each matching the similarly named layer/object blend mode in your graphics program of choice. all of them draw the sprite using parameter value as the alpha channel, i.e. opacity.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/brightness.png" class="highslide" onclick="return hs.expand(this)">BRIGHTNESS</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 192 is used; on the right it's 64. The difference between 8-bit and 16-bit color modes is very small.</span><span class="name">BRIGHTNESS</span> draws the sprite as dark or bright depending on parameter value. Parameter value 0 will draw the sprite in the darkness color (black by default but possible to modify by <a class="name" href="#jjSetDarknessColor">jjSetDarknessColor</a>), value 128 will draw the sprite normally and value 255 will draw it white. Other values will yield expected transitions. This mode is used in JJ2 to draw dark text such as inactive menu items and certain objects such as 3D spike balls when they fade in the distance.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/chromakey.png" class="highslide" onclick="return hs.expand(this)">CHROMAKEY</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 237 is used, corresponding in this tileset to the index of the dark gray color; on the right it's 238�the light gray. The conversion between 8-bit and 16-bit color modes is typically seamless.</span><span class="name">CHROMAKEY</span> draws the sprite without modifications, as if by <span class="ns">SPRITE::NORMAL</span>, except that the sprite is only drawn over background pixels matching the palette color specified by the parameter, and all other pixels are left unaffected (think: green screen effect). In 8-bit mode, the comparison is done by palette index, whereas in 16-bit mode it is done by RGB values.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/frozen.png" class="highslide" onclick="return hs.expand(this)">FROZEN</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is very noticable but was always present in JJ2.</span><span class="name">FROZEN</span> draws the sprite as frozen, ignoring the parameter. JJ2 uses this mode to draw frozen objects.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/gem.png" class="highslide" onclick="return hs.expand(this)">GEM</a>
					<div class="highslide-caption"><span class="imagedesc">Devil Devan is drawn with parameter value 0, the gems with values 0-15. The difference between 8-bit and 16-bit color modes is very noticable but was always present in JJ2.</span><span class="name">GEM</span> is a special sprite mode meant for drawing gem sprites but applicable to other sprites. The mode uses its parameter to determine what color scheme to use. Values 0-3 are values used by original JJ2 gems, values 4-12 are color schemes introduced by JJ2+, values of 13 and higher are undefined and their use is discouraged in order to preserve backward compatibility.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/invisible.png" class="highslide" onclick="return hs.expand(this)">INVISIBLE</a>
					<div class="highslide-caption"><span class="imagedesc">The effects are identical regardless of color mode and parameter value.</span><span class="name">INVISIBLE</span> never draws anything.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/mapping.png" class="highslide" onclick="return hs.expand(this)">MAPPING</a>
					<div class="highslide-caption"><span class="imagedesc">Results achieved by using this mode vary depending on specified mappings.</span><span class="name">MAPPING</span> draws an opaque sprite while applying a color transformation previously specified by calling <a href="#jjSpriteModeSetMapping" class="name">jjSpriteModeSetMapping</a>. The parameter is used to select which mapping to use. This mode is highly performant, on par with built-in opaque modes, and should be preferred over <span class="ns">SPRITE::CUSTOM</span> when possible.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/menuplayer.png" class="highslide" onclick="return hs.expand(this)">MENUPLAYER</a>
					<div class="highslide-caption"><span class="imagedesc">Results achieved by using this mode vary depending on fur of the chosen player. The sets of colors seen here are {40, 80, 72, 80} on the left and {72, 48, 72, 80} on the right. The conversion between 8-bit and 16-bit color modes is seamless.</span><span class="name">MENUPLAYER</span> draws the sprite with respect to fur colors of the player whose ID is the same as the parameter; unlike the <span class="name">PLAYER</span> mode, however, this mode is applicable to menu sprites. This mode was introduced by JJ2+ in order to draw large player characters at the end of each round.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/neonglow.png" class="highslide" onclick="return hs.expand(this)">NEONGLOW</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 0 is used; on the right it's 4. The difference between 8-bit and 16-bit color modes is severe but inevitable due to the nature of this mode.</span><span class="name">NEONGLOW</span> draws the sprite in a certain color using pixel brightness to determine its alpha channel, i.e. opacity. Parameter values 0-6 will result in, in this order, red, green, blue, magenta, yellow, cyan and white sprites. Value 7 is reserved for future use. For values higher than 7, the parameter's value modulo 8 will be used instead. It's unknown whether this mode was originally used for anything by JJ2. Its 8-bit version was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/normal.png" class="highslide" onclick="return hs.expand(this)">NORMAL</a>
					<div class="highslide-caption"><span class="imagedesc">The conversion between 8-bit and 16-bit color modes is seamless.</span><span class="name">NORMAL</span> draws the sprite without any modifications, ignoring the parameter. This mode is used to draw the vast majority JJ2 sprites.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/palshift.png" class="highslide" onclick="return hs.expand(this)">PALSHIFT</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 8 is used; on the right it's 16. The conversion between 8-bit and 16-bit color modes is seamless.</span><span class="name">PALSHIFT</span> draws the sprite with every palette index increased by the value of the parameter (when this would mean the index becomes higher than 255, it has 256 subtracted from it). This mode is used by JJ2 to draw colored text strings.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/player.png" class="highslide" onclick="return hs.expand(this)">PLAYER</a>
					<div class="highslide-caption"><span class="imagedesc">Results achieved by using this mode vary depending on fur of the chosen player. The sets of colors seen here are {40, 80, 72, 80} on the left and {72, 48, 72, 80} on the right. The conversion between 8-bit and 16-bit color modes is seamless.</span><span class="name">PLAYER</span> draws the sprite with respect to fur colors of the player whose ID is the same as the parameter, meaning that character sprites drawn in this mode will actually look like said player. All colors that don't belong to the default fur gradients (which are green, red, blue and yellow, i.e. palette indexes 16-47) stay unchanged when drawn by this mode. JJ2 uses this mode only to draw players, JJ2+ extends its effect to Fastfire pickups and the HUD blaster icon.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/deprecated.png" class="highslide" onclick="return hs.expand(this)">RESIZED</a>
					<div class="highslide-caption"><span class="name">RESIZED</span> draws the sprite scaled up or down depending on the value of the parameter without applying any other effects. This mode was made obsolete by functions such as <a class="name" href="#jjDrawResizedSprite">jjDrawResizedSprite</a> and <a class="name" href="#jjcanvas::drawResizedSprite">jjCANVAS::drawResizedSprite</a> and is no longer supported by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/shadow.png" class="highslide" onclick="return hs.expand(this)">SHADOW</a>
					<div class="highslide-caption"><span class="imagedesc">There is a visible brightness difference between 8-bit and 16-bit color modes but it was always present in JJ2.</span><span class="name">SHADOW</span> draws the sprite black and translucent, ignoring the parameter. This mode is used by JJ2 to draw shadows cast by JJ2 logo and menu items in the main menu.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/singlecolor.png" class="highslide" onclick="return hs.expand(this)">SINGLECOLOR</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 15 is used; on the right it's 16. The conversion between 8-bit and 16-bit color modes is seamless.</span><span class="name">SINGLECOLOR</span> draws the sprite entirely converted to a color with palette index specified by the parameter. JJ2 uses this mode to draw objects that have been recently hit so that they're all white.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/singlehue.png" class="highslide" onclick="return hs.expand(this)">SINGLEHUE</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 16 is used; on the right it's 64. The conversion between 8-bit and 16-bit color modes is seamless.</span><span class="name">SINGLEHUE</span> draws the sprite converting all its colors to a single palette range composed of 8 colors starting at the index specified by the parameter. For the default JJ2 palette this allows the range to contain a single gradient. This mode was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/tinted.png" class="highslide" onclick="return hs.expand(this)">TINTED</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 16 is used; on the right it's 24. The difference between 8-bit and 16-bit color modes is very noticable but was always present in JJ2.</span><span class="name">TINTED</span> draws the sprite with all its colors tinted to the color of palette entry determined by the parameter. It's unknown whether this mode was originally used by JJ2.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucent.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENT</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is not very noticable and it was always present in JJ2.</span><span class="name">TRANSLUCENT</span> draws the sprite as semi-transparent. This mode is used by JJ2 to draw objects such as Ice Ammo +3 pickups, Rapier enemies and bullet explosions.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucentcolor.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENTCOLOR</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 16 is used; on the right it's 24. The difference between 8-bit and 16-bit color modes is not very noticable, like in all other translucent modes.</span><span class="name">TRANSLUCENTCOLOR</span> draws the sprite as semi-transparent and converted to a single color defined by the parameter, so it works like a mix of <span class="name">SINGLECOLOR</span> and <span class="name">TRANSLUCENT</span> modes. This mode was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucentmapping.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENTMAPPING</a>
					<div class="highslide-caption"><span class="imagedesc">Results achieved by using this mode vary depending on specified mappings.</span><span class="name">TRANSLUCENTMAPPING</span> draws a translucent sprite while applying a color transformation previously specified by calling <a href="#jjSpriteModeSetMapping" class="name">jjSpriteModeSetMapping</a>. The parameter is used to select which mapping to use. This mode is highly performant, on par with built-in translucent modes, and should be preferred over <span class="ns">SPRITE::CUSTOM</span> when possible.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucentpalshift.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENTPALSHIFT</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 8 is used; on the right it's 16. The difference between 8-bit and 16-bit color modes is not very noticable, like in all other translucent modes.</span><span class="name">TRANSLUCENTPALSHIFT</span> draws the sprite as semi-transparent with its palette entries shifted by an amount specified by the parameter, so it works like a mix of <span class="name">PALSHIFT</span> and <span class="name">TRANSLUCENT</span> modes. This mode was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucentplayer.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENTPLAYER</a>
					<div class="highslide-caption"><span class="imagedesc">Results achieved by using this mode vary depending on fur of the chosen player. The sets of colors seen here are {40, 80, 72, 80} on the left and {72, 48, 72, 80} on the right. The difference between 8-bit and 16-bit color modes is not very noticable, like in all other translucent modes.</span><span class="name">TRANSLUCENTPLAYER</span> draws the sprite as semi-transparent and with respect to fur colors of the player whose ID is the same as the parameter, so it works like a mix of <span class="name">PLAYER</span> and <span class="name">TRANSLUCENT</span> modes. This mode was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucentsinglehue.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENTSINGLEHUE</a>
					<div class="highslide-caption"><span class="imagedesc">On the left, parameter value 16 is used; on the right it's 64. The difference between 8-bit and 16-bit color modes is not very noticable, like in all other translucent modes.</span><span class="name">TRANSLUCENTSINGLEHUE</span> draws the sprite as semi-transparent with its palette entries converted to an 8-color range in the palette defined by the parameter, so it works like a mix of <span class="name">SINGLEHUE</span> and <span class="name">TRANSLUCENT</span> modes. This mode was introduced by JJ2+.</div>
			</li>
			<li>
					<a href="http://localhost:8080/spritemodes/translucenttile.png" class="highslide" onclick="return hs.expand(this)">TRANSLUCENTTILE</a>
					<div class="highslide-caption"><span class="imagedesc">The difference between 8-bit and 16-bit color modes is not very noticable and it was always present in JJ2.</span><span class="name">TRANSLUCENTTILE</span> is the same as TRANSLUCENT in 8-bit color but is noticeably closer to opaque in 16-bit color. This mode is used by JJ2 to draw translucent tiles.</div>
			</li>
		</ul>
		<h3 id="anim"><span>ANIM::Set</span></h3>
		<p>Values used as indices to the <a class="name" href="#jjAnimSets">jjAnimSets</a> array, plus the <span class="param">setID</span> parameters of the jjOBJ method <a class="name" href="#jjobj::determineCurAnim">determineCurAnim</a>, the jjCANVAS method <a class="name" href="#jjcanvas::drawSprite">drawSprite</a>, and the global function <a class="name" href="#jjDrawSprite">jjDrawSprite</a>, as well as the jjPLAYER <a class="name" href="#jjplayer::setID">setID</a> property. These are in the same order as they appear in <a href="http://www.jazz2online.com/downloads/4041/jazz-sprite-dynamite/">Jazz Sprite Dynamite</a>, so it should be totally straightforward to match the names to the numbers. Sets for HH98 or TSF-exclusive enemies, when used in 1.23, will evaluate to the values of their 1.23 equivalents, e.g. LIZARD for XLIZARD.</p>
		<ul>
			<li>AMMO</li>
			<li>BAT</li>
			<li>BEEBOY</li>
			<li>BEES</li>
			<li>BIGBOX</li>
			<li>BIGROCK</li>
			<li>BIGTREE</li>
			<li>BILSBOSS</li>
			<li>BIRD</li>
			<li>BIRD3D</li>
			<li>BOLLPLAT</li>
			<li>BONUS</li>
			<li>BOSS</li>
			<li>BRIDGE</li>
			<li>BUBBA</li>
			<li>BUMBEE</li>
			<li>BUTTERFLY</li>
			<li>CARROTPOLE</li>
			<li>CAT</li>
			<li>CAT2</li>
			<li>CATERPIL</li>
			<li>CHUCK</li>
			<li>COMMON</li>
			<li>CONTINUE</li>
			<li>DEMON</li>
			<li>DESTSCEN</li>
			<li>DEVAN</li>
			<li>DEVILDEVAN</li>
			<li>DIAMPOLE</li>
			<li>DOG</li>
			<li>DOOR</li>
			<li>DRAGFLY</li>
			<li>DRAGON</li>
			<li>EVA</li>
			<li>FACES</li>
			<li>FATCHK</li>
			<li>FENCER</li>
			<li>FISH</li>
			<li>FLAG</li>
			<li>FLARE</li>
			<li>FONT</li>
			<li>FROG</li>
			<li>FRUITPLAT</li>
			<li>GEMRING</li>
			<li>GLOVE</li>
			<li>GRASSPLAT</li>
			<li>HATTER</li>
			<li>HELMUT</li>
			<li>JAZZ</li>
			<li>JAZZ3D</li>
			<li>JUNGLEPOLE</li>
			<li>LABRAT</li>
			<li>LIZARD</li>
			<li>LORI</li>
			<li>LORI2</li>
			<li>MENU</li>
			<li>MENUFONT</li>
			<li>MONKEY</li>
			<li>MOTH</li>
			<li>PICKUPS</li>
			<li>PINBALL</li>
			<li>PINKPLAT</li>
			<li>PSYCHPOLE</li>
			<li>QUEEN</li>
			<li>RAPIER</li>
			<li>RAVEN</li>
			<li>ROBOT</li>
			<li>ROCK</li>
			<li>ROCKTURT</li>
			<li>SKELETON</li>
			<li>SMALTREE</li>
			<li>SNOW</li>
			<li>SONCSHIP</li>
			<li>SONICPLAT</li>
			<li>SPARK</li>
			<li>SPAZ</li>
			<li>SPAZ2</li>
			<li>SPAZ3D</li>
			<li>SPIKEBOLL</li>
			<li>SPIKEBOLL3D</li>
			<li>SPIKEPLAT</li>
			<li>SPRING</li>
			<li>STEAM</li>
			<li>SUCKER</li>
			<li>TUBETURT</li>
			<li>TUFBOSS</li>
			<li>TUFTUR</li>
			<li>TURTLE</li>
			<li>TWEEDLE</li>
			<li>UTERUS</li>
			<li>VINE</li>
			<li>WARP10</li>
			<li>WARP100</li>
			<li>WARP20</li>
			<li>WARP50</li>
			<li>WITCH</li>
			<li>XBILSY</li>
			<li>XLIZARD</li>
			<li>XTURTLE</li>
			<li>ZDOG</li>
			<li>ZSPARK</li>
		</ul>
		<p>The above constants are all used for accessing animations in the anims.j2a file. JJ2+ comes with its own plus.j2a file, however, with its own set of constants listed below. Because plus.j2a, unlike anims.j2a, has the potential to change in future releases of JJ2+, you should be aware of the following guarantees:</p>
		<p>While the order of anim sets within plus.j2a will not change, their indices might. For example, currently ANIM::PLUS_BETA immediately follows ANIM::PLUS_AMMO, but in some future release of JJ2+, another anim set ANIM::PLUS_BANHAMMER might be added between the two. Treat the ANIM::Set constants as magic numbers and do not subtract them from each other or perform any other such operations that might break in future releases.</p>
		<p>Within an anim set in plus.j2a, the order of animations will not change, but their number might. If new animations are added to an existing anim set, they will be appended to the end, so <code>jjAnimations[jjAnimSets[ANIM::PLUS_SCENERY].firstAnim]</code> will always be a leaf, but <code>jjAnimations[jjAnimSets[ANIM::PLUS_WARP].firstAnim + 2]</code> does not currently exist but might someday later.</p>
		<p>Within an animation in plus.j2a, the number of frames may change. For example, <code>jjAnimations[jjAnimSets[ANIM::PLUS_COMMON].firstAnim + 6]</code> contains the stars used by sugar rushes, and its <a class="name" href="#jjanimation::frameCount">frameCount</a> property equals 2. However, a future release of JJ2+ might add a third star and up <span class="name">frameCount</span> to 3.</p>
		<dl>
			<dt>PLUS_AMMO</dt>
			<dd>Animations used by bullets and related code; loaded in every level. The first five animations deal with unfinished code and should be ignored for now; <code>firstAnim+5</code> is Lori's fastfire pickup/blaster icon, and <code>firstAnim+6</code> is the same but powered up.</dd>
			<dt>PLUS_BETA</dt>
			<dd>Animations from beta versions of JJ2 that were replaced for the final release, as accessible through the JJ2+ menu item Plus-&gt;Beta Sprites. You can load this set if you want to use some or all of the animations regardless of whether the user has checked that menu item. The order of animations is 0: super gem; 1: gem; 2: rect gem; 3: sodas (two frames, 0=Coke and 1=Pepsi).</dd>
			<dt>PLUS_COMMON</dt>
			<dd>All sorts of generally useful animations, loaded in every level. In order they are 0: Gun8 ammo+15 crate; 1: Gun9 ammo+15 crate; 2: Laser Shield monitor; 3: unfinished; 4: unfinished; 5: Lori blaster powerup monitor; 6: sugar rush stars; 7: Carrotade logo (pickup-sized).</dd>
			<dt>PLUS_CONTINUE</dt>
			<dd>Continue animations for Lori, who was missing them in the regular 1.24 release. Same sorts/order of animations as in ANIM::CONTINUE, probably not too useful for general purposes</dd>
			<dt>PLUS_FONT</dt>
			<dd>This is a special case animation that replaces ANIM::FONT to the point that JJ2+ will refuse to load ANIM::FONT from anims.j2a and will load ANIM::PLUS_FONT from plus.j2a instead. It's loaded in every level as ANIM::FONT, so there's not much point in you doing anything with it separately.</dd>
			<dt>PLUS_MENUFONT</dt>
			<dd>Same as ANIM::PLUS_FONT but replacing ANIM::MENUFONT instead.</dd>
			<dt class="updated">PLUS_REPLACEMENTS</dt>
			<dd>Another special case animation: PLUS_REPLACEMENTS is never loaded as a whole set, but instead individual animations are loaded from it to replace individual animations from anims.j2a under specific circumstances. You shouldn't need to access this one, because its contents will already be in game when they're needed. Just in case, though, they are 0=TSF morph box animation, 1�3=plusified Christmas Chronicles logos, 4=fly carrot without one misdrawn frame, 5=purple/orange toaster powerup monitor, 6�7=reshaded Lori menu sprites.</dd>
			<dt>PLUS_RETICLES</dt>
			<dd>Images used by mouse aim mode, specifically 1=WEAPON::NORMAL, 2=WEAPON::MISSILE, 3=WEAPON::POPCORN, 4=WEAPON::CAPPED, and 0 is the smaller target used for displaying fire angle as separate from cursor position. Although each of these animations is only one frame long, JJ2+ can play longer animations in their stead if you mess with the relevant <a href="#jjanimation">jjANIMATION</a> properties.</dd>
			<dt>PLUS_SCENERY</dt>
			<dd>Useful animations for various graphical effects, not loaded by default. In order they are 0=Leaf (used by the Snow event if given the right parameters), 1=Fire, 2=Lava, 3=Bee hive. 4=Various destructible blocks (<small>0: Blank; 1-2: Trigger; 3: Speed destruct; 4: Buttstomp; 5: Unknown; 6-9: Timed destruct; 10: Destruct; 11-19: Weapon-specific destruct; 20-23: Shield-specific destruct</small>).</dd>
			<dt>PLUS_WARP</dt>
			<dd>A pair of animations used by the Warp event when its ShowAnim parameter is set to 1.</dd>
			<dt>CUSTOM[256]</dt>
			<dd>Finally, the CUSTOM array provides you with 256 slots in the <a class="name" href="#jjAnimSets">jjAnimSets</a> array that are guaranteed not to be used by any non-AngelScript code. You should generally use these when loading or creating your own animations unless you're specifically replacing a specific existing animation, e.g. replacing the Tuf Turtle enemy (who has only one animation and is therefore very easy to work with) with a slime creature or something. Unlike the other constants, the ANIM::CUSTOM values do not correspond to any animations in any .j2a file and should never be used in <a class="name" href="#jjanimset::load">jjANIMSET::load</a>.</dd>
		</dl>
		<h3 id="rabbit"><span>RABBIT::Anim</span></h3>
		<p>For the most part, the anims.j2a files in versions 1.23 and 1.24 of Jazz 2 are just the same, differing primarily in that 1.24's has a few extra anim sets, in particular ANIM::LORI and all the X* and Z* enemies. The other difference is that 1.24's removes a number of animations from the Jazz and Spaz anim sets that were not used in the final game, such as the animations for climbing onto a ledge. In practice this means that the animation for Jazz or Spaz on an airboard, for example, is the first animation in the set in 1.24, but the second in 1.23. Since you should try to make your code as version-independent as possible, this is kind of annoying.</p>
		<p>The RABBIT::Anim enum solves this problem for you by providing a series of constants corresponding to the indices of each animation appearing in both 1.23 and 1.24, with their values adjusted internally depending on which version of JJ2 you're running. Thus RABBIT::AIRBOARD equals 0 in 1.24 and 1 in 1.23; RABBIT::HURT equals 29 in 1.24 and 32 in 1.23; and so on. The names are our best guesses for how they were originally named, working from some internal variable names as well as the fact that every animation in anims.j2a is ordered alphabetically.</p>
		<p>To get the animation index of an actual rabbit player, suitable for comparing to RABBIT::Anim values, subtract the first animation of their anim set from their current animation. To see if a rabbit player <code>p</code> is currently standing still, for example, you can check <code>if (p.curAnim - jjAnimSets[p.setID].firstAnim == RABBIT::STAND)</code>, and that will work no matter whether the player is running 1.23 or 1.24, or playing as Jazz, Spaz, or Lori.</p>
		<ul>
			<li>AIRBOARD</li>
			<li>AIRBOARDTURN</li>
			<li>BUTTSTOMPLAND</li>
			<li>CORPSE</li>
			<li>DIE</li>
			<li>DIVE</li>
			<li>DIVEFIREQUIT</li>
			<li>DIVEFIRERIGHT</li>
			<li>DIVEUP</li>
			<li>EARBRACHIATE</li>
			<li>ENDOFLEVEL</li>
			<li>FALL</li>
			<li>FALLBUTTSTOMP</li>
			<li>FALLLAND</li>
			<li>FIRE</li>
			<li>FIREUP</li>
			<li>FIREUPQUIT</li>
			<li>FROG</li>
			<li>HANGFIREQUIT</li>
			<li>HANGFIREREST</li>
			<li>HANGFIREUP</li>
			<li>HANGIDLE1</li>
			<li>HANGIDLE2</li>
			<li>HANGINGFIREQUIT</li>
			<li>HANGINGFIRERIGHT</li>
			<li>HELICOPTER</li>
			<li>HELICOPTERFIREQUIT</li>
			<li>HELICOPTERFIRERIGHT</li>
			<li>HPOLE</li>
			<li>HURT</li>
			<li>IDLE1</li>
			<li>IDLE2</li>
			<li>IDLE3</li>
			<li>IDLE4</li>
			<li>IDLE5</li>
			<li>JUMPFIREQUIT</li>
			<li>JUMPFIRERIGHT</li>
			<li>JUMPING1</li>
			<li>JUMPING2</li>
			<li>JUMPING3</li>
			<li>LEDGEWIGGLE</li>
			<li>LIFT</li>
			<li>LIFTJUMP</li>
			<li>LIFTLAND</li>
			<li>LOOKUP</li>
			<li>LOOPY</li>
			<li>PUSH</li>
			<li>QUIT</li>
			<li>REV1</li>
			<li>REV2</li>
			<li>REV3</li>
			<li>RIGHTFALL</li>
			<li>RIGHTJUMP</li>
			<li>ROLLING</li>
			<li>RUN1</li>
			<li>RUN2</li>
			<li>RUN3</li>
			<li>SKID1</li>
			<li>SKID2</li>
			<li>SKID3</li>
			<li>SPRING</li>
			<li>STAND</li>
			<li>STATIONARYJUMP</li>
			<li>STATIONARYJUMPEND</li>
			<li>STATIONARYJUMPSTART</li>
			<li>STONED</li>
			<li>SWIMDOWN</li>
			<li>SWIMRIGHT</li>
			<li>SWIMTURN1</li>
			<li>SWIMTURN2</li>
			<li>SWIMUP</li>
			<li>SWINGINGVINE</li>
			<li>TELEPORT</li>
			<li>TELEPORTFALL</li>
			<li>TELEPORTFALLING</li>
			<li>TELEPORTFALLTELEPORT</li>
			<li>TELEPORTSTAND</li>
			<li>VPOLE</li>
		</ul>
		<h2 id="thanks"><span>Thanks</span></h2>
		<p>AngelScript is written and maintained by <a href="http://www.angelcode.com/">Andreas J�nsson of AngelCode.com.</a> The JJ2+ developers owe him a great deal of thanks.</p>
	</article>

</body></html>