[
    {
        "name": "jjActiveGameTicks",
        "description": "How long the game has been actively running, at a rate of 70 ticks per second. Unlike jjGameTicks, this value is not incremented when the game is paused, stopped, or in pregame. This is a local value that counts up from 0 except in online Race games, where it is used to track lap times and is therefore synced between server and clients.\n",
        "full": "const uint jjActiveGameTicks",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAllowsFireball",
        "description": "Whether weapon 8 is fireball instead pepper spray, as set by the /fireball command.\n",
        "full": "const bool jjAllowsFireball",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAllowsMouseAim",
        "description": "Whether the server (or the SP level) allows mouse aim, as set by the /allowmouseaim command.\n",
        "full": "const bool jjAllowsMouseAim",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAllowsReady",
        "description": "Whether the server allows players to use the /ready command, as set by the /allowready command.\n",
        "full": "const bool jjAllowsReady",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAllowsWalljump",
        "description": "Whether the server allows players to use the �walljumping� bug, as set by the /allowwalljump command.\n",
        "full": "const bool jjAllowsWalljump",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAlwaysRunning",
        "description": "Whether always running is enabled, as set by the /run command.\n",
        "full": "const bool jjAlwaysRunning",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAnimatedTiles",
        "description": "Animated tiles defined by the level. For every tileID,jjAnimatedTiles[tileID] is jjTiles[tileID | TILE::ANIMATED].\nSee also jjTiles.\n",
        "full": "jjTILE@ jjAnimatedTiles[0x10000]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAnimations",
        "description": "Loaded animations. See the jjANIMATION class description for more information.\n",
        "full": "jjANIMATION@ jjAnimations[1500]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAnimFrames",
        "description": "Loaded animation frames. See the jjANIMFRAME class description for more information.\n",
        "full": "jjANIMFRAME@ jjAnimFrames[15000]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAnimSets",
        "description": "Loaded animation sets. See the jjANIMSET class description for more information.\n",
        "full": "jjANIMSET@ jjAnimSets[ANIM::Set]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjAutoWeaponChange",
        "description": "Whether automatic weapon change is locally enabled, as set by the /weaponchange command.\n",
        "full": "const bool jjAutoWeaponChange",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjBackupPalette",
        "description": "The tileset's original palette. See the jjPAL documentation above for further details.\n",
        "full": "const jjPAL jjBackupPaletteconst jjPAL jjBackupPalette",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjBorderHeight",
        "description": "The size of the black borders that appear at the edges of each local player's subscreen when a subscreen is larger than the level/server's maximum resolution, when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile Width/Tile Height checked), and/or when the F3 key has been used. Useful for deciding where to draw HUD/UI elements. Note that these values refer to the size of each border, not the overall size of the black space, so for instance if jjBorderWidth is 80, there will be 80 columns of black pixels on the left side of the subscreen and an additional 80 columns on the right side.\n",
        "full": "const int jjBorderHeight",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjBorderWidth",
        "description": "The size of the black borders that appear at the edges of each local player's subscreen when a subscreen is larger than the level/server's maximum resolution, when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile Width/Tile Height checked), and/or when the F3 key has been used. Useful for deciding where to draw HUD/UI elements. Note that these values refer to the size of each border, not the overall size of the black space, so for instance if jjBorderWidth is 80, there will be 80 columns of black pixels on the left side of the subscreen and an additional 80 columns on the right side.\n",
        "full": "const int jjBorderWidth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjBottomFeeder",
        "description": "In Roast Tag game mode, the player who is currently the bottom feeder or null if none. For the other special role in Roast Tag, see jjTokenOwner.\n",
        "full": "jjPLAYER@ jjBottomFeeder",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjCharacters",
        "description": "Character profiles. Use either CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2 as an index. Refer to the jjCHARACTER section for more information.\n",
        "full": "jjCHARACTER@ jjCharacters[CHAR::Char]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjColorDepth",
        "description": "Color depth in bits per pixel. Either 8 or 16.\n",
        "full": "const int jjColorDepth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjControlPoints",
        "description": "An array containing all Domination control points in the level. See the jjCONTROLPOINT section for further details.\n",
        "full": "const jjCONTROLPOINT@ jjControlPoints[16]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDeactivatingBecauseOfDeath",
        "description": "When the player dies in Single Player mode, this property is set to true before all jjOBJs have their state property set to DEACTIVATE. Since DEACTIVATE is also used for when an object goes too far off-screen, this property is how to discover the reason for the state change. In practice, is probably only ever consulted by destruct scenery and trigger scenery.\n",
        "full": "const bool jjDeactivatingBecauseOfDeath",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDebugF10",
        "description": "Only ever true in single player, specifically when the player has pressed the F10 key to enable debug mode. Among other peculiarities during this time, neither onPlayer nor onPlayerInput nor any of the various non-layer-based jjCANVAS onDraw hook functions will be called, because JJ2+ will be ignoring all normal player interactions.\n",
        "full": "const bool jjDebugF10",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDelayGeneratedCrateOrigins",
        "description": "If set to true, box objects (trigger crates, all wooden crates, bird morph monitors, and also bird cages) spawned from Generator objects will derive their parameters from the tile they begin at, not the tile they are created at. If the Generator object is in the air, the crate will appear on top of the nearest solid tile below the Generator, and will get its parameters from the tile there.\n",
        "full": "bool jjDelayGeneratedCrateOrigins",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDifficulty",
        "description": "The current difficulty level. 1 for Normal difficulty; 0 and below for Easy; 2 for Hard; 3 and above for Turbo. Numerous enemies base their speeds at least partially on the difficulty, so numbers outside of the well-tested 0-3 range may have unexpected or undesirable effects with certain enemies; still, it's worth a try! This property cannot be used to determine whether to load events specified in JCS as Easy or Hard, since that has already been checked by the time AngelScript starts running in a level.\nWhen you set this property, jjDifficultyNext will also be set to the new value. So for example, if you want to make enemies move a little faster in this level without affecting the difficulty of the next level in the series, try: jjDifficulty += 1; jjDifficultyNext = jjDifficultyOrig;\n",
        "full": "int jjDifficulty",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDifficultyNext",
        "description": "The difficulty for the next level. Normally this will be the same as jjDifficulty, but the /difficulty command can set this property independently. Setting this does not accomplish anything for clients, because clients will have their difficulty updated by the server upon cycling.\n",
        "full": "int jjDifficultyNext",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDifficultyOrig",
        "description": "The difficulty at the start of the level, prior to it being potentially changed by scripts setting jjDifficulty. In online servers, clients who join this level partway through will be sent this value for their difficulty, so they will remove the same events from the event map that everyone else in the server did.\n",
        "full": "const int jjDifficultyOrig",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjDoZombiesAlreadyExist",
        "description": "In Pestilence game mode, whether any player is already a zombie.\n",
        "full": "const bool jjDoZombiesAlreadyExist",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjEcho",
        "description": "The current degree of echo, as set by the \"Echo\" event.\n",
        "full": "int jjEcho",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjEnabledASFunctions",
        "description": "Usually all true. When a Text event is touched with AngelScript=1,Vanish=1, the jjEnabledASFunctions[#] bool for that Text event's TextID value will be set to false and the corresponding onFunction# will be uncallable by other Text events until the bool is set to true again.\n",
        "full": "bool jjEnabledASFunctions[256]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjEnabledTeams",
        "description": "Currently enabled teams. Possible indices are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n",
        "full": "const bool jjEnabledTeams[TEAM::Color]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjEnforceLighting",
        "description": "This setting defines the minimal ambient lighting options required from the game. It will not change game settings if they don't fulfill the requirements but it will display lights as if the settings were changed. Allowed values are:\n\t\t\t\tOPTIONAL: The default value; ambient lighting can be freely disabled and enabled with no limits.\n\t\t\t\tBASIC: Ambient lighting can be disabled but basic lights, such as those emitted by objects, players and laser shields, have to be drawn. This only affects the game if ambient lighting is disabled and low detail is enabled, because that's when basic lights stop being drawn.\n\t\t\t\tCOMPLETE: Ambient lighting cannot be disabled, all lights have to be drawn.\n\t\t\t\t\n",
        "full": "LIGHT::Enforce jjEnforceLighting",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjEventAtLastMaskedPixel",
        "description": "Whenever one of the mask-detection functions, e.g. jjMaskedHLine, finds a masked pixel in layer 4, this property will be set to the event at the tile containing that pixel. This allows you to write code for object like seeker missiles, which ignore masked pixels on tiles with the AREA::ONEWAY, AREA::HOOK, or AREA::VINE events. There's not much reason to edit it manually, since JJ2 changes its value all but constantly, but you can if you want.\n",
        "full": "uint8 jjEventAtLastMaskedPixel",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjFPS",
        "description": "The current frames per second rate, as viewable by pressing F9 twice.\n",
        "full": "const int jjFPS",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjFriendlyFire",
        "description": "Whether friendly fire is enabled, as set by the /friendlyfire command.\n",
        "full": "const bool jjFriendlyFire",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjGameConnection",
        "description": "Is this game joinable by players from other computers, and if so, must they be connected to the same network or just the internet? Options are LOCAL, ONLINE, and LAN.\n",
        "full": "const GAME::Connection jjGameConnectionconst GAME::Connection jjGameConnection",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjGameCustom",
        "description": "If using a custom gamemode, what is it? Options are NOCUSTOM, RT, LRS, XLRS, PEST, TB, JB, DCTF, FR, TLRS, DOM, and HEAD.\n",
        "full": "const GAME::Custom jjGameCustomconst GAME::Custom jjGameCustom",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjGameMode",
        "description": "What is the current base gamemode, irrespective of whether there is a custom gamemode or not? Options are SP, COOP, BATTLE, CTF, TREASURE, and RACE.\n",
        "full": "const GAME::Mode jjGameModeconst GAME::Mode jjGameMode",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjGameState",
        "description": "In an online/network server, is the game started, stopped, or some other variation? Options are. STOPPED, STARTED, PAUSED (only possible if there is a time limit), PREGAME, and OVERTIME.\n",
        "full": "const GAME::State jjGameStateconst GAME::State jjGameState",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjGameTicks",
        "description": "How long the game has been actively running, at a rate of 70 ticks per second.\n",
        "full": "const int jjGameTicks",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjHelpStrings",
        "description": "Help strings as set in level properties and used by Text events and end bosses. These can be modified but are limited to 511 characters each, so longer strings will be truncated. For the standard function to display these strings, see showText.\n",
        "full": "string jjHelpStrings[16]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjIsAdmin",
        "description": "Whether the current game executable is logged in as a Remote Admin in the current online server. To check this property for any client in the server, use jjPLAYER property isAdmin instead.\n",
        "full": "const bool jjIsAdmin",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjIsServer",
        "description": "Whether the current game executable is hosting an online server.\n",
        "full": "const bool jjIsServer",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjIsSnowing",
        "description": "Whether there's any active weather effect. The type of the effect is determined by jjSnowingType.\n",
        "full": "bool jjIsSnowing",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjIsSnowingOutdoorsOnly",
        "description": "Whether the current weather effect is specified to only take effect on transparent tiles, i.e. appear to be limited to outdoors areas.\n",
        "full": "bool jjIsSnowingOutdoorsOnly",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjIsTSF",
        "description": "Whether the current game executable is 1.23+ or 1.24+. Useful for Lori, XMas enemies, etc.\n",
        "full": "const bool jjIsTSF",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjKey",
        "description": "Whether any given key on the keyboard is currently pressed, assuming JJ2 is able to check it, including the left and right mouse buttons. Uses virtual key codes for indexation. Note that jjKey[1] and jjKey[2] refer to the primary and secondary mouse buttons respectively, rather than left and right.\n",
        "full": "const bool jjKey[256]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjKeyChat",
        "description": "The current virtual key used to open the chat prompt in a multiplayer game, default value 0x54 ('T'). No matter the key (or mouse button), pressing the Shift key at the same time will open the chat prompt in Team Chat mode (in CTF games). Note that as a workaround to allow players to cycle and whatnot, pressing Ctrl+T will always open the chat prompt, even if jjKeyChat is set to 0 or something similarly inaccessible.\n",
        "full": "uint8 jjKeyChat",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerHasTiles",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "bool jjLayerHasTiles[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerHeight",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "const int jjLayerHeight[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerLimitVisibleRegion",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "bool jjLayerLimitVisibleRegion[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerTileHeight",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "bool jjLayerTileHeight[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerTileWidth",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "bool jjLayerTileWidth[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerWidth",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "const int jjLayerWidth[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerWidthReal",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "const int jjLayerWidthReal[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerWidthRounded",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "const int jjLayerWidthRounded[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerXAutoSpeed",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "float jjLayerXAutoSpeed[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerYAutoSpeed",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "float jjLayerYAutoSpeed[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerXOffset",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "float jjLayerXOffset[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerYOffset",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "float jjLayerYOffset[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerXSpeed",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "float jjLayerXSpeed[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayerYSpeed",
        "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n",
        "full": "float jjLayerYSpeed[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLayers",
        "description": "The original eight layers placed in this level (i.e. jjLevelFileName) in JCS or some other level editor, 1-indexed to match the JCS numbers, e.g. jjLayers[4] for the main sprite layer or jjLayers[8] for the final background layer, regardless of what other code may have done to create new layers or alter their order. See the jjLAYER documentation above for further details.\n",
        "full": "jjLAYER@ jjLayers[8]jjLAYER@ jjLayers[8]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLevelFileName",
        "description": "File name of the current level, e.g. castle1.j2l, all lowercase. The file extension (.j2l) will be included, but not the folder structure.\n",
        "full": "const string jjLevelFileName",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLevelName",
        "description": "Title of the current level, e.g. Dungeon Dilemma.\n",
        "full": "string jjLevelName",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLocalPlayerCount",
        "description": "The number of local players.\n",
        "full": "const int jjLocalPlayerCount",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLocalPlayers",
        "description": "The local players.\n",
        "full": "const jjPLAYER@ jjLocalPlayers[4]const jjPLAYER@ jjLocalPlayers[4]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjLowDetail",
        "description": "Whether the Low Detail video setting is enabled. When true, only jjLayers[8] and layers whose xSpeed/ySpeed both equal exactly 1 and whose xSpeedModel/ySpeedModel both equal LAYERSPEEDMODEL::NORMAL will be drawn, and even those only if hasTileMap and hasTiles are both true.\n",
        "full": "const bool jjLowDetail",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMaxHealth",
        "description": "The most health a player can ever have, as set by the /maxhealth command. Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.\n",
        "full": "const int jjMaxHealth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMaxScore",
        "description": "In competitive game modes, the score required to win, as set by the /maxscore command.\n",
        "full": "const int jjMaxScore",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMouseAim",
        "description": "Whether mouse aim is locally enabled, as set by the /mouseaim command.\n",
        "full": "const bool jjMouseAim",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMouseX",
        "description": "The current position of the mouse cursor relative to the top left corner of the game window. To convert these coordinates to coordinates within layer 4, you'll need to use the jjPLAYER cameraX and cameraY properties.\n",
        "full": "const int jjMouseX",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMouseY",
        "description": "The current position of the mouse cursor relative to the top left corner of the game window. To convert these coordinates to coordinates within layer 4, you'll need to use the jjPLAYER cameraX and cameraY properties.\n",
        "full": "const int jjMouseY",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMusicActive",
        "description": "Mute Music, as seen in the Sound & Music Properties window.\n",
        "full": "const bool jjMusicActive",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMusicFileName",
        "description": "File name of the music file currently playing, e.g. 3ddemo.mod, all lowercase. The file extension will be included (even if not included by the level or user, e.g. this string will be \"castle.j2b\" if \"castle\" was written in Level Properties), but not the folder structure.\nThis is a const property. To change it, use jjMusicLoad.\n",
        "full": "const string jjMusicFileName",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjMusicVolume",
        "description": "Music Volume, as seen in the Sound & Music Properties window.\n",
        "full": "const int jjMusicVolume",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjNoBlink",
        "description": "Whether the no blink mode is enabled, as set by the /noblink command.\n",
        "full": "const bool jjNoBlink",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjNoMovement",
        "description": "Whether the game blocks movement during stopped games, as set by the /nomovement command.\n",
        "full": "const bool jjNoMovement",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjObjectCount",
        "description": "When looping through jjObjects, this is the endpoint; there should never exist a jjOBJ with an object ID higher than jjObjectCount. It is not however the number of distinct jjOBJs in existence at any given time, since for instance jjObjects[1] and jjObjects[3] may both be active but jjObjects[2] inactive, but jjObjectCount would still equal 4.\n",
        "full": "const int jjObjectCount",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjObjectMax",
        "description": "The most jjOBJs that can ever exist at the same time. This equals 2048 in local Single Player/Coop, or 4096 otherwise.\n",
        "full": "const int jjObjectMax",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjObjectPresets",
        "description": "The templates from which each object is built. Tends to contain default xSpeed, ySpeed, points, curAnim, and so on. Make changes here in onLevelLoad for maximum efficiency.\n",
        "full": "jjOBJ@ jjObjectPresets[256]jjOBJ@ jjObjectPresets[256]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjObjects",
        "description": "All the objects currently in memory.\n",
        "full": "jjOBJ@ jjObjects[jjObjectMax]jjOBJ@ jjObjects[jjObjectMax]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjP",
        "description": "The current player.\n",
        "full": "jjPLAYER@ jjPjjPLAYER@ jjP",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjPalette",
        "description": "The current palette. See the jjPAL documentation above for further details.\n",
        "full": "jjPAL jjPalettejjPAL jjPalette",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjParticles",
        "description": "All the particles currently in memory. See the jjPARTICLE documentation above for further details.\n",
        "full": "jjPARTICLE@ jjParticles[1024]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjPlayerCount",
        "description": "Doesn't work! Check back later.\n",
        "full": "const int jjPlayerCount",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjPlayers",
        "description": "All the players in the game, local or otherwise.\n",
        "full": "const jjPLAYER@ jjPlayers[32]const jjPLAYER@ jjPlayers[32]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjQuirks",
        "description": "Whether the quirks mode is enabled, as set by the /quirks command.\n",
        "full": "const bool jjQuirks",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjRenderFrame",
        "description": "How long the game has been running. Unlike jjGameTicks, jjRenderFrame updates when the game is paused. This is the value used for drawing layers with automatic x/y speeds.\n",
        "full": "const int jjRenderFrame",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjResolutionHeight",
        "description": "The size of the current game window in pixels, usually 640 by 480.\n",
        "full": "const int jjResolutionHeight",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjResolutionWidth",
        "description": "The size of the current game window in pixels, usually 640 by 480.\n",
        "full": "const int jjResolutionWidth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjResolutionMaxHeight",
        "description": "The maximum size the game window is allowed to be in the current level/server.\n",
        "full": "const int jjResolutionMaxHeight",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjResolutionMaxWidth",
        "description": "The maximum size the game window is allowed to be in the current level/server.\n",
        "full": "const int jjResolutionMaxWidth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjScriptModuleID",
        "description": "Each script module (including mutators) will see this property as equalling a different value: 0 for the .j2as script (if any), and 1 or higher for all mutators (loaded in alphabetical order). For use only as parameters of function jjSendPacket and jjPLAYER method hasPrivilege.\n",
        "full": "const uint jjScriptModuleID",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjShowMaxHealth",
        "description": "Whether the show max health option from the Plus menu is enabled.\n",
        "full": "const bool jjShowMaxHealth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSnowingIntensity",
        "description": "Intensity of the current weather effect. Note that that this setting only influences the game if jjIsSnowing is true.\n",
        "full": "uint8 jjSnowingIntensity",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSnowingType",
        "description": "Type of the current weather effect. Note that that this setting only influences the game if jjIsSnowing is true. Possible values are SNOW, FLOWER, RAIN, and LEAF, each spawning particles of the corresponding PARTICLE::Type.\n",
        "full": "SNOWING::Type jjSnowingTypeSNOWING::Type jjSnowingType",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSoundEnabled",
        "description": "Whether JJ2 should produce any form of audio at all.\n",
        "full": "const bool jjSoundEnabled",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSoundFXActive",
        "description": "Mute Sound, as seen in the Sound & Music Properties window.\n",
        "full": "const bool jjSoundFXActive",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSoundFXVolume",
        "description": "Sound Volume, as seen in the Sound & Music Properties window.\n",
        "full": "const int jjSoundFXVolume",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjStartHealth",
        "description": "How much health a player starts with, as set by the /starthealth command. Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.\n",
        "full": "const int jjStartHealth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjStrongPowerups",
        "description": "Whether strong powerups is enabled, as set by the /strongpowerups command.\n",
        "full": "const bool jjStrongPowerups",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSubscreenHeight",
        "description": "The size of a player's subscreen in pixels. If there is only one local player and the game is not being viewed in 3D, these will be equal to jjResolutionHeight and jjResolutionWidth -- otherwise, either or both may be cut in half. The subscreen size includes, and is therefore not changed by the values of, jjBorderHeight and jjBorderWidth.\n",
        "full": "const int jjSubscreenHeight",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSubscreenWidth",
        "description": "The size of a player's subscreen in pixels. If there is only one local player and the game is not being viewed in 3D, these will be equal to jjResolutionHeight and jjResolutionWidth -- otherwise, either or both may be cut in half. The subscreen size includes, and is therefore not changed by the values of, jjBorderHeight and jjBorderWidth.\n",
        "full": "const int jjSubscreenWidth",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjSugarRushAllowed",
        "description": "In online multiplayer levels where this is false for the host, clients with sugar rushes will be kicked for hacking. This property is set to true between onLevelLoad and onLevelBegin if there are any events in the level that will spawn food objects. If you need to allow sugar rushes for another reason, e.g. jjPLAYER::startSugarRush, your script should set this property to true in onLevelBegin at the earliest. (See the description of jjWEAPON::allowed for more technical details, but as applied to the list of food events instead.)\n",
        "full": "bool jjSugarRushAllowed",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTeamScore",
        "description": "Each team's current score in team-based game modes and undefined value in other modes. Available indexes are BLUE, RED, GREEN and YELLOW.\n",
        "full": "const int jjTeamScore[TEAM::Color]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTexturedBGFadePositionX",
        "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n",
        "full": "float jjTexturedBGFadePositionX",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTexturedBGFadePositionY",
        "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n",
        "full": "float jjTexturedBGFadePositionY",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTexturedBGStars",
        "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n",
        "full": "bool jjTexturedBGStars",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTexturedBGStyle",
        "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n",
        "full": "TEXTURE::Style jjTexturedBGStyleTEXTURE::Style jjTexturedBGStyle",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTexturedBGTexture",
        "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n",
        "full": "TEXTURE::Texture jjTexturedBGTextureTEXTURE::Texture jjTexturedBGTexture",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTexturedBGUsed",
        "description": "A shortcut property for jjLayers[8]'s textureSurface property. Returns true iff the property is anything other than SURFACE::UNTEXTURED. Set jjTexturedBGUsed to true to set to SURFACE::LEGACY, or to false to set to SURFACE::UNTEXTURED.\n",
        "full": "bool jjTexturedBGUsed",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTileCount",
        "description": "The number of (non-animated, non-flipped) tiles currently defined in the level, usually a multiple of 10. Can be increased using jjTilesFromTileset.\n",
        "full": "const uint jjTileCount",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTiles",
        "description": "Static and animated tiles corresponding to tile IDs.\nSee also jjAnimatedTiles.\n",
        "full": "const jjTILE@ jjTiles[0x10000]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTilesetFileName",
        "description": "File name of the tileset used by the current level, e.g. castle1.j2t, all lowercase. The file extension (.j2t) will be included, but not the folder structure.\n",
        "full": "const string jjTilesetFileName",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTileType",
        "description": "Each tile's tile type: 0 for normal, 1 for translucent, 3 for invisible, and so on. Refer to your JCS.ini for the full list.\n",
        "full": "uint8 jjTileType[4096]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTriggers",
        "description": "The triggers, as set by the Trigger Zone and Trigger Crate events.\n",
        "full": "bool jjTriggers[32]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjTokenOwner",
        "description": "In Roast Tag game mode, the player who is currently \"it\" or null if none. For the other special role in Roast Tag, see jjBottomFeeder.\n",
        "full": "jjPLAYER@ jjTokenOwner",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjUseLayer8Speeds",
        "description": "A shortcut property for jjLayers[8]'s xSpeedModel/ySpeedModel properties. Returns true iff at least one of the two properties is anything other than LAYERSPEEDMODEL::LAYER8. Set jjUseLayer8Speeds to true to set both properties to LAYERSPEEDMODEL::NORMAL, or to false to set both properties to LAYERSPEEDMODEL::LAYER8.\n",
        "full": "bool jjUseLayer8Speeds",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjVerticalSplitscreen",
        "description": "If there are exactly two local players, how the window is divided into their two subscreens.\n",
        "full": "bool jjVerticalSplitscreen",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWarpsTransmuteCoins",
        "description": "If set to false, using a coin warp in Single Player mode will not turn all remaining coins into red and green gems.\n",
        "full": "bool jjWarpsTransmuteCoins",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWaterChangeSpeed",
        "description": "How fast water moves up or down when the water level is set (by event or function) with the \"Instant\" parameter set to false. Defaults to 1.\n",
        "full": "float jjWaterChangeSpeed",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWaterInteraction",
        "description": "How local players react to being underwater. If this property is set to SWIM, they will swim; if LOWGRAVITY, they will use regular physics but will fall more slowly than usual. If this property is set to POSITIONBASED (the default), the game will choose between the effects of SWIM or LOWGRAVITY depending on whether jjWaterLevel is lower or greater than 32*128. This property has no effects on other objects or on sound effects, which always move more slowly/sound different underwater.\n",
        "full": "WATERINTERACTION::WaterInteraction jjWaterInteractionWATERINTERACTION::WaterInteraction jjWaterInteraction",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWaterLayer",
        "description": "Which layer, 1-8, water is drawn in front of when visible. Defaults to 1. Set to any non-existing layer number to make water invisible. Note that this is a purely visual setting, and putting water behind the sprite layer will not prevent players from swimming in it.\nIf the order of layers has been changed, this property's distance from 4 is its distance from the sprite layer, e.g. leaving it at 1 means that it will be drawn in front of the third layer in front of the sprite layer. (And therefore, if the sprite layer is the first, second, or third layer in the drawing order, water will not be drawn at all.)\n",
        "full": "int jjWaterLayer",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWaterLevel",
        "description": "How high the water currently is, in pixels.\nThis is a constant value; use the jjSetWaterLevel helper function instead for changing it.\n",
        "full": "const float jjWaterLevel",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWaterLighting",
        "description": "The current way that water and ambient lighting interact in the level. (Ambient lighting varies by local player and as such is a jjPLAYER property.) The following constants are permissible values:\n\t\t\t\t\n\t\t\t\t\tWATERLIGHT::NONE: The default. When water is activated, the level will display at lighting 100, regardless of the current settings.\n\t\t\t\t\tWATERLIGHT::GLOBAL: The entire level will be lit according to the current ambient lighting settings, both above and below the water line.\n\t\t\t\t\tWATERLIGHT::LAGUNICUS: The current ambient lighting setting is ignored. Above the water, the level will display at lighting 100. Below the water, the level will display darker and darker depending on how far below the water line the player is.\n\t\t\t\t\n",
        "full": "WATERLIGHT::wl jjWaterLightingWATERLIGHT::wl jjWaterLighting",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWaterTarget",
        "description": "The height the water is moving towards, in pixels. If the water level is set (by event or function) with the \"Instant\" parameter set to false, there will be a period in which jjWaterLevel and jjWaterTarget are two distinct values.\nThis is a constant value; use the jjSetWaterLevel helper function instead for changing it.\n",
        "full": "const float jjWaterTarget",
        "type": "property",
        "arguments": []
    },
    {
        "name": "jjWeapons",
        "description": "Various properties of the nine different weapons available to a player; see the jjWEAPON section. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead.\n",
        "full": "jjWEAPON jjWeapons[WEAPON::Weapon]",
        "type": "property",
        "arguments": []
    },
    {
        "name": "p",
        "description": "The current player; an alias of jjP, and the only property not to begin with the jj prefix, provided solely for convenience value.\n",
        "full": "jjPLAYER@ pjjPLAYER@ p",
        "type": "property",
        "arguments": []
    }
]