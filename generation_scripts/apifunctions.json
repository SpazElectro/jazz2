[
    {
        "name": "jjAddObject",
        "description": "Adds and initiates an object of type eventID at xOrg xPixel and yOrg yPixel. Possible values for creatorType are CREATOR::OBJECT, CREATOR::LEVEL, and CREATOR::PLAYER. Useful values for eventID can be found in the appendix at the bottom of the page. Returns the object ID of the new object, or 0 if the function fails for whatever reason.\nThe difference between jjAddObject(1, 0, 0, CREATOR::OBJECT, 0, BEHAVIOR::BOUNCERBULLET); and jjObjects[jjAddObject(1, 0, 0)].behavior = BEHAVIOR::BOUNCERBULLET; is that jjAddObject calls the object's behavior function as part of creating it. The first version will call BEHAVIOR::BOUNCERBULLET while the object's state is still STATE::START; the second version will call jjObjectPresets[1].behavior and only switch the object's behavior to BEHAVIOR::BOUNCERBULLET after it has already been initialized and its state likely changed to something else. The same distinction applies to setting the object's xOrg/yOrg, creatorType, and creatorID properties as parameters to the function or later on. See jjBEHAVIORINTERFACE.\n"
    },
    {
        "name": "jjAddParticle",
        "description": "Creates and returns a new particle object, or a null pointer if unsuccessful. See the jjPARTICLE documentation above for full details.\n"
    },
    {
        "name": "jjAddParticlePixelExplosion",
        "description": "Creates an explosion of particles based on the shape and possibly colors of the specified curFrame. Use a mode value of 0 for a normal explosion, 1 for a fire explosion caused by a toaster or fire shield bullet, or 2 for an explosion caused by a special move. Values in the range of 15-255 will create fire explosions whose particles will use palette index equal to mode - this effect is currently used by weapons such as powered-up toaster and laser shield to create blue explosions. Value 14 creates a fire explosion whose particles use individually random colors. Values in the range of 3-13 and higher than 255 are undefined and - to preserve backward compatibility - shouldn't be used.\n"
    },
    {
        "name": "jjAddParticleTileExplosion",
        "description": "Creates four fragments of a tile falling from a specified location, like when destroying a destructable scenery block. Does not produce a sound effect; use jjSample or jjSamplePriority for that instead. The fragments will continue to be drawn until they fall off the screen. If you want more control over the fragments' positions, speeds, etc., use jjAddParticle instead.\n"
    },
    {
        "name": "jjAlert",
        "description": "Writes text to the chatlogger window, and also displays it ingame for the local player. Uses size to determine size and positioning of text. If sendToAll is true and the function is called by the server, text will be sent to all clients as well.\n"
    },
    {
        "name": "jjChat",
        "description": "In online play, sends text to the server as a line of chat. If text is a command (e.g. \"/spectate on\" or \"/ready\"), it will be interpreted as such to the extent that the local player is allowed to use that command in the server.\nIn offline play, JJ2+ will try to parse text as a command but will not display it as chat because there is no chat in offline mode. If you want to simulate chatting in a local game, use jjAlert instead.\n"
    },
    {
        "name": "jjConsole",
        "description": "Writes text as a console message to the chatlogger window, and also displays it ingame for the local player. If sendToAll is true and the function is called by the server, text will be sent to all clients as well.\n"
    },
    {
        "name": "jjCos",
        "description": "Returns the cosine of angle with a range of 0.0-1.0 and a domain of 0-1023. Numbers outside the domain will be seemlessly moduloed. You may prefer AngelScript's native cos function.\n"
    },
    {
        "name": "jjCRC32",
        "description": "Computes cyclic redundancy check of input with optional initial value crc. The checksum is computed according to the CRC-32 standard (as used in the zlib library and all JJ2 data files that use CRC).\n"
    },
    {
        "name": "jjDebug",
        "description": "Writes text to the chatlogger window (but not ingame), but only if [General]AngelscriptDebug equals True in plus.ini. If timestamp is true, adds a timestamp before the text.\n"
    },
    {
        "name": "jjDeleteObject",
        "description": "Permanently deletes an object. Like jjAddObject, this function is purely local in its scope.\n"
    },
    {
        "name": "jjDrawPixel",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawRectangle",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawResizedSprite",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawResizedSpriteFromCurFrame",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawRotatedSprite",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawRotatedSpriteFromCurFrame",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawSprite",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawSpriteFromCurFrame",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawString",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawString",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawSwingingVineSpriteFromCurFrame",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjDrawTile",
        "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n"
    },
    {
        "name": "jjEnableEachASFunction",
        "description": "Resets all 256 bools in jjEnabledASFunctions to true.\n\t\t\t\n"
    },
    {
        "name": "jjEventGet",
        "description": "Gets the Event ID at tile xTile,yTile, as seen in JCS.ini. This number can also be compared to the OBJECT or AREA constants listed in the appendix at the bottom of this file.\n"
    },
    {
        "name": "jjEventSet",
        "description": "Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA constants are listed in the appendix at the bottom of this file.\nCaution: this is a permanent change and will subsist even after death in offline play.\n"
    },
    {
        "name": "jjGenerateSettableTileArea",
        "description": "Shortcut global function for jjLAYER::generateSettableTileArea on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjGetFadeColors",
        "description": "Calls and returns the result of jjLayers[8].getFadeColor().\n"
    },
    {
        "name": "jjGetModOrder",
        "description": "Returns the current order in the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n"
    },
    {
        "name": "jjGetModRow",
        "description": "Returns the current row in the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n"
    },
    {
        "name": "jjGetModSpeed",
        "description": "Returns the \"speed\" parameter (ticks per row) of the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n"
    },
    {
        "name": "jjGetModTempo",
        "description": "Returns the tempo of the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n"
    },
    {
        "name": "jjGetPublicInterface",
        "description": "If moduleName is a name of a currently running script module that registers the onGetPublicInterface hook, calls that hook and returns its result, otherwise returns null. Module names are the same as names of files that contain the modules, including the file extension \".j2as\" or \".mut\", and the comparison is not case sensitive. In the target module, onGetPublicInterface must be a global function with the following signature:\n\t\t\tjjPUBLICINTERFACE@ onGetPublicInterface()\n\t\t\tThe exact return type may differ as long as it is a handle to a class or interface that implements jjPUBLICINTERFACE. This function should not be called earlier than in onLevelLoad, i.e. it should not be used to initialize a global variable, as the target module may not be available at that point yet. More details about usage of this function may be found in the dedicated section of this document.\n"
    },
    {
        "name": "jjGetStaticTile",
        "description": "If tileID is animated, i.e. (tileID & TILE::ANIMATED) != 0, returns tile ID of the current animation frame of the tile corresponding to tileID. Otherwise returns tileID.\nLike animated tiles themselves, this function relies on system time rather than game ticks, which means that subsequent calls during the same frame may return different results, and that results may insignificantly differ compared to the effective state of the animation. This behavior may change in the future.\nThis function never returns tile ID of animated tiles. If its result would be animated, which may happen in levels edited by other means than JCS, the function is called recursively on the result until a static tile is obtained.\n"
    },
    {
        "name": "jjGetStringWidth",
        "description": "Returns width, in pixels, that text would have if it was drawn in specified size (or animation) and style. If style allows multi-line text and text is multi-line, width of the longest line is returned.\n"
    },
    {
        "name": "jjGetStringWidth",
        "description": "Returns width, in pixels, that text would have if it was drawn in specified size (or animation) and style. If style allows multi-line text and text is multi-line, width of the longest line is returned.\n"
    },
    {
        "name": "jjIsValidCheat",
        "description": "Returns true if text is interpreted by the game as a cheat code.\n"
    },
    {
        "name": "jjKillObject",
        "description": "Permanently deletes an object, but first calls its native STATE::KILL code (if any). Probably functionally identical to jjDeleteObject in most cases, but might work a little better sometimes.\n"
    },
    {
        "name": "jjLayerOrderGet",
        "description": "A pair of functions for accessing or changing the ordered list of layers drawn to the screen. (In most cases it should be simpler to keep the jjLAYER@ array around in your script as a variable, rather than retrieving it using jjLayerOrderGet, but that function is there just in case you need it.) The arrays are ordered so that the first jjLAYER is in front and the last is in back, meaning that writing jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); should have no visible effect in a previously unaltered level.\nThe array passed to jjLayerOrderSet must include jjLayers[4] (the gameplay/sprite layer) as one of its entries and must not include any null handles, or else the function will return false and cause a debug error. Including multiple handles to the same jjLAYER is allowed but not very useful.\nFollowing a call to jjLayerOrderSet, it takes some extra thought and understanding to figure out how to refer to individual layers in other sections of the code. Specifically there are two different patterns (which happen to come to the same thing if the layer order is never changed at all):\nAll global properties or functions with a 1-indexed layer argument—e.g. jjLayers, jjLayerYSpeed, or jjTileGet— refer exclusively to the level's original eight layers as defined in the level editor. jjLayers[1] will always refer to the same layer no matter which layer ends up being drawn foremost in the foreground. To read or write the size, speeds, etc. of any layer besides those eight, use the properties and methods of its jjLAYER instance. Similarly, the jjCANVAS onDrawLayer# hooks are (currently) only available for those original eight layers, and jjLayers[1] will always call onDrawLayer1 (if defined) no matter its position in the drawing order.\nWhen calling jjDrawSprite or any of its related functions with their layerZ and layerXY arguments, those arguments refer to the list of layers from jjLayerOrderGet, relative to Layer 4's position in that list. The default layerZ value is 4 and will always draw sprites to jjLayers[4]. If layerZ equals 3, 4-1, the sprite will be drawn to whichever jjLAYER is ordered one in front of jjLayers[4]. If 6, 4+2, the layer two behind jjLayers[4]. And so on. The same principle applies to jjWaterLayer.\n"
    },
    {
        "name": "jjLayerOrderSet",
        "description": "A pair of functions for accessing or changing the ordered list of layers drawn to the screen. (In most cases it should be simpler to keep the jjLAYER@ array around in your script as a variable, rather than retrieving it using jjLayerOrderGet, but that function is there just in case you need it.) The arrays are ordered so that the first jjLAYER is in front and the last is in back, meaning that writing jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); should have no visible effect in a previously unaltered level.\nThe array passed to jjLayerOrderSet must include jjLayers[4] (the gameplay/sprite layer) as one of its entries and must not include any null handles, or else the function will return false and cause a debug error. Including multiple handles to the same jjLAYER is allowed but not very useful.\nFollowing a call to jjLayerOrderSet, it takes some extra thought and understanding to figure out how to refer to individual layers in other sections of the code. Specifically there are two different patterns (which happen to come to the same thing if the layer order is never changed at all):\nAll global properties or functions with a 1-indexed layer argument—e.g. jjLayers, jjLayerYSpeed, or jjTileGet— refer exclusively to the level's original eight layers as defined in the level editor. jjLayers[1] will always refer to the same layer no matter which layer ends up being drawn foremost in the foreground. To read or write the size, speeds, etc. of any layer besides those eight, use the properties and methods of its jjLAYER instance. Similarly, the jjCANVAS onDrawLayer# hooks are (currently) only available for those original eight layers, and jjLayers[1] will always call onDrawLayer1 (if defined) no matter its position in the drawing order.\nWhen calling jjDrawSprite or any of its related functions with their layerZ and layerXY arguments, those arguments refer to the list of layers from jjLayerOrderGet, relative to Layer 4's position in that list. The default layerZ value is 4 and will always draw sprites to jjLayers[4]. If layerZ equals 3, 4-1, the sprite will be drawn to whichever jjLAYER is ordered one in front of jjLayers[4]. If 6, 4+2, the layer two behind jjLayers[4]. And so on. The same principle applies to jjWaterLayer.\n"
    },
    {
        "name": "jjLayersFromLevel",
        "description": "Returns an array containing a number of handles of new jjLAYER instances built from the layers defined in the level filename, specifically those requested in the 1-indexed layerIDs. (Passing numbers not in the range of 1–8 in layerIDs is undefined behavior.) For example, jjLayersFromLevel(\"castle1.j2l\", array<uint> = {5,6}); returns an array with two layers, one of width 23 and height 25 and the other of width 20 and height 11, containing different sets of pillars as defined in Layer 5 and Layer 6 of castle1.j2l. These new layer objects may then be inserted into the set of layers drawn to the screen by use of jjLayerOrderSet.\nBy default, the tile IDs of the tiles in these layers will be unchanged, meaning that unless the tileset used by the level filename is the same as is used by this level, the results will likely look very peculiar. (Similarly, any animated tiles used in those layers should probably match those used in this level.) In fact, you may want to make a special unplayable level just for the sake of taking its miscellaneous background or foreground layers into this one (and if you do, remember to tick \"Hide level in Home Cooked Levels list\" in its level properties). Alternatively, the optional tileIDAdjustmentFactor parameter is a value added to the tile IDs of any non-zero, non-animated tiles in the layer/s imported from filename, so for instance, if tileIDAdjustmentFactor equals 10, then a series of tiles 5,6,0,0,3 would become 15,16,0,0,13. (This option is intended for use in conjunction with jjTilesFromTileset, though you may find other uses for it as well.)\nLike in other sections of JJ2+ code, levels saved in either the TSF or regular JCSes work equally well. It does not matter whether the level is passworded. If the file does not exist or does not have the file extension \".j2l\" then the returned array will have zero length. If the file is not a valid level then the game may or may not crash. As with other dependent files, it is recommended to use #pragma require if the level being mined for layers is not a default level.\n"
    },
    {
        "name": "jjMaskedHLine",
        "description": "Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is masked.\n"
    },
    {
        "name": "jjMaskedPixel",
        "description": "Returns true if pixel xPixel,yPixel is masked.\n"
    },
    {
        "name": "jjMaskedTopVLine",
        "description": "If any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked, returns the height of the topmost masked pixel relative to yPixel. (For example, if xPixel,yPixel+2 is masked but +1 and +0 weren't, the function returns 2.) If none of the pixels are masked, returns lineLength+1. Used for detecting inclines and the like.\n"
    },
    {
        "name": "jjMaskedVLine",
        "description": "Returns true if any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked.\n"
    },
    {
        "name": "jjMaskedHLine",
        "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjMaskedPixel",
        "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjMaskedTopVLine",
        "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjMaskedVLine",
        "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjMusicLoad",
        "description": "Loads and starts playing a new music file, of any type supported by JJ2+. Returns false if the file cannot be found in either the main game folder or the cache subfolder, or if the specified music file is already playing and forceReload is false. The temporary parameter is useful only in local single player games, where it is used to load a music file only until the player's death, at which point the non-temporary music file will resume playing: this is how the Activate Boss event works.\n"
    },
    {
        "name": "jjMusicPause",
        "description": "Pauses the current music track. May not work with .mp3 files.\n"
    },
    {
        "name": "jjMusicPlay",
        "description": "(Re)starts the current music track.\n"
    },
    {
        "name": "jjMusicResume",
        "description": "Resumes the current music track, once paused. May not work with .mp3 files.\n"
    },
    {
        "name": "jjMusicStop",
        "description": "Stops the current music track.\n"
    },
    {
        "name": "jjNxt",
        "description": "Ends the level and skips to the next one, or to filename if specified and of length>0. Only works in Single Player and Cooperative.\n"
    },
    {
        "name": "jjNxt",
        "description": "Ends the level and skips to the next one, or to filename if specified and of length>0. Only works in Single Player and Cooperative.\n"
    },
    {
        "name": "jjParameterGet",
        "description": "Gets one of the parameters at tile xTile,yTile. Follow JCS.ini's lead in figuring out how to write the offset and length parameters.\nlength is the simplest: use the exact same formatting JCS.ini does. To get the speed of a belt event, for instance, length should be -8. To get the number of blue gems in a gem crate, length should be 4. And so on.\noffset is calculated by adding the absolute values of every parameter on the tile prior to the one you want. The first (bottommost) parameter will always have offset 0. To get the parameter \"Blue\" in Gem Crate, offset should be 8 (4+4). To get the Y-Speed of a Rotating Rock, offset should be 12 (8+abs(-4)). And so on.\nSet length to 2 and offset to -4 to get the difficulty of an event (normal, easy, hard, multiplayer-only).\n"
    },
    {
        "name": "jjParameterSet",
        "description": "Sets one of the parameters at tile xTile,yTile. length and offset work exactly as they do for jjParameterGet; the only change is newValue, which should be a valid number for the length setting. Trying to assign a negative number to an unsigned length parameter doesn't really make sense, for example, nor can you reasonably assign a newValue of 100 to a length of 3.\nNote that this is not quite as powerful as it may seem, since some objects read and process their parameters into memory when they are first created, rather than continually reading them again and again as the game continues. The function will however work fine for zones that affect the player, such as Warp or Sucker Tube or Wind, and it will also successfully set parameters for any such new objects created after the function is called.\nCaution: this is a permanent change and will subsist even after death in offline play.\n"
    },
    {
        "name": "jjPlayersWithClientID",
        "description": "Convenience function; creates and returns an array containing handles of all active players with a given clientID. The result is an empty array if the client is not connected or if clientID is not a valid ID. The result is a null handle if the function is called by a client.\n"
    },
    {
        "name": "jjPrint",
        "description": "Writes text to the chatlogger window but does not display it ingame. If timestamp is true, adds a timestamp before the text.\n"
    },
    {
        "name": "jjRandom",
        "description": "Provides a random number.\n"
    },
    {
        "name": "jjRegexIsValid",
        "description": "Returns true if expression is a valid regular expression and false otherwise. This is the only regex function that doesn't cause debug errors when the input is an invalid expression and as such it should be always used before calling other regex functions when expression comes from an untrusted source (such as from user input rather than from a constant string in the script). Expressions will be parsed according to modified ECMAScript regular expression grammar.\n"
    },
    {
        "name": "jjRegexMatch",
        "description": "Returns true if expression is a valid regular expression that matches text entirely and false if no match is found. Where the second overload is used, results will contain match results in a standard order. If ignoreCase is true, the matching will be case insensitive. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input. Note that this function only returns true if expression matches the entire string, whereas jjRegexSearch accepts substring matches.\n"
    },
    {
        "name": "jjRegexReplace",
        "description": "Returns a string that is the result of replacement of all substrings of text that are matched by expression with replacement. If ignoreCase is true, the matching will be case insensitive. Capture results ($1, $2, etc., $0 always being the entire matched substring) can be successfully used in the replacement string. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input.\n"
    },
    {
        "name": "jjRegexSearch",
        "description": "Returns true if expression is a valid regular expression that matches any substring of text and false if no match is found. Where the second overload is used, results will contain match results in a standard order. If ignoreCase is true, the matching will be case insensitive. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input. Note that this function returns true if expression matches any character subsequence of text, whereas jjRegexMatch will only look for matches with the entire string.\n"
    },
    {
        "name": "jjResetWaterGradient",
        "description": "Restores 16-bit water to its natural colors.\n"
    },
    {
        "name": "jjSample",
        "description": "Plays a sound from anims.j2a at pixel xPixel, yPixel. Possible values for sample are listed in the appendix at the bottom of this file.\nvolume ranges from 1-63, and 0 will default to 63. Higher values of frequency result in higher frequencies, or leaving it at 0 will use the sample's unique default frequency.\n"
    },
    {
        "name": "jjSampleIsLoaded",
        "description": "Returns whether sample is loaded or not.\n"
    },
    {
        "name": "jjSampleLoad",
        "description": "Attempts to load sample from a .wav file filename and returns true on success or false otherwise. If there is already a loaded sample corresponding to this SOUND::Sample constant, it will be overwritten.\n"
    },
    {
        "name": "jjSampleLooped",
        "description": "Plays a looped sound from anims.j2a at pixel xPixel, yPixel. For every source of sound (e.g. a jjOBJ instance), channel should be 0 on the first call and in later calls should be replaced with the value returned from the previous call of this function.\nvolume ranges from 1-63, and 0 will default to 63. Higher values of frequency result in higher frequencies, or leaving it at 0 will use the sample's unique default frequency.\n"
    },
    {
        "name": "jjSamplePriority",
        "description": "Plays a sound from anims.j2a, no matter what any local players' positions are. This is the function used to play the sugar rush jingle. Possible values for sample are listed in the appendix at the bottom of this file.\n"
    },
    {
        "name": "jjSendPacket",
        "description": "Sends packet from client to server (in case if you're a client) or from server to client (in case if you're a server). Returns true on success and false on failure. If toClientID is a positive value, the packet will be sent only to the client with the appropriate jjPLAYER::clientID. If it's negative, it will be sent to all clients with the exception of the one indicated by toClientID. Using the default value of 0 results in sending the packet to all clients. For a script to receive packet, you will need to declare an onReceive hook, which has the following signature:\n\t\t\tvoid onReceive(jjSTREAM &in packet, int fromClientID)\n\t\t\tNotice that packets can't be sent between two clients but only between the server and a client; if the function is called client-side, the toClientID argument is completely ignored. If a client is meant to send a packet to another client, they have to send the packet to the server first and the server should resend it to the other client from onReceive.\nIf there are multiple distinct script modules running (two or more mutators, or one mutator and a level's primary script), the packet will only be received by the module whose jjScriptModuleID global value matches the toScriptModuleID parameter. By leaving this parameter as the default value, you can ensure that a packet sent from foo.j2mut will always be read by (the onReceive hook defined in) foo.j2mut, rather than another, simultaneously running module that wouldn't know what to do with the data. Passing 0 instead will send the packet to the level's primary script (if any), and is rarely a good idea. Other values are even more rarely a good idea.\n"
    },
    {
        "name": "jjSetDarknessColor",
        "description": "Sets the color of darkness used with ambient lighting.\n"
    },
    {
        "name": "jjSetFadeColors",
        "description": "Sets the fade colors of the level's textured background, as seen in the Layer properties window for layer 8 in JCS. Has no effect if there is no textured background on layer 8.\nExactly equivalent to jjLayers[8].setFadeColor(color).\nA simpler one (or zero!) parameter version of the function also exists to set the fade colors to the same RGB values as used by one of the entries in jjPalette. This defaults to 207, which is the last color of the most common textured background gradient and thus, not infrequently, the fade color used in 8-bit color.\n"
    },
    {
        "name": "jjSetLayerXSpeed",
        "description": "Shortcut global functions for setXSpeed and setYSpeed on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjSetLayerYSpeed",
        "description": "Shortcut global functions for setXSpeed and setYSpeed on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjSetModPosition",
        "description": "Jumps to a specific row of a specific order in the currently playing module file. If reset is true, also stops all notes and resets the module's global volume, tempo, etc. to their original values.\nCalling this function with an invalid order or row number, or while BASS is not playing a module file, will have no effect.\n"
    },
    {
        "name": "jjSetModSpeed",
        "description": "Sets the \"speed\" of the currently playing module music file. Does nothing if BASS is not currently playing a module file. Note that the module may change its own speed, overwriting your change.\n"
    },
    {
        "name": "jjSetModTempo",
        "description": "Sets the tempo of the currently playing module music file. Does nothing if BASS is not currently playing a module file. Note that the module may change its own tempo, overwriting your change.\n"
    },
    {
        "name": "jjSetWaterGradient",
        "description": "Changes the colors used by water in 16-bit color. If no parameters are included, the gradient will be generated from palette entries 176 and 207 instead, the most typical textured background colors (and most of the colors used by 8-bit water).\n"
    },
    {
        "name": "jjSetWaterLevel",
        "description": "Sets jjWaterTarget to yPixel. If instant is true, jjWaterLevel will also be set to yPixel; otherwise, it will move slowly up or down from its current height until it reaches its new target.\nCaution: this function is not identical to the Water Level event in JCS. The event measures in tiles, but this function measures in pixels. Multiply by thirty-two to get the same effect.\n"
    },
    {
        "name": "jjSin",
        "description": "Returns the sine of angle with a range of 0.0-1.0 and a domain of 0-1023. Numbers outside the domain will be seemlessly moduloed. This is the sine function used by JJ2 for spinning platforms and the like, though you may prefer AngelScript's native sin function.\n"
    },
    {
        "name": "jjSlideModChannelVolume",
        "description": "In currently playing module music, slide the volume of channel to volume over a chosen number of milliseconds. Does nothing if BASS is not currently playing a module file or channel does not exist. volume is 1.0 for the module's channel volume, 0.0 for silent. If you give a higher or lower value, the slide will stop when it reaches one of these boundaries. Volume slides continue while the music is paused. If you begin sliding the volume of a channel that is already sliding, the old slide will immediately stop.\n"
    },
    {
        "name": "jjSpriteModeFirstFreeMapping",
        "description": "Returns the minimum index from the range 0–255 such that jjSpriteModeIsMappingUsed(index) is false, or -1 if none exist.\n"
    },
    {
        "name": "jjSpriteModeGetColorMapping",
        "description": "Returns a copy of the mapping provided as the rgbMapping argument during the most recent call to jjSpriteModeSetMapping with the same value of index. If the most recent call didn't provide the rgbMapping argument, instead the indexMapping argument is used in conjunction with jjPalette to determine the result. The returned handle is never null—even if the mapping corresponding to index is unused, the returned handle is still a valid palette but all its colors are black.\n"
    },
    {
        "name": "jjSpriteModeGetIndexMapping",
        "description": "Returns a copy of the mapping provided as the indexMapping argument during the most recent call to jjSpriteModeSetMapping with the same value of index. The returned handle is never null and the array it holds is always of size 256. If the mapping corresponding to index is unused, all elements of the array will be 0.\n"
    },
    {
        "name": "jjSpriteModeIsMappingUsed",
        "description": "Returns whether a mapping with the given index (as used by SPRITE::MAPPING and SPRITE::TRANSLUCENTMAPPING) has been previously successfully registered with use of jjSpriteModeSetMapping.\n"
    },
    {
        "name": "jjSpriteModeSetMapping",
        "description": "Sets a mapping with the given index (as used by SPRITE::MAPPING and SPRITE::TRANSLUCENTMAPPING) to the provided values. indexMapping will be used in 8-bit color mode. If it is shorter than 256 elements, it will be padded with values corresponding to their indices (i.e., if an empty array is provided, the corresponding SPRITE::MAPPING will act exactly like SPRITE::NORMAL in 8-bit color mode). rgbMapping, if provided, will be used in 16-bit color mode, ignoring the level's palette—otherwise indexMapping will be used, to the same effect as in 8-bit color mode.\n"
    },
    {
        "name": "jjSpy",
        "description": "Prints text to the game's built-in spy window activated by running it with the -spy command line parameter, and also writes it to your jazz2.log file.\n"
    },
    {
        "name": "jjSwitchTrigger",
        "description": "Toggles jjTriggers[id] from true to false, or vice versa, like the \"switch\" parameter on the Trigger Zone and Trigger Crate events.\n"
    },
    {
        "name": "jjTakeScreenshot",
        "description": "Takes a screenshot of the game as if F12 was pressed. Returns true if the screenshot request was successfully handled without being dismissed by timing or other restrictions, otherwise returns false.\nThe optional parameter filename can be used to define a custom filename for the screenshot file to be saved. When a custom filename is passed as a parameter, the .png suffix can be omitted, since the suffix will be always ensured. Omitting the custom filename parameter or defining it as an empty string will make the game use the default pattern for screenshot filenames, like Jazz2-[level_filename]-001.png, etc.\nNote that this feature has restrictions on how often it can be used effectively. Calling it more often than once a second won't do anything and will cause the function to return false, as an indicator that the call to take a screenshot was dismissed. There is also a one second delay for using this function successfully after the user presses F12. This is due to the possibility of this feature being able to fill up available diskspace on the calling machine rapidly (and making the game too sluggish to play anyway).\nNote that this feature may only be used to save screenshots into the folder running JJ2 itself. Also, to avoid conflict with system reserved filenames, etc. all custom filenames receive an enforced prefix in their filename as Jazz2_as-, which also helps to differentiate custom screenshot filenames from the default ones (Jazz2-).\nNote that only legal characters for filenames may be used in the custom screenshot filenames to ensure their integrity. Using any illegal characters in the filename will result in the screenshot saving to fail and making this function return false.\n"
    },
    {
        "name": "jjTileGet",
        "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjTileSet",
        "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n"
    },
    {
        "name": "jjTilesFromTileset",
        "description": "Opens the tileset filename, extracts tileCount tiles from it starting at tile ID firstTileID, and appends them to the end of the currently loaded tileset, increasing jjTileCount by tileCount. If paletteColorMapping is not null and is of length 256 or greater, it will be used to recolor the imported tiles in a way that better fits the palette you are currently using, e.g. pixels of color 10 will be changed to paletteColorMapping[10] instead. Returns false upon various reasons for failure.\njjTilesFromTileset is primarily intended to be combined with jjLayersFromLevel and jjLayerOrderSet, and the three should ideally be called in that order, so that jjLayersFromLevel has the right tiles to use in its new layers. Here is a sample script that imports the background pillars from Dungeon Dilemma (into any level using any tileset) and recolors them to use colors from the textured background:\n\t\t\tvoid onLevelLoad() {\n\tconst int oldTileCount = jjTileCount; //the number of tiles in the level's tileset before jjTilesFromTileset increases the number\n\tarray<uint8> pillarColorMapping(256);\n\tfor (int i = 0; i < 16; ++i)\n\t\tpillarColorMapping[i + 128] = i + 192; //map pillars' colors (stored in palette indices 128 through 143) to the (second row of) textured background colors\n\tjjTilesFromTileset( //appends tiles to the end of the internal copy of the tileset used by the current level\n\t\t\"Castle1.j2t\", //filename to take tiles from\n\t\t420, //first tile ID in tileset to take\n\t\t60, //number of tiles to take\n\t\tpillarColorMapping //an array<uint8>(256) that maps colors in the source tileset to colors in the destination tileset, here only working on a single 16-color gradient because that's all that is used in those particular two layers\n\t);\n\tarray<jjLAYER@> castleLayers = jjLayersFromLevel( //builds new jjLAYER instances from the layers defined in this level\n\t\t\"Castle1.j2l\", //filename to take layers from\n\t\tarray<uint> = {5,6}, //which layers to grab\n\t\toldTileCount - 420 //a number to offset the non-zero tileIDs by: the pillars started at tile 420 in castle1.j2t, but here start at the end of the old tileset, aka oldTileCount\n\t);\n\tjjLayerOrderSet(array<jjLAYER@> = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], castleLayers[0], castleLayers[1], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); //insert the two layers from castle1.j2l between Layer 4 and Layer 5\n}\n"
    },
    {
        "name": "jjTriggerRock",
        "description": "Activates all Rotating Rock events with the \"RockID\" parameter set to id, exactly like the Trigger Rock event.\n"
    },
    {
        "name": "jjUnixTimeMs",
        "description": "Returns unix time in milliseconds, i.e. the number of milliseconds that have elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.\n"
    },
    {
        "name": "jjUnixTimeSec",
        "description": "Returns unix time in seconds, i.e. the number of seconds that have elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.\n"
    },
    {
        "name": "jjUpdateTexturedBG",
        "description": "Forces JJ2+ to reconstruct the textured background from its relevant properties. This should be handled automatically now.\n"
    },
    {
        "name": "jjZlibCompress",
        "description": "Compresses data in input using the zlib library. The compression result is placed into output. Returns whether successful, which should almost always be true.\n"
    },
    {
        "name": "jjZlibUncompress",
        "description": "Attempts to uncompresses data in input using the zlib library. The decompression result is placed into output. For successful decompression, size must be at least the same value as the amount of bytes of the predicted output. Returns whether successful. The function can fail if input is not a valid compressed stream or size is too small to accomodate the output or too large to allocate memory required for performing the operation, as well as, rarely, for other reasons.\n"
    }
]