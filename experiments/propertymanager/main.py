from jsonc_parser.parser import JsoncParser
import re

from typing import List

def strbool(b: bool):
    if b == True:
        return "true"
    else:
        return "false"

def SPREAD(s: str):
    return s.upper()

def STYLE(s: str):
    return s.upper()

def parseArgs(args: List[str]):
    global rom_memory
    global ram_memory

    result = ""
    rom_pattern = r'\${(\d+)}'  # Matches "${ANYNUMBER}"
    ram_pattern = r'\*\{(\d+)}'  # Matches "*{ANYNUMBER}"

    def replace(match):
        vType = "string"

        if match.group(2) is not None:
            vType = "int"

        number = int(match.group(1 if vType == "string" else 2))
        if match.group().startswith('*'):  # *{} pattern for ram_memory
            return ram_memory[number - 1] if 0 <= number - 1 < len(ram_memory) else match.group(0)
        else:  # ${} pattern for rom_memory
            return rom_memory[number - 1] if 0 <= number - 1 < len(rom_memory) else match.group(0)

    for arg in args:
        new_string = re.sub(rom_pattern + '|' + ram_pattern, replace, arg)
        result += new_string

    return result

def paddingToSpaces(padding: int) -> str:
    paddingStr = ""

    for x in range(padding):
        paddingStr += " "
    
    return paddingStr

def parseCommands(section):
    global output, rom_memory, ram_memory
    padding = 4
    paddingStr = paddingToSpaces(padding)

    for (index, value) in enumerate(section):
        for (index_2, command) in enumerate(value):
            command = command
            args = value[command]

            if command not in ["endif", "set", "nl"]:
                output += paddingStr
            
            if command == "log":
                output += "jjConsole(\"" + parseArgs(args) + "\");\n"
            elif command == "if":
                output += "if(" + parseArgs(args) + ") {\n"
                padding += 4
                paddingStr = paddingToSpaces(padding)
            elif command == "endif":
                padding -= 4
                paddingStr = paddingToSpaces(padding)
                if output.endswith("\n"):
                    output = output[:-1]
                output += paddingStr + "}\n\n"
            elif command == "eval":
                output += parseArgs(args) + "\n\n"
            elif command == "set":
                ram_memory[args[0]] = args[1]
            elif command == "nl":
                output += "\n"

output = """// Generated by propertymanager

"""

filename = "test.jsonc"
data = JsoncParser.parse_file(filename)

output += "void onLevelBegin() {\n"

output += "    // Weapon initalization\n\n"

jjWeaponProperties = [
    {
        "name": "allowed",
        "type": bool
    },
    {
        "name": "comesFromBirds",
        "type": bool
    },
    {
        "name": "comesFromGunCrates",
        "type": bool
    },
    {
        "name": "defaultSample",
        "type": bool
    },
    {
        "name": "gemsLost",
        "type": int
    },
    {
        "name": "gradualAim",
        "type": bool
    },
    {
        "name": "infinite",
        "type": bool
    },
    {
        "name": "maximum",
        "type": int
    },
    {
        "name": "multiplier",
        "type": int
    },
    {
        "name": "replacedByBubbles",
        "type": bool
    },
    {
        "name": "replacedByShield",
        "type": bool
    },
    {
        "name": "replenishes",
        "type": bool
    },
    {
        "name": "spread",
        "type": SPREAD
    },
    {
        "name": "style",
        "type": STYLE
    }
]

weapons = ["BLASTER", "BOUNCER", "ICE", "SEEKER", "RF", "TOASTER", "TNT", "GUN8", "GUN9"]

for weapon in weapons:
    for propx in jjWeaponProperties:
        prop = propx["name"]
        val = str(propx["type"](data["weapons"][weapon.lower()][prop])).lower()
        # output += f"    jjConsole(\"{weapon.lower()}.{prop} = \" + jjWeapons[WEAPON::{weapon}].{prop});\n"
        if prop == "spread" or prop == "style":
            val = val.upper()

            if prop == "spread":
                val = "SPREAD::" + val
            else:
                val = "WEAPON::" + val
        output += f"    jjWeapons[WEAPON::{weapon}].{prop} = {val};\n"

output += "\n"

rom_memory = []
ram_memory = []

for x in range(data["memory"]):
    ram_memory.append(0)

if data["scripting"].get("onstart"):
    parseCommands(data["scripting"]["onstart"])

output += "}\n\n"

if data["scripting"].get("onchat"):
    output += "bool onLocalChat(string &in stringReceived, CHAT::Type chatType) {\n"

    rom_memory = ["\" + stringReceived + \""]

    parseCommands(data["scripting"]["onchat"])

    output += "}\n\n"

    rom_memory = []

with open("out.j2as", "w") as f:
    f.write(output)
    f.close()
