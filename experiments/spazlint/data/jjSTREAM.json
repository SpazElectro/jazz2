[{"name":"clear","description":"Discards count bytes from the front of the stream. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n","full":"void clear()","type":"function","arguments":[]},{"name":"discard","description":"Reads count bytes from the front of the stream, removes them and places their contents into value. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n","full":"bool discard(uint count)","type":"function","arguments":[{"type":"uint","name":"count","attributes":[],"items":[]}]},{"name":"get","description":"Returns size of the stream in bytes.\n","full":"bool get(const string &out value, uint count = 1)","type":"function","arguments":[{"type":"uint","name":"count","defaultValue":"1","attributes":[],"items":[]}]},{"name":"get","description":"Returns whether the stream is empty, i.e. whether getSize() == 0.\n","full":"bool get(const jjSTREAM &out value, uint count = 1)","type":"function","arguments":[{"type":"uint","name":"count","defaultValue":"1","attributes":[],"items":[]}]},{"name":"getLine","description":"Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n","full":"bool getLine(string &out value, const string &in delim = '\\n')","type":"function","arguments":[{"type":"string","name":"&out","attributes":[],"items":[]},{"type":"string","name":"delim","attributes":["const","&in"],"items":[]}]},{"name":"getSize","description":"Saves contents of the stream to file filename and returns whether successful.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".asdat\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjANIMATION::save and jjPIXELMAP::save).\n","full":"uint getSize() const","type":"function","arguments":[]},{"name":"isEmpty","description":"Appends bytes of value at the end of the stream. In contrast to push, this method doesn't store the size of the provided string or stream, thus making it impossible to pop, but it can still be obtained with get if the size is known or getLine if it ends with a defined delimiter. Returns whether successful, which is always true.\n","full":"bool isEmpty() const","type":"function","arguments":[]},{"name":"pop","description":"","full":"bool pop(T &out value)","type":"function","arguments":[{"type":"T","name":"&out","attributes":[],"items":[]}]},{"name":"push","description":"","full":"bool push(T value)","type":"function","arguments":[{"type":"T","name":"value","attributes":[],"items":[]}]},{"name":"push","description":"","full":"bool push(const string &in value)","type":"function","arguments":[{"type":"string","name":"value","attributes":["const","&in"],"items":[]}]},{"name":"push","description":"","full":"bool push(const jjSTREAM &in value)","type":"function","arguments":[{"type":"jjSTREAM","name":"value","attributes":["const","&in"],"items":[]}]},{"name":"save","description":"","full":"bool save(const string &in filename) const","type":"function","arguments":[{"type":"string","name":"filename","attributes":["const","&in"],"items":[]}]},{"name":"write","description":"","full":"bool write(const string &in value)","type":"function","arguments":[{"type":"string","name":"value","attributes":["const","&in"],"items":[]}]},{"name":"write","description":"","full":"bool write(const jjSTREAM &in value)","type":"function","arguments":[{"type":"jjSTREAM","name":"value","attributes":["const","&in"],"items":[]}]}]