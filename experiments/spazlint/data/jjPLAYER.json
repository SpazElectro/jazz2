[{"name":"alreadyDoubleJumped","description":"How much ammo the player has of each ammo type. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their allowed properties to true in the jjWeapons array.\n","full":"bool alreadyDoubleJumpedbool alreadyDoubleJumped","type":"property","arguments":[]},{"name":"ammo[WEAPON::Weapon]","description":"Whether the player falls up (true) or down (false). Also causes the player to be drawn upside-down.\n(For the record, this mode is still a work-in-progress. A handful of objects�bridges, pinball flippers, and rotating poles�don't work very well with it yet. However, future revisions will be backwards compatible with what works already, so don't hold off on using it for that reason unless it truly can't do yet what you need it do.)\n","full":"int ammo[WEAPON::Weapon]int ammo[WEAPON::Weapon]","type":"property","arguments":[]},{"name":"ammo[9]","description":"(For the record, this mode is still a work-in-progress. A handful of objects�bridges, pinball flippers, and rotating poles�don't work very well with it yet. However, future revisions will be backwards compatible with what works already, so don't hold off on using it for that reason unless it truly can't do yet what you need it do.)\n","full":"int ammo[9]int ammo[9]","type":"property","arguments":[]},{"name":"antiGrav","description":"The object ID of the jjOBJ whose energy is shown in the boss health meter, or -1 if the health meter is receding off the top of the screen, or 0 if the player is not fighting any boss.\nMore specifically, the boss health meter will show the energy of the jjOBJ as a percentage of its initial health as described in its entry in jjObjectPresets. If you create a Tuf Turtle enemy, give it 100 health, and assign a jjPLAYER's boss its object ID, JJ2 will still assume the Tuf Turtle started out at 4 health, not 100. On the other hand, if you write jjObjectPresets[OBJECT::TUFTURT].energy = 100; first, then the boss health meter will work as you might want it to.\n","full":"bool antiGravbool antiGrav","type":"property","arguments":[]},{"name":"ballTime","description":"The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n","full":"int ballTimeint ballTime","type":"property","arguments":[]},{"name":"blink","description":"The player's current character (CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2). This is a read-only value, because you should use morphTo or another related method to change it instead.\n","full":"int blinkint blink","type":"property","arguments":[]},{"name":"boss","description":"ID of the game instance controlling the player. This is particularly useful for packet exchange with use of jjSendPacket but can also be used to determine whether players are splitscreeners.\n","full":"int bossint boss","type":"property","arguments":[]},{"name":"bossActivated","description":"The overall current frame displayed to the screen to represent this player, serving as an index to the jjAnimFrames array. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n","full":"bool bossActivatedbool bossActivated","type":"property","arguments":[]},{"name":"buttstomp","description":"Which ammo type the player currently has selected. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\n","full":"int buttstompint buttstomp","type":"property","arguments":[]},{"name":"cameraX","description":"Which direction the player is facing. Negative values mean left and non-negative ones mean right.\n","full":"const float cameraXconst float cameraX","type":"property","arguments":[]},{"name":"cameraY","description":"How many times the player used double jump in the air since their last regular jump.\n","full":"const float cameraYconst float cameraY","type":"property","arguments":[]},{"name":"charCurr","description":"The object ID of the flag the player is carrying, or 0 if the player is not carrying a flag.\n","full":"const CHAR::Char charCurrconst CHAR::Char charCurr","type":"property","arguments":[]},{"name":"charOrig","description":"If the player is currently using a copter or Cheshire2 object, fly will equal the object ID of that object plus one, which is to say, the jjOBJ the player is holding will be jjObjects[p.fly - 1].\n","full":"CHAR::Char charOrigCHAR::Char charOrig","type":"property","arguments":[]},{"name":"clientID","description":"The index of the current frame displayed to the screen to represent this player within its animation. For example, Jazz's standing animation is only one frame long, so his frameID will always equal 0 while playing that animation, while Spaz's will range from 0 to 4. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n","full":"const int clientIDconst int clientID","type":"property","arguments":[]},{"name":"coins","description":"Palette indexes of the player's fur in the form of 4 colors, 8 bits each. For potentially more intuitive ways of fur color manipulation refer to jjPLAYER methods furGet and furSet. Changes to this setting are automatically shared between all clients in the server. Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n","full":"int coinsint coins","type":"property","arguments":[]},{"name":"curAnim","description":"The amount of time in which player's copter ears will run out or 0 if the player is currently not using copter ears.\n","full":"const uint16 curAnimconst uint16 curAnim","type":"property","arguments":[]},{"name":"curFrame","description":"The amount of time since the last change of idle animation or 0 if the player is not idle.\n","full":"const uint curFrameconst uint curFrame","type":"property","arguments":[]},{"name":"currTile","description":"Whether the player is invisible. Invisible players don't have their sprites or names drawn. Changes to this setting are automatically shared between all clients in the server.\n","full":"const int currTileconst int currTile","type":"property","arguments":[]},{"name":"currWeapon","description":"Whether the player is logged in as a Remote Admin in the current online server. Because admin privileges can vastly differ depending on server and admin group, a more precise tool hasPrivilege exists.\n","full":"uint8 currWeaponuint8 currWeapon","type":"property","arguments":[]},{"name":"deaths","description":"Whether the player is idle and does not appear in the level or player list. Currently this can only ever be true of the server.\n","full":"const int deathsconst int deaths","type":"property","arguments":[]},{"name":"direction","description":"In Jailbreak game mode, whether the player is currently in jail. False in all other game modes.\n","full":"int8 directionint8 direction","type":"property","arguments":[]},{"name":"doubleJumpCount","description":"Equals true if the player has lost all their lives (or joined too late) in an LRS-based gamemode.\n","full":"int doubleJumpCountint doubleJumpCount","type":"property","arguments":[]},{"name":"fastfire","description":"In Pestilence game mode, whether the player is currently a zombie. False in all other game modes.\n","full":"int fastfireint fastfire","type":"property","arguments":[]},{"name":"flag","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"const int flagconst int flag","type":"property","arguments":[]},{"name":"fly","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"int flyint fly","type":"property","arguments":[]},{"name":"food","description":"In Race, the number of laps the player has completed so far. 0 for other modes.\n","full":"int foodint food","type":"property","arguments":[]},{"name":"frameID","description":"In Race, how many ticks it took for this player to run the five most recent laps they completed, where lapTimes[0] is the length of the most recent lap and lapTimes[4] the fifth most recent. If the player has not completed a given lap yet�i.e. if the index used for the lapTimes array is greater or equal to laps�the value will be -1. Undefined for other modes or for players for whom isLocal is false.\n","full":"const uint8 frameIDconst uint8 frameID","type":"property","arguments":[]},{"name":"frozen","description":"The player's current level of ambient lighting, as affected by the Set Light and Reset Light events.\n","full":"int8 frozenint8 frozen","type":"property","arguments":[]},{"name":"fur","description":"In single player or cooperative mode, how many lives the player has remaining. For LRS-based game modes use lrsLives instead. Lives are not displayed in the HUD when jjGameConnection != GAME::LOCAL, but this number still goes up and down as appropriate, even into the negatives; it's just that it has no effect on gameplay.\n","full":"uint32 furuint32 fur","type":"property","arguments":[]},{"name":"gems[GEM::Color]","description":"In LRS-based game modes (LRS, TLRS, XLRS), how many lives the player has remaining, a negative value for other modes. For single player and cooperative modes use lives instead.\n","full":"int gems[GEM::Color]int gems[GEM::Color]","type":"property","arguments":[]},{"name":"health","description":"The player's name in its most basic form, without any | or * characters added or removed for any gamemode-related reasons.\n","full":"uint8 healthuint8 health","type":"property","arguments":[]},{"name":"helicopter","description":"Whether the player is currently allowed to shoot bullets. Hides the default current weapon/ammunition display while true.\n","full":"int helicopterint helicopter","type":"property","arguments":[]},{"name":"helicopterElapsed","description":"In online play, which number the player is in the server's list of players. 0-31.\n","full":"int helicopterElapsedint helicopterElapsed","type":"property","arguments":[]},{"name":"idle","description":"Note that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their allowedPowerup properties to true in the jjWeapons array.\n","full":"int idleint idle","type":"property","arguments":[]},{"name":"invincibility","description":"Is the player currently running? Detects the run key, capslock (if there is only one local player), and the /run <on|off> command. Apparently running is set based on keyRun, and then other parts of code query running exclusively.\n","full":"int invincibilityint invincibility","type":"property","arguments":[]},{"name":"invisibility","description":"In single player and cooperative modes, the number currently displayed for the player's score. Whenever score increases, scoreDisplayed takes a few moments to catch up to the new value. Unless the level defines an onDrawScore function, in which case this property could mean or do anything.\n","full":"bool invisibilitybool invisibility","type":"property","arguments":[]},{"name":"isActive","description":"How much longer (in ticks) the player's shield will last, or 0 if the player doesn't have a shield.\n","full":"const bool isActiveconst bool isActive","type":"property","arguments":[]},{"name":"isAdmin","description":"How long the player has been performing their special move or 0 if the player is currently not using a special move.\n","full":"const bool isAdminconst bool isAdmin","type":"property","arguments":[]},{"name":"isConnecting","description":"A sprite mode parameter further specifying how the player should be drawn. Changes to this setting are automatically shared between all clients in the server.\n","full":"const bool isConnectingconst bool isConnecting","type":"property","arguments":[]},{"name":"isIdle","description":"Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n","full":"const bool isIdleconst bool isIdle","type":"property","arguments":[]},{"name":"isInGame","description":"The player's team in team-based game modes. Possible values are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n","full":"const bool isInGameconst bool isInGame","type":"property","arguments":[]},{"name":"isJailed","description":"Should dying disable the Player Timer (false) or have no effect on it (true)?\n","full":"const bool isJailedconst bool isJailed","type":"property","arguments":[]},{"name":"isLocal","description":"How many ticks are left on the Player Timer.\n","full":"const bool isLocalconst bool isLocal","type":"property","arguments":[]},{"name":"isOut","description":"Horizontal acceleration in pixels per game tick squared, positive or negative.\n","full":"const bool isOutconst bool isOut","type":"property","arguments":[]},{"name":"isSpectating","description":"Horizontal location in pixels.\n","full":"const bool isSpectatingconst bool isSpectating","type":"property","arguments":[]},{"name":"isZombie","description":"Vertical acceleration in pixels per game tick squared, positive or negative.\n","full":"const bool isZombieconst bool isZombie","type":"property","arguments":[]},{"name":"jumpStrength","description":"Vertical location in pixels.\n","full":"float jumpStrengthfloat jumpStrength","type":"property","arguments":[]},{"name":"keyDown","description":"Activates all bosses and disables the player's sugar rush if applicable. Unlike the Activate Boss event, does not change the music track. (Use jjMusicLoad for that instead.)\nSetting activate to false will attempt to deactivate bosses, but this mostly only results in the boss health meter going away. The jjPLAYER object's boss is left unchanged unless you change it manually, and bosses do not stop moving around.\n","full":"bool keyDownbool keyDown","type":"property","arguments":[]},{"name":"keyFire","description":"Setting activate to false will attempt to deactivate bosses, but this mostly only results in the boss health meter going away. The jjPLAYER object's boss is left unchanged unless you change it manually, and bosses do not stop moving around.\n","full":"bool keyFirebool keyFire","type":"property","arguments":[]},{"name":"keyJump","description":"Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n","full":"bool keyJumpbool keyJump","type":"property","arguments":[]},{"name":"keyLeft","description":"Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n","full":"bool keyLeftbool keyLeft","type":"property","arguments":[]},{"name":"keyRight","description":"If cameraFreeze has been called, undoes the effect and lets the camera freely follow the player once again. If instant is left false, the camera will take roughly half a second to scroll to its target.\n","full":"bool keyRightbool keyRight","type":"property","arguments":[]},{"name":"keyRun","description":"Returns true if the player's sprite collides with that of the specified object, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables�including playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in�are taken into account.\n","full":"bool keyRunbool keyRun","type":"property","arguments":[]},{"name":"keySelect","description":"A convenience method to extend the absolute value of the player's invincibility property by the absolute value of the duration parameter, which also makes invincibility positive (visible) if duration is visible. For example, collecting a full energy carrot extends invincibility by +350, whereas buttstomping most enemies extends invincibility by -70.\n","full":"bool keySelectbool keySelect","type":"property","arguments":[]},{"name":"keyUp","description":"Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.\nPossible gun constants may be found in the appendix at the bottom of the page, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nIf depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\nPossible values for direction are DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the mouse cursor is at, rather than whichever direction the player is physically facing. Alternatively you may pass a float angle argument instead of an orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is down, 1.5 * pi is left, and 2 * pi is up again.\n","full":"bool keyUpbool keyUp","type":"property","arguments":[]},{"name":"laps","description":"If depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\nPossible values for direction are DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the mouse cursor is at, rather than whichever direction the player is physically facing. Alternatively you may pass a float angle argument instead of an orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is down, 1.5 * pi is left, and 2 * pi is up again.\n","full":"const int lapsconst int laps","type":"property","arguments":[]},{"name":"lapTimeBest","description":"Freezes the player for the same length of time as the Freeze Enemies pickup, or unfreezes the player if frozen is set to false. Helper method.\n","full":"const int lapTimeBestconst int lapTimeBest","type":"property","arguments":[]},{"name":"lapTimeCurrent","description":"Sets player's fur colors to those represented by provided palette indexes. Changes made by this method are automatically shared between all clients in the server.  Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n","full":"const int lapTimeCurrentconst int lapTimeCurrent","type":"property","arguments":[]},{"name":"lapTimes[5]","description":"Checks whether the player has the specified privilege within the script module moduleID. Privileges are specified in the admin configuration file (typically admin.ini) and serve as a way to determine what actions specific admin groups are allowed to take. You can read more about them in the Remote Admin section of the JJ2+ readme.\nBecause privileges are only known to the host, this function will always return false if called client-side. The function will always return false for players who are not logged in, and will always return true if the player is the host or the game is local. If the privilege string contains invalid characters, i.e. anything besides letters, digits, underscores ('_'), full stops ('.'), and hyphens ('-'), or if moduleID is not valid, the function will also return false. In all other cases, i.e. if called server-side for a logged in client and with valid parameters, privileges obtained from the admin configuration file will be tested for a match, and if one is found, the function will return true, otherwise false.\n","full":"const int lapTimes[5]const int lapTimes[5]","type":"property","arguments":[]},{"name":"light","description":"Attempts to hurt the player damage hearts, or at least strip the player of their bird or reduce their shield time. If attacker is left null, or if it's the same player as the one getting hurt, the injury will be counted as coming from the level, and if a death results, it will be marked online with the \"ate it/you killed yourself\" text. This is what you should do for injuries from enemies and other level-based factors. On the other hand, if the player dies from the hurt call and attacker is another player in the server, that player will get credit for the roast. Returns false if neither the hurtee nor the hurter are local players and the method is not called by the host, or if forceHurt (which bypasses traditional safety sources like the invincibility and blink properties and buttstomping) is false and something or other prevents the hurting from happening.\n","full":"int8 lightint8 light","type":"property","arguments":[]},{"name":"lighting","description":"Again, this method checks only gamemode-related conditions. (And if more gamemodes are added in the future, this method will be updated to reflect them.) It does not check jjPLAYER::isInGame, jjGameState, or anything that might cause jjPLAYER::hurt to return false if its forceHurt parameter is left false.\n","full":"uint8 lightinguint8 lighting","type":"property","arguments":[]},{"name":"lightType","description":"Works like a Limit X Scroll event with the corresponding Left and Width parameters. Remember that these are measured in tiles, not pixels.\n","full":"LIGHT::Type lightTypeLIGHT::Type lightType","type":"property","arguments":[]},{"name":"lives","description":"Sets the player's character to charNew, possible values CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI (in TSF), CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n","full":"int livesint lives","type":"property","arguments":[]},{"name":"localPlayerID","description":"The playerHandling parameter specifies how the player should interact with the object�for example, passing HANDLING::PICKUP will force the player to treat the object as a pickup, even if its actual playerHandling property is set to something else. If the value is not HANDLING::ENEMY, HANDLING::SPECIAL, HANDLING::PICKUP, HANDLING::ENEMYBULLET, or HANDLING::PLAYERBULLET, nothing will happen. If the value is one of the first three and the object has scriptedCollisions set to true, some version of onObjectHit will be called with a null bullet argument, this jjPLAYER as player, and whatever force you call this method with as force.\nThe results of this collision will be broadcast to other players in the server exactly as if it had happened naturally through the sprites colliding. For example, collecting a pickup object half the level away will cause other players to see the pickup disappear.\n","full":"const int localPlayerIDconst int localPlayerID","type":"property","arguments":[]},{"name":"lrsLives","description":"Causes the player to appear to swing around a pole for delay ticks, then launch off at the specified speed/s. For reference, an H-Pole event increases the absolute value of your existing xSpeed by 8 (but not above 20), while a V-Pole event increases the absolute value of your existing ySpeed by 16, with both using the default delay value of 70 ticks (=one second). An H-Pole passes 0 for ySpeed, and a V-Pole passes 0 for xSpeed, but you may use non-orthogonal directions with this method if you'd rather.\n","full":"const int lrsLivesconst int lrsLives","type":"property","arguments":[]},{"name":"name","description":"Reverts the player to the character they were when they began the level, just like the Revert Morph event. If morphEffect is true, displays the default visual effect. Returns the new character (equal to the player's charOrig).\n","full":"const string nameconst string name","type":"property","arguments":[]},{"name":"nameUnformatted","description":"Sets the player's score. While setting the score through the score property is slightly delayed as scoreDisplayed increases/decreases to catch up to the new value, this function sets both properties at once. Probably most helpful as a function for quickly showing you debug information.\n","full":"const string nameUnformattedconst string nameUnformatted","type":"property","arguments":[]},{"name":"noclipMode","description":"Displays text on the player's screen either like a Text event, with the corresponding textID and offset parameters, or simply a specified text. Unique size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use jjHelpStrings instead.\n","full":"bool noclipModebool noclipMode","type":"property","arguments":[]},{"name":"noFire","description":"If sample is true, a sample will be chosen (from among SOUND::COMMON_SPRING1, SOUND::SPRING_BOING_DOWN, and SOUND::SPRING_SPRING1) and played depending on the xSpeed and ySpeed values, and if the player is Spaz, SOUND::SPAZSOUNDS_YAHOO2 may be played as well.\n","full":"bool noFirebool noFire","type":"property","arguments":[]},{"name":"platform","description":"Simulates the player touching a Sucker Tube event with the same parameter names and values (with noclip referring to \"BecomeNoclip\", not \"Noclip Only\"). For each axis this method instructs the player to move along, the center parameter first puts the player in the center of their current tile on the other axis�therefore, passing true is generally safe, but it will get the player stuck if trying to move diagonally every single tick. In normal JJ2, center is true for the first tick the player spends in the tile with the sucker tube event, and false every tick thereafter.\n","full":"int platformint platform","type":"property","arguments":[]},{"name":"playerID","description":"If the player has at least numberOfGems type-colored gems, depletes their type gems by numberOfGems and returns true. Otherwise displays a warning onscreen that they need more gems to continue and returns false. Basically the same as a coin warp event, but you get to choose the result, and it's for gems instead of coins.\nPossible values of type are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n","full":"const int8 playerIDconst int8 playerID","type":"property","arguments":[]},{"name":"powerup[WEAPON::Weapon]","description":"When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n","full":"bool powerup[WEAPON::Weapon]bool powerup[WEAPON::Weapon]","type":"property","arguments":[]},{"name":"powerup[9]","description":"Pauses the Player Timer and returns TIMER::PAUSED.\n","full":"bool powerup[9]bool powerup[9]","type":"property","arguments":[]},{"name":"roasts","description":"Stops the Player Timer and returns TIMER::STOPPED.\n","full":"const int roastsconst int roasts","type":"property","arguments":[]},{"name":"running","description":"Warps the player to the specified tile, instantly if fast is true or using the standard warp effect if fast is false.\n","full":"bool runningbool running","type":"property","arguments":[]},{"name":"score","description":"","full":"int scoreint score","type":"property","arguments":[]},{"name":"scoreDisplayed","description":"","full":"int scoreDisplayedint scoreDisplayed","type":"property","arguments":[]},{"name":"setID","description":"","full":"const ANIM::Set setIDconst ANIM::Set setID","type":"property","arguments":[]},{"name":"shieldTime","description":"","full":"int shieldTimeint shieldTime","type":"property","arguments":[]},{"name":"shieldType","description":"","full":"int shieldTypeint shieldType","type":"property","arguments":[]},{"name":"specialMove","description":"","full":"int specialMoveint specialMove","type":"property","arguments":[]},{"name":"spriteMode","description":"","full":"SPRITE::Mode spriteModeSPRITE::Mode spriteMode","type":"property","arguments":[]},{"name":"spriteParam","description":"","full":"uint8 spriteParamuint8 spriteParam","type":"property","arguments":[]},{"name":"stoned","description":"","full":"int stonedint stoned","type":"property","arguments":[]},{"name":"subscreenX","description":"","full":"const int subscreenXconst int subscreenX","type":"property","arguments":[]},{"name":"subscreenY","description":"","full":"const int subscreenYconst int subscreenY","type":"property","arguments":[]},{"name":"team","description":"","full":"const TEAM::Color teamconst TEAM::Color team","type":"property","arguments":[]},{"name":"teamRed","description":"","full":"const bool teamRedconst bool teamRed","type":"property","arguments":[]},{"name":"timerPersists","description":"","full":"bool timerPersistsbool timerPersists","type":"property","arguments":[]},{"name":"timerState","description":"","full":"const TIMER::State timerStateconst TIMER::State timerStateconst TIMER::State timerStateconst TIMER::State timerState","type":"property","arguments":[]},{"name":"timerTime","description":"","full":"int timerTimeint timerTime","type":"property","arguments":[]},{"name":"warpID","description":"","full":"const int warpIDconst int warpID","type":"property","arguments":[]},{"name":"xAcc","description":"","full":"float xAccfloat xAcc","type":"property","arguments":[]},{"name":"xOrg","description":"","full":"float xOrgfloat xOrg","type":"property","arguments":[]},{"name":"xPos","description":"","full":"float xPosfloat xPos","type":"property","arguments":[]},{"name":"xSpeed","description":"","full":"float xSpeedfloat xSpeed","type":"property","arguments":[]},{"name":"yAcc","description":"","full":"float yAccfloat yAcc","type":"property","arguments":[]},{"name":"yOrg","description":"","full":"float yOrgfloat yOrg","type":"property","arguments":[]},{"name":"yPos","description":"","full":"float yPosfloat yPos","type":"property","arguments":[]},{"name":"ySpeed","description":"","full":"float ySpeedfloat ySpeed","type":"property","arguments":[]},{"name":"activateBoss","description":"","full":"void activateBoss(bool activate = true)","type":"function","arguments":[{"type":"bool","name":"activate","defaultValue":"true","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"","full":"void cameraFreeze(float xPixel, float yPixel, bool centered, bool instant)","type":"function","arguments":[{"type":"float","name":"xPixel","attributes":[],"items":[]},{"type":"float","name":"yPixel","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"","full":"void cameraFreeze(bool xUnfreeze, float yPixel, bool centered, bool instant)","type":"function","arguments":[{"type":"bool","name":"xUnfreeze","attributes":[],"items":[]},{"type":"float","name":"yPixel","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"","full":"void cameraFreeze(float xPixel, bool yUnfreeze, bool centered, bool instant)","type":"function","arguments":[{"type":"float","name":"xPixel","attributes":[],"items":[]},{"type":"bool","name":"yUnfreeze","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"","full":"void cameraFreeze(bool xUnfreeze, bool yUnfreeze, bool centered, bool instant)","type":"function","arguments":[{"type":"bool","name":"xUnfreeze","attributes":[],"items":[]},{"type":"bool","name":"yUnfreeze","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraUnfreeze","description":"","full":"void cameraUnfreeze(bool instant = true)","type":"function","arguments":[{"type":"bool","name":"instant","defaultValue":"true","attributes":[],"items":[]}]},{"name":"doesCollide","description":"","full":"bool doesCollide(const jjOBJ@ object, bool always = false) const","type":"function","arguments":[{"type":"jjOBJ@","name":"object","attributes":["const"],"items":[]},{"type":"bool","name":"always","defaultValue":"false","attributes":[],"items":[]}]},{"name":"extendInvincibility","description":"","full":"int extendInvincibility(int duration)","type":"function","arguments":[{"type":"int","name":"duration","attributes":[],"items":[]}]},{"name":"fireBullet","description":"","full":"int fireBullet(uint8 gun = WEAPON::CURRENT, bool depleteAmmo = true, bool requireAmmo = true, DIRECTION::Dir direction = DIRECTION::CURRENT)","type":"function","arguments":[{"type":"uint8","name":"gun","defaultValue":"WEAPON::CURRENT","attributes":[],"items":[]},{"type":"bool","name":"depleteAmmo","defaultValue":"true","attributes":[],"items":[]},{"type":"bool","name":"requireAmmo","defaultValue":"true","attributes":[],"items":[]},{"type":"DIRECTION::Dir","name":"direction","defaultValue":"DIRECTION::CURRENT","attributes":[],"items":["RIGHT","LEFT","UP","CURRENT"]}]},{"name":"fireBullet","description":"","full":"int fireBullet(uint8 gun, bool depleteAmmo, bool requireAmmo, float angle)","type":"function","arguments":[{"type":"uint8","name":"gun","attributes":[],"items":[]},{"type":"bool","name":"depleteAmmo","attributes":[],"items":[]},{"type":"bool","name":"requireAmmo","attributes":[],"items":[]},{"type":"float","name":"angle","attributes":[],"items":[]}]},{"name":"freeze","description":"","full":"void freeze(bool frozen = true)","type":"function","arguments":[{"type":"bool","name":"frozen","defaultValue":"true","attributes":[],"items":[]}]},{"name":"furGet","description":"","full":"void furGet(uint8 &out a, uint8 &out b, uint8 &out c, uint8 &out d) const","type":"function","arguments":[{"type":"uint8","name":"&out","attributes":[],"items":[]},{"type":"uint8","name":"&out","attributes":[],"items":[]},{"type":"uint8","name":"&out","attributes":[],"items":[]},{"type":"uint8","name":"&out","attributes":[],"items":[]}]},{"name":"furSet","description":"","full":"void furSet(uint8 a, uint8 b, uint8 c, uint8 d)","type":"function","arguments":[{"type":"uint8","name":"a","attributes":[],"items":[]},{"type":"uint8","name":"b","attributes":[],"items":[]},{"type":"uint8","name":"c","attributes":[],"items":[]},{"type":"uint8","name":"d","attributes":[],"items":[]}]},{"name":"getObjectHitForce","description":"","full":"int getObjectHitForce(const jjOBJ@ target = null) const","type":"function","arguments":[{"type":"jjOBJ@","name":"target","attributes":["const"],"items":[]}]},{"name":"hasPrivilege","description":"","full":"bool hasPrivilege(const string &in privilege, uint moduleID = jjScriptModuleID) const","type":"function","arguments":[{"type":"string","name":"privilege","attributes":["const","&in"],"items":[]},{"type":"uint","name":"moduleID","defaultValue":"jjScriptModuleID","attributes":[],"items":[]}]},{"name":"hurt","description":"","full":"bool hurt(int8 damage = 1, bool forceHurt = false, jjPLAYER@ attacker = null)","type":"function","arguments":[{"type":"int8","name":"damage","defaultValue":"1","attributes":[],"items":[]},{"type":"bool","name":"forceHurt","defaultValue":"false","attributes":[],"items":[]},{"type":"jjPLAYER@","name":"attacker","defaultValue":"null","attributes":[],"items":[]}]},{"name":"isEnemy","description":"","full":"bool isEnemy(const jjPLAYER &in victim) const","type":"function","arguments":[{"type":"jjPLAYER","name":"victim","attributes":["const","&in"],"items":[]}]},{"name":"kill","description":"","full":"void kill()","type":"function","arguments":[]},{"name":"limitXScroll","description":"","full":"void limitXScroll(uint16 left, uint16 width)","type":"function","arguments":[{"type":"uint16","name":"left","attributes":[],"items":[]},{"type":"uint16","name":"width","attributes":[],"items":[]}]},{"name":"morph","description":"","full":"CHAR::Char morph(bool rabbitsOnly = false, bool morphEffect = true)","type":"function","arguments":[{"type":"bool","name":"rabbitsOnly","defaultValue":"false","attributes":[],"items":[]},{"type":"bool","name":"morphEffect","defaultValue":"true","attributes":[],"items":[]}]},{"name":"morphTo","description":"","full":"CHAR::Char morphTo(CHAR::Char charNew, bool morphEffect = true)","type":"function","arguments":[{"type":"CHAR::Char","name":"charNew","attributes":[],"items":["JAZZ","SPAZ","LORI","BIRD","FROG","BIRD2"]},{"type":"bool","name":"morphEffect","defaultValue":"true","attributes":[],"items":[]}]},{"name":"objectHit","description":"","full":"bool objectHit(jjOBJ@ target, int force, HANDLING::Player playerHandling)","type":"function","arguments":[{"type":"jjOBJ@","name":"target","attributes":[],"items":[]},{"type":"int","name":"force","attributes":[],"items":[]},{"type":"HANDLING::Player","name":"playerHandling","attributes":[],"items":["PICKUP","ENEMY","SPECIAL","PICKUP","ENEMYBULLET","PLAYERBULLET"]}]},{"name":"offsetPosition","description":"","full":"bool offsetPosition(int xPixels, int yPixels)","type":"function","arguments":[{"type":"int","name":"xPixels","attributes":[],"items":[]},{"type":"int","name":"yPixels","attributes":[],"items":[]}]},{"name":"poleSpin","description":"","full":"void poleSpin(float xSpeed, float ySpeed, uint delay = 70)","type":"function","arguments":[{"type":"float","name":"xSpeed","attributes":[],"items":[]},{"type":"float","name":"ySpeed","attributes":[],"items":[]},{"type":"uint","name":"delay","defaultValue":"70","attributes":[],"items":[]}]},{"name":"resetLight","description":"","full":"uint8 resetLight()","type":"function","arguments":[]},{"name":"revertMorph","description":"","full":"CHAR::Char revertMorph(bool morphEffect = true)","type":"function","arguments":[{"type":"bool","name":"morphEffect","defaultValue":"true","attributes":[],"items":[]}]},{"name":"setName","description":"","full":"bool setName(const string &in name)","type":"function","arguments":[{"type":"string","name":"name","attributes":["const","&in"],"items":[]}]},{"name":"setScore","description":"","full":"int setScore(int score)","type":"function","arguments":[{"type":"int","name":"score","attributes":[],"items":[]}]},{"name":"showText","description":"","full":"void showText(uint8 textID, uint8 offset, STRING::Size size = STRING::SMALL)","type":"function","arguments":[{"type":"uint8","name":"textID","attributes":[],"items":[]},{"type":"uint8","name":"offset","attributes":[],"items":[]},{"type":"STRING::Size","name":"size","defaultValue":"STRING::SMALL","attributes":[],"items":["SMALL","MEDIUM","LARGE"]}]},{"name":"showText","description":"","full":"void showText(string text, STRING::Size size = STRING::SMALL)","type":"function","arguments":[{"type":"string","name":"text","attributes":[],"items":[]},{"type":"STRING::Size","name":"size","defaultValue":"STRING::SMALL","attributes":[],"items":["SMALL","MEDIUM","LARGE"]}]},{"name":"spring","description":"","full":"void spring(float xSpeed, float ySpeed, bool keepZeroSpeeds, bool sample)","type":"function","arguments":[{"type":"float","name":"xSpeed","attributes":[],"items":[]},{"type":"float","name":"ySpeed","attributes":[],"items":[]},{"type":"bool","name":"keepZeroSpeeds","attributes":[],"items":[]},{"type":"bool","name":"sample","attributes":[],"items":[]}]},{"name":"startSugarRush","description":"","full":"bool startSugarRush(int time = 1400)","type":"function","arguments":[{"type":"int","name":"time","defaultValue":"1400","attributes":[],"items":[]}]},{"name":"suckerTube","description":"","full":"void suckerTube(int xSpeed, int ySpeed, bool center, bool noclip = false, bool trigSample = false)","type":"function","arguments":[{"type":"int","name":"xSpeed","attributes":[],"items":[]},{"type":"int","name":"ySpeed","attributes":[],"items":[]},{"type":"bool","name":"center","attributes":[],"items":[]},{"type":"bool","name":"noclip","defaultValue":"false","attributes":[],"items":[]},{"type":"bool","name":"trigSample","defaultValue":"false","attributes":[],"items":[]}]},{"name":"testForCoins","description":"","full":"bool testForCoins(int numberOfCoins)","type":"function","arguments":[{"type":"int","name":"numberOfCoins","attributes":[],"items":[]}]},{"name":"testForGems","description":"","full":"bool testForGems(int numberOfGems, GEM::Color type)","type":"function","arguments":[{"type":"int","name":"numberOfGems","attributes":[],"items":[]},{"type":"GEM::Color","name":"type","attributes":[],"items":["RED","GREEN","BLUE","PURPLE"]}]},{"name":"timerFunction","description":"","full":"void timerFunction(string functionName)","type":"function","arguments":[{"type":"string","name":"functionName","attributes":[],"items":[]}]},{"name":"timerFunction","description":"","full":"void timerFunction(jjVOIDFUNC@ function)","type":"function","arguments":[{"type":"jjVOIDFUNC@","name":"function","attributes":[],"items":[]}]},{"name":"timerFunction","description":"","full":"void timerFunction(jjVOIDFUNCPLAYER@ function)","type":"function","arguments":[{"type":"jjVOIDFUNCPLAYER@","name":"function","attributes":[],"items":[]}]},{"name":"timerPause","description":"","full":"TIMER::State timerPause()","type":"function","arguments":[]},{"name":"timerResume","description":"","full":"TIMER::State timerResume()","type":"function","arguments":[]},{"name":"timerStart","description":"","full":"TIMER::State timerStart(int ticks, bool startPaused = false)","type":"function","arguments":[{"type":"int","name":"ticks","attributes":[],"items":[]},{"type":"bool","name":"startPaused","defaultValue":"false","attributes":[],"items":[]}]},{"name":"timerStop","description":"","full":"TIMER::State timerStop()","type":"function","arguments":[]},{"name":"warpToID","description":"","full":"bool warpToID(uint8 warpID, bool fast = false)","type":"function","arguments":[{"type":"uint8","name":"warpID","attributes":[],"items":[]},{"type":"bool","name":"fast","defaultValue":"false","attributes":[],"items":[]}]},{"name":"warpToTile","description":"","full":"bool warpToTile(int xTile, int yTile, bool fast = false)","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]},{"type":"bool","name":"fast","defaultValue":"false","attributes":[],"items":[]}]}]