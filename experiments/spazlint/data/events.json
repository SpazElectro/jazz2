[{"name":"onChat","description":"onChat is called whenever a chat message pops up in game. onLocalChat is called only when chat is received from players on the same machine the script is executing on. A return value of true indicates that the chat message should be suppressed, whereas a return value of false will cause the message to be handled normally. clientID is a unique ID of the game client that sent the chat message. stringReceived is the text of the chat message that was received. chatType can take one of the following values: NORMAL, TEAMCHAT, WHISPER amd ME.\nAny message beginning with \"/\" is interpreted as a command, not as chat, and so will not be passed to either of these hooks. Messages beginning with \"!\" will, though, as will arguments of commands /whisper (and its aliases, /w and @) and /me.\n","full":"void onChat(int clientID, string &in stringReceived, CHAT::Type chatType)","type":"function","arguments":[{"type":"int","name":"clientID","attributes":[],"items":[]},{"type":"string","name":"&in","attributes":[],"items":[]},{"type":"CHAT::Type","name":"chatType","attributes":[],"items":["NORMAL","TEAMCHAT","WHISPER","ME"]}]},{"name":"onLocalChat","description":"This function is called in single player mode when a player attempts to enter a cheat code. It will be called once for each letter appended to the cheat code after jj. For example, in typing jjgod, onCheat will be called three times, with cheat equal to \"jjg\", \"jjgo\" and \"jjgod\". A return value of true indicates the cheat should be suppressed, whereas a return value of false will cause the cheat to be handled normally. If you want to compare cheat to the full list of standard cheat codes, use jjIsValidCheat, which will be updated if JJ2+ adds or changes any cheat codes in future releases.\nIf the player attempts to enter or exit debug mode by pressing the F10 key, this function will be called with cheat equaling \"f10.\" (This is the only circumstance in which the string will not begin with \"jj.\") You can test whether the player is attempting to enter or exit by checking jjDebugF10.\n","full":"bool onLocalChat(string &in stringReceived, CHAT::Type chatType)","type":"function","arguments":[{"type":"string","name":"&in","attributes":[],"items":[]},{"type":"CHAT::Type","name":"chatType","attributes":[],"items":["NORMAL","TEAMCHAT","WHISPER","ME"]}]},{"name":"onCheat","description":"Also called only at the beginning of the level, but a little bit later, once things have had time to be initialized. For example, onLevelLoad is fired before any jjOBJs have been created and before certain jjPLAYER properties have been initialized, so onLevelBegin allows you to modify those things as well.\n","full":"bool onCheat(string &in cheat)","type":"function","arguments":[{"type":"string","name":"&in","attributes":[],"items":[]}]},{"name":"onLevelLoad","description":"This function is only ever called in Single Player, where it is called every time the player dies, after everything in the level has been reinitialized. Since a great number of things get reset in Single Player when the player dies, this is your chance to make sure some things stay the same.\n","full":"void onLevelLoad()","type":"function","arguments":[]},{"name":"onLevelBegin","description":"This function can be called even more often than onMain: it is called once per tick per local player. If you're playing splitscreen with two players, for instance, it will be called two times per tick. This is a useful distinction because of the jjPLAYER@ parameter, which points to the local player every time onPlayer is called. If you want to prevent blaster from ever being used in a level, for instance, void onPlayer(jjPLAYER@ play) { play.noFire = (play.currWeapon == WEAPON::BLASTER); } is one way of doing that, whereas trying to do the same in onMain would at minimum require manually looping through the jjLocalPlayers array. To check which jjPLAYER is being invoked during any given onPlayer, use the jjPLAYER.localPlayerID property.\n(JJ2+ used to encourage use of a global property p (or occasionally jjP), which performed the same function as the jjPLAYER@ argument. This coding style still works in certain cases, to ensure backwards compatibility with older scripts, but can be unclear and is deprecated/stylistically discouraged.)\n","full":"void onLevelBegin()","type":"function","arguments":[]},{"name":"onGameStart","description":"This function works essentially the same way as onPlayer, and is called very slightly earlier in the tick, but with a caveat: it is only called when the player's input properties, keyRight and keyJump and so on, have had the potential to change. In particular, it is not called while chatting in a multiplayer game unless the player can be moved by a joystick/controller instead of the keyboard. Because of this unpredictability, it should only be used for situations specifically relating to input, for instance swapping the effects of a player's right and left keys.\n","full":"void onGameStart()","type":"function","arguments":[]},{"name":"onGameStart","description":"This function is something of a special case. By default, when a Player Timer runs out (see the jjPLAYER section below), this function will be called for the player whose timer just ran out. However, a single level may have multiple timer sections with different purposes -- one where you die for not doing something quickly enough, one where you warp after a certain delay, and so on -- so it is also possible to change the function called using the jjPLAYER method timerFunction. Thus onPlayerTimerEnd is simply the default function name, not the only one you are allowed to use for this purpose.\n","full":"void onGameStart(bool firstTime)","type":"function","arguments":[{"type":"bool","name":"firstTime","attributes":[],"items":[]}]},{"name":"onGameStop","description":"This function is called every time a player is roasted, including non-local players, including self-inflicted deaths from pits and other environmental hazards (in which case victim is killer will be true). Note however that not every death counts as a roast, e.g. deaths from the /frustration command or from unspectating.\n","full":"void onGameStop()","type":"function","arguments":[]},{"name":"onGameStop","description":"","full":"void onGameStop(bool firstTime)","type":"function","arguments":[{"type":"bool","name":"firstTime","attributes":[],"items":[]}]},{"name":"onLevelReload","description":"","full":"void onLevelReload()","type":"function","arguments":[]},{"name":"onMain","description":"","full":"void onMain()","type":"function","arguments":[]},{"name":"onPlayer","description":"","full":"void onPlayer(jjPLAYER@ play)","type":"function","arguments":[{"type":"jjPLAYER@","name":"play","attributes":[],"items":[]}]},{"name":"onPlayerInput","description":"","full":"void onPlayerInput(jjPLAYER@ play)","type":"function","arguments":[{"type":"jjPLAYER@","name":"play","attributes":[],"items":[]}]},{"name":"onPlayerTimerEnd","description":"","full":"void onPlayerTimerEnd(jjPLAYER@ play)","type":"function","arguments":[{"type":"jjPLAYER@","name":"play","attributes":[],"items":[]}]},{"name":"onRoast","description":"","full":"void onRoast(jjPLAYER@ victim, jjPLAYER@ killer)","type":"function","arguments":[{"type":"jjPLAYER@","name":"victim","attributes":[],"items":[]},{"type":"jjPLAYER@","name":"killer","attributes":[],"items":[]}]}]