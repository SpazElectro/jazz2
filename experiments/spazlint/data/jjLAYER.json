[{"name":"cylinder","description":"bool cylinder.fade, when true, increasingly affects colors closer to the horizon: when jjColorDepth is 16, a semitransparent glowing line appears across the horizon using the RGB color chosen by cylinder.setFadeColor, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.\nfloat cylinder.fadePositionX and float cylinder.fadePositionY set the location of the center of the horizon, as multiplied by the size of the player's screen. The default values are both 0.5. Changing fadePositionY very far from 0.5 tends to look weird, especially when cylinder.halfSize is true.\nbool cylinder.halfSize, when true, stretches the texture four times across the screen instead of only once and makes the curvature more extreme. The default value is false.\njjPALCOLOR cylinder.getFadeColor() const and void cylinder.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the horizon when cylinder.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n","full":"cylinder","type":"property","arguments":[]},{"name":"hasTileMap","description":"Assuming the layer's tileHeight is false and its ySpeedModel is either LAYERSPEEDMODEL::NORMAL or LAYERSPEEDMODEL::BOTHSPEEDS, whether the layer should be vertically offset some pixels downward (true) or not (false), the exact value depending on the current resolution.\n","full":"const bool hasTileMapconst bool hasTileMap","type":"property","arguments":[]},{"name":"hasTiles","description":"uint8 menu.palrow16 and uint8 menu.palrow32 and uint8 menu.palrow256 pick the 16-color-long palette rows used by the three different rotating sublayers, with the smaller numbers corresponding to the further back sublayers. The default values are all 0.\nfloat menu.pivotX and float menu.pivotY are the point that all rotation happens around, as multiplied by the size of the player's screen. The default values are both 0.5.\n","full":"bool hasTilesbool hasTiles","type":"property","arguments":[]},{"name":"height","description":"float reflection.fadePositionX sets the location of the horizontal center of the horizon, as multiplied by the size of the player's screen. The default value is 0.5.\nuint8 reflection.tintColor and uint8 reflection.tintOpacity combine to draw a constant semitransparent color over the entire reflective plane, similar to drawing a rectangle with SPRITE::BLEND_NORMAL but better optimized. Their default values are 192 (the middle palette index from the 176�207 color gradient used by most textured background images) and 0 (no tint at all) respectively.\nbool reflection.blur, when true, applies a post-processing horizontal blur effect to the outcome in 16-bit color mode. Has no effect in 8-bit color mode. The default value is false.\nfloat reflection.top sets the location of the vertical center of the horizon, as multiplied by the size of the player's screen. What this means is that everything below the vertical center reflects everything above the vertical center. When there are more horizontal lines of the screen that are reflecting than there are lines to be reflected�most commonly, when this property is set to a lower number than the default value of 0.5�the top line of the screen is repeated as many times as necessary to make up the difference. When the entire screen is taken up by 3D plane, pure blackness will be reflected\n","full":"const int heightconst int height","type":"property","arguments":[]},{"name":"limitVisibleRegion","description":"Not settable in JCS: the offset of the angle at which this layer rotates while a player is stoned, with a domain of 0�1023 to be passed to jjSin and jjCos.\nLayers 1�8 have values -512, -256, 0, 0, 0, 256, 512, and 768, respectively. A script-created jjLAYER will default to 0.\n","full":"bool limitVisibleRegionbool limitVisibleRegion","type":"property","arguments":[]},{"name":"menu","description":"Not settable in JCS: the multipler of the distance this layer is offset from its center while rotating while a player is stoned. A value of 0 means the layer will not rotate at all; jjLayers[5].rotationRadiusMultiplier = 0; might therefore be a useful line of code in levels that give Layer 5 speed values to match Layer 4's.\nLayers 1�8 have values 4, 3, 0, 0, 2, 2, 1, and 1, respectively. A script-created jjLAYER will default to 0.\n","full":"menu","type":"property","arguments":[]},{"name":"reflection","description":"Whether this layer should be drawn as a texture effect instead of as a regular grid of tiles, and if so, to which parts of the screen it should be drawn. A few enum options are available:\n\t\t\t\t\n\t\t\t\t\tSURFACE::UNTEXTURED: The default, corresponding to leaving the \"Texture mode\" checkbox for this layer unchecked in JCS. The layer will be drawn as a grid of tiles.\n\t\t\t\t\tSURFACE::LEGACY: Used by default by layers in levels (either as part of the main level or imported using jjLayersFromLevel) that have the \"Texture mode\" checkbox checked in JCS and use TEXTURE::WARPHORIZON. When used on layers other than layer 8, this option nevertheless copies many of layer 8's properties when deciding how to draw the texture, and may in some circumstances draw the warp horizon effect to only certain areas of the subscreen. This is included for backwards compatibility but FULLSCREEN should usually be preferable.\n\t\t\t\t\tSURFACE::FULLSCREEN: New in JJ2+. Used by default by layers with the \"Texture mode\" checkbox checked that use any textureStyle other than WARPHORIZON. Draws the texture mode to each player's entire subscreen.\n\t\t\t\t\tSURFACE::INNERWINDOW\n\t\t\t\t\tSURFACE::INNERLAYER: New in JJ2+. The layer will be drawn as some sort of texture effect, but within the same rectangular area that the layer would be drawn were it being drawn as a grid of tiles instead. This allows you to have multiple texture effects on-screen at once or do other cool tricks. The inner speed properties will be used for angling the texture within the layer's area. The difference between the two is that INNERWINDOW acts as if the texture were being drawn to the full size of the subscreen, and provides a layer-sized window to a portion of that full screen effect, whereas INNERLAYER exclusively uses the origin and dimensions of the layer itself. For example, consider a warp horizon texture effect drawn to the top half of the subscreen with fadePositionY at 0.5. Using INNERWINDOW, the fade effect will be drawn halfway down the subscreen, at the bottom of the layer. Using INNERLAYER, the fade effect will be drawn halfway down the layer, one quarter of the way down the subscreen. On tiled dimensions (using tileHeight and/or tileWidth), there is no difference between INNERWINDOW and INNERLAYER, and if both dimensions are tiled, there is no difference between either and FULLSCREEN, except for the use of the inner speed properties.\n\t\t\t\t\n","full":"reflection","type":"property","arguments":[]},{"name":"rotationAngle","description":"float tunnel.fadePositionX and float tunnel.fadePositionY set the location of the center of the tunnel, clamped to a 0�1 range, as multiplied by the size of the player's screen. The default values are both 0.5.\nbool tunnel.spiral, when true, makes the concentric circles gradually spiral inwards into the distance. The default value is false.\njjPALCOLOR tunnel.getFadeColor() const and void tunnel.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the center when tunnel.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n","full":"int rotationAngleint rotationAngle","type":"property","arguments":[]},{"name":"rotationRadiusMultiplier","description":"float warpHorizon.fadePositionX and float warpHorizon.fadePositionY set the location of the center of the horizon, as multiplied by the size of the player's screen. The default values are both 0.5.\nbool warpHorizon.stars, when true, draws a series of little white specks appear across the horizon. The default value is false.\njjPALCOLOR warpHorizon.getFadeColor() const and void warpHorizon.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the horizon when warpHorizon.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n","full":"int rotationRadiusMultiplierint rotationRadiusMultiplier","type":"property","arguments":[]},{"name":"spriteMode","description":"bool wave.distortionAngle effectively rotates the movement of the two distortions ninety degrees. The default value is false.\nuint8 wave.wavelengthX and uint8 wave.wavelengthY set the lengths of the distortions, with powers-of-two-minus-one such as 255 being recommended. Their default values are 0.\nint8 wave.waveSpeed moves the distortions along the surface of the texture, independent of the texture's movement as set by the regular or inner speed properties. Both distortions move at the same rate as determined by this property's absolute value, with the directions resulting from the sign of this property combined with and wave.distortionAngle. The default value is 0.\n","full":"SPRITE::Mode spriteModeSPRITE::Mode spriteMode","type":"property","arguments":[]},{"name":"spriteParam","description":"int8 wave.waveSpeed moves the distortions along the surface of the texture, independent of the texture's movement as set by the regular or inner speed properties. Both distortions move at the same rate as determined by this property's absolute value, with the directions resulting from the sign of this property combined with and wave.distortionAngle. The default value is 0.\n","full":"uint8 spriteParamuint8 spriteParam","type":"property","arguments":[]},{"name":"texture","description":"The auto speed of the layer, as seen in the JCS Layer Properties window.\n","full":"TEXTURE::Texture textureTEXTURE::Texture texture","type":"property","arguments":[]},{"name":"textureSurface","description":"Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n","full":"SURFACE::Surface textureSurfaceSURFACE::Surface textureSurface","type":"property","arguments":[]},{"name":"textureStyle","description":"Not settable in JCS: constant pixel values added to the position of the layer, regardless of its speed.\n","full":"TEXTURE::Style textureStyleTEXTURE::Style textureStyle","type":"property","arguments":[]},{"name":"tileHeight","description":"Not settable in JCS: specifies how the layer's position on screen should be determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed properties, the resolution, and so on. There are several options available for the enum, as follows (for each axis):\n\t\t\t\t\n\t\t\t\t\tLAYERSPEEDMODEL::NORMAL: The default. A non-textured layer's position on this axis will be based on the layer's auto speed for this axis, if non-zero, or otherwise its regular speed. Except for jjLayers[8], only the layers that use this mode for both axes will ever be displayed when Low Detail is enabled.\n\t\t\t\t\tLAYERSPEEDMODEL::LAYER8: The default for jjLayers[8] only, a pair of odd behaviors included for backwards compatibility. A non-textured layer with this setting will ignore all speed and offset settings completely and be tied to the top/left side of the screen. A textured layer will instead base its position for this axis on that of jjLayers[5].\n\t\t\t\t\tLAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this axis will both be used in determining the position: for example, a layer of clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to scroll constantly to the left but also move left or right in response to the player's camera.\n\t\t\t\t\tLAYERSPEEDMODEL::FROMSTART: Similar to LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the resolution and its speeds, and the top/left side of a layer will only be flush with the top/left side of the level if the layer's speed is 1 or the resolution is 320�200. Using this setting forces the layer's origin to be at the top/left side of the level instead of varying by the resolution. Ignores limitVisibleRegion.\n\t\t\t\t\tLAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed properties, and instead ensures that the full extent of this layer will be visible and no blank space outside of it will be shown. The top/left side of the layer will be visible at the top/left edge of the level, and the bottom/right side of the layer will be visible at the bottom/right edge of the level, and the layer will scroll smoothly between those two extremes. Thus, the taller/wider the layer, the faster it will move, though with the exact relative speed dependent on the resolution and level size. If the layer is smaller than the window on this axis, this will effectively result in a negative relative speed.\n\t\t\t\t\tLAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed properties on this axis as multipliers of the current camera size, rather than camera position. When the camera is at the top/left of the level, the layer will be positioned at the camera size on this axis multiplied by the regular speed, or the auto speed instead when the camera is at the bottom/right, and the layer will scroll smoothly between those two extremes. For example, if the screen is 600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the layer will be 450 pixels from the top of the screen when the camera is at the top of the level, and 300 pixels from the top of the screen when the camera is at the bottom of the level. Ignores limitVisibleRegion.\n\t\t\t\t\nNote that all mentions of \"textured\" layers in the above descriptions refer to when textureSurface is LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL, WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied to whatever position is determined by the rules above. If such a layer uses MENU or TILEMENU instead, then its speed models are ignored altogether.\nFor INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they would be for non-textured layers for determining the layer's position within the level, and the inner speed properties are used for determining the texture's position within the layer.\n","full":"bool tileHeightbool tileHeight","type":"property","arguments":[]},{"name":"tileWidth","description":"Makes all tiles in the range of the rectangle with its top left corner at xTile,yTile and specified width and height possible to use tileSet on without the potential consequence of changing other occurrences of the tile in the level due to tile cache. The zero-argument version of the method applies to the entire layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and height to height. Does nothing if hasTileMap is false.\n","full":"bool tileWidthbool tileWidth","type":"property","arguments":[]},{"name":"tileMenu","description":"Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is masked. Returns false if hasTileMap is false.\n","full":"tileMenu","type":"property","arguments":[]},{"name":"tunnel","description":"Changes the X or Y speed. Unlike the basic properties like xSpeed and yAutoSpeed, these functions will ensure that the layer remains in the same position it was before its speeds were changed, and can therefore be much more useful.\n","full":"tunnel","type":"property","arguments":[]},{"name":"warpHorizon","description":"","full":"warpHorizon","type":"property","arguments":[]},{"name":"wave","description":"","full":"wave","type":"property","arguments":[]},{"name":"width","description":"","full":"const int widthconst int width","type":"property","arguments":[]},{"name":"widthReal","description":"","full":"const int widthRealconst int widthReal","type":"property","arguments":[]},{"name":"widthRounded","description":"","full":"const int widthRoundedconst int widthRounded","type":"property","arguments":[]},{"name":"xAutoSpeed","description":"","full":"float xAutoSpeedfloat xAutoSpeed","type":"property","arguments":[]},{"name":"yAutoSpeed","description":"","full":"float yAutoSpeedfloat yAutoSpeed","type":"property","arguments":[]},{"name":"xInnerAutoSpeed","description":"","full":"float xInnerAutoSpeedfloat xInnerAutoSpeed","type":"property","arguments":[]},{"name":"yInnerAutoSpeed","description":"","full":"float yInnerAutoSpeedfloat yInnerAutoSpeed","type":"property","arguments":[]},{"name":"xInnerSpeed","description":"","full":"float xInnerSpeedfloat xInnerSpeed","type":"property","arguments":[]},{"name":"yInnerSpeed","description":"","full":"float yInnerSpeedfloat yInnerSpeed","type":"property","arguments":[]},{"name":"xOffset","description":"","full":"float xOffsetfloat xOffset","type":"property","arguments":[]},{"name":"yOffset","description":"","full":"float yOffsetfloat yOffset","type":"property","arguments":[]},{"name":"xSpeed","description":"","full":"float xSpeedfloat xSpeed","type":"property","arguments":[]},{"name":"ySpeed","description":"","full":"float ySpeedfloat ySpeed","type":"property","arguments":[]},{"name":"xSpeedModel","description":"","full":"LAYERSPEEDMODEL::LayerSpeedModel xSpeedModelLAYERSPEEDMODEL::LayerSpeedModel xSpeedModel","type":"property","arguments":[]},{"name":"ySpeedModel","description":"","full":"LAYERSPEEDMODEL::LayerSpeedModel ySpeedModelLAYERSPEEDMODEL::LayerSpeedModel ySpeedModel","type":"property","arguments":[]},{"name":"generateSettableTileArea","description":"","full":"void generateSettableTileArea()","type":"function","arguments":[]},{"name":"generateSettableTileArea","description":"","full":"void generateSettableTileArea(int xTile, int yTile, int width, int height)","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]},{"type":"int","name":"width","attributes":[],"items":[]},{"type":"int","name":"height","attributes":[],"items":[]}]},{"name":"getXPosition","description":"","full":"float getXPosition(const jjPLAYER &in play) const","type":"function","arguments":[{"type":"jjPLAYER","name":"play","attributes":["const","&in"],"items":[]}]},{"name":"getYPosition","description":"","full":"float getYPosition(const jjPLAYER &in play) const","type":"function","arguments":[{"type":"jjPLAYER","name":"play","attributes":["const","&in"],"items":[]}]},{"name":"maskedHLine","description":"","full":"bool maskedHLine(int xPixel, int lineLength, int yPixel) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"lineLength","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]}]},{"name":"maskedPixel","description":"","full":"bool maskedPixel(int xPixel, int yPixel) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]}]},{"name":"maskedTopVLine","description":"","full":"int maskedTopVLine(int xPixel, int yPixel, int lineLength) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"lineLength","attributes":[],"items":[]}]},{"name":"maskedVLine","description":"","full":"bool maskedVLine(int xPixel, int yPixel, int lineLength) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"lineLength","attributes":[],"items":[]}]},{"name":"setXSpeed","description":"","full":"void setXSpeed(float newspeed, bool newSpeedIsAnAutoSpeed)","type":"function","arguments":[{"type":"float","name":"newspeed","attributes":[],"items":[]},{"type":"bool","name":"newSpeedIsAnAutoSpeed","attributes":[],"items":[]}]},{"name":"setYSpeed","description":"","full":"void setYSpeed(float newspeed, bool newSpeedIsAnAutoSpeed)","type":"function","arguments":[{"type":"float","name":"newspeed","attributes":[],"items":[]},{"type":"bool","name":"newSpeedIsAnAutoSpeed","attributes":[],"items":[]}]},{"name":"tileGet","description":"","full":"uint16 tileGet(int xTile, int yTile) const","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]}]},{"name":"tileSet","description":"","full":"uint16 tileSet(int xTile, int yTile, uint16 newTile)","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]},{"type":"uint16","name":"newTile","attributes":[],"items":[]}]}]