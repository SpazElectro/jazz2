{"jjPLAYERList":[{"name":"alreadyDoubleJumped","description":"Whether it is currently impossible for the player to double jump, assuming they're Spaz and currently in the air. To allow compatibility with multiple air jumps, this was replaced with doubleJumpCount.\n","full":"bool alreadyDoubleJumped","type":"property","arguments":[]},{"name":"ammo[WEAPON::Weapon]","description":"How much ammo the player has of each ammo type. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their allowed properties to true in the jjWeapons array.\n","full":"int ammo[WEAPON::Weapon]","type":"property","arguments":[]},{"name":"ammo[9]","description":"How much ammo the player has of each ammo type. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their allowed properties to true in the jjWeapons array.\n","full":"int ammo[9]","type":"property","arguments":[]},{"name":"antiGrav","description":"Whether the player falls up (true) or down (false). Also causes the player to be drawn upside-down.\n(For the record, this mode is still a work-in-progress. A handful of objects�bridges, pinball flippers, and rotating poles�don't work very well with it yet. However, future revisions will be backwards compatible with what works already, so don't hold off on using it for that reason unless it truly can't do yet what you need it do.)\n","full":"bool antiGrav","type":"property","arguments":[]},{"name":"ballTime","description":"If greater than 0, how much longer (in ticks) the player will be tucked into a ball.\n","full":"int ballTime","type":"property","arguments":[]},{"name":"blink","description":"If greater than 0, how much longer (in ticks) the player will be blinking and invincible and unable to collide with other players, as if recently hurt. Works online.\n","full":"int blink","type":"property","arguments":[]},{"name":"boss","description":"The object ID of the jjOBJ whose energy is shown in the boss health meter, or -1 if the health meter is receding off the top of the screen, or 0 if the player is not fighting any boss.\nMore specifically, the boss health meter will show the energy of the jjOBJ as a percentage of its initial health as described in its entry in jjObjectPresets. If you create a Tuf Turtle enemy, give it 100 health, and assign a jjPLAYER's boss its object ID, JJ2 will still assume the Tuf Turtle started out at 4 health, not 100. On the other hand, if you write jjObjectPresets[OBJECT::TUFTURT].energy = 100; first, then the boss health meter will work as you might want it to.\n","full":"int boss","type":"property","arguments":[]},{"name":"bossActivated","description":"The bool set by the Activate Boss event or the activateBoss method. In general, you should make sure this property is true for at least one local player when writing behaviors for custom bosses.\n","full":"bool bossActivated","type":"property","arguments":[]},{"name":"buttstomp","description":"Buttstomp phase. Values below 41 mean the player is initializing a buttstomp, 41 means the player is currently buttstomping, values between 41 and 121 mean the player is landing on the ground and values of 121 and higher mean the player is not currently buttstomping.\n","full":"int buttstomp","type":"property","arguments":[]},{"name":"cameraX","description":"The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n","full":"const float cameraX","type":"property","arguments":[]},{"name":"cameraY","description":"The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n","full":"const float cameraY","type":"property","arguments":[]},{"name":"charCurr","description":"The player's current character (CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2). This is a read-only value, because you should use morphTo or another related method to change it instead.\n","full":"const CHAR::Char charCurr","type":"property","arguments":[]},{"name":"charOrig","description":"Which character the player began the level as (CHAR::JAZZ, CHAR::SPAZ, or CHAR::LORI), aka the character that the Revert Morph event switches them to.\n","full":"CHAR::Char charOrig","type":"property","arguments":[]},{"name":"clientID","description":"ID of the game instance controlling the player. This is particularly useful for packet exchange with use of jjSendPacket but can also be used to determine whether players are splitscreeners.\n","full":"const int clientID","type":"property","arguments":[]},{"name":"coins","description":"How many coins the player has.\nIf you want to require the player to have a certain number of coins to do something, like with coin warps, consider using the more elaborate testForCoins method instead.\n","full":"int coins","type":"property","arguments":[]},{"name":"curAnim","description":"The current animation the player takes its frames from, serving as an index to the jjAnimations array. Each animation has a distinct value; for example, Jazz standing in place might be 81, but Spaz standing in place might be 185.\n","full":"const uint16 curAnim","type":"property","arguments":[]},{"name":"curFrame","description":"The overall current frame displayed to the screen to represent this player, serving as an index to the jjAnimFrames array. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n","full":"const uint curFrame","type":"property","arguments":[]},{"name":"currTile","description":"A shortcut value, always equalling int(xPos)/32 + int(yPos)/32*65536. Since both xPos and yPos are easily accessible properties, it really only makes sense to use currTile to compare against previous values of currTile, i.e. to see if the player has moved or not.\n","full":"const int currTile","type":"property","arguments":[]},{"name":"currWeapon","description":"Which ammo type the player currently has selected. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\n","full":"uint8 currWeapon","type":"property","arguments":[]},{"name":"deaths","description":"In competitive game modes, the number of deaths the player experienced or a negative value if unknown (this is currently the case when the property is checked by clients in XLRS mode).\n","full":"const int deaths","type":"property","arguments":[]},{"name":"direction","description":"Which direction the player is facing. Negative values mean left and non-negative ones mean right.\n","full":"int8 direction","type":"property","arguments":[]},{"name":"doubleJumpCount","description":"How many times the player used double jump in the air since their last regular jump.\n","full":"int doubleJumpCount","type":"property","arguments":[]},{"name":"fastfire","description":"The waiting time between shots, as decreased by Fastfire events or the JJFIRE cheat code. Starts out at 35�half a second�and decreases to a minimum of 6 (from Fastfire events) or 1 (JJFIRE).\n","full":"int fastfire","type":"property","arguments":[]},{"name":"flag","description":"The object ID of the flag the player is carrying, or 0 if the player is not carrying a flag.\n","full":"const int flag","type":"property","arguments":[]},{"name":"fly","description":"Possible special constant values are FLIGHT::NONE, FLIGHT::FLYCARROT, or FLIGHT::AIRBOARD, from the FLIGHT::Mode enum.\nIf the player is currently using a copter or Cheshire2 object, fly will equal the object ID of that object plus one, which is to say, the jjOBJ the player is holding will be jjObjects[p.fly - 1].\n","full":"int fly","type":"property","arguments":[]},{"name":"food","description":"How much food the player has eaten.\nSetting this to 100 will not cause a sugar rush. Use the startSugarRush method instead.\n","full":"int food","type":"property","arguments":[]},{"name":"frameID","description":"The index of the current frame displayed to the screen to represent this player within its animation. For example, Jazz's standing animation is only one frame long, so his frameID will always equal 0 while playing that animation, while Spaz's will range from 0 to 4. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n","full":"const uint8 frameID","type":"property","arguments":[]},{"name":"frozen","description":"0 if unfrozen; otherwise, constantly counts down towards 0.\n","full":"int8 frozen","type":"property","arguments":[]},{"name":"fur","description":"Palette indexes of the player's fur in the form of 4 colors, 8 bits each. For potentially more intuitive ways of fur color manipulation refer to jjPLAYER methods furGet and furSet. Changes to this setting are automatically shared between all clients in the server. Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n","full":"uint32 fur","type":"property","arguments":[]},{"name":"gems[GEM::Color]","description":"How many gems the player has collected. Possible values of GEM::Color are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n","full":"int gems[GEM::Color]","type":"property","arguments":[]},{"name":"health","description":"How many hearts the player has remaining. If you set this in an online server, all other players will be notified of the change.\n","full":"uint8 health","type":"property","arguments":[]},{"name":"helicopter","description":"The amount of time in which player's copter ears will run out or 0 if the player is currently not using copter ears.\n","full":"int helicopter","type":"property","arguments":[]},{"name":"helicopterElapsed","description":"The amount of time player spent using copter ears since their last jump. If this reaches or exceeds their respective jjCHARACTER::helicopterDurationMax, the player will be unable to use helicopter ears again until they have landed, analogous to using up a double jump.\n","full":"int helicopterElapsed","type":"property","arguments":[]},{"name":"idle","description":"The amount of time since the last change of idle animation or 0 if the player is not idle.\n","full":"int idle","type":"property","arguments":[]},{"name":"invincibility","description":"How much longer the player will be invincible. (Does not work in servers.) Specifically, the absolute value is the remaining duration of the invincibility; a positive number will display the invincibility effect around the player, but a negative number (or zero) will not.\n","full":"int invincibility","type":"property","arguments":[]},{"name":"invisibility","description":"Whether the player is invisible. Invisible players don't have their sprites or names drawn. Changes to this setting are automatically shared between all clients in the server.\n","full":"bool invisibility","type":"property","arguments":[]},{"name":"isActive","description":"Does this jjPLAYER object correspond to an actual player in the server, local or otherwise? If not, few if any of this jjPLAYER's other properties will be reliable. This is a fairly weak check and equals true for several types of players who may be present in the server but not actually playing�isInGame may often be more useful.\n","full":"const bool isActive","type":"property","arguments":[]},{"name":"isAdmin","description":"Whether the player is logged in as a Remote Admin in the current online server. Because admin privileges can vastly differ depending on server and admin group, a more precise tool hasPrivilege exists.\n","full":"const bool isAdmin","type":"property","arguments":[]},{"name":"isConnecting","description":"Whether the player is a client who has not finished joining the current online server yet, as represented by a \"C\" or \"D\" (if downloading) next to their name on the player list.\n","full":"const bool isConnecting","type":"property","arguments":[]},{"name":"isIdle","description":"Whether the player is idle and does not appear in the level or player list. Currently this can only ever be true of the server.\n","full":"const bool isIdle","type":"property","arguments":[]},{"name":"isInGame","description":"Equals true if isActive is true but isConnecting, isIdle, isOut, and isSpectating are all false. If more such properties need to be added in future revisions of JJ2+, isInGame will be updated to reflect them.\n","full":"const bool isInGame","type":"property","arguments":[]},{"name":"isJailed","description":"In Jailbreak game mode, whether the player is currently in jail. False in all other game modes.\n","full":"const bool isJailed","type":"property","arguments":[]},{"name":"isLocal","description":"Is this jjPLAYER object controlled by this instance of JJ2?\n","full":"const bool isLocal","type":"property","arguments":[]},{"name":"isOut","description":"Equals true if the player has lost all their lives (or joined too late) in an LRS-based gamemode.\n","full":"const bool isOut","type":"property","arguments":[]},{"name":"isSpectating","description":"Equals true if the player is spectating normally, i.e. not forced into spectating by being out or an idle server.\n","full":"const bool isSpectating","type":"property","arguments":[]},{"name":"isZombie","description":"In Pestilence game mode, whether the player is currently a zombie. False in all other game modes.\n","full":"const bool isZombie","type":"property","arguments":[]},{"name":"jumpStrength","description":"Vertical speed gained by the player on jump. Defaults to -10.\n","full":"float jumpStrength","type":"property","arguments":[]},{"name":"keyDown","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyDown","type":"property","arguments":[]},{"name":"keyFire","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyFire","type":"property","arguments":[]},{"name":"keyJump","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyJump","type":"property","arguments":[]},{"name":"keyLeft","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyLeft","type":"property","arguments":[]},{"name":"keyRight","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyRight","type":"property","arguments":[]},{"name":"keyRun","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyRun","type":"property","arguments":[]},{"name":"keySelect","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keySelect","type":"property","arguments":[]},{"name":"keyUp","description":"A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n","full":"bool keyUp","type":"property","arguments":[]},{"name":"laps","description":"In Race, the number of laps the player has completed so far. 0 for other modes.\n","full":"const int laps","type":"property","arguments":[]},{"name":"lapTimeBest","description":"In Race, how many ticks it took for this player to run their fastest lap so far. Note that because lapTimes only counts the five most recent laps, lapTimeBest will not appear in that array if this player's fastest lap was not one of their five most recent laps. Undefined for other modes or if laps is still 0.\n","full":"const int lapTimeBest","type":"property","arguments":[]},{"name":"lapTimeCurrent","description":"In Race, how many ticks have elapsed since the player began their current lap. Undefined for other modes.\n","full":"const int lapTimeCurrent","type":"property","arguments":[]},{"name":"lapTimes[5]","description":"In Race, how many ticks it took for this player to run the five most recent laps they completed, where lapTimes[0] is the length of the most recent lap and lapTimes[4] the fifth most recent. If the player has not completed a given lap yet�i.e. if the index used for the lapTimes array is greater or equal to laps�the value will be -1. Undefined for other modes or for players for whom isLocal is false.\n","full":"const int lapTimes[5]","type":"property","arguments":[]},{"name":"light","description":"The intensity of light emitted by the player. Changes to this setting are automatically shared between all clients in the server.\n","full":"int8 light","type":"property","arguments":[]},{"name":"lighting","description":"The player's current level of ambient lighting, as affected by the Set Light and Reset Light events.\n","full":"uint8 lighting","type":"property","arguments":[]},{"name":"lightType","description":"The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER (default). Changes to this setting are automatically shared between all clients in the server.\n","full":"LIGHT::Type lightType","type":"property","arguments":[]},{"name":"lives","description":"In single player or cooperative mode, how many lives the player has remaining. For LRS-based game modes use lrsLives instead. Lives are not displayed in the HUD when jjGameConnection != GAME::LOCAL, but this number still goes up and down as appropriate, even into the negatives; it's just that it has no effect on gameplay.\n","full":"int lives","type":"property","arguments":[]},{"name":"localPlayerID","description":"Which local player the player is, in case of splitscreen. 0-3.\n","full":"const int localPlayerID","type":"property","arguments":[]},{"name":"lrsLives","description":"In LRS-based game modes (LRS, TLRS, XLRS), how many lives the player has remaining, a negative value for other modes. For single player and cooperative modes use lives instead.\n","full":"const int lrsLives","type":"property","arguments":[]},{"name":"name","description":"The player's name. This is a constant property; to change it, you can use the setName method.\n","full":"const string name","type":"property","arguments":[]},{"name":"nameUnformatted","description":"The player's name in its most basic form, without any | or * characters added or removed for any gamemode-related reasons.\n","full":"const string nameUnformatted","type":"property","arguments":[]},{"name":"noclipMode","description":"Whether the player is currently in Noclip Mode, as caused by Sucker Tube events with the \"BecomeNoclip\" parameter set to 1. Setting this to true could be dangerous if the level design is not prepared for it.\n","full":"bool noclipMode","type":"property","arguments":[]},{"name":"noFire","description":"Whether the player is currently allowed to shoot bullets. Hides the default current weapon/ammunition display while true.\n","full":"bool noFire","type":"property","arguments":[]},{"name":"platform","description":"The object ID of the object the player is currently standing on, or 0 if inapplicable.\n","full":"int platform","type":"property","arguments":[]},{"name":"playerID","description":"In online play, which number the player is in the server's list of players. 0-31.\n","full":"const int8 playerID","type":"property","arguments":[]},{"name":"powerup[WEAPON::Weapon]","description":"Whether each ammo type is powered-up or not. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their allowedPowerup properties to true in the jjWeapons array.\n","full":"bool powerup[WEAPON::Weapon]","type":"property","arguments":[]},{"name":"powerup[9]","description":"Whether each ammo type is powered-up or not. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their allowedPowerup properties to true in the jjWeapons array.\n","full":"bool powerup[9]","type":"property","arguments":[]},{"name":"roasts","description":"In competitive game modes, how many kills the player made or a negative value if unknown (this is currently the case when the property is checked by clients in RT, LRS, Pestilence and TLRS modes). If the game mode doesn't allow players to kill other players, as is the case in Single Player, Cooperative, Treasure Hunt and Race, this property will always be equal to 0.\n","full":"const int roasts","type":"property","arguments":[]},{"name":"running","description":"Is the player currently running? Detects the run key, capslock (if there is only one local player), and the /run <on|off> command. Apparently running is set based on keyRun, and then other parts of code query running exclusively.\n","full":"bool running","type":"property","arguments":[]},{"name":"score","description":"In single player and cooperative modes, the player's current score. JJ2 only increments this in multiples of 50 (or 10 if you count the unpatched Butterfly enemy), but that's up to you.\n","full":"int score","type":"property","arguments":[]},{"name":"scoreDisplayed","description":"In single player and cooperative modes, the number currently displayed for the player's score. Whenever score increases, scoreDisplayed takes a few moments to catch up to the new value. Unless the level defines an onDrawScore function, in which case this property could mean or do anything.\n","full":"int scoreDisplayed","type":"property","arguments":[]},{"name":"setID","description":"Which set of animations the player uses, serving as an index to the jjAnimSets array. This is nearly a 1:1 mapping with charCurr, except that the two birds (CHAR::BIRD and CHAR::BIRD2) share a setID.\nThe RABBIT::Anim enum is a version-independent list of all possible animations a rabbit player might use, expressed as indices of animations within the player's anim set. To see if a rabbit player p is currently standing still, for example, you can check if (p.curAnim - jjAnimSets[p.setID].firstAnim == RABBIT::STAND).\n","full":"const ANIM::Set setID","type":"property","arguments":[]},{"name":"shieldTime","description":"How much longer (in ticks) the player's shield will last, or 0 if the player doesn't have a shield.\n","full":"int shieldTime","type":"property","arguments":[]},{"name":"shieldType","description":"Which shield the player currently has, assuming the player has a shield at all. In place of numbers, you may also use the dedicated SHIELD::Shield enum, options being NONE, FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. Using values from outside of the range of existing shields may be a reason of incompatibility with future versions of JJ2+ in case more shields are added.\n","full":"int shieldType","type":"property","arguments":[]},{"name":"specialMove","description":"How long the player has been performing their special move or 0 if the player is currently not using a special move.\n","full":"int specialMove","type":"property","arguments":[]},{"name":"spriteMode","description":"Sprite mode the player's sprite is drawn in. Possible constants appear in the appendix below. Changes to this setting are automatically shared between all clients in the server.\n","full":"SPRITE::Mode spriteMode","type":"property","arguments":[]},{"name":"spriteParam","description":"A sprite mode parameter further specifying how the player should be drawn. Changes to this setting are automatically shared between all clients in the server.\n","full":"uint8 spriteParam","type":"property","arguments":[]},{"name":"stoned","description":"How much longer will the player be stoned, like after touching a smoke ring.\n","full":"int stoned","type":"property","arguments":[]},{"name":"subscreenX","description":"Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n","full":"const int subscreenX","type":"property","arguments":[]},{"name":"subscreenY","description":"Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n","full":"const int subscreenY","type":"property","arguments":[]},{"name":"team","description":"The player's team in team-based game modes. Possible values are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n","full":"const TEAM::Color team","type":"property","arguments":[]},{"name":"teamRed","description":"Incorrectly equals true whenever the player is not on the blue team, i.e. including if they're on green or yellow. Use the property above instead.\n","full":"const bool teamRed","type":"property","arguments":[]},{"name":"timerPersists","description":"Should dying disable the Player Timer (false) or have no effect on it (true)?\n","full":"bool timerPersists","type":"property","arguments":[]},{"name":"timerState","description":"The current state of the Player Timer (TIMER::STOPPED, TIMER::STARTED, or TIMER::PAUSED), for comparisons only. Use the corresponding timerStart, timerStop, timerPause, and timerResume methods to set this instead.\n","full":"const TIMER::State timerState","type":"property","arguments":[]},{"name":"timerTime","description":"How many ticks are left on the Player Timer.\n","full":"int timerTime","type":"property","arguments":[]},{"name":"warpID","description":"If this number is higher than 0, the player is currently warping, and it will equal the ID of the Warp event plus one, a range of 1-256.\nIt is often wise to make sure this property equals 0 before calling a warp method, lest the player be locked into a constant loop of beginning to warp but never finishing it. Something like if (conditionsForWarping && player.warpID == 0) player.warpToID(25);. Performing this check is however unnecessary for fast warps, or warps triggered by Text events, since that code is only called when the player first enters the tile.\n","full":"const int warpID","type":"property","arguments":[]},{"name":"xAcc","description":"Horizontal acceleration in pixels per game tick squared, positive or negative.\n","full":"float xAcc","type":"property","arguments":[]},{"name":"xOrg","description":"If this or yOrg are non-zero, where the player should respawn after death.\n","full":"float xOrg","type":"property","arguments":[]},{"name":"xPos","description":"Horizontal location in pixels.\n","full":"float xPos","type":"property","arguments":[]},{"name":"xSpeed","description":"Horizontal speed in pixels per game tick, positive or negative.\n","full":"float xSpeed","type":"property","arguments":[]},{"name":"yAcc","description":"Vertical acceleration in pixels per game tick squared, positive or negative.\n","full":"float yAcc","type":"property","arguments":[]},{"name":"yOrg","description":"If this or xOrg are non-zero, where the player should respawn after death.\n","full":"float yOrg","type":"property","arguments":[]},{"name":"yPos","description":"Vertical location in pixels.\n","full":"float yPos","type":"property","arguments":[]},{"name":"ySpeed","description":"Vertical speed in pixels per game tick, positive or negative.\n","full":"float ySpeed","type":"property","arguments":[]},{"name":"activateBoss","description":"Activates all bosses and disables the player's sugar rush if applicable. Unlike the Activate Boss event, does not change the music track. (Use jjMusicLoad for that instead.)\nSetting activate to false will attempt to deactivate bosses, but this mostly only results in the boss health meter going away. The jjPLAYER object's boss is left unchanged unless you change it manually, and bosses do not stop moving around.\n","full":"void activateBoss(bool activate = true)","type":"function","arguments":[{"type":"bool","name":"activate","defaultValue":"true","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n","full":"void cameraFreeze(float xPixel, float yPixel, bool centered, bool instant)","type":"function","arguments":[{"type":"float","name":"xPixel","attributes":[],"items":[]},{"type":"float","name":"yPixel","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n","full":"void cameraFreeze(bool xUnfreeze, float yPixel, bool centered, bool instant)","type":"function","arguments":[{"type":"bool","name":"xUnfreeze","attributes":[],"items":[]},{"type":"float","name":"yPixel","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n","full":"void cameraFreeze(float xPixel, bool yUnfreeze, bool centered, bool instant)","type":"function","arguments":[{"type":"float","name":"xPixel","attributes":[],"items":[]},{"type":"bool","name":"yUnfreeze","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraFreeze","description":"Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n","full":"void cameraFreeze(bool xUnfreeze, bool yUnfreeze, bool centered, bool instant)","type":"function","arguments":[{"type":"bool","name":"xUnfreeze","attributes":[],"items":[]},{"type":"bool","name":"yUnfreeze","attributes":[],"items":[]},{"type":"bool","name":"centered","attributes":[],"items":[]},{"type":"bool","name":"instant","attributes":[],"items":[]}]},{"name":"cameraUnfreeze","description":"If cameraFreeze has been called, undoes the effect and lets the camera freely follow the player once again. If instant is left false, the camera will take roughly half a second to scroll to its target.\n","full":"void cameraUnfreeze(bool instant = true)","type":"function","arguments":[{"type":"bool","name":"instant","defaultValue":"true","attributes":[],"items":[]}]},{"name":"doesCollide","description":"Returns true if the player's sprite collides with that of the specified object, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables�including playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in�are taken into account.\n","full":"bool doesCollide(const jjOBJ@ object, bool always = false) const","type":"function","arguments":[{"type":"jjOBJ@","name":"object","attributes":["const"],"items":[]},{"type":"bool","name":"always","defaultValue":"false","attributes":[],"items":[]}]},{"name":"extendInvincibility","description":"A convenience method to extend the absolute value of the player's invincibility property by the absolute value of the duration parameter, which also makes invincibility positive (visible) if duration is visible. For example, collecting a full energy carrot extends invincibility by +350, whereas buttstomping most enemies extends invincibility by -70.\n","full":"int extendInvincibility(int duration)","type":"function","arguments":[{"type":"int","name":"duration","attributes":[],"items":[]}]},{"name":"fireBullet","description":"Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.\nPossible gun constants may be found in the appendix at the bottom of the page, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nIf depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\n","full":"int fireBullet(uint8 gun = WEAPON::CURRENT, bool depleteAmmo = true, bool requireAmmo = true, DIRECTION::Dir direction = DIRECTION::CURRENT)","type":"function","arguments":[{"type":"uint8","name":"gun","defaultValue":"WEAPON::CURRENT","attributes":[],"items":[]},{"type":"bool","name":"depleteAmmo","defaultValue":"true","attributes":[],"items":[]},{"type":"bool","name":"requireAmmo","defaultValue":"true","attributes":[],"items":[]},{"type":"DIRECTION::Dir","name":"direction","defaultValue":"DIRECTION::CURRENT","attributes":[],"items":["RIGHT","LEFT","UP","CURRENT"]}]},{"name":"fireBullet","description":"Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.\nPossible gun constants may be found in the appendix at the bottom of the page, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nIf depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\nPossible values for direction are DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the mouse cursor is at, rather than whichever direction the player is physically facing. Alternatively you may pass a float angle argument instead of an orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is down, 1.5 * pi is left, and 2 * pi is up again.\n","full":"int fireBullet(uint8 gun, bool depleteAmmo, bool requireAmmo, float angle)","type":"function","arguments":[{"type":"uint8","name":"gun","attributes":[],"items":[]},{"type":"bool","name":"depleteAmmo","attributes":[],"items":[]},{"type":"bool","name":"requireAmmo","attributes":[],"items":[]},{"type":"float","name":"angle","attributes":[],"items":[]}]},{"name":"freeze","description":"Freezes the player for the same length of time as the Freeze Enemies pickup, or unfreezes the player if frozen is set to false. Helper method.\n","full":"void freeze(bool frozen = true)","type":"function","arguments":[{"type":"bool","name":"frozen","defaultValue":"true","attributes":[],"items":[]}]},{"name":"furGet","description":"Sets provided parameters' values to palette indexes of the player's fur colors.\n","full":"void furGet(uint8 &out a, uint8 &out b, uint8 &out c, uint8 &out d) const","type":"function","arguments":[{"type":"uint8","name":"&out","attributes":[],"items":[]},{"type":"uint8","name":"&out","attributes":[],"items":[]},{"type":"uint8","name":"&out","attributes":[],"items":[]},{"type":"uint8","name":"&out","attributes":[],"items":[]}]},{"name":"furSet","description":"Sets player's fur colors to those represented by provided palette indexes. Changes made by this method are automatically shared between all clients in the server.  Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n","full":"void furSet(uint8 a, uint8 b, uint8 c, uint8 d)","type":"function","arguments":[{"type":"uint8","name":"a","attributes":[],"items":[]},{"type":"uint8","name":"b","attributes":[],"items":[]},{"type":"uint8","name":"c","attributes":[],"items":[]},{"type":"uint8","name":"d","attributes":[],"items":[]}]},{"name":"getObjectHitForce","description":"Returns a value expressing whether the player is currently in a state to harm objects or other players, equivalent to the \"force\" argument in objectHit or the onObjectHit hook/method. Specifically, this method returns -1 if the player is performing a special move and the canHurt property of their respective jjCHARACTER is true, 1 if the player is buttstomping or has a sugar rush, or 0 if none of the above are true. Doesn't work especially well when called on non-local players.\nIf a non-null jjOBJ@ is specified as target, two additional checks will be performed, returning -101 if the object is frozen and the player is running into it really fast, or -1 if the player is a frog (with a true canHurt) hitting the object with its tongue.\n","full":"int getObjectHitForce(const jjOBJ@ target = null) const","type":"function","arguments":[{"type":"jjOBJ@","name":"target","attributes":["const"],"items":[]}]},{"name":"hasPrivilege","description":"Checks whether the player has the specified privilege within the script module moduleID. Privileges are specified in the admin configuration file (typically admin.ini) and serve as a way to determine what actions specific admin groups are allowed to take. You can read more about them in the Remote Admin section of the JJ2+ readme.\nBecause privileges are only known to the host, this function will always return false if called client-side. The function will always return false for players who are not logged in, and will always return true if the player is the host or the game is local. If the privilege string contains invalid characters, i.e. anything besides letters, digits, underscores ('_'), full stops ('.'), and hyphens ('-'), or if moduleID is not valid, the function will also return false. In all other cases, i.e. if called server-side for a logged in client and with valid parameters, privileges obtained from the admin configuration file will be tested for a match, and if one is found, the function will return true, otherwise false.\n","full":"bool hasPrivilege(const string &in privilege, uint moduleID = jjScriptModuleID) const","type":"function","arguments":[{"type":"string","name":"privilege","attributes":["const","&in"],"items":[]},{"type":"uint","name":"moduleID","defaultValue":"jjScriptModuleID","attributes":[],"items":[]}]},{"name":"hurt","description":"Attempts to hurt the player damage hearts, or at least strip the player of their bird or reduce their shield time. If attacker is left null, or if it's the same player as the one getting hurt, the injury will be counted as coming from the level, and if a death results, it will be marked online with the \"ate it/you killed yourself\" text. This is what you should do for injuries from enemies and other level-based factors. On the other hand, if the player dies from the hurt call and attacker is another player in the server, that player will get credit for the roast. Returns false if neither the hurtee nor the hurter are local players and the method is not called by the host, or if forceHurt (which bypasses traditional safety sources like the invincibility and blink properties and buttstomping) is false and something or other prevents the hurting from happening.\n","full":"bool hurt(int8 damage = 1, bool forceHurt = false, jjPLAYER@ attacker = null)","type":"function","arguments":[{"type":"int8","name":"damage","defaultValue":"1","attributes":[],"items":[]},{"type":"bool","name":"forceHurt","defaultValue":"false","attributes":[],"items":[]},{"type":"jjPLAYER@","name":"attacker","defaultValue":"null","attributes":[],"items":[]}]},{"name":"isEnemy","description":"Returns true iff victim is a player who can be hurt by this player's bullets or other attacks, according to the rules of the current gamemode. Potentially useful if you are writing a custom weapon behavior and don't want to use HANDLING::PLAYERBULLET.\nThe following conditions will cause this method to return false: the two jjPLAYER objects are the same player; the gamemode is Single Player or Cooperative; in a team-based game, the two players are on the same team and jjFriendlyFire is false; in Roast Tag, Eva's Ring has been captured, yet neither player is jjTokenOwner or jjBottomFeeder; in Pestilence, either both players are zombies or neither are zombies but jjDoZombiesAlreadyExist is false; or in Jailbreak, victim is in jail.\nAgain, this method checks only gamemode-related conditions. (And if more gamemodes are added in the future, this method will be updated to reflect them.) It does not check jjPLAYER::isInGame, jjGameState, or anything that might cause jjPLAYER::hurt to return false if its forceHurt parameter is left false.\n","full":"bool isEnemy(const jjPLAYER &in victim) const","type":"function","arguments":[{"type":"jjPLAYER","name":"victim","attributes":["const","&in"],"items":[]}]},{"name":"kill","description":"Kills the player instantly. If you want the player to be roasted by some other player in an online server, use hurt with a high damage value instead.\n","full":"void kill()","type":"function","arguments":[]},{"name":"limitXScroll","description":"Works like a Limit X Scroll event with the corresponding Left and Width parameters. Remember that these are measured in tiles, not pixels.\n","full":"void limitXScroll(uint16 left, uint16 width)","type":"function","arguments":[{"type":"uint16","name":"left","attributes":[],"items":[]},{"type":"uint16","name":"width","attributes":[],"items":[]}]},{"name":"morph","description":"Cycles the player's character to the next on the list, just like the JJMORPH cheat: Jazz-Spaz-(Lori-)Bird-Frog-Bird2. Or if rabbitsOnly is true, skips birds and frog and acts like a morph monitor instead, restricting available morph targets to those whose jjCHARACTER::morphBoxCycle properties equal true. Returns the player's new character: CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n","full":"CHAR::Char morph(bool rabbitsOnly = false, bool morphEffect = true)","type":"function","arguments":[{"type":"bool","name":"rabbitsOnly","defaultValue":"false","attributes":[],"items":[]},{"type":"bool","name":"morphEffect","defaultValue":"true","attributes":[],"items":[]}]},{"name":"morphTo","description":"Sets the player's character to charNew, possible values CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI (in TSF), CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n","full":"CHAR::Char morphTo(CHAR::Char charNew, bool morphEffect = true)","type":"function","arguments":[{"type":"CHAR::Char","name":"charNew","attributes":[],"items":["JAZZ","SPAZ","LORI","BIRD","FROG","BIRD2"]},{"type":"bool","name":"morphEffect","defaultValue":"true","attributes":[],"items":[]}]},{"name":"objectHit","description":"Causes the game to think the player is colliding with object target, even if they are not in the same area, and returns true if (generally speaking) the object is affected somehow. Calling this method on a non-local player will return false unless called by the host of a server.\nThe force parameter hints at whether the player should be able to damage the object, if the object can be damaged to begin with. A value of 0 means that the player is simply bumping into the object at random; 1 means a buttstomp or sugar rush; -1 means a special move; and -101 means the object is frozen and the player runs into it really fast. If you want this parameter to reflect reality, get the value from jjPLAYER's getObjectHitForce method.\nThe playerHandling parameter specifies how the player should interact with the object�for example, passing HANDLING::PICKUP will force the player to treat the object as a pickup, even if its actual playerHandling property is set to something else. If the value is not HANDLING::ENEMY, HANDLING::SPECIAL, HANDLING::PICKUP, HANDLING::ENEMYBULLET, or HANDLING::PLAYERBULLET, nothing will happen. If the value is one of the first three and the object has scriptedCollisions set to true, some version of onObjectHit will be called with a null bullet argument, this jjPLAYER as player, and whatever force you call this method with as force.\nThe results of this collision will be broadcast to other players in the server exactly as if it had happened naturally through the sprites colliding. For example, collecting a pickup object half the level away will cause other players to see the pickup disappear.\n","full":"bool objectHit(jjOBJ@ target, int force, HANDLING::Player playerHandling)","type":"function","arguments":[{"type":"jjOBJ@","name":"target","attributes":[],"items":[]},{"type":"int","name":"force","attributes":[],"items":[]},{"type":"HANDLING::Player","name":"playerHandling","attributes":[],"items":["PICKUP","ENEMY","SPECIAL","PICKUP","ENEMYBULLET","PLAYERBULLET"]}]},{"name":"offsetPosition","description":"Instantly moves the player xPixels pixels to the right and yPixels pixels down. The camera instantly readjusts itself to follow, as does the glowing trace following the player while running and any companion bird the player may have. The best way of creating seamlessly looping levels.\n","full":"bool offsetPosition(int xPixels, int yPixels)","type":"function","arguments":[{"type":"int","name":"xPixels","attributes":[],"items":[]},{"type":"int","name":"yPixels","attributes":[],"items":[]}]},{"name":"poleSpin","description":"Causes the player to appear to swing around a pole for delay ticks, then launch off at the specified speed/s. For reference, an H-Pole event increases the absolute value of your existing xSpeed by 8 (but not above 20), while a V-Pole event increases the absolute value of your existing ySpeed by 16, with both using the default delay value of 70 ticks (=one second). An H-Pole passes 0 for ySpeed, and a V-Pole passes 0 for xSpeed, but you may use non-orthogonal directions with this method if you'd rather.\n","full":"void poleSpin(float xSpeed, float ySpeed, uint delay = 70)","type":"function","arguments":[{"type":"float","name":"xSpeed","attributes":[],"items":[]},{"type":"float","name":"ySpeed","attributes":[],"items":[]},{"type":"uint","name":"delay","defaultValue":"70","attributes":[],"items":[]}]},{"name":"resetLight","description":"Resets player's ambient lighting value to the level's default.\n","full":"uint8 resetLight()","type":"function","arguments":[]},{"name":"revertMorph","description":"Reverts the player to the character they were when they began the level, just like the Revert Morph event. If morphEffect is true, displays the default visual effect. Returns the new character (equal to the player's charOrig).\n","full":"CHAR::Char revertMorph(bool morphEffect = true)","type":"function","arguments":[{"type":"bool","name":"morphEffect","defaultValue":"true","attributes":[],"items":[]}]},{"name":"setName","description":"Sets the player's name. This method will only succeed if called server-side or in a local game, and it will then return true to indicate success. Otherwise no change will occur and the method will return false.\n","full":"bool setName(const string &in name)","type":"function","arguments":[{"type":"string","name":"name","attributes":["const","&in"],"items":[]}]},{"name":"setScore","description":"Sets the player's score. While setting the score through the score property is slightly delayed as scoreDisplayed increases/decreases to catch up to the new value, this function sets both properties at once. Probably most helpful as a function for quickly showing you debug information.\n","full":"int setScore(int score)","type":"function","arguments":[{"type":"int","name":"score","attributes":[],"items":[]}]},{"name":"showText","description":"Displays text on the player's screen either like a Text event, with the corresponding textID and offset parameters, or simply a specified text. Unique size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use jjHelpStrings instead.\n","full":"void showText(uint8 textID, uint8 offset, STRING::Size size = STRING::SMALL)","type":"function","arguments":[{"type":"uint8","name":"textID","attributes":[],"items":[]},{"type":"uint8","name":"offset","attributes":[],"items":[]},{"type":"STRING::Size","name":"size","defaultValue":"STRING::SMALL","attributes":[],"items":["SMALL","MEDIUM","LARGE"]}]},{"name":"showText","description":"Displays text on the player's screen either like a Text event, with the corresponding textID and offset parameters, or simply a specified text. Unique size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use jjHelpStrings instead.\n","full":"void showText(string text, STRING::Size size = STRING::SMALL)","type":"function","arguments":[{"type":"string","name":"text","attributes":[],"items":[]},{"type":"STRING::Size","name":"size","defaultValue":"STRING::SMALL","attributes":[],"items":["SMALL","MEDIUM","LARGE"]}]},{"name":"spring","description":"Simulates the player touching and getting bounced by a Spring object. For reference, the absolute values of red, green, and blue springs' speeds are 16, 24, and 32 respectively: for example, an upward-facing red spring uses xSpeed 0 and ySpeed -16.\nThe keepZeroSpeeds argument affects what happens if either speed axis is left at 0, equivalent to the \"Keep X-Speed\" and \"Keep Y-Speed\" event parameters: if keepZeroSpeeds is false, the player's speed on that axis will be set to 0, but if true, it will be left at its value prior to spring being called.\nIf sample is true, a sample will be chosen (from among SOUND::COMMON_SPRING1, SOUND::SPRING_BOING_DOWN, and SOUND::SPRING_SPRING1) and played depending on the xSpeed and ySpeed values, and if the player is Spaz, SOUND::SPAZSOUNDS_YAHOO2 may be played as well.\n","full":"void spring(float xSpeed, float ySpeed, bool keepZeroSpeeds, bool sample)","type":"function","arguments":[{"type":"float","name":"xSpeed","attributes":[],"items":[]},{"type":"float","name":"ySpeed","attributes":[],"items":[]},{"type":"bool","name":"keepZeroSpeeds","attributes":[],"items":[]},{"type":"bool","name":"sample","attributes":[],"items":[]}]},{"name":"startSugarRush","description":"Gives the player a sugar rush lasting time ticks, unless their bossActivated property equals true, in which case the method returns false. Otherwise returns true. In online multiplayer, jjSugarRushAllowed should be true for the host, or else clients who call this method may be kicked.\n","full":"bool startSugarRush(int time = 1400)","type":"function","arguments":[{"type":"int","name":"time","defaultValue":"1400","attributes":[],"items":[]}]},{"name":"suckerTube","description":"Simulates the player touching a Sucker Tube event with the same parameter names and values (with noclip referring to \"BecomeNoclip\", not \"Noclip Only\"). For each axis this method instructs the player to move along, the center parameter first puts the player in the center of their current tile on the other axis�therefore, passing true is generally safe, but it will get the player stuck if trying to move diagonally every single tick. In normal JJ2, center is true for the first tick the player spends in the tile with the sucker tube event, and false every tick thereafter.\n","full":"void suckerTube(int xSpeed, int ySpeed, bool center, bool noclip = false, bool trigSample = false)","type":"function","arguments":[{"type":"int","name":"xSpeed","attributes":[],"items":[]},{"type":"int","name":"ySpeed","attributes":[],"items":[]},{"type":"bool","name":"center","attributes":[],"items":[]},{"type":"bool","name":"noclip","defaultValue":"false","attributes":[],"items":[]},{"type":"bool","name":"trigSample","defaultValue":"false","attributes":[],"items":[]}]},{"name":"testForCoins","description":"If the player has at least numberOfCoins coins, depletes their coins by numberOfCoins and returns true. Otherwise displays a warning onscreen that they need more coins to continue and returns false. Basically the same as a coin warp event, but you get to choose the result.\n","full":"bool testForCoins(int numberOfCoins)","type":"function","arguments":[{"type":"int","name":"numberOfCoins","attributes":[],"items":[]}]},{"name":"testForGems","description":"If the player has at least numberOfGems type-colored gems, depletes their type gems by numberOfGems and returns true. Otherwise displays a warning onscreen that they need more gems to continue and returns false. Basically the same as a coin warp event, but you get to choose the result, and it's for gems instead of coins.\nPossible values of type are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n","full":"bool testForGems(int numberOfGems, GEM::Color type)","type":"function","arguments":[{"type":"int","name":"numberOfGems","attributes":[],"items":[]},{"type":"GEM::Color","name":"type","attributes":[],"items":["RED","GREEN","BLUE","PURPLE"]}]},{"name":"timerFunction","description":"When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n","full":"void timerFunction(string functionName)","type":"function","arguments":[{"type":"string","name":"functionName","attributes":[],"items":[]}]},{"name":"timerFunction","description":"When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n","full":"void timerFunction(jjVOIDFUNC@ function)","type":"function","arguments":[{"type":"jjVOIDFUNC@","name":"function","attributes":[],"items":[]}]},{"name":"timerFunction","description":"When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n","full":"void timerFunction(jjVOIDFUNCPLAYER@ function)","type":"function","arguments":[{"type":"jjVOIDFUNCPLAYER@","name":"function","attributes":[],"items":[]}]},{"name":"timerPause","description":"Pauses the Player Timer and returns TIMER::PAUSED.\n","full":"TIMER::State timerPause()","type":"function","arguments":[]},{"name":"timerResume","description":"Resumes the Player Timer and returns TIMER::STARTED.\n","full":"TIMER::State timerResume()","type":"function","arguments":[]},{"name":"timerStart","description":"Begins the Player Timer (and optionally pauses it) with ticks ticks remaining on the clock. Returns TIMER::STARTED or TIMER::PAUSED, depending.\n","full":"TIMER::State timerStart(int ticks, bool startPaused = false)","type":"function","arguments":[{"type":"int","name":"ticks","attributes":[],"items":[]},{"type":"bool","name":"startPaused","defaultValue":"false","attributes":[],"items":[]}]},{"name":"timerStop","description":"Stops the Player Timer and returns TIMER::STOPPED.\n","full":"TIMER::State timerStop()","type":"function","arguments":[]},{"name":"warpToID","description":"Warps the player to a Warp Target event with the specified Warp ID, instantly if fast is true or using the standard warp effect if fast is false.\n","full":"bool warpToID(uint8 warpID, bool fast = false)","type":"function","arguments":[{"type":"uint8","name":"warpID","attributes":[],"items":[]},{"type":"bool","name":"fast","defaultValue":"false","attributes":[],"items":[]}]},{"name":"warpToTile","description":"Warps the player to the specified tile, instantly if fast is true or using the standard warp effect if fast is false.\n","full":"bool warpToTile(int xTile, int yTile, bool fast = false)","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]},{"type":"bool","name":"fast","defaultValue":"false","attributes":[],"items":[]}]}],"jjOBJList":[{"name":"age","description":"A variable totally unused by JJ2. The name comes from its original intended purpose as indicating how long had elapsed since the object was created.\n","full":"int age","type":"property","arguments":[]},{"name":"animSpeed","description":"Intended to determine how fast the object animates. However, only gem rings, speed destruct scenery, and collapse scenery actually use this property for that purpose, and all other non-bullet objects leave it untouched.\nBULLETS: This property stores the amount of damage a bullet does to enemies, e.g. 1 for normal blaster, 2 for normal seekers, or 3 for certain shield bullets.\n","full":"int animSpeed","type":"property","arguments":[]},{"name":"behavior","description":"Which function is called for this object's behavior. See jjBEHAVIORINTERFACE.\nIn order to avoid common bugs, it's strongly discouraged to modify behavior of objects of eventID OBJECT::GENERATOR, and especially of jjObjectPresets[OBJECT::GENERATOR]. Currently a great portion of game code tests it against BEHAVIOR::GENERATOR and if it doesn't succeed, it may take unexpected actions, typically involving kicking and banning clients for invalid weapons. Similarly, replacing BEHAVIOR::DIAMONDSAREFOREVER is liable to break Treasure Hunt or Head Hunters games.\nReplacing BEHAVIOR::DESTRUCTSCENERY, BEHAVIOR::TRIGGERSCENERY, or BEHAVIOR::SUPERGEM will normally prevent the states of those objects from being shared with newly joining clients in online servers, but this can be circumvented by replacing them with jjBEHAVIORINTERFACE-implementing classes that define onGetActive/onSetActive methods appropriately.\n","full":"jjBEHAVIOR behavior","type":"property","arguments":[]},{"name":"bulletHandling","description":"What happens when a bullet (or turtle shell, or TNT blast, or attacking bird) comes into contact with this object, assuming that playerHandling is either ENEMY or SPECIAL and state is anything other than KILL?\n\t\t\t\tHURTBYBULLET: If this object has a non-zero energy property, then hitting it will decrease its energy by the force of the bullet. If the object is frozen, it will be unfrozen. If the object's energy sinks to 0 or less, its state will change to STATE::KILL and the player behind the bullet will receive the object's points. Otherwise, its justHit property will be set to 5. The bullet will be destroyed unless it has bit 16 set for its var[6], like fireball bullets do, or if the object has causesRicochet as true. If the object's playerHandling is SPECIAL, other things may happen.\n\t\t\t\tIGNOREBULLET: The object will be unaffected in every way by the collision, and the bullet will not be destroyed.\n\t\t\t\tDESTROYBULLET: The object will be unaffected in every way by the collision, and the bullet will be destroyed no matter what its properties are.\n\t\t\t\tDETECTBULLET: The object is by default unaffected, but the bullet will be destroyed unless it has bit 16 set for its var[6], like fireball bullets do, or if the object has causesRicochet as true. If the object's playerHandling is SPECIAL, other things may happen.\n\t\t\t\n","full":"HANDLING::Bullet bulletHandling","type":"property","arguments":[]},{"name":"causesRicochet","description":"When true, colliding bullets will ricochet off of this object unless bulletHandling is set to DESTROYBULLET.\n","full":"bool causesRicochet","type":"property","arguments":[]},{"name":"counter","description":"A general purpose property, usually used for counting up or down to some future event.\n","full":"int counter","type":"property","arguments":[]},{"name":"counterEnd","description":"A general purpose property, usually used for counting up or down to some future event. Only goes up to 255, so not as versatile as counter.\nBULLETS: how long a bullet will exist before exploding. Used by pretty much every bullet behavior but BEHAVIOR::BOLLYBULLET, although no behavior-external code seems to reference it specifically.\n","full":"uint8 counterEnd","type":"property","arguments":[]},{"name":"creator","description":"The sum of the creatorID and creatorType properties, which is less useful than you might hope.\n","full":"int creator","type":"property","arguments":[]},{"name":"creatorID","description":"The object ID or player ID of the object or player that created this object, as usable as the index for jjObjects or jjPlayers. 0 if no creator is actually known.\n","full":"int creatorID","type":"property","arguments":[]},{"name":"creatorType","description":"CREATOR::OBJECT if the object was created by another object, CREATOR::PLAYER if it was created by a player, or CREATOR::LEVEL if it was added directly from the event map.\nIf the object was created by a Generator object specifically, then creatorType will equal CREATOR::LEVEL, but creatorID will equal the object ID of that Generator object rather than 0.\n","full":"CREATOR::Type creatorType","type":"property","arguments":[]},{"name":"curAnim","description":"The current animation the object takes its frames from; an index for the jjAnimations array. You can obtain useful values for this from the determineCurAnim method or else any jjANIMSET::firstAnim.\n","full":"int16 curAnim","type":"property","arguments":[]},{"name":"curFrame","description":"The overall current frame displayed to the screen to represent this object, taking into account both curAnim and frameID; an index for the jjAnimFrames array. You can obtain useful values for this from the determineCurFrame method or else any jjANIMATION::firstFrame.\n","full":"uint curFrame","type":"property","arguments":[]},{"name":"deactivates","description":"When true, this object will be deleted from memory if the player wanders too far away from it in local single player mode, and all its properties will be reset next time it gets loaded. This property has absolutely no effect in multiplayer, and setting it to false cannot force an object to remain in memory in single player when the player dies.\n","full":"bool deactivates","type":"property","arguments":[]},{"name":"direction","description":"Which way the object is facing. Generally, direction >= 0 is right and < 0 is left. Some objects may also correctly interpret SPRITE::Direction constants: SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV but the ones involving vertical flip will not be perfectly reliable for objects without custom behavior, except for box objects (crates, barrels, monitors), which will take vertically flipped direction values as a cue to fall upwards instead of downwards.\n","full":"int8 direction","type":"property","arguments":[]},{"name":"doesHurt","description":"A variable totally unused by JJ2. The name comes from its original intended purpose as specifying whether boss objects could hurt the player.\n","full":"uint8 doesHurt","type":"property","arguments":[]},{"name":"energy","description":"If this object's playerHandling value is HANDLING::ENEMY, this number is how many more hits the object can take before it is destroyed, unless it equals 0, in which case the object is invincible to bullets (but not to special attacks). This property is also used to determine the fullness of the boss bar.\n","full":"int8 energy","type":"property","arguments":[]},{"name":"eventID","description":"e.g. 158 for a peach, 43 for a bomb, 243 for an airboard, 1 for a blaster bullet, and so on. Is a uint8 for maximum flexibility, but you should probably set/compare it to OBJECT::Object constants instead most of the time, if for no other reason than readability.\nWhile this value is not strictly constant/read-only, changing it can lead to unpredictable and undesirable effects, since this is the only truly reliable way of knowing what kind of object a given jjOBJ really is, and JJ2 queries it very frequently. The effects can vary from a food pickup playing the wrong sound effect when collected to, say, a red spring simply not working at all when touched. You have been warned.\n","full":"uint8 eventID","type":"property","arguments":[]},{"name":"frameID","description":"The object's current frame within a single animation set, e.g. which direction the Tube Turtle faces while it rotates in place.\n","full":"int8 frameID","type":"property","arguments":[]},{"name":"freeze","description":"0 if the object is unfrozen, otherwise counts down to 0 for most behaviors, though you'll need to implement that manually if writing your own.\n","full":"uint8 freeze","type":"property","arguments":[]},{"name":"isActive","description":"Does this jjOBJ correspond to a real object, or is it just the abandoned memory of one? For any jjOBJ o, (o.isActive) is the same as (o.behavior != BEHAVIOR::INACTIVE), but one is obviously much shorter than the other.\n","full":"const bool isActive","type":"property","arguments":[]},{"name":"isBlastable","description":"When true, nearby TNT explosions will set this object's xSpeed and ySpeed properties.\n","full":"bool isBlastable","type":"property","arguments":[]},{"name":"isFreezable","description":"When false, this object will treat ice bullets just the same as any other bullet with the same properties. This is what Caterpillar and Queen do, for example.\n","full":"bool isFreezable","type":"property","arguments":[]},{"name":"isTarget","description":"When true, this object will be attacked by birds and seeker missiles.\n","full":"bool isTarget","type":"property","arguments":[]},{"name":"justHit","description":"When this property has a non-zero value, most objects will be drawn as pure white until the property counts back down to 0 one tick at a time. JJ2 deincrements this property for all objects, so you needn't worry about it when defining your own behavior functions.\n","full":"uint8 justHit","type":"property","arguments":[]},{"name":"killAnim","description":"Which animation the object uses while being destroyed, in the same format as curAnim.\n","full":"int16 killAnim","type":"property","arguments":[]},{"name":"light","description":"The intensity of the light produced by the object.\n","full":"int8 light","type":"property","arguments":[]},{"name":"lightType","description":"The type of light produced by the object. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER.\n","full":"LIGHT::Type lightType","type":"property","arguments":[]},{"name":"oldState","description":"If the object is frozen, what state it was in before it was frozen. Possible constants are listed in the appendix at the end of this file.\n","full":"STATE::State oldState","type":"property","arguments":[]},{"name":"playerHandling","description":"How does this object interact with the rest of the game, most specifically coming into contact with players, although also bullets?\n\t\t\t\tENEMY: If a player touches this object, they will be hurt (barring invincibility and such), unless they are using a special attack, in which case the object's energy property will decrease by 4. If energy reaches 0 or lower, the object's state will be set to KILL and the player will receive its points. Objects of playerHandling PLAYERBULLET that come into contact with this object have the potential to collide with it, depending on its bulletHandling setting.\n\t\t\t\tPLAYERBULLET: When the object's state is anything but START or EXPLODE, this object will constantly be checked for collision with players other than its creatorID, as well as objects with playerHandling ENEMY, PICKUP, or SPECIAL.\n\t\t\t\tENEMYBULLET: When the object's state is anything but START or EXPLODE, if a player touches this object, they will be hurt (barring invincibility and such).\n\t\t\t\tPARTICLE: Effect unknown (semantic only?)\n\t\t\t\tEXPLOSION: Effect unknown (semantic only?)\n\t\t\t\tPICKUP: If a player touches this object, something special will happen, exactly what depending on its eventID value. Usually if nothing else the player will receive its points, and its behavior will be set to BEHAVIOR::EXPLOSION2, though sometimes (e.g. carrots when touched by a player with full health) nothing will happen at all. If the object has scriptedCollisions set to true, that will override the effect of the eventID value. Should it have 0 xSpeed/ySpeed properties and be overlapped by an object of playerHandling PLAYERBULLET whose state is not START or EXPLODE, the pickup object will partially inherit that bullet object's speed and direction.\n\t\t\t\tDELAYEDPICKUP: Effect unknown (semantic only?)\n\t\t\t\tHURT: Effect unknown (semantic only?)\n\t\t\t\tSPECIAL: Whenever this object is overlapped by a player or an object of playerHandling PLAYERBULLET (depending in the latter case on this object's bulletHandling value), something special will happen, exactly what depending on its eventID value. If the object has scriptedCollisions set to true, that will override the effect of the eventID value.\n\t\t\t\tDYING: Effect unknown (semantic only?)\n\t\t\t\tSPECIALDONE: Effect unknown (semantic only?)\n\t\t\t\tSELFCOLLISION: Effect unknown (semantic only?)\n\t\t\t\n","full":"HANDLING::Player playerHandling","type":"property","arguments":[]},{"name":"points","description":"How many points a player will gain for destroying the object.\n","full":"uint16 points","type":"property","arguments":[]},{"name":"noHit","description":"Instead, use the properties bulletHandling, causesRicochet, isFreezable, and isBlastable.\n","full":"int8 noHit","type":"property","arguments":[]},{"name":"objectID","description":"For all values of n such that n < jjObjectMax, jjObjects[n].objectID == n.\n","full":"const uint16 objectID","type":"property","arguments":[]},{"name":"objType","description":"Instead, use the properties playerHandling, isTarget, triggersTNT, deactivates, and scriptedCollisions.\n","full":"uint8 objType","type":"property","arguments":[]},{"name":"scriptedCollisions","description":"When true, JJ2 will call some version of onObjectHit to determine what to do if a bullet or player is detected as having collided with this object. See jjBEHAVIORINTERFACE. This property's effect if playerHandling is anything other than ENEMY, PICKUP, or SPECIAL is presently undefined.\n","full":"bool scriptedCollisions","type":"property","arguments":[]},{"name":"special","description":"A general-purpose variable, means different things for different objects.\nBULLETS: This property stores the animation (curAnim-style) that is used if the bullet is shot upwards, not horizontally. If this property equals 0, it will not be possible to shoot the bullet upwards except by mouse aiming; this is how shields work.\n","full":"int special","type":"property","arguments":[]},{"name":"state","description":"The current state of the state machine that is the object. Possible constants are listed in the appendix at the end of this file.\n","full":"STATE::State state","type":"property","arguments":[]},{"name":"triggersTNT","description":"When true, TNT will explode if this object is nearby.\n","full":"bool triggersTNT","type":"property","arguments":[]},{"name":"var[11]","description":"A series of general-purpose variables, used for different things by different objects. In general, earlier values are more likely to be used by the game's native behavior functions than later ones.\nBULLETS:\n\t\t\t\tvar[3] represents what ammo type the bullet is, 1-9, which is primarily used for destroying destruct scenery with a non-zero \"Weapon\" parameter.\n\t\t\t\tvar[6] is used as a series of boolean flags that specify how the bullet interacts with various objects: bit 2 for fire-based bullets which can melt springs and burn enemies into fire/smoke particles; bit 4 for the laser shield's laser; bit 8 for bullets that do two damage in multiplayer; and bit 16 for bullets that pass through enemies, like the fireball, rather than explode on impact.\n\t\t\t\tvar[7] is the xSpeed that the player who fired this bullet was moving at when the bullet was fired, reduced to a range of -8�8... multiplied by 65536. Sorry about that.\n\t\t\t\tvar[9] is a counter for how many times the bullet has ricocheted in its lifetime, beginning at 0.\n\t\t\t\tvar[10] is a counter for how long it's been since the bullet has last ricocheted; each ricochet resets it to 0, but traditional bullet behaviors constantly increment it, and a bullet cannot ricochet if the value is less than 8.\n\t\t\t\n","full":"int var[11]","type":"property","arguments":[]},{"name":"xAcc","description":"Horizontal acceleration in pixels per game tick squared, positive or negative.\n","full":"float xAcc","type":"property","arguments":[]},{"name":"xOrg","description":"Original horizontal location in pixels.\n","full":"float xOrg","type":"property","arguments":[]},{"name":"xPos","description":"Current horizontal location in pixels.\n","full":"float xPos","type":"property","arguments":[]},{"name":"xSpeed","description":"Horizontal speed in pixels per game tick, positive or negative.\n","full":"float xSpeed","type":"property","arguments":[]},{"name":"yAcc","description":"Vertical acceleration in pixels per game tick squared, positive or negative.\n","full":"float yAcc","type":"property","arguments":[]},{"name":"yPos","description":"Current vertical location in pixels.\n","full":"float yPos","type":"property","arguments":[]},{"name":"yOrg","description":"Original vertical location in pixels.\n","full":"float yOrg","type":"property","arguments":[]},{"name":"ySpeed","description":"Vertical speed in pixels per game tick, positive or negative.\n","full":"float ySpeed","type":"property","arguments":[]},{"name":"behave","description":"Causes this jjOBJ to perform the specified jjBEHAVIOR function, or its own behavior property if behavior is set to BEHAVIOR::DEFAULT. If draw is false, it will not draw anything to the screen. See jjBEHAVIORINTERFACE.\n","full":"void behave(jjBEHAVIOR behavior = BEHAVIOR::DEFAULT, bool draw = true)","type":"function","arguments":[{"type":"jjBEHAVIOR","name":"behavior","defaultValue":"BEHAVIOR::DEFAULT","attributes":[],"items":["BULLET","SEEKERBULLET","RFBULLET","TOASTERBULLET","PEPPERBULLET","ELECTROBULLET","BUMP","PADDLE","BIGOBJECT","WALKINGENEMY","DESTRUCTSCENERY","ROCKETTURTLE","ROCKETTURTLEPLUS","BOLLYTOP","BOLLYBOTTOM","PLATFORM","SPRING","AMMO15","MONITOR","CRATE","PICKUP","DIAMONDSAREFOREVER","FLAG","INACTIVE","DEFAULT","MONKEYBULLET","BILSYBULLET","BOLLYBULLET","BOLLYSPIKEBALL","WITCHBULLET","TUFBOSSBULLET","ROBOTSHARD","BONE","EXPLOSION2","BURNING","AIRBOARDFALL","BIRDFEATHER","UFO","CORPSE"]},{"type":"bool","name":"draw","defaultValue":"true","attributes":[],"items":[]}]},{"name":"bePlatform","description":"Makes the object act as a platform for players. Unlike beSolid, this method will only cause interactions with players on top of the object and not on its sides. Additionally, this method better accounts for the object's self-induced movement. The parameters xOld and yOld should be set to horizontal and vertical position of the object in the previous tick, whereas the jjOBJ properties xPos and yPos will be used for its current position. The remaining two parameters, width and height, should indicate the platform's dimensions in pixels. The default value of 0 will result in dimensions chosen automatically based on the size of the object's curFrame.\n","full":"void bePlatform(float xOld, float yOld, int width = 0, int height = 0)","type":"function","arguments":[{"type":"float","name":"xOld","attributes":[],"items":[]},{"type":"float","name":"yOld","attributes":[],"items":[]},{"type":"int","name":"width","defaultValue":"0","attributes":[],"items":[]},{"type":"int","name":"height","defaultValue":"0","attributes":[],"items":[]}]},{"name":"beSolid","description":"Causes this jjOBJ to serve as a solid block for players trying to move into it. Used by crates, monitors, etc. Returns -1 if a player is trying to push the object to the left, 1 if a player is trying to push it to the right, or otherwise 0, in case you wish to write some code to make the object pushable.\nIf shouldCheckForStompingLocalPlayers is true, any local players who are landing on this object while buttstomping get an additional chance to destroy this object before landing, effectively by calling jjPLAYER::objectHit. If the collision changes this object's state to either STATE::ACTION or STATE::KILL, jjOBJ::behave() will be called.\n","full":"int beSolid(bool shouldCheckForStompingLocalPlayers = false)","type":"function","arguments":[{"type":"bool","name":"shouldCheckForStompingLocalPlayers","defaultValue":"false","attributes":[],"items":[]}]},{"name":"blast","description":"Sends all players within maxDistance of the object flying away, like RFs or Bombs do when they explode. If creatorType equals CREATOR::PLAYER and players can currently hurt each other, the blast will hurt nearby players unless their playerID is equal to this object's creatorID. If blastObjects is true, then other jjOBJs within maxDistance whose isBlastable property equals true will be damaged and/or sent flying, just like when a TNT object explodes.\n","full":"void blast(int maxDistance, bool blastObjects)","type":"function","arguments":[{"type":"int","name":"maxDistance","attributes":[],"items":[]},{"type":"bool","name":"blastObjects","attributes":[],"items":[]}]},{"name":"clearPlatform()","description":"Causes all local players that are currently standing on top of this object or pushing it to no longer be standing on top of it or pushing it. Should be called when deleting an object that calls bePlatform or beSolid.\n","full":"void clearPlatform()","type":"function","arguments":[]},{"name":"deactivate","description":"A wrapper method, called by most objects when their state property equals DEACTIVATE:\n\t\t\t\tobj.delete();\nif(obj.creatorType == CREATOR::LEVEL) {\n\tjjEventSet(obj.xOrg/32, obj.yOrg/32, obj.eventID);\n\tjjParameterSet(obj.xOrg/32, obj.yOrg/32, -1, 1, 0);\n}\n","full":"void deactivate()","type":"function","arguments":[]},{"name":"delete","description":"Permanently deletes the object. Like jjAddObject, this method is purely local in its scope.\n","full":"void delete()","type":"function","arguments":[]},{"name":"determineCurAnim","description":"Determines the value of the curAnim corresponding to Set ID setID and Animation animation as seen in Jazz Sprite Dynamite. (0-indexed.) If change is specified as false, this serves as essentially a static method, calculating the proper curAnim value but not actually setting this particular jjOBJ's curAnim to that value.\nYou are allowed to use a simple uint8 to specify the setID, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24. The full list of constants can be found in the appendix at the bottom of this file.\nInternally, this method runs the following code:\n\t\t\t\tif (jjAnimSets[setID].firstAnim == 0) //not yet loaded\n\tjjAnimSets[setID].load(); //load from anims.j2a or plus.j2a, depending on setID\nconst int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation;\nif (change)\n\tthis.curAnim = newCurAnimValue;\nreturn newCurAnimValue;\n","full":"int16 determineCurAnim(uint8 setID, uint8 animation, bool change = true)","type":"function","arguments":[{"type":"uint8","name":"setID","attributes":[],"items":[]},{"type":"uint8","name":"animation","attributes":[],"items":[]},{"type":"bool","name":"change","defaultValue":"true","attributes":[],"items":[]}]},{"name":"determineCurAnim","description":"Determines the value of the curAnim corresponding to Set ID setID and Animation animation as seen in Jazz Sprite Dynamite. (0-indexed.) If change is specified as false, this serves as essentially a static method, calculating the proper curAnim value but not actually setting this particular jjOBJ's curAnim to that value.\nYou are allowed to use a simple uint8 to specify the setID, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24. The full list of constants can be found in the appendix at the bottom of this file.\nInternally, this method runs the following code:\n\t\t\t\tif (jjAnimSets[setID].firstAnim == 0) //not yet loaded\n\tjjAnimSets[setID].load(); //load from anims.j2a or plus.j2a, depending on setID\nconst int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation;\nif (change)\n\tthis.curAnim = newCurAnimValue;\nreturn newCurAnimValue;\n","full":"int16 determineCurAnim(ANIM::Set setID, uint8 animation, bool change = true)","type":"function","arguments":[{"type":"ANIM::Set","name":"setID","attributes":[],"items":["AMMO","BAT","BEEBOY","BEES","BIGBOX","BIGROCK","BIGTREE","BILSBOSS","BIRD","BIRD3D","BOLLPLAT","BONUS","BOSS","BRIDGE","BUBBA","BUMBEE","BUTTERFLY","CARROTPOLE","CAT","CAT2","CATERPIL","CHUCK","COMMON","CONTINUE","DEMON","DESTSCEN","DEVAN","DEVILDEVAN","DIAMPOLE","DOG","DOOR","DRAGFLY","DRAGON","EVA","FACES","FATCHK","FENCER","FISH","FLAG","FLARE","FONT","FROG","FRUITPLAT","GEMRING","GLOVE","GRASSPLAT","HATTER","HELMUT","JAZZ","JAZZ3D","JUNGLEPOLE","LABRAT","LIZARD","LORI","LORI2","MENU","MENUFONT","MONKEY","MOTH","PICKUPS","PINBALL","PINKPLAT","PSYCHPOLE","QUEEN","RAPIER","RAVEN","ROBOT","ROCK","ROCKTURT","SKELETON","SMALTREE","SNOW","SONCSHIP","SONICPLAT","SPARK","SPAZ","SPAZ2","SPAZ3D","SPIKEBOLL","SPIKEBOLL3D","SPIKEPLAT","SPRING","STEAM","SUCKER","TUBETURT","TUFBOSS","TUFTUR","TURTLE","TWEEDLE","UTERUS","VINE","WARP10","WARP100","WARP20","WARP50","WITCH","XBILSY","XLIZARD","XTURTLE","ZDOG","ZSPARK"]},{"type":"uint8","name":"animation","attributes":[],"items":[]},{"type":"bool","name":"change","defaultValue":"true","attributes":[],"items":[]}]},{"name":"determineCurFrame","description":"Determines the value of the curFrame corresponding to this jjOBJ's current curAnim and frameID values. If change is specified as false, this calculates the proper value but does not actually set this particular jjOBJ's curFrame property to that value.\nInternally, this method runs the following code:\n\t\t\t\tconst jjANIMATION@ animation = jjAnimations[this.curAnim];\nconst uint newCurFrameValue = (animation.frameCount == 0) ? 0 : (animation.firstFrame + (this.frameID % animation.frameCount));\nif (change)\n\tthis.curFrame = newCurFrameValue;\nreturn newCurFrameValue;\n","full":"uint determineCurFrame(bool change = true)","type":"function","arguments":[{"type":"bool","name":"change","defaultValue":"true","attributes":[],"items":[]}]},{"name":"doesCollide","description":"Returns true if the object's sprite collides with that of the specified object or player, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables�including playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in�are taken into account.\n","full":"bool doesCollide(const jjOBJ@ object, bool always = false) const","type":"function","arguments":[{"type":"jjOBJ@","name":"object","attributes":["const"],"items":[]},{"type":"bool","name":"always","defaultValue":"false","attributes":[],"items":[]}]},{"name":"doesCollide","description":"Returns true if the object's sprite collides with that of the specified object or player, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables�including playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in�are taken into account.\n","full":"bool doesCollide(const jjPLAYER@ player, bool always = false) const","type":"function","arguments":[{"type":"jjPLAYER@","name":"player","attributes":["const"],"items":[]},{"type":"bool","name":"always","defaultValue":"false","attributes":[],"items":[]}]},{"name":"draw","description":"Essentially a wrapper for jjDrawSpriteFromCurFrame; uses the jjOBJ's xPos, yPos, direction, freeze, justHit, and curFrame properties to determine where to draw the sprite and what mode to use. This isn't specific enough for all objects, but it does the job in a high percentage of cases.\n","full":"int draw()","type":"function","arguments":[]},{"name":"findNearestPlayer","description":"Returns the playerID property of the nearest jjPLAYER object within maxDistance, or a negative number if none exist. If the foundDistance parameter is included, it will be set to the distance of the found jjPLAYER. Both maxDistance and foundDistance are actually squares of the distance expressed in pixels. Used by numerous enemies and other objects in order to react to nearby players.\n","full":"int findNearestPlayer(int maxDistance) const","type":"function","arguments":[{"type":"int","name":"maxDistance","attributes":[],"items":[]}]},{"name":"findNearestPlayer","description":"Returns the playerID property of the nearest jjPLAYER object within maxDistance, or a negative number if none exist. If the foundDistance parameter is included, it will be set to the distance of the found jjPLAYER. Both maxDistance and foundDistance are actually squares of the distance expressed in pixels. Used by numerous enemies and other objects in order to react to nearby players.\n","full":"int findNearestPlayer(int maxDistance, int &out foundDistance) const","type":"function","arguments":[{"type":"int","name":"maxDistance","attributes":[],"items":[]},{"type":"int","name":"&out","attributes":[],"items":[]}]},{"name":"fireBullet","description":"A much-simplified version of jjAddObject. This method creates a new object of type eventID, directly at the \"gunspot\" position of the jjOBJ's current curFrame sprite, and sets its direction, xSpeed, and xAcc based on the jjOBJ's direction. The return value is the object ID of the new bullet object, or 0 if the method was unsuccessful. Used by dragons, hatters, Bilsy, and so on.\n","full":"int fireBullet(OBJECT::Object eventID) const","type":"function","arguments":[{"type":"OBJECT::Object","name":"eventID","attributes":[],"items":["BLASTERBULLET","BOUNCERBULLET","ICEBULLET","SEEKERBULLET","RFBULLET","TOASTERBULLET","FIREBALLBULLET","ELECTROBULLET","BLASTERBULLETPU","BOUNCERBULLETPU","ICEBULLETPU","SEEKERBULLETPU","RFBULLETPU","TOASTERBULLETPU","FIREBALLBULLETPU","ELECTROBULLETPU","FIRESHIELDBULLET","WATERSHIELDBULLET","BUBBLESHIELDBULLET","LIGHTNINGSHIELDBULLET","PLASMASHIELDBULLET","BULLET","SMOKERING","SHARD","EXPLOSION","BOUNCEONCE","FLICKERGEM","LASER","UTERUSSPIKEBALL","BIRD","BUBBLE","ICEAMMO3","BOUNCERAMMO3","SEEKERAMMO3","RFAMMO3","TOASTERAMMO3","TNTAMMO3","GUN8AMMO3","GUN9AMMO3","TURTLESHELL","SWINGINGVINE","BOMB","SILVERCOIN","GOLDCOIN","GUNCRATE","CARROTCRATE","ONEUPCRATE","GEMBARREL","CARROTBARREL","ONEUPBARREL","BOMBCRATE","ICEAMMO15","BOUNCERAMMO15","SEEKERAMMO15","RFAMMO15","TOASTERAMMO15","TNT","AIRBOARDGENERATOR","FROZENSPRING","FASTFIRE","SPRINGCRATE","REDGEM","GREENGEM","BLUEGEM","PURPLEGEM","SUPERGEM","BIRDCAGE","GUNBARREL","GEMCRATE","MORPH","CARROT","FULLENERGY","FIRESHIELD","WATERSHIELD","BUBBLESHIELD","LIGHTNINGSHIELD","PLASMASHIELD","FASTFEET","ONEUP","EXTRALIFE","EXTRALIVE","EOLPOST","SAVEPOST","CHECKPOINT","BONUSPOST","REDSPRING","GREENSPRING","BLUESPRING","INVINCIBILITY","EXTRATIME","FREEZER","FREEZEENEMIES","HORREDSPRING","HORGREENSPRING","HORBLUESPRING","BIRDMORPH","TRIGGERCRATE","FLYCARROT","RECTREDGEM","RECTGREENGEM","RECTBLUEGEM","TUFTURT","TUFBOSS","LABRAT","DRAGON","LIZARD","BEE","BUMBEE","RAPIER","SPARK","BAT","SUCKER","CATERPILLAR","CHESHIRE1","CHESHIRE2","HATTER","BILSY","SKELETON","DOGGYDOGG","NORMTURTLE","HELMUT","DEMON","DRAGONFLY","MONKEY","FATCHICK","FENCER","FISH","MOTH","STEAM","ROTATINGROCK","BLASTERPOWERUP","BOUNCERPOWERUP","ICEPOWERUP","SEEKERPOWERUP","RFPOWERUP","TOASTERPOWERUP","LEFTPADDLE","RIGHTPADDLE","FIVEHUNDREDBUMP","CARROTBUMP","APPLE","BANANA","CHERRY","ORANGE","PEAR","PRETZEL","STRAWBERRY","STEADYLIGHT","PULZELIGHT","PULSELIGHT","FLICKERLIGHT","QUEEN","FLOATSUCKER","BRIDGE","LEMON","LIME","THING","WATERMELON","PEACH","GRAPES","LETTUCE","EGGPLANT","CUCUMB","CUCUMBER","COKE","SOFTDRINK","PEPSI","SODAPOP","MILK","PIE","CAKE","DONUT","CUPCAKE","CHIPS","CANDY","CHOCBAR","CHOCOLATEBAR","ICECREAM","BURGER","PIZZA","FRIES","CHICKENLEG","SANDWICH","TACO","WEENIE","HAM","CHEESE","FLOATLIZARD","STANDMONKEY","DESTRUCTSCENERY","DESTRUCTSCENERYBOMB","TNTDESTRUCTSCENERY","COLLAPSESCENERY","STOMPSCENERY","GEMSTOMP","RAVEN","TUBETURTLE","GEMRING","SMALLTREE","AMBIENTSOUND","UTERUS","CRAB","WITCH","ROCKETTURTLE","BUBBA","DEVILDEVAN","DEVANROBOT","ROBOT","CARROTUSPOLE","PSYCHPOLE","DIAMONDUSPOLE","FRUITPLATFORM","BOLLPLATFORM","GRASSPLATFORM","PINKPLATFORM","SONICPLATFORM","SPIKEPLATFORM","SPIKEBOLL","GENERATOR","EVA","BUBBLER","TNTPOWERUP","GUN8POWERUP","GUN9POWERUP","SPIKEBOLL3D","SPRINGCORD","BEES","COPTER","LASERSHIELD","STOPWATCH","JUNGLEPOLE","WARP","BIGROCK","BIGBOX","TRIGGERSCENERY","BOLLY","BUTTERFLY","BEEBOY","SNOW","TWEEDLEBOSS","AIRBOARD","CTFBASE","XMASNORMTURTLE","XMASLIZARD","XMASFLOATLIZARD","XMASBILSY","CAT","PACMANGHOST"]}]},{"name":"grantPickup","description":"Potentially creates a random pickup (red gem, green gem, blue gem, or carrot) in front of the jjOBJ, the likelihood depending on frequency (higher values are less likely). Traditionally, this method is called when an enemy or crate is destroyed by a bullet, and frequency equals 5 if the bullet was an unpowered-up blaster bullet or otherwise 10.\nThe player parameter is necessary because one in every eight pickups a player is granted is a fastfire instead, so JJ2 needs to be able to keep track of when each individual player should next receive a fastfire.\nOnly works if creatorType equals CREATOR::LEVEL.\n","full":"void grantPickup(jjPLAYER@ player, int frequency) const","type":"function","arguments":[{"type":"jjPLAYER@","name":"player","attributes":[],"items":[]},{"type":"int","name":"frequency","attributes":[],"items":[]}]},{"name":"objectHit","description":"Assumes that this object is a player bullet colliding with object target, even if they are not in the same area or if this object is not actually HANDLING::PLAYERBULLET. You are allowed to set what HANDLING::Player value the target object will be treated as having�HANDLING::ENEMY, HANDLING::SPECIAL, or HANDLING::PICKUP, with all other values having no effect�but otherwise the code will run exactly as if the two objects really did collide. Effects may or may not be broadcast to other players in the server, and some version of onObjectHit will be called (with force as this object's animSpeed property) iff target has scriptedCollisions set to true and HANDLING::SPECIAL is passed as playerHandling.\n","full":"void objectHit(jjOBJ@ target, HANDLING::Player playerHandling)","type":"function","arguments":[{"type":"jjOBJ@","name":"target","attributes":[],"items":[]},{"type":"HANDLING::Player","name":"playerHandling","attributes":[],"items":["PICKUP","ENEMY","SPECIAL","PICKUP","ENEMYBULLET","PLAYERBULLET"]}]},{"name":"particlePixelExplosion","description":"A fast wrapper for jjAddParticlePixelExplosion, using the jjOBJ's own xPos, yPos, direction, and curFrame properties.\n","full":"void particlePixelExplosion(int style) const","type":"function","arguments":[{"type":"int","name":"style","attributes":[],"items":[]}]},{"name":"pathMovement","description":"Makes the object use the same waypoint-based path movement as the Butterfly and Rocket Turtle objects. The method potentially sets the xAcc, yAcc, xPos, yPos, xSpeed, ySpeed, counter, direction, var[6] and var[7] properties in the process.\n","full":"void pathMovement()","type":"function","arguments":[]},{"name":"putOnGround","description":"Moves the object downward until it's on top of the nearest available masked tile below it, or else the bottom of the level. If precise is left false, the resulting yPos may be off by as much as three pixels either up or down, which is still fine for most objects.\n","full":"void putOnGround(bool precise = false)","type":"function","arguments":[{"type":"bool","name":"precise","defaultValue":"false","attributes":[],"items":[]}]},{"name":"ricochet","description":"To be used on bullet objects. Reverses the bullet's xSpeed/xAcc/direction, gives it a randomized ySpeed, plays one of the SOUND::AMMO_BUL* samples, and calls jjAddParticle(PARTICLE::SPARK) several times. Returns false if the bullet last ricocheted too recently.\n","full":"bool ricochet()","type":"function","arguments":[]},{"name":"unfreeze","description":"Sets freeze to 0, plays SOUND::COMMON_ICECRUSH, and creates an explosion of ice fragments radiating outward from the object. Unique values for style are 0, 1, or any other number.\n","full":"int unfreeze(int style)","type":"function","arguments":[{"type":"int","name":"style","attributes":[],"items":[]}]}],"jjPARTICLEList":[{"name":"isActive","description":"The point of this property is somewhat unclear, since JJ2 prefers to check if a given particle is active by testing whether type equals PARTICLE::INACTIVE or not, but it does exist and does get set sometimes.\n","full":"bool isActive","type":"property","arguments":[]},{"name":"type","description":"Any of the standard type options allowed by jjAddParticle: INACTIVE, FIRE, FLOWER, ICETRAIL, LEAF, PIXEL, RAIN, SMOKE, SNOW, SPARK, STAR, STRING, or TILE.\n","full":"PARTICLE::Type type","type":"property","arguments":[]},{"name":"xPos","description":"Horizontal location in pixels.\n","full":"float xPos","type":"property","arguments":[]},{"name":"xSpeed","description":"Horizontal speed in pixels, positive or negative.\n","full":"float xSpeed","type":"property","arguments":[]},{"name":"yPos","description":"Vertical location in pixels.\n","full":"float yPos","type":"property","arguments":[]},{"name":"ySpeed","description":"Vertical speed in pixels, positive or negative.\n","full":"float ySpeed","type":"property","arguments":[]},{"name":"fire","description":"Corresponds to PARTICLE::FIRE. Fire particles are drawn as small horizontal ovals, and before they disappear, may at any time create a smoke particle. Fire particles are usually created when an enemy or other destructible object is destroyed using a fire-based weapon.\nuint8 fire.color is the color (palette entry) which a fire particle will be drawn as. This property gradually increases as the particle remains active, until it reaches colorStop (default 48, pink), at which point the particle will disappear. The default initial value is 40 (yellow).\nint8 fire.colorDelta is the rate at which the color property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.\nuint8 fire.colorStop is the color value which, when reached, will cause the particle to disappear. The default value is 48 (pink).\nuint8 fire.size decides how large the oval will be, ranging from 0-3. The default value is 3.\n","full":"fire","type":"property","arguments":[]},{"name":"flower","description":"Corresponds to PARTICLE::FLOWER. Flower particles are drawn as single color, partially transparent, rotationally symmetric flowers, and drift for a while while getting progressively smaller. They are traditionally created by setting Type=1 on a Snow event.\nuint8 flower.angle is the current angle of rotation the flower is drawn at.\nint8 flower.angularSpeed is how much the angle changes every tick, positive or negative. By default they do not rotate at all.\nuint8 flower.color is the color which a flower particle will be drawn as, and does not change during the particle's lifetime. The default value is 16 (green)\nuint8 flower.size is how large the flower should be drawn, though this is not equal to its size in actual pixels. Decreases by 1 every tick until it reaches 0, at which point the particle disappears. The default starting value is 64.\n","full":"flower","type":"property","arguments":[]},{"name":"icetrail","description":"Corresponds to PARTICLE::ICETRAIL. Ice trail particles are drawn as single pixels. In regular JJ2, ice bullets leave them in their wake as they fly.\nuint8 icetrail.color is the color (palette entry) which an ice trail particle will be drawn as. This property gradually increases as the particle remains active, until it reaches colorStop (default 40, yellow), at which point the particle will disappear. The default initial value is 32 (light blue).\nint8 icetrail.colorDelta is the rate at which the color property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.\nuint8 icetrail.colorStop is the color value which, when reached, will cause the particle to disappear. The default value is 40 (yellow).\n","full":"icetrail","type":"property","arguments":[]},{"name":"leaf","description":"Corresponds to PARTICLE::LEAF. Leaf particles are drawn as frames of the ANIM::PLUS_SCENERY animation set, and float along based on their speed properties and some random jiggling, until they pass offscreen or hit a wall and fall to the ground. They are traditionally created by setting Type=3 on a Snow event. Note that you will need to load ANIM::PLUS_SCENERY manually in order for leaf particles to display properly.\nuint8 leaf.countup is set to 1 when the leaf hits a wall, then increments every tick until it hits 140 and the particle is deleted.\nuint8 leaf.frame specifies which frame of the animation will be drawn. This ranges from 0-31 when the leaf is in motion and 0-2 once the deathcounter property is non-zero. The value of this property does not exactly correspond to frames in the animation in plus.j2a, however, since the leaf animation repeats many frames that are only included once in the file.\nuint16 leaf.frameBase is ID of the frame the particle will use as a base sprite (curFrame-style), and has the default value of jjAnimations[jjAnimSets[ANIM::PLUS_SCENERY].firstAnim].firstFrame.\nuint8 leaf.height is the distance from the ground in pixels that the particle must be in order to stop falling after hitting a wall. The default value is 2.\n","full":"leaf","type":"property","arguments":[]},{"name":"pixel","description":"Corresponds to PARTICLE::PIXEL. Depending on their size value, pixel particles will be drawn as\t1x1, 2x2, or 3x3 rectangles of pixels. They move both horizontally and vertically, and will also bounce off of masks. These are the particles created by destroying most enemies.\nuint8 pixel.color[9] specifies which colors will be drawn at each pixel in the particle's rectangle. Note that if the rectangle is smaller than 3x3, not every number in the array will be used. Values of 0 represent transparent pixels and will therefore not be drawn.\nuint8 pixel.size specifies the size of the rectangle drawn to the screen. 0 for 1x1, 1 for 2x2, or any other number for 3x3. The default value is 0.\n","full":"pixel","type":"property","arguments":[]},{"name":"rain","description":"Corresponds to PARTICLE::RAIN. Rain particles are drawn as transparent, resized sprites, and move around according to their xSpeed/ySpeed properties until they hit a masked pixel, at which point they are either deleted (if the pixel is to their side) or begin a splashing animation (if the pixel is above or below). They are traditionally created by setting Type=2 on a Snow event.\nuint8 rain.frame ranges from 0-7 while the particle is in motion, switches to 8 upon hitting a floor or ceiling, and then increases until it hits 18 and the particle is deleted.\nuint16 rain.frameBase is the first frame of the animation used by the particle, and has the default value of jjAnimations[jjAnimSets[ANIM::COMMON].firstAnim + 2].firstFrame. The displayed frame will be equal to this property plus the current value of the frame property.\n","full":"rain","type":"property","arguments":[]},{"name":"smoke","description":"Corresponds to PARTICLE::SMOKE. Smoke particles are drawn as small gray rectangles and always move erratically upwards. Traditionally they are created from fire particles or from the BEHAVIOR::BURNING objects created by powered-up toaster or a frozen Bily.\nuint8 smoke.countdown gradually decreases until it reaches 64, at which point the particle will disappear. The default value is 71.\n","full":"smoke","type":"property","arguments":[]},{"name":"snow","description":"Corresponds to PARTICLE::SNOW. Snow particles are drawn as frames of the ANIM::SNOW animation set, and fly slowly around based on their speed properties and a general wind force until they hit a masked tile and slowly fade away. They are, of course, traditionally created by the Snow event. Note that you will need to load ANIM::SNOW manually in order for snow particles to display properly.\nuint8 snow.countdown specifies how long (in ticks) the particle may pass through masked tiles after first being created before masked tiles cause it to fade away and disappear. The default value is 35.\nuint8 snow.countup has something unknown to do with the particle disappearing once it hits a masked tile. The default value is 0.\nuint8 snow.frame specifies which frame of the animation will be drawn. This remains constant until the particle hits a wall, at which point it will increase to 7 before disappearing. The default initial value is 0.\nuint16 snow.frameBase is ID of the frame the particle will use as a base sprite (curFrame-style), and has the default value of jjAnimations[jjAnimSets[ANIM::SNOW].firstAnim].firstFrame. The displayed frame will be equal to this property plus the current value of the frame property.\n","full":"snow","type":"property","arguments":[]},{"name":"spark","description":"Corresponds to PARTICLE::SPARK. Spark particles move around according to their xSpeed/ySpeed properties and also gravity, and are drawn as short trails left behind as they move. They are traditionally created by bullets ricocheting off of turtle shells or metallic surfaces, or by electro-blaster bullets in flight.\nuint8 spark.color is the color (palette entry) which a spark particle's trail will be drawn as. This property gradually increases as the particle remains active, until it reaches colorStop (default 46, maroon), at which point the particle will disappear. The default initial value is 40 (yellow).\nint8 spark.colorDelta is the rate at which the color property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.\nuint8 spark.colorStop is the color value which, when reached, will cause the particle to disappear. The default value is 46 (maroon).\n","full":"spark","type":"property","arguments":[]},{"name":"star","description":"Corresponds to PARTICLE::STAR. Star particles were added to the game to indicate sugar rush. They are drawn as a rotated star sprite. Besides linear speed they also have angular speed and change colors.\nuint8 star.angle is the current angle of rotation the star is drawn at.\nint8 star.angularSpeed is how much the angle changes every tick, positive or negative. By default they do not rotate at all.\nuint8 star.color is the color the star is drawn as. The default value is 40 (yellow).\nuint8 star.colorChangeCounter counts down to 0, at which point it resets to the value of the colorChangeInterval property and changes the color property to one of the sprite colors at random.\n","full":"star","type":"property","arguments":[]},{"name":"string","description":"Corresponds to PARTICLE::STRING. String particles move at ever-increasing speeds until they leave the screen, drawing up to eight consecutive characters as they go. They are traditionally used to show many points a player gained for destroying an object.\nstring string.text is the series of characters that will be drawn. Strings longer than eight characters will be truncated.\n","full":"string","type":"property","arguments":[]},{"name":"tile","description":"Corresponds to PARTICLE::TILE. Tile particles move around according to their xSpeed/ySpeed properties and also gravity, and are drawn as single tiles (or quarters of single tiles) from the tileset used by the level. They are traditionally created from the destruction of destruct or collapse scenery blocks.\nTILE::Quadrant tile.quadrant specifies how much of the tile will be drawn to the screen. Possible values of TILE::Quadrant are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS.\nuint16 tile.tileID specifies which tile the particle draws in the first place. The default value is 0, so remember to change it.\n","full":"tile","type":"property","arguments":[]}],"jjCONTROLPOINTList":[{"name":"controlTeam","description":"The team that this point is presently under control of. Possible values are TEAM::NEUTRAL, TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n","full":"const TEAM::Color controlTeam","type":"property","arguments":[]},{"name":"direction","description":"Direction of the gem sprite displayed by the control point. The value has purely visual influence on the game.\n","full":"const int direction","type":"property","arguments":[]},{"name":"name","description":"The control point's name.\n","full":"const string name","type":"property","arguments":[]},{"name":"xPos","description":"Horizontal position in pixels.\n","full":"const float xPos","type":"property","arguments":[]},{"name":"xTile","description":"Horizontal position in tiles.\n","full":"const int xTile","type":"property","arguments":[]},{"name":"yPos","description":"Vertical position in pixels.\n","full":"const float yPos","type":"property","arguments":[]},{"name":"yTile","description":"Vertical position in tiles.\n","full":"const int yTile","type":"property","arguments":[]}],"jjCHARACTERList":[{"name":"airJump","description":"Determines the character's reaction to pressing jump in the air. Possible values are AIR::NONE, AIR::HELICOPTER and AIR::DOUBLEJUMP. No effect for birds or frogs.\n","full":"AIR::Jump airJump","type":"property","arguments":[]},{"name":"canHurt","description":"Whether the character can cause damage by using their special moves. This property also applies to Chuck's beak attack and Frog's tongue attack. Defaults true for all rabbits and false for birds and frogs.\n","full":"bool canHurt","type":"property","arguments":[]},{"name":"canRun","description":"Whether the character is capable of fast movement. Defaults true for all rabbits and false for birds and frogs.\n","full":"bool canRun","type":"property","arguments":[]},{"name":"doubleJumpCountMax","description":"The maximum number of jumps the character can perform in the air if their airJump property allows it. Defaults 1 for Spaz.\n","full":"int doubleJumpCountMax","type":"property","arguments":[]},{"name":"doubleJumpXSpeed","description":"What horizontal and vertical speed the character will gain by using double jump. doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is relative to the player's current direction, so for example a negative doubleJumpXSpeed will make the character move backwards.\n","full":"float doubleJumpXSpeed","type":"property","arguments":[]},{"name":"doubleJumpYSpeed","description":"What horizontal and vertical speed the character will gain by using double jump. doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is relative to the player's current direction, so for example a negative doubleJumpXSpeed will make the character move backwards.\n","full":"float doubleJumpYSpeed","type":"property","arguments":[]},{"name":"helicopterDurationMax","description":"The maximum amount of time the character can keep using helicopter ears if their airJump property allows it.\n","full":"int helicopterDurationMax","type":"property","arguments":[]},{"name":"helicopterXSpeed","description":"What horizontal and vertical speed the character will gain by using helicopter ears. helicopterYSpeed defaults 1 for all rabbits; its effects when <= 0 are currently undefined. helicopterXSpeed defaults 0 and is relative to the player's current direction, so for example a negative helicopterXSpeed will make the character move backwards.\n","full":"float helicopterXSpeed","type":"property","arguments":[]},{"name":"helicopterYSpeed","description":"What horizontal and vertical speed the character will gain by using helicopter ears. helicopterYSpeed defaults 1 for all rabbits; its effects when <= 0 are currently undefined. helicopterXSpeed defaults 0 and is relative to the player's current direction, so for example a negative helicopterXSpeed will make the character move backwards.\n","full":"float helicopterYSpeed","type":"property","arguments":[]},{"name":"groundJump","description":"Determines the character's reaction to pressing jump while crouching. Possible values are GROUND::JAZZ, GROUND::SPAZ, GROUND::LORI (available even in 1.23), GROUND::CROUCH (character remains crouching and does not jump), and GROUND::JUMP (character jumps but does not immediately buttstomp). No effect for birds or frogs. Note that changing this property to any the first three values may look pretty silly if the animations are not edited accordingly.\n","full":"GROUND::Jump groundJump","type":"property","arguments":[]},{"name":"morphBoxCycle","description":"Whether the character can be morphed to using the \"Jazz<->Spaz\" morph box. Also affects the jjPLAYER function morph when its rabbitsOnly argument is set to true.\n","full":"bool morphBoxCycle","type":"property","arguments":[]}],"jjWEAPONList":[{"name":"allowed","description":"Whether the weapon and/or its powerup can be legally used in the level. This value is used by the server to detect attempts of cheating and kick offenders, and by all players to determine which weapons they get upon use of the /ready command.\nBetween onLevelLoad and onLevelBegin, JJ2+ runs a function to determine the values for these properties for each weapon. jjWeapons[WEAPON::BLASTER].allowed will always be set to true; for the rest, JJ2+ looks at the current contents of jjObjects and checks each active object's jjOBJ::eventID. Any +3 ammo pickup or +15 ammo crate will set allowed to true for that weapon, and any powerup will set both allowed and allowedPowerup to true. Additionally, OBJECT::GUNCRATE and OBJECT::GUNBARREL will both set jjWeapons[WEAPON::BOUNCER].allowed to true, and OBJECT::GENERATOR and object-spawning crates will behave as if they were the objects they will spawn, e.g. a generator that creates +3 Toaster pickups will set jjWeapons[WEAPON::TOASTER].allowed to true. (Anything not set to true will be set to false, so there is no point in editing these properties in onLevelLoad.)\nThis system covers most levels, but it is absolutely possible to set up your level to include ammo that JJ2+ was unable to guess based on a single loop through jjObjects, e.g. MCEs, or the \"Weapon\" parameter on +15 Bouncer crates, or any number of scripting changes. If you're at all unsure whether JJ2+ will make the right predictions for your particular level, there is zero harm in explicitly setting as many allowed and allowedPowerup values as you want, to true or to false, although make sure to set them in onLevelBegin at the earliest.\n","full":"bool allowed","type":"property","arguments":[]},{"name":"allowedPowerup","description":"Whether the weapon and/or its powerup can be legally used in the level. This value is used by the server to detect attempts of cheating and kick offenders, and by all players to determine which weapons they get upon use of the /ready command.\nBetween onLevelLoad and onLevelBegin, JJ2+ runs a function to determine the values for these properties for each weapon. jjWeapons[WEAPON::BLASTER].allowed will always be set to true; for the rest, JJ2+ looks at the current contents of jjObjects and checks each active object's jjOBJ::eventID. Any +3 ammo pickup or +15 ammo crate will set allowed to true for that weapon, and any powerup will set both allowed and allowedPowerup to true. Additionally, OBJECT::GUNCRATE and OBJECT::GUNBARREL will both set jjWeapons[WEAPON::BOUNCER].allowed to true, and OBJECT::GENERATOR and object-spawning crates will behave as if they were the objects they will spawn, e.g. a generator that creates +3 Toaster pickups will set jjWeapons[WEAPON::TOASTER].allowed to true. (Anything not set to true will be set to false, so there is no point in editing these properties in onLevelLoad.)\nThis system covers most levels, but it is absolutely possible to set up your level to include ammo that JJ2+ was unable to guess based on a single loop through jjObjects, e.g. MCEs, or the \"Weapon\" parameter on +15 Bouncer crates, or any number of scripting changes. If you're at all unsure whether JJ2+ will make the right predictions for your particular level, there is zero harm in explicitly setting as many allowed and allowedPowerup values as you want, to true or to false, although make sure to set them in onLevelBegin at the earliest.\n","full":"bool allowedPowerup","type":"property","arguments":[]},{"name":"comesFromBirds","description":"Determines whether or not the red companion bird is allowed to shoot bullets of the specified weapon (comesFromBirds), and, if so, whether they may be powered-up (comesFromBirdsPowerup) if the player currently has a powerup for that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless of the player's currWeapon.\nBird bullets do not affect the player's ammo count, regardless of the weapon's infinite property, and will not be replaced by shield bullets (because the bird does not have its own shield), regardless of the weapon's replacedByShield property.\n\t\t\t\n","full":"bool comesFromBirds","type":"property","arguments":[]},{"name":"comesFromBirdsPowerup","description":"Determines whether or not the red companion bird is allowed to shoot bullets of the specified weapon (comesFromBirds), and, if so, whether they may be powered-up (comesFromBirdsPowerup) if the player currently has a powerup for that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless of the player's currWeapon.\nBird bullets do not affect the player's ammo count, regardless of the weapon's infinite property, and will not be replaced by shield bullets (because the bird does not have its own shield), regardless of the weapon's replacedByShield property.\n\t\t\t\n","full":"bool comesFromBirdsPowerup","type":"property","arguments":[]},{"name":"comesFromGunCrates","description":"Determines whether or not the ammo for the specified weapon can drop from Gun Crates and Gun Barrels. Defaults to true for WEAPON::BOUNCER, WEAPON::ICE, WEAPON::SEEKER, WEAPON::RF, WEAPON::TOASTER, and false for WEAPON::TNT, WEAPON::GUN8 and WEAPON::GUN9. Has no effect on WEAPON::BLASTER. In an online server, the pickups dropped will be according to the comesFromGunCrates settings for the player who destroyed the crate/barrel.\n","full":"bool comesFromGunCrates","type":"property","arguments":[]},{"name":"defaultSample","description":"When false, the default sample of the bullet will not be played.\n","full":"bool defaultSample","type":"property","arguments":[]},{"name":"gemsLost","description":"How many gems a player shot by this weapon will lose in Treasure Hunt. (If the player has fewer gems than the weapon should cause them to lose, they will lose all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT, WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making no difference by default. Doesn't have any effect when changed by clients, only by the server (or in local games).\n","full":"int gemsLost","type":"property","arguments":[]},{"name":"gemsLostPowerup","description":"How many gems a player shot by this weapon will lose in Treasure Hunt. (If the player has fewer gems than the weapon should cause them to lose, they will lose all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT, WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making no difference by default. Doesn't have any effect when changed by clients, only by the server (or in local games).\n","full":"int gemsLostPowerup","type":"property","arguments":[]},{"name":"gradualAim","description":"Whether it takes a few shots for bullets to adjust their direction to the direction the player is aiming, as is the case with pepper spray. If this weapon's spread property is SPREAD::GUN8 and jjAllowsFireball is true, this property will be treated as false.\n","full":"bool gradualAim","type":"property","arguments":[]},{"name":"infinite","description":"When true, ammo displays an infinity symbol for its quantity and can never be deplenished. Defaults to true for WEAPON::BLASTER. When spectating another player, the ammo count will appear according to your infinite setting for their currently chosen weapon, not their own.\n","full":"bool infinite","type":"property","arguments":[]},{"name":"maximum","description":"Determines how much of each ammo type a player can hold at a time. Defaults to -1, which is interpreted as \"99 in single player or cooperative, otherwise 50,\" but you may want to change some numbers individually (e.g. limit the number of seekers but not bouncers).\n","full":"int maximum","type":"property","arguments":[]},{"name":"multiplier","description":"The factor by which ammo pickups/powerups increase a weapon's ammo count, and by which that count is divided to be displayed onscreen. Defaults to 32 for WEAPON::TOASTER and 1 for everything else. When spectating another player, the ammo count will appear according to your multiplier setting for their currently chosen weapon, not their own.\n","full":"int multiplier","type":"property","arguments":[]},{"name":"replacedByBubbles","description":"When true, the bullet will be replaced by an air bubble when shot underwater or if it goes underwater subsequent to being shot. Defaults to true for WEAPON::TOASTER (and therefore also for fire shield bullets).\n","full":"bool replacedByBubbles","type":"property","arguments":[]},{"name":"replacedByShield","description":"When true and a shield is active, shield ammo will replace default weapon ammo. Defaults to true for WEAPON::BLASTER.\nUnder certain circumstances this setting is used to determine validity of network packets, so keep in mind that if its value is not the same for the host as it is for clients, they may be kicked for cheating.\n","full":"bool replacedByShield","type":"property","arguments":[]},{"name":"replenishes","description":"When true, ammo jumps back up to 50 or 99 on level (re)load. Should be set in onLevelLoad, rather than onLevelBegin, since it actually takes effect between the two. Defaults to true for WEAPON::BLASTER.\n","full":"bool replenishes","type":"property","arguments":[]},{"name":"spread","description":"How many bullets are spawned by a single use of the weapon and in what manner. Possible values are:\n\t\t\t\tNORMAL: Fires one bullet.\n\t\t\t\tICEPU: Fires two bullets; one in the direction you face, one in the direction you aim.\n\t\t\t\tICE: Same as NORMAL when not powered up, and ICEPU when powered up.\n\t\t\t\tRFNORMAL: Fires two bullets.\n\t\t\t\tRFPU: Fires three bullets.\n\t\t\t\tRF: Same as RFNORMAL when not powered up, and RFPU when powered up.\n\t\t\t\tTOASTER: Fires one bullet with its speed partially determined by how much fastfire the player has.\n\t\t\t\tPEPPERSPRAY: Fires two pepper spray bullets.\n\t\t\t\tGUN8: Same as NORMAL if jjAllowsFireball is true (but ignoring this weapon's gradualAim property), and PEPPERSPRAY when it's off.\n\t\t\t\t\nAny assignments of GUN8 or PEPPERSPRAY should be shared between clients and server to prevent kicking for invalid gun use.\n","full":"SPREAD::Spread spread","type":"property","arguments":[]},{"name":"style","description":"Determines how often will the weapon fire a bullet when the player holds the fire button. Possible values are WEAPON::NORMAL (fires continously, respecting the player's fastfire property), WEAPON::MISSILE (fires once per press of the button), WEAPON::POPCORN (fires continously and respects the player's fastfire property, but at a capped minimum rate of fire), and WEAPON::CAPPED (like NORMAL, but prevents players from shooting faster than allowed by their fastfire property).\n","full":"WEAPON::Style style","type":"property","arguments":[]}],"jjSTREAMList":[{"name":"clear","description":"Clears content of the stream leaving it empty.\n","full":"void clear()","type":"function","arguments":[]},{"name":"discard","description":"Discards count bytes from the front of the stream. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n","full":"bool discard(uint count)","type":"function","arguments":[{"type":"uint","name":"count","attributes":[],"items":[]}]},{"name":"get","description":"Reads count bytes from the front of the stream, removes them and places their contents into value. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n","full":"bool get(const string &out value, uint count = 1)","type":"function","arguments":[{"type":"uint","name":"count","defaultValue":"1","attributes":[],"items":[]}]},{"name":"get","description":"Reads count bytes from the front of the stream, removes them and places their contents into value. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n","full":"bool get(const jjSTREAM &out value, uint count = 1)","type":"function","arguments":[{"type":"uint","name":"count","defaultValue":"1","attributes":[],"items":[]}]},{"name":"getLine","description":"Reads bytes from the stream, interpreting them as text characters, until it finds the character sequence delim. The read bytes are placed into value. All read characters are removed from the stream, including delim; however, the resulting value will not contain delim. Returns true on success and false if delim was not found anywhere in the stream. In the latter case, the behavior is still well-defined and all contents of the stream are placed into value, making the stream empty.\n","full":"bool getLine(string &out value, const string &in delim = '\\n')","type":"function","arguments":[{"type":"string","name":"&out","attributes":[],"items":[]},{"type":"string","name":"delim","attributes":["const","&in"],"items":[]}]},{"name":"getSize","description":"Returns size of the stream in bytes.\n","full":"uint getSize() const","type":"function","arguments":[]},{"name":"isEmpty","description":"Returns whether the stream is empty, i.e. whether getSize() == 0.\n","full":"bool isEmpty() const","type":"function","arguments":[]},{"name":"pop","description":"Pops value from the stream into value, causing value to be filled and reducing the size of the stream. Returns true on success and false on failure, i.e. if the stream didn't have sufficiently many bytes to perform the operation. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow obtaining data previously inserted using push (read its documentation for details).\n","full":"bool pop(T &out value)","type":"function","arguments":[{"type":"T","name":"&out","attributes":[],"items":[]}]},{"name":"push","description":"Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n","full":"bool push(T value)","type":"function","arguments":[{"type":"T","name":"value","attributes":[],"items":[]}]},{"name":"push","description":"Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n","full":"bool push(const string &in value)","type":"function","arguments":[{"type":"string","name":"value","attributes":["const","&in"],"items":[]}]},{"name":"push","description":"Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n","full":"bool push(const jjSTREAM &in value)","type":"function","arguments":[{"type":"jjSTREAM","name":"value","attributes":["const","&in"],"items":[]}]},{"name":"save","description":"Saves contents of the stream to file filename and returns whether successful.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".asdat\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjANIMATION::save and jjPIXELMAP::save).\n","full":"bool save(const string &in filename) const","type":"function","arguments":[{"type":"string","name":"filename","attributes":["const","&in"],"items":[]}]},{"name":"write","description":"Appends bytes of value at the end of the stream. In contrast to push, this method doesn't store the size of the provided string or stream, thus making it impossible to pop, but it can still be obtained with get if the size is known or getLine if it ends with a defined delimiter. Returns whether successful, which is always true.\n","full":"bool write(const string &in value)","type":"function","arguments":[{"type":"string","name":"value","attributes":["const","&in"],"items":[]}]},{"name":"write","description":"Appends bytes of value at the end of the stream. In contrast to push, this method doesn't store the size of the provided string or stream, thus making it impossible to pop, but it can still be obtained with get if the size is known or getLine if it ends with a defined delimiter. Returns whether successful, which is always true.\n","full":"bool write(const jjSTREAM &in value)","type":"function","arguments":[{"type":"jjSTREAM","name":"value","attributes":["const","&in"],"items":[]}]}],"jjRNGList":[{"name":"seed","description":"Sets the current state of the generator based on value.\n","full":"void seed(uint64 value = 5489)","type":"function","arguments":[{"type":"uint64","name":"value","defaultValue":"5489","attributes":[],"items":[]}]},{"name":"discard","description":"Advances the generator's state by count. The effect is equivalent to invoking the call operator count times and discarding the returned values, but calculated more efficiently.\n","full":"void discard(uint64 count = 1)","type":"function","arguments":[{"type":"uint64","name":"count","defaultValue":"1","attributes":[],"items":[]}]}],"jjPALList":[{"name":"color[256]","description":"At its heart, a palette is a collection of 256 colors, and you can access them individually through the color array. In fact, you could if you chose reproduce nearly every jjPAL method here by directly altering the colors, but the methods are here to save you time, so don't do that. The details of jjPALCOLOR objects are listed below this section, though most basically you just use their properties red, green, and blue.\n","full":"jjPALCOLOR color[256]","type":"property","arguments":[]},{"name":"apply","description":"Causes the contents of this jjPAL object to be the current colors in use by the game, and by extension jjPalette.\nNote that this function does a fair bit of housekeeping behind the scenes to make sure everything is propertly converted to the new palette�there's a difference between myPal.apply(); and jjPalette = myPal;�and so it should always be called after doing any edits, even if you've been making the edits directly to jjPalette. Failure to do so can have unpredictable consequences.\n","full":"void apply() const","type":"function","arguments":[]},{"name":"copyFrom","description":"Overlays length colors from source onto the current palette, beginning at start on this palette and start2 on source. If opacity is below 1.0, the new colors will only partially replace the old.\n","full":"void copyFrom(uint8 start, uint8 length, uint8 start2, const jjPAL &in source, float opacity)","type":"function","arguments":[{"type":"uint8","name":"start","attributes":[],"items":[]},{"type":"uint8","name":"length","attributes":[],"items":[]},{"type":"uint8","name":"start2","attributes":[],"items":[]},{"type":"jjPAL","name":"source","attributes":["const","&in"],"items":[]},{"type":"float","name":"opacity","attributes":[],"items":[]}]},{"name":"fill","description":"Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n","full":"void fill(uint8 red, uint8 green, uint8 blue, uint8 start, uint8 length, float opacity = 1.0)","type":"function","arguments":[{"type":"uint8","name":"red","attributes":[],"items":[]},{"type":"uint8","name":"green","attributes":[],"items":[]},{"type":"uint8","name":"blue","attributes":[],"items":[]},{"type":"uint8","name":"start","attributes":[],"items":[]},{"type":"uint8","name":"length","attributes":[],"items":[]},{"type":"float","name":"opacity","defaultValue":"1.0","attributes":[],"items":[]}]},{"name":"fill","description":"Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n","full":"void fill(uint8 red, uint8 green, uint8 blue, float opacity = 1.0)","type":"function","arguments":[{"type":"uint8","name":"red","attributes":[],"items":[]},{"type":"uint8","name":"green","attributes":[],"items":[]},{"type":"uint8","name":"blue","attributes":[],"items":[]},{"type":"float","name":"opacity","defaultValue":"1.0","attributes":[],"items":[]}]},{"name":"fill","description":"Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n","full":"void fill(jjPALCOLOR color, uint8 start, uint8 length, float opacity = 1.0)","type":"function","arguments":[{"type":"jjPALCOLOR","name":"color","attributes":[],"items":[]},{"type":"uint8","name":"start","attributes":[],"items":[]},{"type":"uint8","name":"length","attributes":[],"items":[]},{"type":"float","name":"opacity","defaultValue":"1.0","attributes":[],"items":[]}]},{"name":"fill","description":"Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n","full":"void fill(jjPALCOLOR color, float opacity = 1.0)","type":"function","arguments":[{"type":"jjPALCOLOR","name":"color","attributes":[],"items":[]},{"type":"float","name":"opacity","defaultValue":"1.0","attributes":[],"items":[]}]},{"name":"findNearestColor","description":"Returns index of the palette entry whose components differ the least from those of the provided color. Ensures the result has no special treatment by never returning values from the range of 0-15.\n","full":"uint8 findNearestColor(jjPALCOLOR color) const","type":"function","arguments":[{"type":"jjPALCOLOR","name":"color","attributes":[],"items":[]}]},{"name":"gradient","description":"Replaces a series of length colors beginning at start with a gradient beginning with red1,green1,blue1 (or color1) and ending with red2,green2,blue2 (or color2). If opacity is specified and below 1.0, the new colors will only partially replace the old, making for a tinting effect.\nIf inclusive is false (default), the gradient will lead up to the second color but the second color will not itself appear. If true, the second color will appear directly in the palette as the final color of the gradient. For example, a gradient of red1:100, red2:0, and length:3 will produce the red values 100,66,33 when inclusive is false, but 100,50,0 when inclusive is true.\nThe default values for start and length will set a gradient for the colors used by water and (in most tilesets) textured backgrounds.\n","full":"void gradient(uint8 red1, uint8 green1, uint8 blue1, uint8 red2, uint8 green2, uint8 blue2, uint8 start = 176, uint8 length = 32, float opacity = 1.0, bool inclusive = false)","type":"function","arguments":[{"type":"uint8","name":"red1","attributes":[],"items":[]},{"type":"uint8","name":"green1","attributes":[],"items":[]},{"type":"uint8","name":"blue1","attributes":[],"items":[]},{"type":"uint8","name":"red2","attributes":[],"items":[]},{"type":"uint8","name":"green2","attributes":[],"items":[]},{"type":"uint8","name":"blue2","attributes":[],"items":[]},{"type":"uint8","name":"start","defaultValue":"176","attributes":[],"items":[]},{"type":"uint8","name":"length","defaultValue":"32","attributes":[],"items":[]},{"type":"float","name":"opacity","defaultValue":"1.0","attributes":[],"items":[]},{"type":"bool","name":"inclusive","defaultValue":"false","attributes":[],"items":[]}]},{"name":"gradient","description":"Replaces a series of length colors beginning at start with a gradient beginning with red1,green1,blue1 (or color1) and ending with red2,green2,blue2 (or color2). If opacity is specified and below 1.0, the new colors will only partially replace the old, making for a tinting effect.\nIf inclusive is false (default), the gradient will lead up to the second color but the second color will not itself appear. If true, the second color will appear directly in the palette as the final color of the gradient. For example, a gradient of red1:100, red2:0, and length:3 will produce the red values 100,66,33 when inclusive is false, but 100,50,0 when inclusive is true.\nThe default values for start and length will set a gradient for the colors used by water and (in most tilesets) textured backgrounds.\n","full":"void gradient(jjPALCOLOR color1, jjPALCOLOR color2, uint8 start = 176, uint8 length = 32, float opacity = 1.0, bool inclusive = false)","type":"function","arguments":[{"type":"jjPALCOLOR","name":"color1","attributes":[],"items":[]},{"type":"jjPALCOLOR","name":"color2","attributes":[],"items":[]},{"type":"uint8","name":"start","defaultValue":"176","attributes":[],"items":[]},{"type":"uint8","name":"length","defaultValue":"32","attributes":[],"items":[]},{"type":"float","name":"opacity","defaultValue":"1.0","attributes":[],"items":[]},{"type":"bool","name":"inclusive","defaultValue":"false","attributes":[],"items":[]}]},{"name":"load","description":"Loads a palette from the specified file. If the file is a tileset with a \".j2t\" extension, an 8-bit globally-paletted GIF image/animation with a \".gif\" extension, or an 8-bit paletted or grayscale PNG image with a \".png\" extension, will try to access the palette stored in the file. Otherwise, tries to treat it as a palette file saved in \"Color Table\" format in Palette Suite, and if that fails, simply reads the first 1024 bytes of the file. Returns false if the file cannot be found, or if trying to read the file based on its extension fails, or if the file is fewer than 1024 bytes long; otherwise true.\n","full":"bool load(string& filename)","type":"function","arguments":[{"type":"string&","name":"filename","attributes":[],"items":[]}]},{"name":"reset","description":"Loads the original colors used by the tileset. There is no non-stylistic difference between myPal.reset(); and myPal = jjBackupPalette;.\n","full":"void reset()","type":"function","arguments":[]}],"jjPALCOLORList":[{"name":"red","description":"How red this palette color is.\n","full":"uint8 red","type":"property","arguments":[]},{"name":"green","description":"How green this palette color is.\n","full":"uint8 green","type":"property","arguments":[]},{"name":"blue","description":"How blue this palette color is.\n","full":"uint8 blue","type":"property","arguments":[]},{"name":"getHue","description":"The hue of this palette color.\n","full":"uint8 getHue() const","type":"function","arguments":[]},{"name":"getSat","description":"The saturation of this palette color, where 0 is grayscale and 255 is most saturated.\n","full":"uint8 getSat() const","type":"function","arguments":[]},{"name":"getLight","description":"The lighting of this palette color, where 0 is black and 255 is white.\n","full":"uint8 getLight() const","type":"function","arguments":[]},{"name":"setHSL","description":"Changes the entire color to a brand new one derived from the given HSL values. Due to the complexity of the calculations involved, you can only change all three values at a time, so if you want to leave, for instance, saturation constant, you'll need to read the old value through getSat and then use that as the sat parameter.\nhue is an int instead of a uint8 because it's a loop instead of a scale. 2, 258, 514, -254, etc., are all equally valid and all mean the same hue.\n","full":"void setHSL(int hue, uint8 sat, uint8 light)","type":"function","arguments":[{"type":"int","name":"hue","attributes":[],"items":[]},{"type":"uint8","name":"sat","attributes":[],"items":[]},{"type":"uint8","name":"light","attributes":[],"items":[]}]},{"name":"swizzle","description":"Swaps values of selected components of the color. The value of the red component will be replaced with that specified by parameter red, the value of the green component with that specified by green and the value of blue with that specified by blue. Values accepted by the parameters are COLOR::RED, COLOR::GREEN and COLOR::BLUE.\n","full":"void swizzle(COLOR::Component red, COLOR::Component green, COLOR::Component blue)","type":"function","arguments":[{"type":"COLOR::Component","name":"red","attributes":[],"items":["RED","GREEN","BLUE"]},{"type":"COLOR::Component","name":"green","attributes":[],"items":["RED","GREEN","BLUE"]},{"type":"COLOR::Component","name":"blue","attributes":[],"items":["RED","GREEN","BLUE"]}]}],"jjCANVASList":[{"name":"drawSprite","description":"Draws a single sprite frame at xPixel,yPixel. The setID, animation, and frame parameters correspond to the \"Set ID,\" \"Animation,\" and \"Frame #\" sliders respectively in Jazz Sprite Dynamite, but are 0-indexed. You are allowed to use a simple integer to specify the setID, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24; the full list of constants can be found in the appendix at the bottom of this file. For an example, to draw a broken bird cage (9-5-1 in Jazz Sprite Dynamite), you would write ANIM::BIRD, 4, 0.\nThe direction parameter determines which direction the sprite will be facing; values 0 to 63 will not flip the sprite, -64 to -1 will flip it horizontally, 64 to 127 will flip it vertically, and -128 to -65 will flip it both horizontally and vertically. Alternatively to integer values, you can use constants made for this very purpose that belong to the SPRITE::Direction enum: SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV, SPRITE::FLIPHV.\n","full":"void drawSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, int8 direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"setID","attributes":[],"items":[]},{"type":"uint8","name":"animation","attributes":[],"items":[]},{"type":"uint8","name":"frame","attributes":[],"items":[]},{"type":"int8","name":"direction","defaultValue":"0","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawSpriteFromCurFrame","description":"The same as drawSprite, but takes a single sprite parameter instead of one each for Set, Animation, and Frame. The name references the curFrame property of jjOBJ and jjPLAYER, whose real significance is as an index to jjAnimFrames[].\nInternally any draw*Sprite method is actually a call to the corresponding draw*SpriteFromCurFrame method, with the following formula applied to find the curFrame value: (jjAnimations[jjAnimSets[setID].firstAnim + animation].firstFrame + frame) % jjAnimations[jjAnimSets[setID].firstAnim + animation].frameCount\n","full":"void drawSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, int8 direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"uint","name":"sprite","attributes":[],"items":[]},{"type":"int8","name":"direction","defaultValue":"0","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawResizedSprite","description":"Draws a single resized sprite frame at xPixel,yPixel. This swaps out drawSprite's direction argument with a pair of float arguments, xScale and yScale, which determine how much the sprite is enlarged (or shrunken) on each axis. For example, a 32x32 sprite drawn with xScale 3 and yScale 1.5 would be drawn across a 96�48 area. Making one or both scale values negative will cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing will be performed while resizing the sprite.\n","full":"void drawResizedSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"setID","attributes":[],"items":[]},{"type":"uint8","name":"animation","attributes":[],"items":[]},{"type":"uint8","name":"frame","attributes":[],"items":[]},{"type":"float","name":"xScale","attributes":[],"items":[]},{"type":"float","name":"yScale","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawResizedSpriteFromCurFrame","description":"Draws a single resized sprite frame at xPixel,yPixel. This swaps out drawSprite's direction argument with a pair of float arguments, xScale and yScale, which determine how much the sprite is enlarged (or shrunken) on each axis. For example, a 32x32 sprite drawn with xScale 3 and yScale 1.5 would be drawn across a 96�48 area. Making one or both scale values negative will cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing will be performed while resizing the sprite.\n","full":"void drawResizedSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"uint","name":"sprite","attributes":[],"items":[]},{"type":"float","name":"xScale","attributes":[],"items":[]},{"type":"float","name":"yScale","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawRotatedSprite","description":"Draws a single resized and rotated sprite frame at xPixel,yPixel. This carries over the xScale and yScale arguments from drawResizedSprite, and adds a new angle parameter with the same 0-1023 domain as jjSin and jjCos. (Numbers outside the domain will be seemlessly moduloed.) An angle of 0 will not rotate the sprite at all. Without getting into matrix math, you can think of the sprite as being resized before it is rotated, which in most cases is exactly what you'd want. For example, a 32�32 sprite drawn with angle 256, xScale 2, and yScale 1 would be drawn across an area of 32�64, not 64�32.\nRotated sprites should be no larger (before transformations are applied) than 128 pixels wide or 256 pixels high. The results of drawing larger sprites are, for now, undefined while we decide whether this restriction should or can be removed.\nAny sprite that drawSprite can draw, drawResizedSprite can draw in the same way by setting xScale and yScale each to 1. And any sprite that drawResizedSprite can draw, drawRotatedSprite can draw unless it's greater than 128�256, by setting angle to 0. As you might imagine, though, the simpler methods (besides being quicker to write) run faster than the more complicated methods, so you might as well use them when you can get away with it.\n","full":"void drawRotatedSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"setID","attributes":[],"items":[]},{"type":"uint8","name":"animation","attributes":[],"items":[]},{"type":"uint8","name":"frame","attributes":[],"items":[]},{"type":"int","name":"angle","attributes":[],"items":[]},{"type":"float","name":"xScale","defaultValue":"1","attributes":[],"items":[]},{"type":"float","name":"yScale","defaultValue":"1","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawRotatedSpriteFromCurFrame","description":"Draws a single resized and rotated sprite frame at xPixel,yPixel. This carries over the xScale and yScale arguments from drawResizedSprite, and adds a new angle parameter with the same 0-1023 domain as jjSin and jjCos. (Numbers outside the domain will be seemlessly moduloed.) An angle of 0 will not rotate the sprite at all. Without getting into matrix math, you can think of the sprite as being resized before it is rotated, which in most cases is exactly what you'd want. For example, a 32�32 sprite drawn with angle 256, xScale 2, and yScale 1 would be drawn across an area of 32�64, not 64�32.\nRotated sprites should be no larger (before transformations are applied) than 128 pixels wide or 256 pixels high. The results of drawing larger sprites are, for now, undefined while we decide whether this restriction should or can be removed.\nAny sprite that drawSprite can draw, drawResizedSprite can draw in the same way by setting xScale and yScale each to 1. And any sprite that drawResizedSprite can draw, drawRotatedSprite can draw unless it's greater than 128�256, by setting angle to 0. As you might imagine, though, the simpler methods (besides being quicker to write) run faster than the more complicated methods, so you might as well use them when you can get away with it.\n","full":"void drawRotatedSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"uint","name":"sprite","attributes":[],"items":[]},{"type":"int","name":"angle","attributes":[],"items":[]},{"type":"float","name":"xScale","defaultValue":"1","attributes":[],"items":[]},{"type":"float","name":"yScale","defaultValue":"1","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawSwingingVineSpriteFromCurFrame","description":"Draws a single sprite frame at xPixel,yPixel in the style of a Swinging Vine object. The parameters named length and curvature correspond respectively to properties var[1] (normally always 128) and var[2] of swinging vines; if the sprite is shorter than the length value, its pixels will be repeated again from the top as necessary.\nFor boring internal code reasons, this method expects that sprites will have no transparent pixels. Instead, to tell this method not to draw an individual pixel from the frame, its value must be 128 instead of 0. Using normal transparent pixels instead will cause the sprite to be drawn as a jumbled mess.\n","full":"void drawSwingingVineSpriteFromCurFrame(int xPixel, int yPixel, int sprite, int length, int curvature, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"sprite","attributes":[],"items":[]},{"type":"int","name":"length","attributes":[],"items":[]},{"type":"int","name":"curvature","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawPixel","description":"Changes the color of the pixel at xPixel,yPixel into the palette color corresponding to index color. If you are drawing anything more than a handful of pixels at a time, you should consider creating a new sprite of your own using jjPIXELMAP, and then drawing that sprite as a single unit with some other drawing method.\n","full":"void drawPixel(int xPixel, int yPixel, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"uint8","name":"color","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawRectangle","description":"Draws a rectangle with one of its vertices at xPixel,yPixel of specified width and height in the palette color corresponding to index color.\n","full":"void drawRectangle(int xPixel, int yPixel, int width, int height, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"width","attributes":[],"items":[]},{"type":"int","name":"height","attributes":[],"items":[]},{"type":"uint8","name":"color","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"mode","defaultValue":"SPRITE::NORMAL","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawString","description":"Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is �0�, frame 33 is �A�, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n","full":"void drawString(int xPixel, int yPixel, const string &in text, STRING::Size size = STRING::SMALL,STRING::Mode mode = STRING::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"string","name":"text","attributes":["const","&in"],"items":[]},{"type":"STRING::Size","name":"size","defaultValue":"STRING::SMALL,STRING::Mode","attributes":[],"items":["SMALL","MEDIUM","LARGE"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawString","description":"Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is �0�, frame 33 is �A�, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n","full":"void drawString(int xPixel, int yPixel, const string &in text, const jjANIMATION &in animation, STRING::Mode mode = STRING::NORMAL, uint8 param = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"string","name":"text","attributes":["const","&in"],"items":[]},{"type":"jjANIMATION","name":"animation","attributes":["const","&in"],"items":[]},{"type":"STRING::Mode","name":"mode","defaultValue":"STRING::NORMAL","attributes":[],"items":["NORMAL","DARK","RIGHTALIGN","BOUNCE","SPIN","PALSHIFT"]},{"type":"uint8","name":"param","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawString","description":"Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is �0�, frame 33 is �A�, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n","full":"void drawString(int xPixel, int yPixel, const string &in text, STRING::Size size, const jjTEXTAPPEARANCE &in appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"string","name":"text","attributes":["const","&in"],"items":[]},{"type":"STRING::Size","name":"size","attributes":[],"items":["SMALL","MEDIUM","LARGE"]},{"type":"jjTEXTAPPEARANCE","name":"appearance","attributes":["const","&in"],"items":[]},{"type":"uint8","name":"param1","defaultValue":"0","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"spriteMode","defaultValue":"SPRITE::PALSHIFT","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param2","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawString","description":"Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is �0�, frame 33 is �A�, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n","full":"void drawString(int xPixel, int yPixel, const string &in text, const jjANIMATION &in animation, const jjTEXTAPPEARANCE &in appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"string","name":"text","attributes":["const","&in"],"items":[]},{"type":"jjANIMATION","name":"animation","attributes":["const","&in"],"items":[]},{"type":"jjTEXTAPPEARANCE","name":"appearance","attributes":["const","&in"],"items":[]},{"type":"uint8","name":"param1","defaultValue":"0","attributes":[],"items":[]},{"type":"SPRITE::Mode","name":"spriteMode","defaultValue":"SPRITE::PALSHIFT","attributes":[],"items":["ALPHAMAP","BLEND_NORMAL","BLEND_DISSOLVE","BLEND_DARKEN","BLEND_MULTIPLY","BLEND_BURN","BLEND_LIGHTEN","BLEND_SCREEN","BLEND_DODGE","BLEND_OVERLAY","BLEND_SOFTLIGHT","BLEND_HARDLIGHT","BLEND_DIFFERENCE","BLEND_EXCLUSION","BLEND_COLOR","BLEND_HUE","BLEND_SATURATION","BLEND_LUMINANCE","BRIGHTNESS","CHROMAKEY","FROZEN","GEM","INVISIBLE","MAPPING","MENUPLAYER","NEONGLOW","NORMAL","PALSHIFT","PLAYER","RESIZED","SHADOW","SINGLECOLOR","SINGLEHUE","TINTED","TRANSLUCENT","TRANSLUCENTCOLOR","TRANSLUCENTMAPPING","TRANSLUCENTPALSHIFT","TRANSLUCENTPLAYER","TRANSLUCENTSINGLEHUE","TRANSLUCENTTILE"]},{"type":"uint8","name":"param2","defaultValue":"0","attributes":[],"items":[]}]},{"name":"drawTile","description":"Draws a tile of your choice at some position on the screen. This is purely a drawing operation; using it to draw masked tiles to the screen does not create masked areas for players or other objects to interact with. Possible values of tileQuadrant are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS.\n","full":"void drawTile(int xPixel, int yPixel, uint16 tile, TILE::Quadrant tileQuadrant = TILE::ALLQUADRANTS)","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"uint16","name":"tile","attributes":[],"items":[]},{"type":"TILE::Quadrant","name":"tileQuadrant","defaultValue":"TILE::ALLQUADRANTS","attributes":[],"items":["TOPLEFT","TOPRIGHT","BOTTOMLEFT","BOTTOMRIGHT","ALLQUADRANTS"]}]}],"jjLAYERList":[{"name":"cylinder","description":"Properties used by this layer when its textureStyle is TEXTURE::CYLINDER, which draws texture as the inside of a horizontal cylinder receding a little ways into the distance.\nbool cylinder.fade, when true, increasingly affects colors closer to the horizon: when jjColorDepth is 16, a semitransparent glowing line appears across the horizon using the RGB color chosen by cylinder.setFadeColor, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.\nfloat cylinder.fadePositionX and float cylinder.fadePositionY set the location of the center of the horizon, as multiplied by the size of the player's screen. The default values are both 0.5. Changing fadePositionY very far from 0.5 tends to look weird, especially when cylinder.halfSize is true.\nbool cylinder.halfSize, when true, stretches the texture four times across the screen instead of only once and makes the curvature more extreme. The default value is false.\njjPALCOLOR cylinder.getFadeColor() const and void cylinder.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the horizon when cylinder.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n","full":"cylinder","type":"property","arguments":[]},{"name":"hasTileMap","description":"Layers that contain no tiles at all (other than tile 0) in JCS are saved as defective layers that define size, speed, etc. properties but do not include actual tile maps, meaning that they can never be successfully drawn to the screen. This property is therefore false for those defective layers and true for all other layers.\n","full":"const bool hasTileMap","type":"property","arguments":[]},{"name":"hasTiles","description":"Simply, whether JJ2 should draw the layer or not. (Defaults to the same value as hasTileMap.) In addition to the layer's tiles, this also controls whether the layer's onDrawLayer# hook, if any, can be called (see jjCANVAS section), but does not impact sprites drawn by the jjDrawSprite family no matter the value of their layerZ arguments. If hasTileMap is false but hasTiles is true, the onDrawLayer# hook will still work but no tiles will be drawn because there will be no tiles to draw.\nAs an alternative to setting hasTiles to false, you can also exclude a layer from the drawing order altogether using jjLayerOrderSet.\n","full":"bool hasTiles","type":"property","arguments":[]},{"name":"height","description":"The height of the layer in tiles.\n","full":"const int height","type":"property","arguments":[]},{"name":"limitVisibleRegion","description":"Assuming the layer's tileHeight is false and its ySpeedModel is either LAYERSPEEDMODEL::NORMAL or LAYERSPEEDMODEL::BOTHSPEEDS, whether the layer should be vertically offset some pixels downward (true) or not (false), the exact value depending on the current resolution.\n","full":"bool limitVisibleRegion","type":"property","arguments":[]},{"name":"menu","description":"Properties used by this layer when its textureStyle is TEXTURE::MENU, which draws the rotating menu effect from the game's main menu. If textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then x/yInnerAutoSpeed control the rotating/zooming speeds respectively.\nbool menu.lightToDark should be set to true if the palette rows are light-to-dark gradients instead of the dark-to-light gradients used by the game's menu palette, but the default value is false.\nuint8 menu.palrow16 and uint8 menu.palrow32 and uint8 menu.palrow256 pick the 16-color-long palette rows used by the three different rotating sublayers, with the smaller numbers corresponding to the further back sublayers. The default values are all 0.\nfloat menu.pivotX and float menu.pivotY are the point that all rotation happens around, as multiplied by the size of the player's screen. The default values are both 0.5.\n","full":"menu","type":"property","arguments":[]},{"name":"reflection","description":"Properties used by this layer when its textureStyle is TEXTURE::REFLECTION, which draws the bottom part of the screen as a 3D plane stretching into an infinite horizon (similar to warpHorizon). However, the top part of the screen is not drawn to by this layer at all, and the bottom part (the 3D plane) reflects (i.e. vertically mirrors) all the tiles and sprites that had already been drawn to the top part of the screen prior to this layer being drawn. This texture style does not support sprite modes.\nuint8 reflection.distance adjusts how close the 3D plane appears to be to the camera view. The default value is 0.\nuint8 reflection.distortion distorts the reflection away from being a pure vertical mirroring, with higher values being more distorted, as based on the texture image and its internal offset. The default value is 0.\nfloat reflection.fadePositionX sets the location of the horizontal center of the horizon, as multiplied by the size of the player's screen. The default value is 0.5.\nuint8 reflection.tintColor and uint8 reflection.tintOpacity combine to draw a constant semitransparent color over the entire reflective plane, similar to drawing a rectangle with SPRITE::BLEND_NORMAL but better optimized. Their default values are 192 (the middle palette index from the 176�207 color gradient used by most textured background images) and 0 (no tint at all) respectively.\n","full":"reflection","type":"property","arguments":[]},{"name":"rotationAngle","description":"Not settable in JCS: the offset of the angle at which this layer rotates while a player is stoned, with a domain of 0�1023 to be passed to jjSin and jjCos.\nLayers 1�8 have values -512, -256, 0, 0, 0, 256, 512, and 768, respectively. A script-created jjLAYER will default to 0.\n","full":"int rotationAngle","type":"property","arguments":[]},{"name":"rotationRadiusMultiplier","description":"Not settable in JCS: the multipler of the distance this layer is offset from its center while rotating while a player is stoned. A value of 0 means the layer will not rotate at all; jjLayers[5].rotationRadiusMultiplier = 0; might therefore be a useful line of code in levels that give Layer 5 speed values to match Layer 4's.\nLayers 1�8 have values 4, 3, 0, 0, 2, 2, 1, and 1, respectively. A script-created jjLAYER will default to 0.\n","full":"int rotationRadiusMultiplier","type":"property","arguments":[]},{"name":"spriteMode","description":"The sprite mode and sprite mode parameter used to draw this layer's tiles or texture effect. The default values for all layers are SPRITE::NORMAL and 0, but other possible SPRITE::Mode constants appear with explanations in the appendix below.\nFor non-textured layers, all tiles in this layer whose jjTileType values are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite mode and parameter, while tile types 1, 2, 3, and 6 override this with SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN respectively. Textured layers ignore tile types altogether but have their own caveat: they will be drawn in 8-bit style in order to create a sprite suitable for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is noticeable only when jjColorDepth is 16, textureStyle is WARPHORIZON, TUNNEL, or CYLINDER, and fade is true.\nThese properties do not affect any calls made to any jjCANVAS methods on an onDrawLayer hook attached to this layer. SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No sprite modes other than SPRITE::NORMAL are supported by textured layers using TEXTURE::REFLECTION.\n","full":"SPRITE::Mode spriteMode","type":"property","arguments":[]},{"name":"spriteParam","description":"The sprite mode and sprite mode parameter used to draw this layer's tiles or texture effect. The default values for all layers are SPRITE::NORMAL and 0, but other possible SPRITE::Mode constants appear with explanations in the appendix below.\nFor non-textured layers, all tiles in this layer whose jjTileType values are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite mode and parameter, while tile types 1, 2, 3, and 6 override this with SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN respectively. Textured layers ignore tile types altogether but have their own caveat: they will be drawn in 8-bit style in order to create a sprite suitable for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is noticeable only when jjColorDepth is 16, textureStyle is WARPHORIZON, TUNNEL, or CYLINDER, and fade is true.\nThese properties do not affect any calls made to any jjCANVAS methods on an onDrawLayer hook attached to this layer. SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No sprite modes other than SPRITE::NORMAL are supported by textured layers using TEXTURE::REFLECTION.\n","full":"uint8 spriteParam","type":"property","arguments":[]},{"name":"texture","description":"For textured layers, which 256�256 pixel (aka 8�8 tile) texture is used by the layer, unless textureStyle is TEXTURE::MENU. Defaults to TEXTURE::FROMTILES (previously named LAYER8 after the only layer that could be reasonably textured), meaning whatever the first 64(=8*8) tiles in the layer are. (If the layer has fewer than 64 tiles, this may cause JJ2 to crash.) If jjPIXELMAP::makeTexture was called on this layer, then texture will equal TEXTURE::CUSTOM, but you cannot write that value to this property manually. The other options are listed in the appendix at the bottom of this file.\n","full":"TEXTURE::Texture texture","type":"property","arguments":[]},{"name":"textureSurface","description":"Whether this layer should be drawn as a texture effect instead of as a regular grid of tiles, and if so, to which parts of the screen it should be drawn. A few enum options are available:\n\t\t\t\t\n\t\t\t\t\tSURFACE::UNTEXTURED: The default, corresponding to leaving the \"Texture mode\" checkbox for this layer unchecked in JCS. The layer will be drawn as a grid of tiles.\n\t\t\t\t\tSURFACE::LEGACY: Used by default by layers in levels (either as part of the main level or imported using jjLayersFromLevel) that have the \"Texture mode\" checkbox checked in JCS and use TEXTURE::WARPHORIZON. When used on layers other than layer 8, this option nevertheless copies many of layer 8's properties when deciding how to draw the texture, and may in some circumstances draw the warp horizon effect to only certain areas of the subscreen. This is included for backwards compatibility but FULLSCREEN should usually be preferable.\n\t\t\t\t\tSURFACE::FULLSCREEN: New in JJ2+. Used by default by layers with the \"Texture mode\" checkbox checked that use any textureStyle other than WARPHORIZON. Draws the texture mode to each player's entire subscreen.\n\t\t\t\t\tSURFACE::INNERWINDOW\n\t\t\t\t\tSURFACE::INNERLAYER: New in JJ2+. The layer will be drawn as some sort of texture effect, but within the same rectangular area that the layer would be drawn were it being drawn as a grid of tiles instead. This allows you to have multiple texture effects on-screen at once or do other cool tricks. The inner speed properties will be used for angling the texture within the layer's area. The difference between the two is that INNERWINDOW acts as if the texture were being drawn to the full size of the subscreen, and provides a layer-sized window to a portion of that full screen effect, whereas INNERLAYER exclusively uses the origin and dimensions of the layer itself. For example, consider a warp horizon texture effect drawn to the top half of the subscreen with fadePositionY at 0.5. Using INNERWINDOW, the fade effect will be drawn halfway down the subscreen, at the bottom of the layer. Using INNERLAYER, the fade effect will be drawn halfway down the layer, one quarter of the way down the subscreen. On tiled dimensions (using tileHeight and/or tileWidth), there is no difference between INNERWINDOW and INNERLAYER, and if both dimensions are tiled, there is no difference between either and FULLSCREEN, except for the use of the inner speed properties.\n\t\t\t\t\n","full":"SURFACE::Surface textureSurface","type":"property","arguments":[]},{"name":"textureStyle","description":"The visual effect used by a layer for which textureSurface is not set to SURFACE::UNTEXTURED, defaulting to whichever is specified in the layer's texture dropdown box in JCS. Options are TEXTURE::CYLINDER, TEXTURE::MENU, TEXTURE::REFLECTION, TEXTURE::TILEMENU, TEXTURE::TUNNEL, TEXTURE::WAVE, and TEXTURE::WARPHORIZON (the only such option available in vanilla JJ2)\nFor all cases but MENU and TILEMENU, the texture's offset is determined by combining the speed, autoSpeed, and offset properties of this layer, and/or of jjLayers[5] if the speedModel properties equal LAYERSPEEDMODEL::LAYER8, or by the various inner speed properties if textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW.\n","full":"TEXTURE::Style textureStyle","type":"property","arguments":[]},{"name":"tileHeight","description":"Whether the layer should be vertically tiled, as seen in the JCS Layer Properties window.\n","full":"bool tileHeight","type":"property","arguments":[]},{"name":"tileWidth","description":"Whether the layer should be horizontally tiled, as seen in the JCS Layer Properties window.\nSetting this to true for a layer that is not saved with Tile Width checked in JCS may lead to unpredictable effects if the layer's width and widthReal are not equal. If you wish to turn it on partway through the level, it is best to check Tile Width in JCS and then disable it in onLevelLoad.\n","full":"bool tileWidth","type":"property","arguments":[]},{"name":"tileMenu","description":"Properties used by this layer when its textureStyle is TEXTURE::TILEMENU, which draws the rotating menu effect from the game's main menu, but with different graphics. texture is used for the frontmost rotating sublayer, then the middle sublayer is filled with the 2�2 square set of tiles in the top left corner of layer 4, from 0,0 to 1,1, and the back sublayer is filled with tile 0,2 in layer 4. If textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then x/yInnerAutoSpeed control the rotating/zooming speeds respectively.\nbool tileMenu.fullSize sets whether the rotating sublayers are drawn at half size (false, default) or full size (true).\nfloat tileMenu.pivotX and float tileMenu.pivotY are the point that all rotation happens around, as multiplied by the size of the player's screen. The default values are both 0.5.\n","full":"tileMenu","type":"property","arguments":[]},{"name":"tunnel","description":"Properties used by this layer when its textureStyle is TEXTURE::TUNNEL, which draws texture as a series of concentric, ever-smaller circles receding into the distance, though it is repeated horizontally only once..\nbool tunnel.fade, when true, increasingly affects colors farther into the background: when jjColorDepth is 16, a glowing circle appears in the tunnel's center using the RGB color chosen by tunnel.setFadeColor, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the center. The default value is true.\nfloat tunnel.fadePositionX and float tunnel.fadePositionY set the location of the center of the tunnel, clamped to a 0�1 range, as multiplied by the size of the player's screen. The default values are both 0.5.\nbool tunnel.spiral, when true, makes the concentric circles gradually spiral inwards into the distance. The default value is false.\njjPALCOLOR tunnel.getFadeColor() const and void tunnel.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the center when tunnel.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n","full":"tunnel","type":"property","arguments":[]},{"name":"warpHorizon","description":"Properties used by this layer when its textureStyle is TEXTURE::WARPHORIZON, which draws this layer as two horizontal 3D planes, repeating the same texture several times and stretching to an infinite horizon, with some amount of dithering/antialiasing.\nbool warpHorizon.fade, when true, increasingly affects colors closer to the horizon: when jjColorDepth is 16, a thick glowing line appears across the horizon using the RGB color chosen by warpHorizon.setFadeColor, or if 8, texture colors in the 176�207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.\nfloat warpHorizon.fadePositionX and float warpHorizon.fadePositionY set the location of the center of the horizon, as multiplied by the size of the player's screen. The default values are both 0.5.\nbool warpHorizon.stars, when true, draws a series of little white specks appear across the horizon. The default value is false.\njjPALCOLOR warpHorizon.getFadeColor() const and void warpHorizon.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the horizon when warpHorizon.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n","full":"warpHorizon","type":"property","arguments":[]},{"name":"wave","description":"Properties used by this layer when its textureStyle is TEXTURE::WAVE, which draws texture as a repeating, unrotated 2D image, but applies sine wave distortions at regular intervals. The properties all affect the positions and dimensions of those sine wave distortions.\nfloat wave.amplitudeX and float wave.amplitudeY set the distortions' amplitudes as multiples of the texture's width and height (256 pixels). The default values are both 0.5, meaning 128 pixels.\nbool wave.distortionAngle effectively rotates the movement of the two distortions ninety degrees. The default value is false.\nuint8 wave.wavelengthX and uint8 wave.wavelengthY set the lengths of the distortions, with powers-of-two-minus-one such as 255 being recommended. Their default values are 0.\nint8 wave.waveSpeed moves the distortions along the surface of the texture, independent of the texture's movement as set by the regular or inner speed properties. Both distortions move at the same rate as determined by this property's absolute value, with the directions resulting from the sign of this property combined with and wave.distortionAngle. The default value is 0.\n","full":"wave","type":"property","arguments":[]},{"name":"width","description":"The width of the layer in tiles. Normally these two values will be equal, but they may differ on layers that were saved with the \"Tile Width\" checkbox checked in their level editors. The reason for this is that layers are not stored as arrays of tile IDs but rather as arrays of \"word\" IDs, where each word is defined in the \"tile cache\" as a row of four adjacent tile IDs. In order to properly tile, therefore, a layer whose width is not a multiple of four is expanded by the level editor to a widthReal that is the lowest common multiple of 4 and width, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.\n","full":"const int width","type":"property","arguments":[]},{"name":"widthReal","description":"The width of the layer in tiles. Normally these two values will be equal, but they may differ on layers that were saved with the \"Tile Width\" checkbox checked in their level editors. The reason for this is that layers are not stored as arrays of tile IDs but rather as arrays of \"word\" IDs, where each word is defined in the \"tile cache\" as a row of four adjacent tile IDs. In order to properly tile, therefore, a layer whose width is not a multiple of four is expanded by the level editor to a widthReal that is the lowest common multiple of 4 and width, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.\n","full":"const int widthReal","type":"property","arguments":[]},{"name":"widthRounded","description":"The width of the layer in \"words,\" always equal to (jjLAYER::widthReal + 3) / 4.\n","full":"const int widthRounded","type":"property","arguments":[]},{"name":"xAutoSpeed","description":"The auto speed of the layer, as seen in the JCS Layer Properties window.\n","full":"float xAutoSpeed","type":"property","arguments":[]},{"name":"yAutoSpeed","description":"The auto speed of the layer, as seen in the JCS Layer Properties window.\n","full":"float yAutoSpeed","type":"property","arguments":[]},{"name":"xInnerAutoSpeed","description":"Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n","full":"float xInnerAutoSpeed","type":"property","arguments":[]},{"name":"yInnerAutoSpeed","description":"Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n","full":"float yInnerAutoSpeed","type":"property","arguments":[]},{"name":"xInnerSpeed","description":"Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n","full":"float xInnerSpeed","type":"property","arguments":[]},{"name":"yInnerSpeed","description":"Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n","full":"float yInnerSpeed","type":"property","arguments":[]},{"name":"xOffset","description":"Not settable in JCS: constant pixel values added to the position of the layer, regardless of its speed.\n","full":"float xOffset","type":"property","arguments":[]},{"name":"yOffset","description":"Not settable in JCS: constant pixel values added to the position of the layer, regardless of its speed.\n","full":"float yOffset","type":"property","arguments":[]},{"name":"xSpeed","description":"The speed of the layer, as seen in the JCS Layer Properties window.\n","full":"float xSpeed","type":"property","arguments":[]},{"name":"ySpeed","description":"The speed of the layer, as seen in the JCS Layer Properties window.\n","full":"float ySpeed","type":"property","arguments":[]},{"name":"xSpeedModel","description":"Not settable in JCS: specifies how the layer's position on screen should be determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed properties, the resolution, and so on. There are several options available for the enum, as follows (for each axis):\n\t\t\t\t\n\t\t\t\t\tLAYERSPEEDMODEL::NORMAL: The default. A non-textured layer's position on this axis will be based on the layer's auto speed for this axis, if non-zero, or otherwise its regular speed. Except for jjLayers[8], only the layers that use this mode for both axes will ever be displayed when Low Detail is enabled.\n\t\t\t\t\tLAYERSPEEDMODEL::LAYER8: The default for jjLayers[8] only, a pair of odd behaviors included for backwards compatibility. A non-textured layer with this setting will ignore all speed and offset settings completely and be tied to the top/left side of the screen. A textured layer will instead base its position for this axis on that of jjLayers[5].\n\t\t\t\t\tLAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this axis will both be used in determining the position: for example, a layer of clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to scroll constantly to the left but also move left or right in response to the player's camera.\n\t\t\t\t\tLAYERSPEEDMODEL::FROMSTART: Similar to LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the resolution and its speeds, and the top/left side of a layer will only be flush with the top/left side of the level if the layer's speed is 1 or the resolution is 320�200. Using this setting forces the layer's origin to be at the top/left side of the level instead of varying by the resolution. Ignores limitVisibleRegion.\n\t\t\t\t\tLAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed properties, and instead ensures that the full extent of this layer will be visible and no blank space outside of it will be shown. The top/left side of the layer will be visible at the top/left edge of the level, and the bottom/right side of the layer will be visible at the bottom/right edge of the level, and the layer will scroll smoothly between those two extremes. Thus, the taller/wider the layer, the faster it will move, though with the exact relative speed dependent on the resolution and level size. If the layer is smaller than the window on this axis, this will effectively result in a negative relative speed.\n\t\t\t\t\tLAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed properties on this axis as multipliers of the current camera size, rather than camera position. When the camera is at the top/left of the level, the layer will be positioned at the camera size on this axis multiplied by the regular speed, or the auto speed instead when the camera is at the bottom/right, and the layer will scroll smoothly between those two extremes. For example, if the screen is 600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the layer will be 450 pixels from the top of the screen when the camera is at the top of the level, and 300 pixels from the top of the screen when the camera is at the bottom of the level. Ignores limitVisibleRegion.\n\t\t\t\t\nNote that all mentions of \"textured\" layers in the above descriptions refer to when textureSurface is LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL, WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied to whatever position is determined by the rules above. If such a layer uses MENU or TILEMENU instead, then its speed models are ignored altogether.\nFor INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they would be for non-textured layers for determining the layer's position within the level, and the inner speed properties are used for determining the texture's position within the layer.\n","full":"LAYERSPEEDMODEL::LayerSpeedModel xSpeedModel","type":"property","arguments":[]},{"name":"ySpeedModel","description":"Not settable in JCS: specifies how the layer's position on screen should be determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed properties, the resolution, and so on. There are several options available for the enum, as follows (for each axis):\n\t\t\t\t\n\t\t\t\t\tLAYERSPEEDMODEL::NORMAL: The default. A non-textured layer's position on this axis will be based on the layer's auto speed for this axis, if non-zero, or otherwise its regular speed. Except for jjLayers[8], only the layers that use this mode for both axes will ever be displayed when Low Detail is enabled.\n\t\t\t\t\tLAYERSPEEDMODEL::LAYER8: The default for jjLayers[8] only, a pair of odd behaviors included for backwards compatibility. A non-textured layer with this setting will ignore all speed and offset settings completely and be tied to the top/left side of the screen. A textured layer will instead base its position for this axis on that of jjLayers[5].\n\t\t\t\t\tLAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this axis will both be used in determining the position: for example, a layer of clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to scroll constantly to the left but also move left or right in response to the player's camera.\n\t\t\t\t\tLAYERSPEEDMODEL::FROMSTART: Similar to LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the resolution and its speeds, and the top/left side of a layer will only be flush with the top/left side of the level if the layer's speed is 1 or the resolution is 320�200. Using this setting forces the layer's origin to be at the top/left side of the level instead of varying by the resolution. Ignores limitVisibleRegion.\n\t\t\t\t\tLAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed properties, and instead ensures that the full extent of this layer will be visible and no blank space outside of it will be shown. The top/left side of the layer will be visible at the top/left edge of the level, and the bottom/right side of the layer will be visible at the bottom/right edge of the level, and the layer will scroll smoothly between those two extremes. Thus, the taller/wider the layer, the faster it will move, though with the exact relative speed dependent on the resolution and level size. If the layer is smaller than the window on this axis, this will effectively result in a negative relative speed.\n\t\t\t\t\tLAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed properties on this axis as multipliers of the current camera size, rather than camera position. When the camera is at the top/left of the level, the layer will be positioned at the camera size on this axis multiplied by the regular speed, or the auto speed instead when the camera is at the bottom/right, and the layer will scroll smoothly between those two extremes. For example, if the screen is 600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the layer will be 450 pixels from the top of the screen when the camera is at the top of the level, and 300 pixels from the top of the screen when the camera is at the bottom of the level. Ignores limitVisibleRegion.\n\t\t\t\t\nNote that all mentions of \"textured\" layers in the above descriptions refer to when textureSurface is LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL, WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied to whatever position is determined by the rules above. If such a layer uses MENU or TILEMENU instead, then its speed models are ignored altogether.\nFor INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they would be for non-textured layers for determining the layer's position within the level, and the inner speed properties are used for determining the texture's position within the layer.\n","full":"LAYERSPEEDMODEL::LayerSpeedModel ySpeedModel","type":"property","arguments":[]},{"name":"generateSettableTileArea","description":"Makes all tiles in the range of the rectangle with its top left corner at xTile,yTile and specified width and height possible to use tileSet on without the potential consequence of changing other occurrences of the tile in the level due to tile cache. The zero-argument version of the method applies to the entire layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and height to height. Does nothing if hasTileMap is false.\n","full":"void generateSettableTileArea()","type":"function","arguments":[]},{"name":"generateSettableTileArea","description":"Makes all tiles in the range of the rectangle with its top left corner at xTile,yTile and specified width and height possible to use tileSet on without the potential consequence of changing other occurrences of the tile in the level due to tile cache. The zero-argument version of the method applies to the entire layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and height to height. Does nothing if hasTileMap is false.\n","full":"void generateSettableTileArea(int xTile, int yTile, int width, int height)","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]},{"type":"int","name":"width","attributes":[],"items":[]},{"type":"int","name":"height","attributes":[],"items":[]}]},{"name":"getXPosition","description":"Gets the last position of this layer for the specified jjPLAYER. (The results of calling this method for players for whom isLocal is false are undefined.) For example, given a jjPLAYER@ object play, you could attach water to the top of layer 7 by continually calling jjSetWaterLevel(play.cameraY - jjLayers[7].getYPosition(play), true); This takes into account everything that could possibly reposition a layer, including its speeds and offsets, the resolution and max resolution, the player's camera position, and whether the player is stoned.\nNote that these values are not updated for layers while they are not drawn to the screen on account of having been left out in the last call to jjLayerOrderSet.\n","full":"float getXPosition(const jjPLAYER &in play) const","type":"function","arguments":[{"type":"jjPLAYER","name":"play","attributes":["const","&in"],"items":[]}]},{"name":"getYPosition","description":"Gets the last position of this layer for the specified jjPLAYER. (The results of calling this method for players for whom isLocal is false are undefined.) For example, given a jjPLAYER@ object play, you could attach water to the top of layer 7 by continually calling jjSetWaterLevel(play.cameraY - jjLayers[7].getYPosition(play), true); This takes into account everything that could possibly reposition a layer, including its speeds and offsets, the resolution and max resolution, the player's camera position, and whether the player is stoned.\nNote that these values are not updated for layers while they are not drawn to the screen on account of having been left out in the last call to jjLayerOrderSet.\n","full":"float getYPosition(const jjPLAYER &in play) const","type":"function","arguments":[{"type":"jjPLAYER","name":"play","attributes":["const","&in"],"items":[]}]},{"name":"maskedHLine","description":"Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is masked. Returns false if hasTileMap is false.\n","full":"bool maskedHLine(int xPixel, int lineLength, int yPixel) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"lineLength","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]}]},{"name":"maskedPixel","description":"Returns true if pixel xPixel,yPixel is masked. Returns false if hasTileMap is false.\n","full":"bool maskedPixel(int xPixel, int yPixel) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]}]},{"name":"maskedTopVLine","description":"If any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked, returns the height of the topmost masked pixel relative to yPixel. (For example, if xPixel,yPixel+2 is masked but +1 and +0 weren't, the function returns 2.) If none of the pixels are masked, returns lineLength+1. Used for detecting inclines and the like. Returns 0 if hasTileMap is false.\n","full":"int maskedTopVLine(int xPixel, int yPixel, int lineLength) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"lineLength","attributes":[],"items":[]}]},{"name":"maskedVLine","description":"Returns true if any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked. Returns false if hasTileMap is false.\n","full":"bool maskedVLine(int xPixel, int yPixel, int lineLength) const","type":"function","arguments":[{"type":"int","name":"xPixel","attributes":[],"items":[]},{"type":"int","name":"yPixel","attributes":[],"items":[]},{"type":"int","name":"lineLength","attributes":[],"items":[]}]},{"name":"setXSpeed","description":"Changes the X or Y speed. Unlike the basic properties like xSpeed and yAutoSpeed, these functions will ensure that the layer remains in the same position it was before its speeds were changed, and can therefore be much more useful.\n","full":"void setXSpeed(float newspeed, bool newSpeedIsAnAutoSpeed)","type":"function","arguments":[{"type":"float","name":"newspeed","attributes":[],"items":[]},{"type":"bool","name":"newSpeedIsAnAutoSpeed","attributes":[],"items":[]}]},{"name":"setYSpeed","description":"Changes the X or Y speed. Unlike the basic properties like xSpeed and yAutoSpeed, these functions will ensure that the layer remains in the same position it was before its speeds were changed, and can therefore be much more useful.\n","full":"void setYSpeed(float newspeed, bool newSpeedIsAnAutoSpeed)","type":"function","arguments":[{"type":"float","name":"newspeed","attributes":[],"items":[]},{"type":"bool","name":"newSpeedIsAnAutoSpeed","attributes":[],"items":[]}]},{"name":"tileGet","description":"Returns the current tile at location xTile,yTile. If the tile is an animated tile, this function will return the tile ID for that animated tile instead of the current frame. Returns 0 if hasTileMap is false.\n","full":"uint16 tileGet(int xTile, int yTile) const","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]}]},{"name":"tileSet","description":"Sets the current tile at location xTile,yTile to be newTile. The same change will be applied to all instances of the same four-tile word that appear elsewhere in the level unless the tiles had had generateSettableTileArea used on them prior to the change. Returns newTile, or 0 (and does nothing) if hasTileMap is false.\n","full":"uint16 tileSet(int xTile, int yTile, uint16 newTile)","type":"function","arguments":[{"type":"int","name":"xTile","attributes":[],"items":[]},{"type":"int","name":"yTile","attributes":[],"items":[]},{"type":"uint16","name":"newTile","attributes":[],"items":[]}]}],"jjTEXTAPPEARANCEList":[{"name":"align","description":"Horizontal alignment of text. This can take values of DEFAULT, LEFT, CENTER or RIGHT.\nWhereas LEFT, CENTER and RIGHT should be self-explanatory, DEFAULT is the value JJ2 used for all strings originally, defined as follows: if xPixel is less than 0x4000, the string will have its left side aligned to the left side of the screen or layer. If in the range of 0x4000 to 0xFFFF, the string will be center-aligned relative to 0x8000, so for instance 0x8020 would align the center of the string to 0x20 pixels right of the center of the screen. Finally, if xPixel is greater than or equal to 0x10000, it will be drawn with its right side aligned to the right side of the screen instead, with higher values moving farther left. Note that these special cases currently apply only for drawing to the screen; the use of values of 0x4000 or higher for onDrawLayer# hooks is currently undefined.\n","full":"STRING::Alignment align","type":"property","arguments":[]},{"name":"at","description":"Treatment of the at ('@') character. If it's SPECIALSIGN, at will begin a new line of text 20 pixels below the previous one.\n","full":"STRING::SignTreatment at","type":"property","arguments":[]},{"name":"caret","description":"Treatment of the caret ('^') character. If it's SPECIALSIGN, caret will be displayed as infinity signs.\n","full":"STRING::SignTreatment caret","type":"property","arguments":[]},{"name":"hash","description":"Treatment of the hash ('#') character. If it's SPECIALSIGN, characters following hash will use a pattern of colors (or other parameters depending on sprite mode of the string).\n","full":"STRING::SignTreatment hash","type":"property","arguments":[]},{"name":"monospace","description":"Usually strings achieve naturally looking spacing between characters by placing the next character at character width + spacing relative to the previous one. When this property is set to true, character width is disregarded, and placement is determined only by spacing, i.e. is constant throughout the string (unless modified by special function of section sign). Because, by default, spacing is a low value, you may want to modify it if you use this property. This property is compatible with section, although the result of changing the spacing partway through a string may look somewhat bizarre.\n","full":"bool monospace","type":"property","arguments":[]},{"name":"newline","description":"Treatment of the line feed character (created by the escape sequence '\\n' in AngelScript). If it's either DISPLAYSIGN or SPECIALSIGN, line feed will begin a new line of text below the previous one, with vertical spacing varying depending on font size.\n","full":"STRING::SignTreatment newline","type":"property","arguments":[]},{"name":"pipe","description":"Treatment of the pipe ('|') character. If it's SPECIALSIGN, pipe will change text color (or other parameter depending on sprite mode of the string) of the following characters.\n","full":"STRING::SignTreatment pipe","type":"property","arguments":[]},{"name":"section","description":"Treatment of the section sign ('�') character. If it's SPECIALSIGN, section sign will use ASCII code of the directly following character to determine spacing used for further text.\n","full":"STRING::SignTreatment section","type":"property","arguments":[]},{"name":"skipInitialHash","description":"Whether or not to ignore the first character of a string if it's a hash ('#'). The ignored hash will not be displayed or otherwise affect the string. If the string is preceded by more than one hash, all but the first one will be displayed.\nThis property is provided mainly for compatibility with several STRING::Mode values, as it's used by JJ2 wherever strings are meant to be conditionally colored, such as menu items.\n","full":"bool skipInitialHash","type":"property","arguments":[]},{"name":"spacing","description":"Default spacing between characters, in pixels. If section is set to SPECIALSIGN, this value only applies until the first section sign character is found, as the effect of the section sign is absolute rather than relative to this property.\n","full":"int spacing","type":"property","arguments":[]},{"name":"tilde","description":"Treatment of the tilde ('~') character. If it's SPECIALSIGN, tilde will cancel the special effect of hash or, if it's already inactive, it will change the color (or other parameter depending on sprite mode) to default.\n","full":"STRING::SignTreatment tilde","type":"property","arguments":[]},{"name":"xAmp","description":"Horizontal and vertical amplitudes of text movement.\n","full":"int xAmp","type":"property","arguments":[]},{"name":"yAmp","description":"Horizontal and vertical amplitudes of text movement.\n","full":"int yAmp","type":"property","arguments":[]}],"jjPLAYERDRAWList":[{"name":"airboardBouncingMotion","description":"When true, causes the player sprite (and some other effects) to rise and fall in a gradual sine wave motion. By default, only true for rabbits whose jjPLAYER::fly is FLIGHT::AIRBOARD.\n","full":"bool airboardBouncingMotion","type":"property","arguments":[]},{"name":"airboardPuff","description":"When true, causes little brown explosions to appear behind the player at regular intervals. By default, only true for rabbits whose jjPLAYER::fly is FLIGHT::AIRBOARD.\n","full":"bool airboardPuff","type":"property","arguments":[]},{"name":"angle","description":"What angle to draw the player sprite at, in the manner of the angle parameter of jjCANVAS::drawRotatedSprite. (Only the player sprite itself is affected by this, none of the other elements potentially being drawn.) By default always 0 unless jjPLAYER::poleSpin has been called with both xSpeed and ySpeed using non-zero values.\n","full":"int angle","type":"property","arguments":[]},{"name":"curFrame","description":"The current sprite number, as an index to jjAnimFrames, that should be drawn for this player. Changing this is a purely visual effect and does not affect sprite-based collision with pickups, enemies, and so on. By default, equals the same as jjPLAYER::curFrame.\n","full":"uint curFrame","type":"property","arguments":[]},{"name":"flag","description":"When not set to TEAM::NEUTRAL, this property causes a flag of the specified color to be drawn behind the player, with its direction based on xScale/yScale. If the player is carrying a flag in CTF, DCTF, or Flag Run, this value will be TEAM::BLUE or TEAM::RED as appropriate. Setting this property to TEAM::GREEN or TEAM::YELLOW is also allowed, but the appearance of those flags is somewhat of a placeholder and may change in future JJ2+ revisions if they ever become important for actual gameplay reasons.\n","full":"TEAM::COLOR flag","type":"property","arguments":[]},{"name":"gunFlash","description":"When true, a sprite of a small flash is drawn coming out of the player's gun. Has no effect when angle does not equal 0 or either xScale or yScale do not equal 1 or -1. By default, only true immediately after the player has fired.\n","full":"bool gunFlash","type":"property","arguments":[]},{"name":"invincibility","description":"When true, a series of blue circles are drawn following the player around. By default, only true when jjPLAYER::invincibility is greater than 0.\n","full":"bool invincibility","type":"property","arguments":[]},{"name":"layer","description":"What layer to draw the player (and related elements) in front of. By default always 4.\n","full":"int layer","type":"property","arguments":[]},{"name":"light","description":"The intensity of light emitted by the player. By default, equals the same as jjPLAYER::light.\n\t\t\t\n","full":"int8 light","type":"property","arguments":[]},{"name":"lightType","description":"The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER. By default, equals the same as jjPLAYER::lightType.\n","full":"LIGHT::Type lightType","type":"property","arguments":[]},{"name":"name","description":"When true, the string jjPLAYER::name will be drawn above the player's head. By default, true in non-local games when jjPLAYER::frozen is 0 and the F8 key has not been pressed.\n","full":"bool name","type":"property","arguments":[]},{"name":"player","description":"The player being drawn. This is a read-only property, so you can modify properties of the player but you cannot change which jjPLAYER object the jjPLAYERDRAW object has a handle to.\n","full":"jjPLAYER@ player","type":"property","arguments":[]},{"name":"shield[SHIELD::Shield]","description":"Whether each of the possible shields should be drawn around the player: for example, you can set shield[SHIELD::FIRE] = true; to draw the fire shield. Applicable options in the SHIELD::Shield enum are FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. By default, each is only true if it is the value of jjPLAYER::shieldType, the player is non-local or jjPLAYER::shieldTime is greater than -128, and jjPLAYER::frozen is 0.\n","full":"bool shield[SHIELD::Shield]","type":"property","arguments":[]},{"name":"sprite","description":"Determines whether the player sprite should be drawn at all. By default, usually true but sometimes false when the player is flashing from being hurt or from timing out in an online server.\n","full":"bool sprite","type":"property","arguments":[]},{"name":"spriteMode","description":"What sprite mode to use for the player. By default, equals the same as jjPLAYER::spriteMode, or SPRITE::FROZEN if jjPLAYER::frozen is non-zero.\n","full":"SPRITE::Mode spriteMode","type":"property","arguments":[]},{"name":"spriteParam","description":"A sprite mode parameter further specifying how the player should be drawn. By default, equals the same as jjPLAYER::spriteParam.\n","full":"uint8 spriteParam","type":"property","arguments":[]},{"name":"sugarRush","description":"When true, spriteMode and spriteParam will be ignored in favor of drawing the player in random flashing colors with lots of little star-shaped particles appearing nearby. By default, true when the player genuinely has a sugar rush but jjPLAYER::frozen is 0.\n","full":"bool sugarRush","type":"property","arguments":[]},{"name":"trail","description":"When true, a glowing white trail follows the player around. By default, true when the player is moving at a decent speed.\n","full":"bool trail","type":"property","arguments":[]},{"name":"xOffset","description":"Allows you to draw most elements of the player at some relative position offset from the player's actual position. This is more powerful and more customizable than airboardBouncingMotion, which in particular does not modify the position the player's name is drawn at. By default, both properties equal 0.\n","full":"float xOffset","type":"property","arguments":[]},{"name":"yOffset","description":"Allows you to draw most elements of the player at some relative position offset from the player's actual position. This is more powerful and more customizable than airboardBouncingMotion, which in particular does not modify the position the player's name is drawn at. By default, both properties equal 0.\n","full":"float yOffset","type":"property","arguments":[]},{"name":"xScale","description":"What scale to draw the player at, in the manner of the corresponding parameters of jjCANVAS::drawResizedSprite. By default, xScale will equal 1 or -1 depending on jjPLAYER::direction, and yScale will equal 1 if jjPLAYER::antiGrav is false or -1 if it is true.\n","full":"float xScale","type":"property","arguments":[]},{"name":"yScale","description":"What scale to draw the player at, in the manner of the corresponding parameters of jjCANVAS::drawResizedSprite. By default, xScale will equal 1 or -1 depending on jjPLAYER::direction, and yScale will equal 1 if jjPLAYER::antiGrav is false or -1 if it is true.\n","full":"float yScale","type":"property","arguments":[]}],"jjANIMSETList":[{"name":"firstAnim","description":"ID of the first animation in the set, to be used with the jjAnimations array.\n","full":"uint firstAnim","type":"property","arguments":[]},{"name":"allocate","description":"Creates space for an animation set with the number of animations equal to length of frameCounts, each with a number of frames determined by the corresponding frameCounts array element.\n","full":"jjANIMSET@ allocate(const array<uint> &in frameCounts)","type":"function","arguments":[{"type":"array<uint>","name":"frameCounts","attributes":["const","&in"],"items":[]}]},{"name":"load","description":"Loads animation set specified by fileSetID from a j2a file specified by filename. Using the default value of fileSetID results in loading the set appropriate for the jjANIMSET it's called on. If filename is left empty, it deduces the file name from fileSetID, using either Anims.j2a or plus.j2a.\nBy default, any new animations and animframes begin at the first unused entries in jjAnimations and jjAnimFrames respectively. By passing positive values to the firstAnimToOverwrite and/or firstFrameToOverwrite arguments, however, you may choose specific animations and/or animframes to overwrite instead.\n","full":"jjANIMSET@ load(uint fileSetID = 2048, const string &in filename = \"\", int firstAnimToOverwrite = -1, int firstFrameToOverwrite = -1)","type":"function","arguments":[{"type":"uint","name":"fileSetID","defaultValue":"2048","attributes":[],"items":[]},{"type":"string","name":"filename","attributes":["const","&in"],"items":[]},{"type":"int","name":"firstAnimToOverwrite","defaultValue":"-1","attributes":[],"items":[]},{"type":"int","name":"firstFrameToOverwrite","defaultValue":"-1","attributes":[],"items":[]}]},{"name":"load","description":"Loads animation set defined in a sprite sheet image. This method overload is an alternate way to turn your external graphics into JJ2 sprites compared to the above overload which reads from an external j2a file instead. Loading from a sprite sheet is designed to be easier, though less flexible.\nFor example, suppose you want to replace the sprites used by the Helmut enemy, which is a simple case that only uses two animations: standing and walking. We'll use these public domain sprites from opengameart.org. (For best results, you should generally use images that have been manually drawn or edited to use the standard JJ2 sprite palette or else the palette of the specific level you're using the sprites in, but the jjPIXELMAP constructor's automatic color reduction for 24- or 32-bit images is fine for an example.)\n\n\t\t\tvoid onLevelLoad() {\n\tjjAnimSets[ANIM::HELMUT].load(\n\t\tjjPIXELMAP(\"Margery.png\"),\n\t\tframeWidth: 24,\n\t\tframeHeight: 26,\n\t\tframeSpacingX: 2,\n\t\tframeSpacingY: 2,\n\t\tstartY: 26,\n\t\tfirstAnimToOverwrite: jjAnimSets[ANIM::HELMUT]\n\t);\n\tjjObjectPresets[OBJECT::HELMUT].determineCurFrame();\n}\nThe spriteSheet argument is self-explanatory, and is primarily intended for use in combination with the jjPIXELMAP constructor from filename, as above, so you can load an external PNG image and convert it to an animation set. The sprite sheet must take the form of a grid of equally-sized rectangles, where each row is a separate animation for this animation set and each cell is a separate frame for that animation. A completely blank/transparent cell indicates the end of the animation, so in the above example image, the first animation (standing) has only one frame but the second animation (walking) has six frames. The number of animations in the animation set is inferred from the height of the image in conjunction with the other arguments.\nframeWidth and frameHeight specify the rectangular areas used by every frame in every animation in the sprite sheet. The largest and smallest sprites in your sheet must each have the same area devoted to them. However, JJ2+ will trim the transparent pixels from around the edges of every frame: in the above example, none of the sprites extend all the way to the left and right sides of their rectangles, so none of the resulting jjANIMFRAME objects will be the full 24 pixels wide.\n","full":"jjANIMSET@ load(const jjPIXELMAP &in spriteSheet, uint frameWidth, uint frameHeight, uint frameSpacingX = 0, uint frameSpacingY = 0, uint startX = 0, uint startY = 0, const array<int> &in coldSpotYOffsets = array<int>(), int firstAnimToOverwrite = -1, int firstFrameToOverwrite = -1)","type":"function","arguments":[{"type":"jjPIXELMAP","name":"spriteSheet","attributes":["const","&in"],"items":[]},{"type":"uint","name":"frameWidth","attributes":[],"items":[]},{"type":"uint","name":"frameHeight","attributes":[],"items":[]},{"type":"uint","name":"frameSpacingX","defaultValue":"0","attributes":[],"items":[]},{"type":"uint","name":"frameSpacingY","defaultValue":"0","attributes":[],"items":[]},{"type":"uint","name":"startX","defaultValue":"0","attributes":[],"items":[]},{"type":"uint","name":"startY","defaultValue":"0","attributes":[],"items":[]},{"type":"array<int>","name":"coldSpotYOffsets","attributes":["const","&in"],"items":[]}]}],"jjANIMATIONList":[{"name":"firstFrame","description":"ID of the first frame of the animation, to be used with the jjAnimFrames array.\n","full":"uint firstFrame","type":"property","arguments":[]},{"name":"fps","description":"This property corresponds to the \"FPS\" number for animations in Jazz Sprite Dynamite, but that name is only a guess, because its value is never referenced by JJ2 at all. Most commonly equals 10.\n","full":"int16 fps","type":"property","arguments":[]},{"name":"frameCount","description":"The number of frames used by the animation.\n","full":"uint16 frameCount","type":"property","arguments":[]},{"name":"save","description":"Saves all the frames of this animation to an animated GIF image file on the local computer and returns whether successful. The image will be saved with whatever palette is passed to this method, by default the game's current palette. Each frame's delay time will be set to jjANIMATION::fps.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".gif\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjPIXELMAP::save and jjSTREAM::save).\n","full":"bool save(const string &in filename, const jjPAL &in palette = jjPalette) const","type":"function","arguments":[{"type":"string","name":"filename","attributes":["const","&in"],"items":[]},{"type":"jjPAL","name":"palette","attributes":["const","&in"],"items":[]}]},{"name":"load","description":"Reads all frames of a GIF image on the local computer and outputs them as a series of jjANIMFRAME objects, and adjusts this animation's firstFrame and frameCount properties to match the new frames. Each frame in the animation will be trimmed to exclude fully transparent rows/columns on the edges. Returns true on success or false if the filename cannot be found or is in some way not a valid GIF.\nEach resulting sprite will use the same palette indices as the GIF itself. The GIF's own palette will be ignored. For the easiest to understand results, then, you should use a GIF using an unoptimized palette that is identical or similar (e.g. day vs. night versions) to the one the level is using, or grayscale for use with SPRITE::ALPHAMAP. Alternatively, you may want to load the GIF's actual palette using jjPAL::load.\njjANIMFRAME::coldSpotY is only relevant to certain objects affected by gravity, which use it to determine how far off the ground their sprites should be. For the first frame, coldSpotY will be set to the bottom of the opaque pixels, and each subsequent sprite will have its coldSpotY at the same distance from its hotSpotY as in the first sprite. If this automatic guess isn't quite right for your sprites, and you want to adjust these numbers so the sprites sink into the ground or float above it a little more, you can use the optional coldSpotYOffset argument.\nBy default, any new animframes begin at the first unused entries in jjAnimFrames. By passing a positive value to the firstFrameToOverwrite argument, however, you may choose specific animframes to overwrite instead.\nThis method always sets jjANIMFRAME::gunSpotX and jjANIMFRAME::coldSpotX to the same value as jjANIMFRAME::hotSpotX, jjANIMFRAME::gunSpotY to the same value as jjANIMFRAME::hotSpotY, jjANIMFRAME::transparent to false, and jjANIMATION::fps to the first gif frame's delay (or 10 if no delay is specified in the file). If your script has any more specialized use for those properties you will have to set them manually.\n","full":"bool load(const string &in filename, int hotSpotX, int hotSpotY, int coldSpotYOffset = 0, int firstFrameToOverwrite = -1)","type":"function","arguments":[{"type":"string","name":"filename","attributes":["const","&in"],"items":[]},{"type":"int","name":"hotSpotX","attributes":[],"items":[]},{"type":"int","name":"hotSpotY","attributes":[],"items":[]},{"type":"int","name":"coldSpotYOffset","defaultValue":"0","attributes":[],"items":[]},{"type":"int","name":"firstFrameToOverwrite","defaultValue":"-1","attributes":[],"items":[]}]}],"jjANIMFRAMEList":[{"name":"coldSpotX","description":"Horizontal and vertical position of the frame's cold spot, relative to its hot spot. It is considered to be the point at which the frame would touch the ground. It's mostly used by objects such as walking enemies and pickup crates, as well as players themselves. In particular, the jjOBJ method putOnGround, if its argument is set to true, uses coldSpotY to determine the outcome.\n","full":"int16 coldSpotX","type":"property","arguments":[]},{"name":"coldSpotY","description":"Horizontal and vertical position of the frame's cold spot, relative to its hot spot. It is considered to be the point at which the frame would touch the ground. It's mostly used by objects such as walking enemies and pickup crates, as well as players themselves. In particular, the jjOBJ method putOnGround, if its argument is set to true, uses coldSpotY to determine the outcome.\n","full":"int16 coldSpotY","type":"property","arguments":[]},{"name":"gunSpotX","description":"Horizontal and vertical position of the frame's gun spot, i.e. the point that's used to determine initial position of projectiles, relative to its hot spot. Originally this is only defined for player animations and sprites of enemies that produce projectiles.\n","full":"int16 gunSpotX","type":"property","arguments":[]},{"name":"gunSpotY","description":"Horizontal and vertical position of the frame's gun spot, i.e. the point that's used to determine initial position of projectiles, relative to its hot spot. Originally this is only defined for player animations and sprites of enemies that produce projectiles.\n","full":"int16 gunSpotY","type":"property","arguments":[]},{"name":"height","description":"Frame height in pixels.\n","full":"const uint16 height","type":"property","arguments":[]},{"name":"hotSpotX","description":"Horizontal and vertical position of the frame's hot spot, added to the sprite position by all drawing operations and used by collision detection, etc. These properties are analogous to the hot spot coordinates shown by Jazz Sprite Dynamite, however it should be noted that JSD inverts their values for user convenience, while JJ2 doesn't. This means that you will usually want to use negative values for these properties.\n","full":"int16 hotSpotX","type":"property","arguments":[]},{"name":"hotSpotY","description":"Horizontal and vertical position of the frame's hot spot, added to the sprite position by all drawing operations and used by collision detection, etc. These properties are analogous to the hot spot coordinates shown by Jazz Sprite Dynamite, however it should be noted that JSD inverts their values for user convenience, while JJ2 doesn't. This means that you will usually want to use negative values for these properties.\n","full":"int16 hotSpotY","type":"property","arguments":[]},{"name":"transparent","description":"Whether the frame is to be drawn as translucent by default. The only AngelScript function this directly affects is the jjOBJ method draw but JJ2 objects often use this property, e.g. to draw freezer ammo pickups as translucent even though they use the same behavior as any other pickup.\n","full":"bool transparent","type":"property","arguments":[]},{"name":"width","description":"Frame width in pixels.\n","full":"const uint16 width","type":"property","arguments":[]},{"name":"doesCollide","description":"Returns true if this sprite (at position xPos,yPos and direction direction) would collide with another sprite with its own specified coordinates and direction, taking both sprites' hotspot positions into account; otherwise false. If always is true, collisions will be registered even if there is only one overlapping pixel (used by bullets); the default value of false will require at least about eight common pixels (used by players), which is probably a better test in most cases. Both direction parameters will be tested for the sprites being horizontally flipped, vertically flipped, or both, and the collision detection will be carried out accordingly.\n","full":"bool doesCollide(int xPos, int yPos, int direction, const jjANIMFRAME@ frame2, int xPos2, int yPos2, int direction2, bool always = false) const","type":"function","arguments":[{"type":"int","name":"xPos","attributes":[],"items":[]},{"type":"int","name":"yPos","attributes":[],"items":[]},{"type":"int","name":"direction","attributes":[],"items":[]},{"type":"jjANIMFRAME@","name":"frame2","attributes":["const"],"items":[]},{"type":"int","name":"xPos2","attributes":[],"items":[]},{"type":"int","name":"yPos2","attributes":[],"items":[]},{"type":"int","name":"direction2","attributes":[],"items":[]},{"type":"bool","name":"always","defaultValue":"false","attributes":[],"items":[]}]}],"jjTILEList":[{"name":"fps","description":"Animation speed in frames per second. For static tiles this is always 0.\nThis property is safe to modify, but it is currently undefined which animation frame will be visible immediately after the change.\n","full":"uint8 fps","type":"property","arguments":[]},{"name":"tileID","description":"Tile ID corresponding to the instance, such that for every non-null jjTILE handle tile, tile is jjTiles[tile.tileID].\n","full":"const uint16 tileID","type":"property","arguments":[]},{"name":"getFrames","description":"Constructs and returns an array of tile IDs of animation frames of the instance. For static tiles this is an array of size 1 containing this tile's own ID.\nThe returned array represents animation frames after all transformations selected in animating tile properties, such as ping-pong animation or frames to wait between animation cycles. This means that the result may contain more entries than the animation as viewed in JCS.\nKeep in mind that in levels edited by other means than JCS, entries of the array may themselves be animations.\n","full":"array<uint16>@ getFrames() const","type":"function","arguments":[]},{"name":"setFrames","description":"Entirely replaces the previous array of animation frames for this animated tile with a new one based on the passed arguments. Returns false if frames is empty (zero frames long) or if this is not a valid animated tile. The results are undefined if frames is more than 64 frames long.\nThe arguments correspond exactly to the similarly named JCS animated tile properties, respectively: \"Ping-Pong animation\"; \"Frames to wait between two animation cycles\"; \"Random adder amplitude for frame wait\"; and \"Frame wait interval between Ping-Pong cycle.\"\nNote that this method is used to replace an existing animated tile. At this time there is no way to expand the number of animated tiles past however many are defined in the level.\n","full":"bool setFrames(const array<uint16> &in frames, bool pingPong = false, uint16 wait = 0, uint16 randomWait = 0, uint16 pingPongWait = 0)","type":"function","arguments":[{"type":"array<uint16>","name":"frames","attributes":["const","&in"],"items":[]},{"type":"bool","name":"pingPong","defaultValue":"false","attributes":[],"items":[]},{"type":"uint16","name":"wait","defaultValue":"0","attributes":[],"items":[]},{"type":"uint16","name":"randomWait","defaultValue":"0","attributes":[],"items":[]},{"type":"uint16","name":"pingPongWait","defaultValue":"0","attributes":[],"items":[]}]}],"jjPIXELMAPList":[{"name":"height","description":"Dimensions of the map in pixels, set by the map's constructor. These properties are read-only but may be modified using the addBorders, crop, resize, or trim methods, or swapped using the rotate method.\n","full":"const uint height","type":"property","arguments":[]},{"name":"width","description":"Dimensions of the map in pixels, set by the map's constructor. These properties are read-only but may be modified using the addBorders, crop, resize, or trim methods, or swapped using the rotate method.\n","full":"const uint width","type":"property","arguments":[]},{"name":"addBorders","description":"For each of the four edges of the current image, this method either extends the image outwards by a number of pixels (positive number, filling in the new empty space with borderColor) or crops the image inwards (negative number). Returns a reference to self. If the resulting image would be size 0 on either axis, or if you try to crop out more of the original image than exists (e.g. width equals 9 and both left and right equal -5), no change wil occur.\n\t\t\t\n","full":"jjPIXELMAP& addBorders(int left, int top, int right, int bottom, uint8 borderColor = 0)","type":"function","arguments":[{"type":"int","name":"left","attributes":[],"items":[]},{"type":"int","name":"top","attributes":[],"items":[]},{"type":"int","name":"right","attributes":[],"items":[]},{"type":"int","name":"bottom","attributes":[],"items":[]},{"type":"uint8","name":"borderColor","defaultValue":"0","attributes":[],"items":[]}]},{"name":"crop","description":"Crops the pixel map to the specified coordinates and dimensions and returns a reference to self. If the arguments are invalid (width and/or height equals zero, or any point of the cropped rectangle is outside the current bounds), no change will occur.\n","full":"jjPIXELMAP& crop(uint left, uint top, uint width, uint height)","type":"function","arguments":[{"type":"uint","name":"left","attributes":[],"items":[]},{"type":"uint","name":"top","attributes":[],"items":[]},{"type":"uint","name":"width","attributes":[],"items":[]},{"type":"uint","name":"height","attributes":[],"items":[]}]},{"name":"flip","description":"Flips the pixel map's image across one or both axes and returns a reference to self. Useful argument values are SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV.\n","full":"jjPIXELMAP& flip(SPRITE::Direction directions)","type":"function","arguments":[{"type":"SPRITE::Direction","name":"directions","attributes":[]}]},{"name":"makeTexture","description":"Changes the specified layer's texture to the contents of the pixel map. If you leave layer as null it will default to the background layer,  i.e. jjLayers[8]. The map has to be exactly 256�256 to allow this action and if that is not the case, the function will report failure by returning false. On success returns true.\n","full":"bool makeTexture(jjLAYER@ layer = null)","type":"function","arguments":[{"type":"jjLAYER@","name":"layer","defaultValue":"null","attributes":[],"items":[]}]},{"name":"recolor","description":"If colorMapping is length 256 or greater, replaces each index in the pixel map with the value in colorMapping at that index, e.g. pixels of color 10 will be changed to paletteColorMapping[10] instead. Returns a reference to self.\n","full":"jjPIXELMAP& recolor(const array<uint8> &in colorMapping)","type":"function","arguments":[{"type":"array<uint8>","name":"colorMapping","attributes":["const","&in"],"items":[]}]},{"name":"resize","description":"If neither the old dimensions nor the new dimensions are zero on either axis, resizes the pixel map's image to use the new dimensions using primitive nearest neighbor interpolation. Returns a reference to self.\n","full":"jjPIXELMAP& resize(uint width, uint height)","type":"function","arguments":[{"type":"uint","name":"width","attributes":[],"items":[]},{"type":"uint","name":"height","attributes":[],"items":[]}]},{"name":"rotate","description":"Rotates the pixel map's image ninety degrees clockwise and returns a reference to self.\n","full":"jjPIXELMAP& rotate()","type":"function","arguments":[]},{"name":"save","description":"Overwrites tileset tile selected by tileID with contents of the pixel map. The map has to be exactly 32�32 to allow this action and if that is not the case, the function will report failure by returning false. On success returns true.\nIf (tileID & TILE::VFLIPPED) != 0, the pixel map image will be vertically flipped while saving the tile. TILE::HFLIPPED is somewhat more complicated, because JJ2 stores horizontally flipped tiles separately from their non-flipped versions. By default, and to avoid unnecessary memory usage, jjPIXELMAP::save will only save to either the regular version of the tile or the horizontally flipped version, depending on whether (tileID & TILE::HFLIPPED) != 0. By setting hFlip to true, though, you can ensure that both the regular and the horizontally flipped version of the tile will be overwritten.\nThe results of saving when (tileID & TILE::ANIMATED) != 0 || (tileID & TILE::RAWRANGE) == 0 are undefined.\n","full":"bool save(uint16 tileID, bool hFlip = false) const","type":"function","arguments":[{"type":"uint16","name":"tileID","attributes":[],"items":[]},{"type":"bool","name":"hFlip","defaultValue":"false","attributes":[],"items":[]}]},{"name":"save","description":"Overwrites the image used by frame with contents of the pixel map. Returns true on success and false on failure.\n","full":"bool save(jjANIMFRAME@ frame) const","type":"function","arguments":[{"type":"jjANIMFRAME@","name":"frame","attributes":[],"items":[]}]},{"name":"save","description":"Saves the contents of the pixel map to an 8-bit PNG image file on the local computer and returns whether successful. The image will be saved with whatever palette is passed to this method, by default the game's current palette.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".png\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjANIMATION::save and jjSTREAM::save).\n","full":"bool save(const string &in filename, const jjPAL &in palette = jjPalette) const","type":"function","arguments":[{"type":"string","name":"filename","attributes":["const","&in"],"items":[]},{"type":"jjPAL","name":"palette","attributes":["const","&in"],"items":[]}]},{"name":"trim","description":"Trims away all totally empty rows and columns�i.e. lines containing no colors other than trimColor, which defaults to 0, or transparent�from the four sides of the current image and returns a reference to self. If there are no colors other than trimColor anywhere in the image, as a special case, the resulting image will be cropped to 1�1 instead of 0�0.\nThe method overload with four uint &out arguments lets you know how many rows/columns were trimmed from each of the four sides. If no cropping occurs, they will all equal 0, and if the image was fully trimColor, left and right will equal width (prior to the method being called) and top and bottom will equal height.\n","full":"jjPIXELMAP& trim(uint8 trimColor = 0)","type":"function","arguments":[{"type":"uint8","name":"trimColor","defaultValue":"0","attributes":[],"items":[]}]},{"name":"trim","description":"Trims away all totally empty rows and columns�i.e. lines containing no colors other than trimColor, which defaults to 0, or transparent�from the four sides of the current image and returns a reference to self. If there are no colors other than trimColor anywhere in the image, as a special case, the resulting image will be cropped to 1�1 instead of 0�0.\nThe method overload with four uint &out arguments lets you know how many rows/columns were trimmed from each of the four sides. If no cropping occurs, they will all equal 0, and if the image was fully trimColor, left and right will equal width (prior to the method being called) and top and bottom will equal height.\n","full":"jjPIXELMAP& trim(uint left &out, uint top &out, uint right &out, uint bottom &out, uint8 trimColor = 0)","type":"function","arguments":[{"type":"uint","name":"left","attributes":[],"items":[]},{"type":"uint","name":"top","attributes":[],"items":[]},{"type":"uint","name":"right","attributes":[],"items":[]},{"type":"uint","name":"bottom","attributes":[],"items":[]},{"type":"uint8","name":"trimColor","defaultValue":"0","attributes":[],"items":[]}]}],"jjMASKMAPList":[{"name":"save","description":"Overwrites mask of tileset tile selected by tileID with contents of the mask map. All notes mentioned for jjPIXELMAP::save apply in exactly the same way here, although you don't have to worry about dimensions, since mask maps are always 32�32.\n","full":"bool save(uint16 tileID, bool hFlip = false) const","type":"function","arguments":[{"type":"uint16","name":"tileID","attributes":[],"items":[]},{"type":"bool","name":"hFlip","defaultValue":"false","attributes":[],"items":[]}]}]}