[{"name": "alreadyDoubleJumped", "description": "Whether it is currently impossible for the player to double jump, assuming they're Spaz and currently in the air. To allow compatibility with multiple air jumps, this was replaced with doubleJumpCount.\n", "full": "bool alreadyDoubleJumped", "type": "property", "arguments": []}, {"name": "ammo", "description": "How much ammo the player has of each ammo type. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their allowed properties to true in the jjWeapons array.\n", "full": "int ammo[WEAPON::Weapon]", "type": "property", "arguments": []}, {"name": "antiGrav", "description": "Whether the player falls up (true) or down (false). Also causes the player to be drawn upside-down.\n(For the record, this mode is still a work-in-progress. A handful of objects\u00ef\u00bf\u00bdbridges, pinball flippers, and rotating poles\u00ef\u00bf\u00bddon't work very well with it yet. However, future revisions will be backwards compatible with what works already, so don't hold off on using it for that reason unless it truly can't do yet what you need it do.)\n", "full": "bool antiGrav", "type": "property", "arguments": []}, {"name": "ballTime", "description": "If greater than 0, how much longer (in ticks) the player will be tucked into a ball.\n", "full": "int ballTime", "type": "property", "arguments": []}, {"name": "blink", "description": "If greater than 0, how much longer (in ticks) the player will be blinking and invincible and unable to collide with other players, as if recently hurt. Works online.\n", "full": "int blink", "type": "property", "arguments": []}, {"name": "boss", "description": "The object ID of the jjOBJ whose energy is shown in the boss health meter, or -1 if the health meter is receding off the top of the screen, or 0 if the player is not fighting any boss.\nMore specifically, the boss health meter will show the energy of the jjOBJ as a percentage of its initial health as described in its entry in jjObjectPresets. If you create a Tuf Turtle enemy, give it 100 health, and assign a jjPLAYER's boss its object ID, JJ2 will still assume the Tuf Turtle started out at 4 health, not 100. On the other hand, if you write jjObjectPresets[OBJECT::TUFTURT].energy = 100; first, then the boss health meter will work as you might want it to.\n", "full": "int boss", "type": "property", "arguments": []}, {"name": "bossActivated", "description": "The bool set by the Activate Boss event or the activateBoss method. In general, you should make sure this property is true for at least one local player when writing behaviors for custom bosses.\n", "full": "bool bossActivated", "type": "property", "arguments": []}, {"name": "buttstomp", "description": "Buttstomp phase. Values below 41 mean the player is initializing a buttstomp, 41 means the player is currently buttstomping, values between 41 and 121 mean the player is landing on the ground and values of 121 and higher mean the player is not currently buttstomping.\n", "full": "int buttstomp", "type": "property", "arguments": []}, {"name": "cameraX", "description": "The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n", "full": "const float cameraX", "type": "property", "arguments": []}, {"name": "cameraY", "description": "The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n", "full": "const float cameraY", "type": "property", "arguments": []}, {"name": "charCurr", "description": "The player's current character (CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2). This is a read-only value, because you should use morphTo or another related method to change it instead.\n", "full": "const CHAR::Char charCurr", "type": "property", "arguments": []}, {"name": "charOrig", "description": "Which character the player began the level as (CHAR::JAZZ, CHAR::SPAZ, or CHAR::LORI), aka the character that the Revert Morph event switches them to.\n", "full": "CHAR::Char charOrig", "type": "property", "arguments": []}, {"name": "clientID", "description": "ID of the game instance controlling the player. This is particularly useful for packet exchange with use of jjSendPacket but can also be used to determine whether players are splitscreeners.\n", "full": "const int clientID", "type": "property", "arguments": []}, {"name": "coins", "description": "How many coins the player has.\nIf you want to require the player to have a certain number of coins to do something, like with coin warps, consider using the more elaborate testForCoins method instead.\n", "full": "int coins", "type": "property", "arguments": []}, {"name": "curAnim", "description": "The current animation the player takes its frames from, serving as an index to the jjAnimations array. Each animation has a distinct value; for example, Jazz standing in place might be 81, but Spaz standing in place might be 185.\n", "full": "const uint16 curAnim", "type": "property", "arguments": []}, {"name": "curFrame", "description": "The overall current frame displayed to the screen to represent this player, serving as an index to the jjAnimFrames array. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n", "full": "const uint curFrame", "type": "property", "arguments": []}, {"name": "currTile", "description": "A shortcut value, always equalling int(xPos)/32 + int(yPos)/32*65536. Since both xPos and yPos are easily accessible properties, it really only makes sense to use currTile to compare against previous values of currTile, i.e. to see if the player has moved or not.\n", "full": "const int currTile", "type": "property", "arguments": []}, {"name": "currWeapon", "description": "Which ammo type the player currently has selected. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\n", "full": "uint8 currWeapon", "type": "property", "arguments": []}, {"name": "deaths", "description": "In competitive game modes, the number of deaths the player experienced or a negative value if unknown (this is currently the case when the property is checked by clients in XLRS mode).\n", "full": "const int deaths", "type": "property", "arguments": []}, {"name": "direction", "description": "Which direction the player is facing. Negative values mean left and non-negative ones mean right.\n", "full": "int8 direction", "type": "property", "arguments": []}, {"name": "doubleJumpCount", "description": "How many times the player used double jump in the air since their last regular jump.\n", "full": "int doubleJumpCount", "type": "property", "arguments": []}, {"name": "fastfire", "description": "The waiting time between shots, as decreased by Fastfire events or the JJFIRE cheat code. Starts out at 35\u00ef\u00bf\u00bdhalf a second\u00ef\u00bf\u00bdand decreases to a minimum of 6 (from Fastfire events) or 1 (JJFIRE).\n", "full": "int fastfire", "type": "property", "arguments": []}, {"name": "flag", "description": "The object ID of the flag the player is carrying, or 0 if the player is not carrying a flag.\n", "full": "const int flag", "type": "property", "arguments": []}, {"name": "fly", "description": "Possible special constant values are FLIGHT::NONE, FLIGHT::FLYCARROT, or FLIGHT::AIRBOARD, from the FLIGHT::Mode enum.\nIf the player is currently using a copter or Cheshire2 object, fly will equal the object ID of that object plus one, which is to say, the jjOBJ the player is holding will be jjObjects[p.fly - 1].\n", "full": "int fly", "type": "property", "arguments": []}, {"name": "food", "description": "How much food the player has eaten.\nSetting this to 100 will not cause a sugar rush. Use the startSugarRush method instead.\n", "full": "int food", "type": "property", "arguments": []}, {"name": "frameID", "description": "The index of the current frame displayed to the screen to represent this player within its animation. For example, Jazz's standing animation is only one frame long, so his frameID will always equal 0 while playing that animation, while Spaz's will range from 0 to 4. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n", "full": "const uint8 frameID", "type": "property", "arguments": []}, {"name": "frozen", "description": "0 if unfrozen; otherwise, constantly counts down towards 0.\n", "full": "int8 frozen", "type": "property", "arguments": []}, {"name": "fur", "description": "Palette indexes of the player's fur in the form of 4 colors, 8 bits each. For potentially more intuitive ways of fur color manipulation refer to jjPLAYER methods furGet and furSet. Changes to this setting are automatically shared between all clients in the server. Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n", "full": "uint32 fur", "type": "property", "arguments": []}, {"name": "gems", "description": "How many gems the player has collected. Possible values of GEM::Color are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n", "full": "int gems[GEM::Color]", "type": "property", "arguments": []}, {"name": "health", "description": "How many hearts the player has remaining. If you set this in an online server, all other players will be notified of the change.\n", "full": "uint8 health", "type": "property", "arguments": []}, {"name": "helicopter", "description": "The amount of time in which player's copter ears will run out or 0 if the player is currently not using copter ears.\n", "full": "int helicopter", "type": "property", "arguments": []}, {"name": "helicopterElapsed", "description": "The amount of time player spent using copter ears since their last jump. If this reaches or exceeds their respective jjCHARACTER::helicopterDurationMax, the player will be unable to use helicopter ears again until they have landed, analogous to using up a double jump.\n", "full": "int helicopterElapsed", "type": "property", "arguments": []}, {"name": "idle", "description": "The amount of time since the last change of idle animation or 0 if the player is not idle.\n", "full": "int idle", "type": "property", "arguments": []}, {"name": "invincibility", "description": "How much longer the player will be invincible. (Does not work in servers.) Specifically, the absolute value is the remaining duration of the invincibility; a positive number will display the invincibility effect around the player, but a negative number (or zero) will not.\n", "full": "int invincibility", "type": "property", "arguments": []}, {"name": "invisibility", "description": "Whether the player is invisible. Invisible players don't have their sprites or names drawn. Changes to this setting are automatically shared between all clients in the server.\n", "full": "bool invisibility", "type": "property", "arguments": []}, {"name": "isActive", "description": "Does this jjPLAYER object correspond to an actual player in the server, local or otherwise? If not, few if any of this jjPLAYER's other properties will be reliable. This is a fairly weak check and equals true for several types of players who may be present in the server but not actually playing\u00ef\u00bf\u00bdisInGame may often be more useful.\n", "full": "const bool isActive", "type": "property", "arguments": []}, {"name": "isAdmin", "description": "Whether the player is logged in as a Remote Admin in the current online server. Because admin privileges can vastly differ depending on server and admin group, a more precise tool hasPrivilege exists.\n", "full": "const bool isAdmin", "type": "property", "arguments": []}, {"name": "isConnecting", "description": "Whether the player is a client who has not finished joining the current online server yet, as represented by a \"C\" or \"D\" (if downloading) next to their name on the player list.\n", "full": "const bool isConnecting", "type": "property", "arguments": []}, {"name": "isIdle", "description": "Whether the player is idle and does not appear in the level or player list. Currently this can only ever be true of the server.\n", "full": "const bool isIdle", "type": "property", "arguments": []}, {"name": "isInGame", "description": "Equals true if isActive is true but isConnecting, isIdle, isOut, and isSpectating are all false. If more such properties need to be added in future revisions of JJ2+, isInGame will be updated to reflect them.\n", "full": "const bool isInGame", "type": "property", "arguments": []}, {"name": "isJailed", "description": "In Jailbreak game mode, whether the player is currently in jail. False in all other game modes.\n", "full": "const bool isJailed", "type": "property", "arguments": []}, {"name": "isLocal", "description": "Is this jjPLAYER object controlled by this instance of JJ2?\n", "full": "const bool isLocal", "type": "property", "arguments": []}, {"name": "isOut", "description": "Equals true if the player has lost all their lives (or joined too late) in an LRS-based gamemode.\n", "full": "const bool isOut", "type": "property", "arguments": []}, {"name": "isSpectating", "description": "Equals true if the player is spectating normally, i.e. not forced into spectating by being out or an idle server.\n", "full": "const bool isSpectating", "type": "property", "arguments": []}, {"name": "isZombie", "description": "In Pestilence game mode, whether the player is currently a zombie. False in all other game modes.\n", "full": "const bool isZombie", "type": "property", "arguments": []}, {"name": "jumpStrength", "description": "Vertical speed gained by the player on jump. Defaults to -10.\n", "full": "float jumpStrength", "type": "property", "arguments": []}, {"name": "keyDown", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyDown", "type": "property", "arguments": []}, {"name": "keyFire", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyFire", "type": "property", "arguments": []}, {"name": "keyJump", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyJump", "type": "property", "arguments": []}, {"name": "keyLeft", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyLeft", "type": "property", "arguments": []}, {"name": "keyRight", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyRight", "type": "property", "arguments": []}, {"name": "keyRun", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyRun", "type": "property", "arguments": []}, {"name": "keySelect", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keySelect", "type": "property", "arguments": []}, {"name": "keyUp", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyUp", "type": "property", "arguments": []}, {"name": "laps", "description": "In Race, the number of laps the player has completed so far. 0 for other modes.\n", "full": "const int laps", "type": "property", "arguments": []}, {"name": "lapTimeBest", "description": "In Race, how many ticks it took for this player to run their fastest lap so far. Note that because lapTimes only counts the five most recent laps, lapTimeBest will not appear in that array if this player's fastest lap was not one of their five most recent laps. Undefined for other modes or if laps is still 0.\n", "full": "const int lapTimeBest", "type": "property", "arguments": []}, {"name": "lapTimeCurrent", "description": "In Race, how many ticks have elapsed since the player began their current lap. Undefined for other modes.\n", "full": "const int lapTimeCurrent", "type": "property", "arguments": []}, {"name": "lapTimes", "description": "In Race, how many ticks it took for this player to run the five most recent laps they completed, where lapTimes[0] is the length of the most recent lap and lapTimes[4] the fifth most recent. If the player has not completed a given lap yet\u00ef\u00bf\u00bdi.e. if the index used for the lapTimes array is greater or equal to laps\u00ef\u00bf\u00bdthe value will be -1. Undefined for other modes or for players for whom isLocal is false.\n", "full": "const int lapTimes[5]", "type": "property", "arguments": []}, {"name": "light", "description": "The intensity of light emitted by the player. Changes to this setting are automatically shared between all clients in the server.\n", "full": "int8 light", "type": "property", "arguments": []}, {"name": "lighting", "description": "The player's current level of ambient lighting, as affected by the Set Light and Reset Light events.\n", "full": "uint8 lighting", "type": "property", "arguments": []}, {"name": "lightType", "description": "The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER (default). Changes to this setting are automatically shared between all clients in the server.\n", "full": "LIGHT::Type lightType", "type": "property", "arguments": []}, {"name": "lives", "description": "In single player or cooperative mode, how many lives the player has remaining. For LRS-based game modes use lrsLives instead. Lives are not displayed in the HUD when jjGameConnection != GAME::LOCAL, but this number still goes up and down as appropriate, even into the negatives; it's just that it has no effect on gameplay.\n", "full": "int lives", "type": "property", "arguments": []}, {"name": "localPlayerID", "description": "Which local player the player is, in case of splitscreen. 0-3.\n", "full": "const int localPlayerID", "type": "property", "arguments": []}, {"name": "lrsLives", "description": "In LRS-based game modes (LRS, TLRS, XLRS), how many lives the player has remaining, a negative value for other modes. For single player and cooperative modes use lives instead.\n", "full": "const int lrsLives", "type": "property", "arguments": []}, {"name": "name", "description": "The player's name. This is a constant property; to change it, you can use the setName method.\n", "full": "const string name", "type": "property", "arguments": []}, {"name": "nameUnformatted", "description": "The player's name in its most basic form, without any | or * characters added or removed for any gamemode-related reasons.\n", "full": "const string nameUnformatted", "type": "property", "arguments": []}, {"name": "noclipMode", "description": "Whether the player is currently in Noclip Mode, as caused by Sucker Tube events with the \"BecomeNoclip\" parameter set to 1. Setting this to true could be dangerous if the level design is not prepared for it.\n", "full": "bool noclipMode", "type": "property", "arguments": []}, {"name": "noFire", "description": "Whether the player is currently allowed to shoot bullets. Hides the default current weapon/ammunition display while true.\n", "full": "bool noFire", "type": "property", "arguments": []}, {"name": "platform", "description": "The object ID of the object the player is currently standing on, or 0 if inapplicable.\n", "full": "int platform", "type": "property", "arguments": []}, {"name": "playerID", "description": "In online play, which number the player is in the server's list of players. 0-31.\n", "full": "const int8 playerID", "type": "property", "arguments": []}, {"name": "powerup", "description": "Whether each ammo type is powered-up or not. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their allowedPowerup properties to true in the jjWeapons array.\n", "full": "bool powerup[WEAPON::Weapon]", "type": "property", "arguments": []}, {"name": "roasts", "description": "In competitive game modes, how many kills the player made or a negative value if unknown (this is currently the case when the property is checked by clients in RT, LRS, Pestilence and TLRS modes). If the game mode doesn't allow players to kill other players, as is the case in Single Player, Cooperative, Treasure Hunt and Race, this property will always be equal to 0.\n", "full": "const int roasts", "type": "property", "arguments": []}, {"name": "running", "description": "Is the player currently running? Detects the run key, capslock (if there is only one local player), and the /run <on|off> command. Apparently running is set based on keyRun, and then other parts of code query running exclusively.\n", "full": "bool running", "type": "property", "arguments": []}, {"name": "score", "description": "In single player and cooperative modes, the player's current score. JJ2 only increments this in multiples of 50 (or 10 if you count the unpatched Butterfly enemy), but that's up to you.\n", "full": "int score", "type": "property", "arguments": []}, {"name": "scoreDisplayed", "description": "In single player and cooperative modes, the number currently displayed for the player's score. Whenever score increases, scoreDisplayed takes a few moments to catch up to the new value. Unless the level defines an onDrawScore function, in which case this property could mean or do anything.\n", "full": "int scoreDisplayed", "type": "property", "arguments": []}, {"name": "setID", "description": "Which set of animations the player uses, serving as an index to the jjAnimSets array. This is nearly a 1:1 mapping with charCurr, except that the two birds (CHAR::BIRD and CHAR::BIRD2) share a setID.\nThe RABBIT::Anim enum is a version-independent list of all possible animations a rabbit player might use, expressed as indices of animations within the player's anim set. To see if a rabbit player p is currently standing still, for example, you can check if (p.curAnim - jjAnimSets[p.setID].firstAnim == RABBIT::STAND).\n", "full": "const ANIM::Set setID", "type": "property", "arguments": []}, {"name": "shieldTime", "description": "How much longer (in ticks) the player's shield will last, or 0 if the player doesn't have a shield.\n", "full": "int shieldTime", "type": "property", "arguments": []}, {"name": "shieldType", "description": "Which shield the player currently has, assuming the player has a shield at all. In place of numbers, you may also use the dedicated SHIELD::Shield enum, options being NONE, FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. Using values from outside of the range of existing shields may be a reason of incompatibility with future versions of JJ2+ in case more shields are added.\n", "full": "int shieldType", "type": "property", "arguments": []}, {"name": "specialMove", "description": "How long the player has been performing their special move or 0 if the player is currently not using a special move.\n", "full": "int specialMove", "type": "property", "arguments": []}, {"name": "spriteMode", "description": "Sprite mode the player's sprite is drawn in. Possible constants appear in the appendix below. Changes to this setting are automatically shared between all clients in the server.\n", "full": "SPRITE::Mode spriteMode", "type": "property", "arguments": []}, {"name": "spriteParam", "description": "A sprite mode parameter further specifying how the player should be drawn. Changes to this setting are automatically shared between all clients in the server.\n", "full": "uint8 spriteParam", "type": "property", "arguments": []}, {"name": "stoned", "description": "How much longer will the player be stoned, like after touching a smoke ring.\n", "full": "int stoned", "type": "property", "arguments": []}, {"name": "subscreenX", "description": "Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n", "full": "const int subscreenX", "type": "property", "arguments": []}, {"name": "subscreenY", "description": "Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n", "full": "const int subscreenY", "type": "property", "arguments": []}, {"name": "team", "description": "The player's team in team-based game modes. Possible values are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n", "full": "const TEAM::Color team", "type": "property", "arguments": []}, {"name": "teamRed", "description": "Incorrectly equals true whenever the player is not on the blue team, i.e. including if they're on green or yellow. Use the property above instead.\n", "full": "const bool teamRed", "type": "property", "arguments": []}, {"name": "timerPersists", "description": "Should dying disable the Player Timer (false) or have no effect on it (true)?\n", "full": "bool timerPersists", "type": "property", "arguments": []}, {"name": "timerState", "description": "The current state of the Player Timer (TIMER::STOPPED, TIMER::STARTED, or TIMER::PAUSED), for comparisons only. Use the corresponding timerStart, timerStop, timerPause, and timerResume methods to set this instead.\n", "full": "const TIMER::State timerStateconst TIMER::State timerState", "type": "property", "arguments": []}, {"name": "timerTime", "description": "How many ticks are left on the Player Timer.\n", "full": "int timerTime", "type": "property", "arguments": []}, {"name": "warpID", "description": "If this number is higher than 0, the player is currently warping, and it will equal the ID of the Warp event plus one, a range of 1-256.\nIt is often wise to make sure this property equals 0 before calling a warp method, lest the player be locked into a constant loop of beginning to warp but never finishing it. Something like if (conditionsForWarping && player.warpID == 0) player.warpToID(25);. Performing this check is however unnecessary for fast warps, or warps triggered by Text events, since that code is only called when the player first enters the tile.\n", "full": "const int warpID", "type": "property", "arguments": []}, {"name": "xAcc", "description": "Horizontal acceleration in pixels per game tick squared, positive or negative.\n", "full": "float xAcc", "type": "property", "arguments": []}, {"name": "xOrg", "description": "If this or yOrg are non-zero, where the player should respawn after death.\n", "full": "float xOrg", "type": "property", "arguments": []}, {"name": "xPos", "description": "Horizontal location in pixels.\n", "full": "float xPos", "type": "property", "arguments": []}, {"name": "xSpeed", "description": "Horizontal speed in pixels per game tick, positive or negative.\n", "full": "float xSpeed", "type": "property", "arguments": []}, {"name": "yAcc", "description": "Vertical acceleration in pixels per game tick squared, positive or negative.\n", "full": "float yAcc", "type": "property", "arguments": []}, {"name": "yOrg", "description": "If this or xOrg are non-zero, where the player should respawn after death.\n", "full": "float yOrg", "type": "property", "arguments": []}, {"name": "yPos", "description": "Vertical location in pixels.\n", "full": "float yPos", "type": "property", "arguments": []}, {"name": "ySpeed", "description": "Vertical speed in pixels per game tick, positive or negative.\n", "full": "float ySpeed", "type": "property", "arguments": []}, {"name": "activateBoss", "description": "Activates all bosses and disables the player's sugar rush if applicable. Unlike the Activate Boss event, does not change the music track. (Use jjMusicLoad for that instead.)\nSetting activate to false will attempt to deactivate bosses, but this mostly only results in the boss health meter going away. The jjPLAYER object's boss is left unchanged unless you change it manually, and bosses do not stop moving around.\n", "full": "void activateBoss(bool activate = true)", "type": "function", "arguments": [{"type": "bool", "name": "activate", "defaultValue": "true", "attributes": [], "items": []}]}, {"name": "cameraFreeze", "description": "Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n", "full": "void cameraFreeze(float xPixel, float yPixel, bool centered, bool instant)", "type": "function", "arguments": [{"type": "float", "name": "xPixel", "attributes": [], "items": []}, {"type": "float", "name": "yPixel", "attributes": [], "items": []}, {"type": "bool", "name": "centered", "attributes": [], "items": []}, {"type": "bool", "name": "instant", "attributes": [], "items": []}]}, {"name": "cameraUnfreeze", "description": "If cameraFreeze has been called, undoes the effect and lets the camera freely follow the player once again. If instant is left false, the camera will take roughly half a second to scroll to its target.\n", "full": "void cameraUnfreeze(bool instant = true)", "type": "function", "arguments": [{"type": "bool", "name": "instant", "defaultValue": "true", "attributes": [], "items": []}]}, {"name": "doesCollide", "description": "Returns true if the player's sprite collides with that of the specified object, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables\u00ef\u00bf\u00bdincluding playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in\u00ef\u00bf\u00bdare taken into account.\n", "full": "bool doesCollide(const jjOBJ@ object, bool always = false) const", "type": "function", "arguments": [{"type": "jjOBJ@", "name": "object", "attributes": ["const"], "items": []}, {"type": "bool", "name": "always", "defaultValue": "false", "attributes": [], "items": []}]}, {"name": "extendInvincibility", "description": "A convenience method to extend the absolute value of the player's invincibility property by the absolute value of the duration parameter, which also makes invincibility positive (visible) if duration is visible. For example, collecting a full energy carrot extends invincibility by +350, whereas buttstomping most enemies extends invincibility by -70.\n", "full": "int extendInvincibility(int duration)", "type": "function", "arguments": [{"type": "int", "name": "duration", "attributes": [], "items": []}]}, {"name": "fireBullet", "description": "Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.\nPossible gun constants may be found in the appendix at the bottom of the page, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nIf depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\nPossible values for direction are DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the mouse cursor is at, rather than whichever direction the player is physically facing. Alternatively you may pass a float angle argument instead of an orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is down, 1.5 * pi is left, and 2 * pi is up again.\n", "full": "int fireBullet(uint8 gun = WEAPON::CURRENT, bool depleteAmmo = true,\nbool requireAmmo = true, DIRECTION::Dir direction = DIRECTION::CURRENT)", "type": "function", "arguments": [{"type": "uint8", "name": "gun", "defaultValue": "WEAPON::CURRENT", "attributes": [], "items": []}, {"type": "bool", "name": "depleteAmmo", "defaultValue": "true,\nbool", "attributes": [], "items": []}, {"type": "DIRECTION::Dir", "name": "direction", "defaultValue": "DIRECTION::CURRENT", "attributes": []}]}, {"name": "freeze", "description": "Freezes the player for the same length of time as the Freeze Enemies pickup, or unfreezes the player if frozen is set to false. Helper method.\n", "full": "void freeze(bool frozen = true)", "type": "function", "arguments": [{"type": "bool", "name": "frozen", "defaultValue": "true", "attributes": [], "items": []}]}, {"name": "furGet", "description": "Sets provided parameters' values to palette indexes of the player's fur colors.\n", "full": "void furGet(uint8 &out a, uint8 &out b, uint8 &out c, uint8 &out d) const", "type": "function", "arguments": [{"type": "uint8", "name": "&out", "attributes": [], "items": []}, {"type": "uint8", "name": "&out", "attributes": [], "items": []}, {"type": "uint8", "name": "&out", "attributes": [], "items": []}, {"type": "uint8", "name": "&out", "attributes": [], "items": []}]}, {"name": "furSet", "description": "Sets player's fur colors to those represented by provided palette indexes. Changes made by this method are automatically shared between all clients in the server.  Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n", "full": "void furSet(uint8 a, uint8 b, uint8 c, uint8 d)", "type": "function", "arguments": [{"type": "uint8", "name": "a", "attributes": [], "items": []}, {"type": "uint8", "name": "b", "attributes": [], "items": []}, {"type": "uint8", "name": "c", "attributes": [], "items": []}, {"type": "uint8", "name": "d", "attributes": [], "items": []}]}, {"name": "getObjectHitForce", "description": "Returns a value expressing whether the player is currently in a state to harm objects or other players, equivalent to the \"force\" argument in objectHit or the onObjectHit hook/method. Specifically, this method returns -1 if the player is performing a special move and the canHurt property of their respective jjCHARACTER is true, 1 if the player is buttstomping or has a sugar rush, or 0 if none of the above are true. Doesn't work especially well when called on non-local players.\nIf a non-null jjOBJ@ is specified as target, two additional checks will be performed, returning -101 if the object is frozen and the player is running into it really fast, or -1 if the player is a frog (with a true canHurt) hitting the object with its tongue.\n", "full": "int getObjectHitForce(const jjOBJ@ target = null) const", "type": "function", "arguments": [{"type": "jjOBJ@", "name": "target", "attributes": ["const"], "items": []}]}, {"name": "hasPrivilege", "description": "Checks whether the player has the specified privilege within the script module moduleID. Privileges are specified in the admin configuration file (typically admin.ini) and serve as a way to determine what actions specific admin groups are allowed to take. You can read more about them in the Remote Admin section of the JJ2+ readme.\nBecause privileges are only known to the host, this function will always return false if called client-side. The function will always return false for players who are not logged in, and will always return true if the player is the host or the game is local. If the privilege string contains invalid characters, i.e. anything besides letters, digits, underscores ('_'), full stops ('.'), and hyphens ('-'), or if moduleID is not valid, the function will also return false. In all other cases, i.e. if called server-side for a logged in client and with valid parameters, privileges obtained from the admin configuration file will be tested for a match, and if one is found, the function will return true, otherwise false.\n", "full": "bool hasPrivilege(const string &in privilege, uint moduleID = jjScriptModuleID) const", "type": "function", "arguments": [{"type": "string", "name": "privilege", "attributes": ["const", "&in"], "items": []}, {"type": "uint", "name": "moduleID", "defaultValue": "jjScriptModuleID", "attributes": [], "items": []}]}, {"name": "hurt", "description": "Attempts to hurt the player damage hearts, or at least strip the player of their bird or reduce their shield time. If attacker is left null, or if it's the same player as the one getting hurt, the injury will be counted as coming from the level, and if a death results, it will be marked online with the \"ate it/you killed yourself\" text. This is what you should do for injuries from enemies and other level-based factors. On the other hand, if the player dies from the hurt call and attacker is another player in the server, that player will get credit for the roast. Returns false if neither the hurtee nor the hurter are local players and the method is not called by the host, or if forceHurt (which bypasses traditional safety sources like the invincibility and blink properties and buttstomping) is false and something or other prevents the hurting from happening.\n", "full": "bool hurt(int8 damage = 1, bool forceHurt = false, jjPLAYER@ attacker = null)", "type": "function", "arguments": [{"type": "int8", "name": "damage", "defaultValue": "1", "attributes": [], "items": []}, {"type": "bool", "name": "forceHurt", "defaultValue": "false", "attributes": [], "items": []}, {"type": "jjPLAYER@", "name": "attacker", "defaultValue": "null", "attributes": [], "items": []}]}, {"name": "isEnemy", "description": "Returns true iff victim is a player who can be hurt by this player's bullets or other attacks, according to the rules of the current gamemode. Potentially useful if you are writing a custom weapon behavior and don't want to use HANDLING::PLAYERBULLET.\nThe following conditions will cause this method to return false: the two jjPLAYER objects are the same player; the gamemode is Single Player or Cooperative; in a team-based game, the two players are on the same team and jjFriendlyFire is false; in Roast Tag, Eva's Ring has been captured, yet neither player is jjTokenOwner or jjBottomFeeder; in Pestilence, either both players are zombies or neither are zombies but jjDoZombiesAlreadyExist is false; or in Jailbreak, victim is in jail.\nAgain, this method checks only gamemode-related conditions. (And if more gamemodes are added in the future, this method will be updated to reflect them.) It does not check jjPLAYER::isInGame, jjGameState, or anything that might cause jjPLAYER::hurt to return false if its forceHurt parameter is left false.\n", "full": "bool isEnemy(const jjPLAYER &in victim) const", "type": "function", "arguments": [{"type": "jjPLAYER", "name": "victim", "attributes": ["const", "&in"], "items": []}]}, {"name": "kill", "description": "Kills the player instantly. If you want the player to be roasted by some other player in an online server, use hurt with a high damage value instead.\n", "full": "void kill()", "type": "function", "arguments": []}, {"name": "limitXScroll", "description": "Works like a Limit X Scroll event with the corresponding Left and Width parameters. Remember that these are measured in tiles, not pixels.\n", "full": "void limitXScroll(uint16 left, uint16 width)", "type": "function", "arguments": [{"type": "uint16", "name": "left", "attributes": [], "items": []}, {"type": "uint16", "name": "width", "attributes": [], "items": []}]}, {"name": "morph", "description": "Cycles the player's character to the next on the list, just like the JJMORPH cheat: Jazz-Spaz-(Lori-)Bird-Frog-Bird2. Or if rabbitsOnly is true, skips birds and frog and acts like a morph monitor instead, restricting available morph targets to those whose jjCHARACTER::morphBoxCycle properties equal true. Returns the player's new character: CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n", "full": "CHAR::Char morph(bool rabbitsOnly = false, bool morphEffect = true)", "type": "function", "arguments": [{"type": "bool", "name": "rabbitsOnly", "defaultValue": "false", "attributes": [], "items": []}, {"type": "bool", "name": "morphEffect", "defaultValue": "true", "attributes": [], "items": []}]}, {"name": "morphTo", "description": "Sets the player's character to charNew, possible values CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI (in TSF), CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n", "full": "CHAR::Char morphTo(CHAR::Char charNew, bool morphEffect = true)", "type": "function", "arguments": [{"type": "CHAR::Char", "name": "charNew", "attributes": []}, {"type": "bool", "name": "morphEffect", "defaultValue": "true", "attributes": [], "items": []}]}, {"name": "objectHit", "description": "Causes the game to think the player is colliding with object target, even if they are not in the same area, and returns true if (generally speaking) the object is affected somehow. Calling this method on a non-local player will return false unless called by the host of a server.\nThe force parameter hints at whether the player should be able to damage the object, if the object can be damaged to begin with. A value of 0 means that the player is simply bumping into the object at random; 1 means a buttstomp or sugar rush; -1 means a special move; and -101 means the object is frozen and the player runs into it really fast. If you want this parameter to reflect reality, get the value from jjPLAYER's getObjectHitForce method.\nThe playerHandling parameter specifies how the player should interact with the object\u00ef\u00bf\u00bdfor example, passing HANDLING::PICKUP will force the player to treat the object as a pickup, even if its actual playerHandling property is set to something else. If the value is not HANDLING::ENEMY, HANDLING::SPECIAL, HANDLING::PICKUP, HANDLING::ENEMYBULLET, or HANDLING::PLAYERBULLET, nothing will happen. If the value is one of the first three and the object has scriptedCollisions set to true, some version of onObjectHit will be called with a null bullet argument, this jjPLAYER as player, and whatever force you call this method with as force.\nThe results of this collision will be broadcast to other players in the server exactly as if it had happened naturally through the sprites colliding. For example, collecting a pickup object half the level away will cause other players to see the pickup disappear.\n", "full": "bool objectHit(jjOBJ@ target, int force, HANDLING::Player playerHandling)", "type": "function", "arguments": [{"type": "jjOBJ@", "name": "target", "attributes": [], "items": []}, {"type": "int", "name": "force", "attributes": [], "items": []}, {"type": "HANDLING::Player", "name": "playerHandling", "attributes": []}]}, {"name": "offsetPosition", "description": "Instantly moves the player xPixels pixels to the right and yPixels pixels down. The camera instantly readjusts itself to follow, as does the glowing trace following the player while running and any companion bird the player may have. The best way of creating seamlessly looping levels.\n", "full": "bool offsetPosition(int xPixels, int yPixels)", "type": "function", "arguments": [{"type": "int", "name": "xPixels", "attributes": [], "items": []}, {"type": "int", "name": "yPixels", "attributes": [], "items": []}]}, {"name": "poleSpin", "description": "Causes the player to appear to swing around a pole for delay ticks, then launch off at the specified speed/s. For reference, an H-Pole event increases the absolute value of your existing xSpeed by 8 (but not above 20), while a V-Pole event increases the absolute value of your existing ySpeed by 16, with both using the default delay value of 70 ticks (=one second). An H-Pole passes 0 for ySpeed, and a V-Pole passes 0 for xSpeed, but you may use non-orthogonal directions with this method if you'd rather.\n", "full": "void poleSpin(float xSpeed, float ySpeed, uint delay = 70)", "type": "function", "arguments": [{"type": "float", "name": "xSpeed", "attributes": [], "items": []}, {"type": "float", "name": "ySpeed", "attributes": [], "items": []}, {"type": "uint", "name": "delay", "defaultValue": "70", "attributes": [], "items": []}]}, {"name": "resetLight", "description": "Resets player's ambient lighting value to the level's default.\n", "full": "uint8 resetLight()", "type": "function", "arguments": []}, {"name": "revertMorph", "description": "Reverts the player to the character they were when they began the level, just like the Revert Morph event. If morphEffect is true, displays the default visual effect. Returns the new character (equal to the player's charOrig).\n", "full": "CHAR::Char revertMorph(bool morphEffect = true)", "type": "function", "arguments": [{"type": "bool", "name": "morphEffect", "defaultValue": "true", "attributes": [], "items": []}]}, {"name": "setName", "description": "Sets the player's name. This method will only succeed if called server-side or in a local game, and it will then return true to indicate success. Otherwise no change will occur and the method will return false.\n", "full": "bool setName(const string &in name)", "type": "function", "arguments": [{"type": "string", "name": "name", "attributes": ["const", "&in"], "items": []}]}, {"name": "setScore", "description": "Sets the player's score. While setting the score through the score property is slightly delayed as scoreDisplayed increases/decreases to catch up to the new value, this function sets both properties at once. Probably most helpful as a function for quickly showing you debug information.\n", "full": "int setScore(int score)", "type": "function", "arguments": [{"type": "int", "name": "score", "attributes": [], "items": []}]}, {"name": "showText", "description": "Displays text on the player's screen either like a Text event, with the corresponding textID and offset parameters, or simply a specified text. Unique size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use jjHelpStrings instead.\n", "full": "void showText(uint8 textID, uint8 offset, STRING::Size size = STRING::SMALL)", "type": "function", "arguments": [{"type": "uint8", "name": "textID", "attributes": [], "items": []}, {"type": "uint8", "name": "offset", "attributes": [], "items": []}, {"type": "STRING::Size", "name": "size", "defaultValue": "STRING::SMALL", "attributes": [], "items": ["SMALL", "MEDIUM", "LARGE"]}]}, {"name": "spring", "description": "Simulates the player touching and getting bounced by a Spring object. For reference, the absolute values of red, green, and blue springs' speeds are 16, 24, and 32 respectively: for example, an upward-facing red spring uses xSpeed 0 and ySpeed -16.\nThe keepZeroSpeeds argument affects what happens if either speed axis is left at 0, equivalent to the \"Keep X-Speed\" and \"Keep Y-Speed\" event parameters: if keepZeroSpeeds is false, the player's speed on that axis will be set to 0, but if true, it will be left at its value prior to spring being called.\nIf sample is true, a sample will be chosen (from among SOUND::COMMON_SPRING1, SOUND::SPRING_BOING_DOWN, and SOUND::SPRING_SPRING1) and played depending on the xSpeed and ySpeed values, and if the player is Spaz, SOUND::SPAZSOUNDS_YAHOO2 may be played as well.\n", "full": "void spring(float xSpeed, float ySpeed, bool keepZeroSpeeds, bool sample)", "type": "function", "arguments": [{"type": "float", "name": "xSpeed", "attributes": [], "items": []}, {"type": "float", "name": "ySpeed", "attributes": [], "items": []}, {"type": "bool", "name": "keepZeroSpeeds", "attributes": [], "items": []}, {"type": "bool", "name": "sample", "attributes": [], "items": []}]}, {"name": "startSugarRush", "description": "Gives the player a sugar rush lasting time ticks, unless their bossActivated property equals true, in which case the method returns false. Otherwise returns true. In online multiplayer, jjSugarRushAllowed should be true for the host, or else clients who call this method may be kicked.\n", "full": "bool startSugarRush(int time = 1400)", "type": "function", "arguments": [{"type": "int", "name": "time", "defaultValue": "1400", "attributes": [], "items": []}]}, {"name": "suckerTube", "description": "Simulates the player touching a Sucker Tube event with the same parameter names and values (with noclip referring to \"BecomeNoclip\", not \"Noclip Only\"). For each axis this method instructs the player to move along, the center parameter first puts the player in the center of their current tile on the other axis\u00ef\u00bf\u00bdtherefore, passing true is generally safe, but it will get the player stuck if trying to move diagonally every single tick. In normal JJ2, center is true for the first tick the player spends in the tile with the sucker tube event, and false every tick thereafter.\n", "full": "void suckerTube(int xSpeed, int ySpeed, bool center, bool noclip = false, bool trigSample = false)", "type": "function", "arguments": [{"type": "int", "name": "xSpeed", "attributes": [], "items": []}, {"type": "int", "name": "ySpeed", "attributes": [], "items": []}, {"type": "bool", "name": "center", "attributes": [], "items": []}, {"type": "bool", "name": "noclip", "defaultValue": "false", "attributes": [], "items": []}, {"type": "bool", "name": "trigSample", "defaultValue": "false", "attributes": [], "items": []}]}, {"name": "testForCoins", "description": "If the player has at least numberOfCoins coins, depletes their coins by numberOfCoins and returns true. Otherwise displays a warning onscreen that they need more coins to continue and returns false. Basically the same as a coin warp event, but you get to choose the result.\n", "full": "bool testForCoins(int numberOfCoins)", "type": "function", "arguments": [{"type": "int", "name": "numberOfCoins", "attributes": [], "items": []}]}, {"name": "testForGems", "description": "If the player has at least numberOfGems type-colored gems, depletes their type gems by numberOfGems and returns true. Otherwise displays a warning onscreen that they need more gems to continue and returns false. Basically the same as a coin warp event, but you get to choose the result, and it's for gems instead of coins.\nPossible values of type are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n", "full": "bool testForGems(int numberOfGems, GEM::Color type)", "type": "function", "arguments": [{"type": "int", "name": "numberOfGems", "attributes": [], "items": []}, {"type": "GEM::Color", "name": "type", "attributes": []}]}, {"name": "timerFunction", "description": "When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n", "full": "void timerFunction(string functionName)", "type": "function", "arguments": [{"type": "string", "name": "functionName", "attributes": [], "items": []}]}, {"name": "timerPause", "description": "Pauses the Player Timer and returns TIMER::PAUSED.\n", "full": "TIMER::State timerPause()", "type": "function", "arguments": []}, {"name": "timerResume", "description": "Resumes the Player Timer and returns TIMER::STARTED.\n", "full": "TIMER::State timerResume()", "type": "function", "arguments": []}, {"name": "timerStart", "description": "Begins the Player Timer (and optionally pauses it) with ticks ticks remaining on the clock. Returns TIMER::STARTED or TIMER::PAUSED, depending.\n", "full": "TIMER::State timerStart(int ticks, bool startPaused = false)", "type": "function", "arguments": [{"type": "int", "name": "ticks", "attributes": [], "items": []}, {"type": "bool", "name": "startPaused", "defaultValue": "false", "attributes": [], "items": []}]}, {"name": "timerStop", "description": "Stops the Player Timer and returns TIMER::STOPPED.\n", "full": "TIMER::State timerStop()", "type": "function", "arguments": []}, {"name": "warpToID", "description": "Warps the player to a Warp Target event with the specified Warp ID, instantly if fast is true or using the standard warp effect if fast is false.\n", "full": "bool warpToID(uint8 warpID, bool fast = false)", "type": "function", "arguments": [{"type": "uint8", "name": "warpID", "attributes": [], "items": []}, {"type": "bool", "name": "fast", "defaultValue": "false", "attributes": [], "items": []}]}, {"name": "warpToTile", "description": "Warps the player to the specified tile, instantly if fast is true or using the standard warp effect if fast is false.\n", "full": "bool warpToTile(int xTile, int yTile, bool fast = false)", "type": "function", "arguments": [{"type": "int", "name": "xTile", "attributes": [], "items": []}, {"type": "int", "name": "yTile", "attributes": [], "items": []}, {"type": "bool", "name": "fast", "defaultValue": "false", "attributes": [], "items": []}]}]