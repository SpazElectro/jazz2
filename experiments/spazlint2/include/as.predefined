// Generated on 2025-02-14 13:04:40.491268

class ref{}
funcdef bool less(const ?&in a, const ?&in b);
class array<T>{
	uint length() const;
	void resize(uint);
	void reverse();
	void insertAt(uint index, const T& in value);
	void insertAt(uint index, const array<T>& arr);
	void insertLast(const T& in);
	void removeAt(uint index);
	void removeLast();
	void removeRange(uint start, uint count);
	void sortAsc();
	void sortAsc(uint startAt, uint count);
	void sortDesc();
	void sortDesc(uint startAt, uint count);
	void sort(const less &in compareFunc, uint startAt = 0, uint count = uint(-1));
	int find(const T& in);
	int find(uint startAt, const T& in);
	int findByRef(const T& in);
	int findByRef(uint startAt, const T& in);
	
	T opIndex(uint index) const;

	array();
	array(uint size);
};
class dictionary{
	void set(const string &in key, ? &in value);
	void set(const string &in key, int64 &in value);
	void set(const string &in key, double &in value);
	bool get(const string &in key, ? &out value) const;
	bool get(const string &in key, int64 &out value) const;
	bool get(const string &in key, double &out value) const;
	array<string> @getKeys() const;
	bool exists(const string &in key) const;
	bool delete(const string &in key);
	void deleteAll();
	bool isEmpty() const;
	uint getSize() const;

	dictionaryValue@ opIndex(const string &in key) const;
	void opIndexAssign(const string &in key, const dictionaryValue &in value);

	dictionary();
}
class dictionaryValue{}
class string {
    uint length() const;
    void resize(uint new);
    bool isEmpty() const;
    string substr(uint start = 0, int count = -1) const;
    void insert(uint pos, const string &in other);
    void erase(uint pos, int count = -1);
    int findFirst(const string &in str, uint start = 0) const;
    int findLast(const string &in str, int start = -1) const;
    int findFirstOf(const string &in chars, int start = 0) const;
    int findFirstNotOf(const string &in chars, int start = 0) const;
    int findLastOf(const string &in chars, int start = -1) const;
    int findLastNotOf(const string &in chars, int start = -1) const;
    array<string>@ split(const string &in delimiter) const;

	string& opAddAssign(int);
	string& opAddAssign(double);
	string& opAddAssign(float);
	string& opAddAssign(string);
	string& opAdd_r(int);
	string& opAdd_r(double);
	string& opAdd_r(float);
	string& opAdd_r(string);
	string& opAdd(int);
	string& opAdd(double);
	string& opAdd(float);
	string& opAdd(string);
};
class any {
	any();
	any(? &in value);
	any(int64 &in value);
	any(double &in value);
	any &opAssign(const any &in other);
	void store(? &in value);
	void store(int64 &in value);
	void store(double &in value);
	bool retrieve(? &out value) const;
	bool retrieve(int64 &out value) const;
	bool retrieve(double &out value) const;
}

string join(const array<string> &in arr, const string &in delimiter);
int64 parseInt(const string &in str, uint base = 10, uint &out byteCount = 0);
uint64 parseUInt(const string &in str, uint base = 10, uint &out byteCount = 0);
double parseFloat(const string &in, uint &out byteCount = 0);
string formatInt(int64 val, const string &in options = '', uint width = 0);
string formatUInt(uint64 val, const string &in options = '', uint width = 0);
string formatFloat(double val, const string &in options = '', uint width = 0, uint precision = 0);

// P = index type, V = value type
class fakearray<P, V, T> {
	V opIndex(P index) const;
	V opIndex(T index) const;
	void opIndexAssign(V index, P value);
	
	// We can't use V because the parser is broken
	void opAssign(V b);

	void opAssign(string b);
	void opAssign(int b);
	void opAssign(float b);
};

// int ammo[WEAPON::Weapon]
fakearray<int, string> ammo;
fakearray<string, bool> powerup;
void main() {
	ammo[2] = "hello";
	
	string v = ammo[2];
	
	powerup["ga"] = true;

}
// any T;
// typedef jjBEHAVIOR = BEHAVIOR::BEHAVIOR;

funcdef void jjVOIDFUNC();
funcdef void jjVOIDFUNCPLAYER(jjPLAYER@ player);

shared interface jjPUBLICINTERFACE {}
// This file was automatically generated at 2025-02-14 13:04:39.542975


namespace CREATOR {
    enum Type {
        OBJECT,
        LEVEL,
        PLAYER,
    };
    // Aliases
    const auto OBJECT = Type::OBJECT;
    const auto LEVEL = Type::LEVEL;
    const auto PLAYER = Type::PLAYER;
};
namespace PARTICLE {
    enum Type {
        INACTIVE,
        FIRE,
        FLOWER,
        ICETRAIL,
        LEAF,
        PIXEL,
        RAIN,
        SMOKE,
        SNOW,
        SPARK,
        STAR,
        STRING,
        TILE,
    };
    // Aliases
    const auto INACTIVE = Type::INACTIVE;
    const auto FIRE = Type::FIRE;
    const auto FLOWER = Type::FLOWER;
    const auto ICETRAIL = Type::ICETRAIL;
    const auto LEAF = Type::LEAF;
    const auto PIXEL = Type::PIXEL;
    const auto RAIN = Type::RAIN;
    const auto SMOKE = Type::SMOKE;
    const auto SNOW = Type::SNOW;
    const auto SPARK = Type::SPARK;
    const auto STAR = Type::STAR;
    const auto STRING = Type::STRING;
    const auto TILE = Type::TILE;
};
namespace STRING {
    enum Size {
        SMALL,
        MEDIUM,
        LARGE,
    };
    enum SIZE {
        SMALL,
        MEDIUM,
        LARGE,
    };
    enum Mode {
        NORMAL,
        DARK,
        RIGHTALIGN,
        BOUNCE,
        SPIN,
        PALSHIFT,
    };
    enum Alignment {
        DEFAULT,
        LEFT,
        CENTER,
        RIGHT,
    };
    enum SignTreatment {
        HIDESIGN,
        DISPLAYSIGN,
        SPECIALSIGN,
    };
    // Aliases
    const auto SMALL = Size::SMALL;
    const auto MEDIUM = Size::MEDIUM;
    const auto LARGE = Size::LARGE;
    const auto NORMAL = Mode::NORMAL;
    const auto DARK = Mode::DARK;
    const auto RIGHTALIGN = Mode::RIGHTALIGN;
    const auto BOUNCE = Mode::BOUNCE;
    const auto SPIN = Mode::SPIN;
    const auto PALSHIFT = Mode::PALSHIFT;
    const auto DEFAULT = Alignment::DEFAULT;
    const auto LEFT = Alignment::LEFT;
    const auto CENTER = Alignment::CENTER;
    const auto RIGHT = Alignment::RIGHT;
    const auto HIDESIGN = SignTreatment::HIDESIGN;
    const auto DISPLAYSIGN = SignTreatment::DISPLAYSIGN;
    const auto SPECIALSIGN = SignTreatment::SPECIALSIGN;
};
namespace SPRITE {
    enum Mode {
        ALPHAMAP,
        BLEND_NORMAL,
        BLEND_DISSOLVE,
        BLEND_DARKEN,
        BLEND_MULTIPLY,
        BLEND_BURN,
        BLEND_LIGHTEN,
        BLEND_SCREEN,
        BLEND_DODGE,
        BLEND_OVERLAY,
        BLEND_SOFTLIGHT,
        BLEND_HARDLIGHT,
        BLEND_DIFFERENCE,
        BLEND_EXCLUSION,
        BLEND_COLOR,
        BLEND_HUE,
        BLEND_SATURATION,
        BLEND_LUMINANCE,
        BRIGHTNESS,
        CHROMAKEY,
        FROZEN,
        GEM,
        INVISIBLE,
        MAPPING,
        MENUPLAYER,
        NEONGLOW,
        NORMAL,
        PALSHIFT,
        PLAYER,
        RESIZED,
        SHADOW,
        SINGLECOLOR,
        SINGLEHUE,
        TINTED,
        TRANSLUCENT,
        TRANSLUCENTCOLOR,
        TRANSLUCENTMAPPING,
        TRANSLUCENTPALSHIFT,
        TRANSLUCENTPLAYER,
        TRANSLUCENTSINGLEHUE,
        TRANSLUCENTTILE,
    };
    enum Direction {
        FLIPNONE,
        FLIPH,
        FLIPV,
        FLIPHV,
    };
    // Aliases
    const auto ALPHAMAP = Mode::ALPHAMAP;
    const auto BLEND_NORMAL = Mode::BLEND_NORMAL;
    const auto BLEND_DISSOLVE = Mode::BLEND_DISSOLVE;
    const auto BLEND_DARKEN = Mode::BLEND_DARKEN;
    const auto BLEND_MULTIPLY = Mode::BLEND_MULTIPLY;
    const auto BLEND_BURN = Mode::BLEND_BURN;
    const auto BLEND_LIGHTEN = Mode::BLEND_LIGHTEN;
    const auto BLEND_SCREEN = Mode::BLEND_SCREEN;
    const auto BLEND_DODGE = Mode::BLEND_DODGE;
    const auto BLEND_OVERLAY = Mode::BLEND_OVERLAY;
    const auto BLEND_SOFTLIGHT = Mode::BLEND_SOFTLIGHT;
    const auto BLEND_HARDLIGHT = Mode::BLEND_HARDLIGHT;
    const auto BLEND_DIFFERENCE = Mode::BLEND_DIFFERENCE;
    const auto BLEND_EXCLUSION = Mode::BLEND_EXCLUSION;
    const auto BLEND_COLOR = Mode::BLEND_COLOR;
    const auto BLEND_HUE = Mode::BLEND_HUE;
    const auto BLEND_SATURATION = Mode::BLEND_SATURATION;
    const auto BLEND_LUMINANCE = Mode::BLEND_LUMINANCE;
    const auto BRIGHTNESS = Mode::BRIGHTNESS;
    const auto CHROMAKEY = Mode::CHROMAKEY;
    const auto FROZEN = Mode::FROZEN;
    const auto GEM = Mode::GEM;
    const auto INVISIBLE = Mode::INVISIBLE;
    const auto MAPPING = Mode::MAPPING;
    const auto MENUPLAYER = Mode::MENUPLAYER;
    const auto NEONGLOW = Mode::NEONGLOW;
    const auto NORMAL = Mode::NORMAL;
    const auto PALSHIFT = Mode::PALSHIFT;
    const auto PLAYER = Mode::PLAYER;
    const auto RESIZED = Mode::RESIZED;
    const auto SHADOW = Mode::SHADOW;
    const auto SINGLECOLOR = Mode::SINGLECOLOR;
    const auto SINGLEHUE = Mode::SINGLEHUE;
    const auto TINTED = Mode::TINTED;
    const auto TRANSLUCENT = Mode::TRANSLUCENT;
    const auto TRANSLUCENTCOLOR = Mode::TRANSLUCENTCOLOR;
    const auto TRANSLUCENTMAPPING = Mode::TRANSLUCENTMAPPING;
    const auto TRANSLUCENTPALSHIFT = Mode::TRANSLUCENTPALSHIFT;
    const auto TRANSLUCENTPLAYER = Mode::TRANSLUCENTPLAYER;
    const auto TRANSLUCENTSINGLEHUE = Mode::TRANSLUCENTSINGLEHUE;
    const auto TRANSLUCENTTILE = Mode::TRANSLUCENTTILE;
    const auto FLIPNONE = Direction::FLIPNONE;
    const auto FLIPH = Direction::FLIPH;
    const auto FLIPV = Direction::FLIPV;
    const auto FLIPHV = Direction::FLIPHV;
};
namespace TILE {
    enum Quadrant {
        TOPLEFT,
        TOPRIGHT,
        BOTTOMLEFT,
        BOTTOMRIGHT,
        ALLQUADRANTS,
    };
    // Aliases
    const auto TOPLEFT = Quadrant::TOPLEFT;
    const auto TOPRIGHT = Quadrant::TOPRIGHT;
    const auto BOTTOMLEFT = Quadrant::BOTTOMLEFT;
    const auto BOTTOMRIGHT = Quadrant::BOTTOMRIGHT;
    const auto ALLQUADRANTS = Quadrant::ALLQUADRANTS;
};
namespace SOUND {
    enum Sample {
        AMMO_BLUB1,
        AMMO_BLUB2,
        AMMO_BMP1,
        AMMO_BMP2,
        AMMO_BMP3,
        AMMO_BMP4,
        AMMO_BMP5,
        AMMO_BMP6,
        AMMO_BOEM1,
        AMMO_BUL1,
        AMMO_BULFL1,
        AMMO_BULFL2,
        AMMO_BULFL3,
        AMMO_FIREGUN1A,
        AMMO_FIREGUN2A,
        AMMO_FUMP,
        AMMO_GUN1,
        AMMO_GUN2,
        AMMO_GUN3PLOP,
        AMMO_GUNFLP,
        AMMO_GUNFLP1,
        AMMO_GUNFLP2,
        AMMO_GUNFLP3,
        AMMO_GUNFLP4,
        AMMO_GUNFLPL,
        AMMO_GUNJAZZ,
        AMMO_GUNVELOCITY,
        AMMO_ICEGUN,
        AMMO_ICEGUN2,
        AMMO_ICEGUNPU,
        AMMO_ICEPU1,
        AMMO_ICEPU2,
        AMMO_ICEPU3,
        AMMO_ICEPU4,
        AMMO_LASER,
        AMMO_LASER2,
        AMMO_LASER3,
        AMMO_LAZRAYS,
        AMMO_MISSILE,
        AMMO_SPZBL1,
        AMMO_SPZBL2,
        AMMO_SPZBL3,
        BAT_BATFLY1,
        BILSBOSS_BILLAPPEAR,
        BILSBOSS_FINGERSNAP,
        BILSBOSS_FIRE,
        BILSBOSS_FIRESTART,
        BILSBOSS_SCARY3,
        BILSBOSS_THUNDER,
        BILSBOSS_ZIP,
        BONUS_BONUS1,
        BONUS_BONUSBLUB,
        BUBBA_BUBBABOUNCE1,
        BUBBA_BUBBABOUNCE2,
        BUBBA_BUBBAEXPLO,
        BUBBA_FROG2,
        BUBBA_FROG3,
        BUBBA_FROG4,
        BUBBA_FROG5,
        BUBBA_SNEEZE2,
        BUBBA_TORNADOATTACK2,
        BUMBEE_BEELOOP,
        CATERPIL_RIDOE,
        COMMON_AIRBOARD,
        COMMON_AIRBTURN,
        COMMON_AIRBTURN2,
        COMMON_BASE1,
        COMMON_BELL_FIRE,
        COMMON_BELL_FIRE2,
        COMMON_BENZIN1,
        COMMON_BIRDFLY,
        COMMON_BIRDFLY2,
        COMMON_BLOKPLOP,
        COMMON_BLUB1,
        COMMON_BUBBLGN1,
        COMMON_BURN,
        COMMON_BURNIN,
        COMMON_CANSPS,
        COMMON_CLOCK,
        COMMON_COIN,
        COMMON_COLLAPS,
        COMMON_CUP,
        COMMON_DAMPED1,
        COMMON_DOWN,
        COMMON_DOWNFL2,
        COMMON_DRINKSPAZZ1,
        COMMON_DRINKSPAZZ2,
        COMMON_DRINKSPAZZ3,
        COMMON_DRINKSPAZZ4,
        COMMON_EAT1,
        COMMON_EAT2,
        COMMON_EAT3,
        COMMON_EAT4,
        COMMON_ELECTRIC1,
        COMMON_ELECTRIC2,
        COMMON_ELECTRICHIT,
        COMMON_EXPL_TNT,
        COMMON_EXPSM1,
        COMMON_FLAMER,
        COMMON_FLAP,
        COMMON_FOEW1,
        COMMON_FOEW2,
        COMMON_FOEW3,
        COMMON_FOEW4,
        COMMON_FOEW5,
        COMMON_GEMSMSH1,
        COMMON_GLASS2,
        COMMON_GUNSM1,
        COMMON_HARP1,
        COMMON_HEAD,
        COMMON_HELI1,
        COMMON_HIBELL,
        COMMON_HOLYFLUT,
        COMMON_HORN1,
        COMMON_ICECRUSH,
        COMMON_IMPACT1,
        COMMON_IMPACT2,
        COMMON_IMPACT3,
        COMMON_IMPACT4,
        COMMON_IMPACT5,
        COMMON_IMPACT6,
        COMMON_IMPACT7,
        COMMON_IMPACT8,
        COMMON_IMPACT9,
        COMMON_ITEMTRE,
        COMMON_JUMP,
        COMMON_JUMP2,
        COMMON_LAND,
        COMMON_LAND1,
        COMMON_LAND2,
        COMMON_LANDCAN1,
        COMMON_LANDCAN2,
        COMMON_LANDPOP,
        COMMON_LOADJAZZ,
        COMMON_LOADSPAZ,
        COMMON_METALHIT,
        COMMON_MONITOR,
        COMMON_NOCOIN,
        COMMON_PICKUP1,
        COMMON_PICKUPW1,
        COMMON_PISTOL1,
        COMMON_PLOOP1,
        COMMON_PLOP1,
        COMMON_PLOP2,
        COMMON_PLOP3,
        COMMON_PLOP4,
        COMMON_PLOPKORK,
        COMMON_PREEXPL1,
        COMMON_PREHELI,
        COMMON_REVUP,
        COMMON_RINGGUN,
        COMMON_RINGGUN2,
        COMMON_SHIELD1,
        COMMON_SHIELD4,
        COMMON_SHIELD_ELEC,
        COMMON_SHLDOF3,
        COMMON_SLIP,
        COMMON_SMASH,
        COMMON_SPLAT1,
        COMMON_SPLAT2,
        COMMON_SPLAT3,
        COMMON_SPLAT4,
        COMMON_SPLUT,
        COMMON_SPRING1,
        COMMON_STEAM,
        COMMON_STEP,
        COMMON_STRETCH,
        COMMON_SWISH1,
        COMMON_SWISH2,
        COMMON_SWISH3,
        COMMON_SWISH4,
        COMMON_SWISH5,
        COMMON_SWISH6,
        COMMON_SWISH7,
        COMMON_SWISH8,
        COMMON_TELPORT1,
        COMMON_TELPORT2,
        COMMON_UP,
        COMMON_WATER,
        COMMON_WOOD1,
        DEMON_RUN,
        DEVILDEVAN_DRAGONFIRE,
        DEVILDEVAN_FLAP,
        DEVILDEVAN_FROG4,
        DEVILDEVAN_JUMPUP,
        DEVILDEVAN_LAUGH,
        DEVILDEVAN_PHASER2,
        DEVILDEVAN_STRECh3,
        DEVILDEVAN_STRECHTAIL,
        DEVILDEVAN_STRETCH1,
        DEVILDEVAN_STRETCH3,
        DEVILDEVAN_VANISH1,
        DEVILDEVAN_WHISTLEDESCENDING2,
        DEVILDEVAN_WINGSOUT,
        DOG_AGRESSIV,
        DOG_SNIF1,
        DOG_WAF1,
        DOG_WAF2,
        DOG_WAF3,
        DRAGFLY_BEELOOP,
        ENDING_OHTHANK,
        ENDTUNEJAZZ_TUNE,
        ENDTUNELORI_CAKE,
        ENDTUNESPAZ_TUNE,
        EPICLOGO_EPIC1,
        EPICLOGO_EPIC2,
        EVA_KISS1,
        EVA_KISS2,
        EVA_KISS3,
        EVA_KISS4,
        FAN_FAN,
        FATCHK_HIT1,
        FATCHK_HIT2,
        FATCHK_HIT3,
        FENCER_FENCE1,
        FROG_FROG,
        FROG_FROG1,
        FROG_FROG2,
        FROG_FROG3,
        FROG_FROG4,
        FROG_FROG5,
        FROG_JAZZ2FROG,
        FROG_TONG,
        GLOVE_HIT,
        HATTER_CUP,
        HATTER_HAT,
        HATTER_PTOEI,
        HATTER_SPLIN,
        HATTER_SPLOUT,
        INTRO_BLOW,
        INTRO_BOEM1,
        INTRO_BOEM2,
        INTRO_BRAKE,
        INTRO_END,
        INTRO_GRAB,
        INTRO_GREN1,
        INTRO_GREN2,
        INTRO_GREN3,
        INTRO_GUNM0,
        INTRO_GUNM1,
        INTRO_GUNM2,
        INTRO_HELI,
        INTRO_HITSPAZ,
        INTRO_HITTURT,
        INTRO_IFEEL,
        INTRO_INHALE,
        INTRO_INSECT,
        INTRO_KATROL,
        INTRO_LAND,
        INTRO_MONSTER,
        INTRO_MONSTER2,
        INTRO_ROCK,
        INTRO_ROPE1,
        INTRO_ROPE2,
        INTRO_RUN,
        INTRO_SHOT1,
        INTRO_SHOTGRN,
        INTRO_SKI,
        INTRO_STRING,
        INTRO_SWISH1,
        INTRO_SWISH2,
        INTRO_SWISH3,
        INTRO_SWISH4,
        INTRO_UHTURT,
        INTRO_UP1,
        INTRO_UP2,
        INTRO_WIND_01,
        JAZZSOUNDS_BALANCE,
        JAZZSOUNDS_HEY1,
        JAZZSOUNDS_HEY2,
        JAZZSOUNDS_HEY3,
        JAZZSOUNDS_HEY4,
        JAZZSOUNDS_IDLE,
        JAZZSOUNDS_JAZZV1,
        JAZZSOUNDS_JAZZV2,
        JAZZSOUNDS_JAZZV3,
        JAZZSOUNDS_JAZZV4,
        JAZZSOUNDS_JUMMY,
        JAZZSOUNDS_PFOE,
        LABRAT_BITE,
        LABRAT_EYE2,
        LABRAT_EYE3,
        LABRAT_MOUSE1,
        LABRAT_MOUSE2,
        LABRAT_MOUSE3,
        LIZARD_LIZ1,
        LIZARD_LIZ2,
        LIZARD_LIZ4,
        LIZARD_LIZ6,
        LORISOUNDS_DIE1,
        LORISOUNDS_HURT0,
        LORISOUNDS_HURT1,
        LORISOUNDS_HURT2,
        LORISOUNDS_HURT3,
        LORISOUNDS_HURT4,
        LORISOUNDS_HURT5,
        LORISOUNDS_HURT6,
        LORISOUNDS_HURT7,
        LORISOUNDS_LORI1,
        LORISOUNDS_LORI2,
        LORISOUNDS_LORIBOOM,
        LORISOUNDS_LORIFALL,
        LORISOUNDS_LORIJUMP,
        LORISOUNDS_LORIJUMP2,
        LORISOUNDS_LORIJUMP3,
        LORISOUNDS_LORIJUMP4,
        LORISOUNDS_TOUCH,
        LORISOUNDS_WEHOO,
        MENUSOUNDS_SELECT0,
        MENUSOUNDS_SELECT1,
        MENUSOUNDS_SELECT2,
        MENUSOUNDS_SELECT3,
        MENUSOUNDS_SELECT4,
        MENUSOUNDS_SELECT5,
        MENUSOUNDS_SELECT6,
        MENUSOUNDS_TYPE,
        MENUSOUNDS_TYPEENTER,
        MONKEY_SPLUT,
        MONKEY_THROW,
        MOTH_FLAPMOTH,
        ORANGE_BOEML,
        ORANGE_BOEMR,
        ORANGE_BUBBELSL,
        ORANGE_BUBBELSR,
        ORANGE_GLAS1L,
        ORANGE_GLAS1R,
        ORANGE_GLAS2L,
        ORANGE_GLAS2R,
        ORANGE_MERGE,
        ORANGE_SWEEP0L,
        ORANGE_SWEEP0R,
        ORANGE_SWEEP1L,
        ORANGE_SWEEP1R,
        ORANGE_SWEEP2L,
        ORANGE_SWEEP2R,
        P2_CRUNCH,
        P2_FART,
        P2_FOEW1,
        P2_FOEW4,
        P2_FOEW5,
        P2_FROG1,
        P2_FROG2,
        P2_FROG3,
        P2_FROG4,
        P2_FROG5,
        P2_KISS4,
        P2_OPEN,
        P2_PINCH1,
        P2_PINCH2,
        P2_PLOPSEQ1,
        P2_PLOPSEQ2,
        P2_PLOPSEQ3,
        P2_PLOPSEQ4,
        P2_POEP,
        P2_PTOEI,
        P2_SPLOUT,
        P2_SPLUT,
        P2_THROW,
        P2_TONG,
        PICKUPS_BOING_CHECK,
        PICKUPS_HELI2,
        PICKUPS_STRETCH1A,
        PINBALL_BELL,
        PINBALL_FLIP1,
        PINBALL_FLIP2,
        PINBALL_FLIP3,
        PINBALL_FLIP4,
        QUEEN_LADYUP,
        QUEEN_SCREAM,
        RAPIER_GOSTDIE,
        RAPIER_GOSTLOOP,
        RAPIER_GOSTOOOH,
        RAPIER_GOSTRIP,
        RAPIER_HITCHAR,
        ROBOT_BIG1,
        ROBOT_BIG2,
        ROBOT_CAN1,
        ROBOT_CAN2,
        ROBOT_HYDRO,
        ROBOT_HYDRO2,
        ROBOT_HYDROFIL,
        ROBOT_HYDROPUF,
        ROBOT_IDLE1,
        ROBOT_IDLE2,
        ROBOT_JMPCAN1,
        ROBOT_JMPCAN10,
        ROBOT_JMPCAN2,
        ROBOT_JMPCAN3,
        ROBOT_JMPCAN4,
        ROBOT_JMPCAN5,
        ROBOT_JMPCAN6,
        ROBOT_JMPCAN7,
        ROBOT_JMPCAN8,
        ROBOT_JMPCAN9,
        ROBOT_METAL1,
        ROBOT_METAL2,
        ROBOT_METAL3,
        ROBOT_METAL4,
        ROBOT_METAL5,
        ROBOT_OPEN,
        ROBOT_OUT,
        ROBOT_POEP,
        ROBOT_POLE,
        ROBOT_SHOOT,
        ROBOT_STEP1,
        ROBOT_STEP2,
        ROBOT_STEP3,
        ROCK_ROCK1,
        RUSH_RUSH,
        SCIENCE_PLOPKAOS,
        SKELETON_BONE1,
        SKELETON_BONE2,
        SKELETON_BONE3,
        SKELETON_BONE5,
        SKELETON_BONE6,
        SKELETON_BONE7,
        SMALTREE_FALL,
        SMALTREE_GROUND,
        SMALTREE_HEAD,
        SONCSHIP_METAL1,
        SONCSHIP_MISSILE2,
        SONCSHIP_SCRAPE,
        SONCSHIP_SHIPLOOP,
        SONCSHIP_TARGETLOCK,
        SPAZSOUNDS_AUTSCH1,
        SPAZSOUNDS_AUTSCH2,
        SPAZSOUNDS_BIRDSIT,
        SPAZSOUNDS_BURP,
        SPAZSOUNDS_CHIRP,
        SPAZSOUNDS_EATBIRD,
        SPAZSOUNDS_HAHAHA,
        SPAZSOUNDS_HAHAHA2,
        SPAZSOUNDS_HAPPY,
        SPAZSOUNDS_HIHI,
        SPAZSOUNDS_HOHOHO1,
        SPAZSOUNDS_HOOO,
        SPAZSOUNDS_KARATE7,
        SPAZSOUNDS_KARATE8,
        SPAZSOUNDS_OHOH,
        SPAZSOUNDS_OOOH,
        SPAZSOUNDS_WOOHOO,
        SPAZSOUNDS_YAHOO,
        SPAZSOUNDS_YAHOO2,
        SPRING_BOING_DOWN,
        SPRING_SPRING1,
        STEAM_STEAM,
        STONED_STONED,
        SUCKER_FART,
        SUCKER_PINCH1,
        SUCKER_PINCH2,
        SUCKER_PINCH3,
        SUCKER_PLOPSEQ1,
        SUCKER_PLOPSEQ2,
        SUCKER_PLOPSEQ3,
        SUCKER_PLOPSEQ4,
        SUCKER_UP,
        TUFBOSS_CATCH,
        TUFBOSS_RELEASE,
        TUFBOSS_SWING,
        TURTLE_BITE3,
        TURTLE_HIDE,
        TURTLE_HITSHELL,
        TURTLE_IDLE1,
        TURTLE_IDLE2,
        TURTLE_NECK,
        TURTLE_SPK1TURT,
        TURTLE_SPK2TURT,
        TURTLE_SPK3TURT,
        TURTLE_SPK4TURT,
        TURTLE_TURN,
        UTERUS_CRABCLOSE,
        UTERUS_CRABOPEN2,
        UTERUS_SCISSORS1,
        UTERUS_SCISSORS2,
        UTERUS_SCISSORS3,
        UTERUS_SCISSORS4,
        UTERUS_SCISSORS5,
        UTERUS_SCISSORS6,
        UTERUS_SCISSORS7,
        UTERUS_SCISSORS8,
        UTERUS_SCREAM1,
        UTERUS_STEP1,
        UTERUS_STEP2,
        WIND_WIND2A,
        WITCH_LAUGH,
        WITCH_MAGIC,
        XBILSY_BILLAPPEAR,
        XBILSY_FINGERSNAP,
        XBILSY_FIRE,
        XBILSY_FIRESTART,
        XBILSY_SCARY3,
        XBILSY_THUNDER,
        XBILSY_ZIP,
        XLIZARD_LIZ1,
        XLIZARD_LIZ2,
        XLIZARD_LIZ4,
        XLIZARD_LIZ6,
        XTURTLE_BITE3,
        XTURTLE_HIDE,
        XTURTLE_HITSHELL,
        XTURTLE_IDLE1,
        XTURTLE_IDLE2,
        XTURTLE_NECK,
        XTURTLE_SPK1TURT,
        XTURTLE_SPK2TURT,
        XTURTLE_SPK3TURT,
        XTURTLE_SPK4TURT,
        XTURTLE_TURN,
        ZDOG_AGRESSIV,
        ZDOG_SNIF1,
        ZDOG_WAF1,
        ZDOG_WAF2,
        ZDOG_WAF3,
    };
    // Aliases
    const auto AMMO_BLUB1 = Sample::AMMO_BLUB1;
    const auto AMMO_BLUB2 = Sample::AMMO_BLUB2;
    const auto AMMO_BMP1 = Sample::AMMO_BMP1;
    const auto AMMO_BMP2 = Sample::AMMO_BMP2;
    const auto AMMO_BMP3 = Sample::AMMO_BMP3;
    const auto AMMO_BMP4 = Sample::AMMO_BMP4;
    const auto AMMO_BMP5 = Sample::AMMO_BMP5;
    const auto AMMO_BMP6 = Sample::AMMO_BMP6;
    const auto AMMO_BOEM1 = Sample::AMMO_BOEM1;
    const auto AMMO_BUL1 = Sample::AMMO_BUL1;
    const auto AMMO_BULFL1 = Sample::AMMO_BULFL1;
    const auto AMMO_BULFL2 = Sample::AMMO_BULFL2;
    const auto AMMO_BULFL3 = Sample::AMMO_BULFL3;
    const auto AMMO_FIREGUN1A = Sample::AMMO_FIREGUN1A;
    const auto AMMO_FIREGUN2A = Sample::AMMO_FIREGUN2A;
    const auto AMMO_FUMP = Sample::AMMO_FUMP;
    const auto AMMO_GUN1 = Sample::AMMO_GUN1;
    const auto AMMO_GUN2 = Sample::AMMO_GUN2;
    const auto AMMO_GUN3PLOP = Sample::AMMO_GUN3PLOP;
    const auto AMMO_GUNFLP = Sample::AMMO_GUNFLP;
    const auto AMMO_GUNFLP1 = Sample::AMMO_GUNFLP1;
    const auto AMMO_GUNFLP2 = Sample::AMMO_GUNFLP2;
    const auto AMMO_GUNFLP3 = Sample::AMMO_GUNFLP3;
    const auto AMMO_GUNFLP4 = Sample::AMMO_GUNFLP4;
    const auto AMMO_GUNFLPL = Sample::AMMO_GUNFLPL;
    const auto AMMO_GUNJAZZ = Sample::AMMO_GUNJAZZ;
    const auto AMMO_GUNVELOCITY = Sample::AMMO_GUNVELOCITY;
    const auto AMMO_ICEGUN = Sample::AMMO_ICEGUN;
    const auto AMMO_ICEGUN2 = Sample::AMMO_ICEGUN2;
    const auto AMMO_ICEGUNPU = Sample::AMMO_ICEGUNPU;
    const auto AMMO_ICEPU1 = Sample::AMMO_ICEPU1;
    const auto AMMO_ICEPU2 = Sample::AMMO_ICEPU2;
    const auto AMMO_ICEPU3 = Sample::AMMO_ICEPU3;
    const auto AMMO_ICEPU4 = Sample::AMMO_ICEPU4;
    const auto AMMO_LASER = Sample::AMMO_LASER;
    const auto AMMO_LASER2 = Sample::AMMO_LASER2;
    const auto AMMO_LASER3 = Sample::AMMO_LASER3;
    const auto AMMO_LAZRAYS = Sample::AMMO_LAZRAYS;
    const auto AMMO_MISSILE = Sample::AMMO_MISSILE;
    const auto AMMO_SPZBL1 = Sample::AMMO_SPZBL1;
    const auto AMMO_SPZBL2 = Sample::AMMO_SPZBL2;
    const auto AMMO_SPZBL3 = Sample::AMMO_SPZBL3;
    const auto BAT_BATFLY1 = Sample::BAT_BATFLY1;
    const auto BILSBOSS_BILLAPPEAR = Sample::BILSBOSS_BILLAPPEAR;
    const auto BILSBOSS_FINGERSNAP = Sample::BILSBOSS_FINGERSNAP;
    const auto BILSBOSS_FIRE = Sample::BILSBOSS_FIRE;
    const auto BILSBOSS_FIRESTART = Sample::BILSBOSS_FIRESTART;
    const auto BILSBOSS_SCARY3 = Sample::BILSBOSS_SCARY3;
    const auto BILSBOSS_THUNDER = Sample::BILSBOSS_THUNDER;
    const auto BILSBOSS_ZIP = Sample::BILSBOSS_ZIP;
    const auto BONUS_BONUS1 = Sample::BONUS_BONUS1;
    const auto BONUS_BONUSBLUB = Sample::BONUS_BONUSBLUB;
    const auto BUBBA_BUBBABOUNCE1 = Sample::BUBBA_BUBBABOUNCE1;
    const auto BUBBA_BUBBABOUNCE2 = Sample::BUBBA_BUBBABOUNCE2;
    const auto BUBBA_BUBBAEXPLO = Sample::BUBBA_BUBBAEXPLO;
    const auto BUBBA_FROG2 = Sample::BUBBA_FROG2;
    const auto BUBBA_FROG3 = Sample::BUBBA_FROG3;
    const auto BUBBA_FROG4 = Sample::BUBBA_FROG4;
    const auto BUBBA_FROG5 = Sample::BUBBA_FROG5;
    const auto BUBBA_SNEEZE2 = Sample::BUBBA_SNEEZE2;
    const auto BUBBA_TORNADOATTACK2 = Sample::BUBBA_TORNADOATTACK2;
    const auto BUMBEE_BEELOOP = Sample::BUMBEE_BEELOOP;
    const auto CATERPIL_RIDOE = Sample::CATERPIL_RIDOE;
    const auto COMMON_AIRBOARD = Sample::COMMON_AIRBOARD;
    const auto COMMON_AIRBTURN = Sample::COMMON_AIRBTURN;
    const auto COMMON_AIRBTURN2 = Sample::COMMON_AIRBTURN2;
    const auto COMMON_BASE1 = Sample::COMMON_BASE1;
    const auto COMMON_BELL_FIRE = Sample::COMMON_BELL_FIRE;
    const auto COMMON_BELL_FIRE2 = Sample::COMMON_BELL_FIRE2;
    const auto COMMON_BENZIN1 = Sample::COMMON_BENZIN1;
    const auto COMMON_BIRDFLY = Sample::COMMON_BIRDFLY;
    const auto COMMON_BIRDFLY2 = Sample::COMMON_BIRDFLY2;
    const auto COMMON_BLOKPLOP = Sample::COMMON_BLOKPLOP;
    const auto COMMON_BLUB1 = Sample::COMMON_BLUB1;
    const auto COMMON_BUBBLGN1 = Sample::COMMON_BUBBLGN1;
    const auto COMMON_BURN = Sample::COMMON_BURN;
    const auto COMMON_BURNIN = Sample::COMMON_BURNIN;
    const auto COMMON_CANSPS = Sample::COMMON_CANSPS;
    const auto COMMON_CLOCK = Sample::COMMON_CLOCK;
    const auto COMMON_COIN = Sample::COMMON_COIN;
    const auto COMMON_COLLAPS = Sample::COMMON_COLLAPS;
    const auto COMMON_CUP = Sample::COMMON_CUP;
    const auto COMMON_DAMPED1 = Sample::COMMON_DAMPED1;
    const auto COMMON_DOWN = Sample::COMMON_DOWN;
    const auto COMMON_DOWNFL2 = Sample::COMMON_DOWNFL2;
    const auto COMMON_DRINKSPAZZ1 = Sample::COMMON_DRINKSPAZZ1;
    const auto COMMON_DRINKSPAZZ2 = Sample::COMMON_DRINKSPAZZ2;
    const auto COMMON_DRINKSPAZZ3 = Sample::COMMON_DRINKSPAZZ3;
    const auto COMMON_DRINKSPAZZ4 = Sample::COMMON_DRINKSPAZZ4;
    const auto COMMON_EAT1 = Sample::COMMON_EAT1;
    const auto COMMON_EAT2 = Sample::COMMON_EAT2;
    const auto COMMON_EAT3 = Sample::COMMON_EAT3;
    const auto COMMON_EAT4 = Sample::COMMON_EAT4;
    const auto COMMON_ELECTRIC1 = Sample::COMMON_ELECTRIC1;
    const auto COMMON_ELECTRIC2 = Sample::COMMON_ELECTRIC2;
    const auto COMMON_ELECTRICHIT = Sample::COMMON_ELECTRICHIT;
    const auto COMMON_EXPL_TNT = Sample::COMMON_EXPL_TNT;
    const auto COMMON_EXPSM1 = Sample::COMMON_EXPSM1;
    const auto COMMON_FLAMER = Sample::COMMON_FLAMER;
    const auto COMMON_FLAP = Sample::COMMON_FLAP;
    const auto COMMON_FOEW1 = Sample::COMMON_FOEW1;
    const auto COMMON_FOEW2 = Sample::COMMON_FOEW2;
    const auto COMMON_FOEW3 = Sample::COMMON_FOEW3;
    const auto COMMON_FOEW4 = Sample::COMMON_FOEW4;
    const auto COMMON_FOEW5 = Sample::COMMON_FOEW5;
    const auto COMMON_GEMSMSH1 = Sample::COMMON_GEMSMSH1;
    const auto COMMON_GLASS2 = Sample::COMMON_GLASS2;
    const auto COMMON_GUNSM1 = Sample::COMMON_GUNSM1;
    const auto COMMON_HARP1 = Sample::COMMON_HARP1;
    const auto COMMON_HEAD = Sample::COMMON_HEAD;
    const auto COMMON_HELI1 = Sample::COMMON_HELI1;
    const auto COMMON_HIBELL = Sample::COMMON_HIBELL;
    const auto COMMON_HOLYFLUT = Sample::COMMON_HOLYFLUT;
    const auto COMMON_HORN1 = Sample::COMMON_HORN1;
    const auto COMMON_ICECRUSH = Sample::COMMON_ICECRUSH;
    const auto COMMON_IMPACT1 = Sample::COMMON_IMPACT1;
    const auto COMMON_IMPACT2 = Sample::COMMON_IMPACT2;
    const auto COMMON_IMPACT3 = Sample::COMMON_IMPACT3;
    const auto COMMON_IMPACT4 = Sample::COMMON_IMPACT4;
    const auto COMMON_IMPACT5 = Sample::COMMON_IMPACT5;
    const auto COMMON_IMPACT6 = Sample::COMMON_IMPACT6;
    const auto COMMON_IMPACT7 = Sample::COMMON_IMPACT7;
    const auto COMMON_IMPACT8 = Sample::COMMON_IMPACT8;
    const auto COMMON_IMPACT9 = Sample::COMMON_IMPACT9;
    const auto COMMON_ITEMTRE = Sample::COMMON_ITEMTRE;
    const auto COMMON_JUMP = Sample::COMMON_JUMP;
    const auto COMMON_JUMP2 = Sample::COMMON_JUMP2;
    const auto COMMON_LAND = Sample::COMMON_LAND;
    const auto COMMON_LAND1 = Sample::COMMON_LAND1;
    const auto COMMON_LAND2 = Sample::COMMON_LAND2;
    const auto COMMON_LANDCAN1 = Sample::COMMON_LANDCAN1;
    const auto COMMON_LANDCAN2 = Sample::COMMON_LANDCAN2;
    const auto COMMON_LANDPOP = Sample::COMMON_LANDPOP;
    const auto COMMON_LOADJAZZ = Sample::COMMON_LOADJAZZ;
    const auto COMMON_LOADSPAZ = Sample::COMMON_LOADSPAZ;
    const auto COMMON_METALHIT = Sample::COMMON_METALHIT;
    const auto COMMON_MONITOR = Sample::COMMON_MONITOR;
    const auto COMMON_NOCOIN = Sample::COMMON_NOCOIN;
    const auto COMMON_PICKUP1 = Sample::COMMON_PICKUP1;
    const auto COMMON_PICKUPW1 = Sample::COMMON_PICKUPW1;
    const auto COMMON_PISTOL1 = Sample::COMMON_PISTOL1;
    const auto COMMON_PLOOP1 = Sample::COMMON_PLOOP1;
    const auto COMMON_PLOP1 = Sample::COMMON_PLOP1;
    const auto COMMON_PLOP2 = Sample::COMMON_PLOP2;
    const auto COMMON_PLOP3 = Sample::COMMON_PLOP3;
    const auto COMMON_PLOP4 = Sample::COMMON_PLOP4;
    const auto COMMON_PLOPKORK = Sample::COMMON_PLOPKORK;
    const auto COMMON_PREEXPL1 = Sample::COMMON_PREEXPL1;
    const auto COMMON_PREHELI = Sample::COMMON_PREHELI;
    const auto COMMON_REVUP = Sample::COMMON_REVUP;
    const auto COMMON_RINGGUN = Sample::COMMON_RINGGUN;
    const auto COMMON_RINGGUN2 = Sample::COMMON_RINGGUN2;
    const auto COMMON_SHIELD1 = Sample::COMMON_SHIELD1;
    const auto COMMON_SHIELD4 = Sample::COMMON_SHIELD4;
    const auto COMMON_SHIELD_ELEC = Sample::COMMON_SHIELD_ELEC;
    const auto COMMON_SHLDOF3 = Sample::COMMON_SHLDOF3;
    const auto COMMON_SLIP = Sample::COMMON_SLIP;
    const auto COMMON_SMASH = Sample::COMMON_SMASH;
    const auto COMMON_SPLAT1 = Sample::COMMON_SPLAT1;
    const auto COMMON_SPLAT2 = Sample::COMMON_SPLAT2;
    const auto COMMON_SPLAT3 = Sample::COMMON_SPLAT3;
    const auto COMMON_SPLAT4 = Sample::COMMON_SPLAT4;
    const auto COMMON_SPLUT = Sample::COMMON_SPLUT;
    const auto COMMON_SPRING1 = Sample::COMMON_SPRING1;
    const auto COMMON_STEAM = Sample::COMMON_STEAM;
    const auto COMMON_STEP = Sample::COMMON_STEP;
    const auto COMMON_STRETCH = Sample::COMMON_STRETCH;
    const auto COMMON_SWISH1 = Sample::COMMON_SWISH1;
    const auto COMMON_SWISH2 = Sample::COMMON_SWISH2;
    const auto COMMON_SWISH3 = Sample::COMMON_SWISH3;
    const auto COMMON_SWISH4 = Sample::COMMON_SWISH4;
    const auto COMMON_SWISH5 = Sample::COMMON_SWISH5;
    const auto COMMON_SWISH6 = Sample::COMMON_SWISH6;
    const auto COMMON_SWISH7 = Sample::COMMON_SWISH7;
    const auto COMMON_SWISH8 = Sample::COMMON_SWISH8;
    const auto COMMON_TELPORT1 = Sample::COMMON_TELPORT1;
    const auto COMMON_TELPORT2 = Sample::COMMON_TELPORT2;
    const auto COMMON_UP = Sample::COMMON_UP;
    const auto COMMON_WATER = Sample::COMMON_WATER;
    const auto COMMON_WOOD1 = Sample::COMMON_WOOD1;
    const auto DEMON_RUN = Sample::DEMON_RUN;
    const auto DEVILDEVAN_DRAGONFIRE = Sample::DEVILDEVAN_DRAGONFIRE;
    const auto DEVILDEVAN_FLAP = Sample::DEVILDEVAN_FLAP;
    const auto DEVILDEVAN_FROG4 = Sample::DEVILDEVAN_FROG4;
    const auto DEVILDEVAN_JUMPUP = Sample::DEVILDEVAN_JUMPUP;
    const auto DEVILDEVAN_LAUGH = Sample::DEVILDEVAN_LAUGH;
    const auto DEVILDEVAN_PHASER2 = Sample::DEVILDEVAN_PHASER2;
    const auto DEVILDEVAN_STRECh3 = Sample::DEVILDEVAN_STRECh3;
    const auto DEVILDEVAN_STRECHTAIL = Sample::DEVILDEVAN_STRECHTAIL;
    const auto DEVILDEVAN_STRETCH1 = Sample::DEVILDEVAN_STRETCH1;
    const auto DEVILDEVAN_STRETCH3 = Sample::DEVILDEVAN_STRETCH3;
    const auto DEVILDEVAN_VANISH1 = Sample::DEVILDEVAN_VANISH1;
    const auto DEVILDEVAN_WHISTLEDESCENDING2 = Sample::DEVILDEVAN_WHISTLEDESCENDING2;
    const auto DEVILDEVAN_WINGSOUT = Sample::DEVILDEVAN_WINGSOUT;
    const auto DOG_AGRESSIV = Sample::DOG_AGRESSIV;
    const auto DOG_SNIF1 = Sample::DOG_SNIF1;
    const auto DOG_WAF1 = Sample::DOG_WAF1;
    const auto DOG_WAF2 = Sample::DOG_WAF2;
    const auto DOG_WAF3 = Sample::DOG_WAF3;
    const auto DRAGFLY_BEELOOP = Sample::DRAGFLY_BEELOOP;
    const auto ENDING_OHTHANK = Sample::ENDING_OHTHANK;
    const auto ENDTUNEJAZZ_TUNE = Sample::ENDTUNEJAZZ_TUNE;
    const auto ENDTUNELORI_CAKE = Sample::ENDTUNELORI_CAKE;
    const auto ENDTUNESPAZ_TUNE = Sample::ENDTUNESPAZ_TUNE;
    const auto EPICLOGO_EPIC1 = Sample::EPICLOGO_EPIC1;
    const auto EPICLOGO_EPIC2 = Sample::EPICLOGO_EPIC2;
    const auto EVA_KISS1 = Sample::EVA_KISS1;
    const auto EVA_KISS2 = Sample::EVA_KISS2;
    const auto EVA_KISS3 = Sample::EVA_KISS3;
    const auto EVA_KISS4 = Sample::EVA_KISS4;
    const auto FAN_FAN = Sample::FAN_FAN;
    const auto FATCHK_HIT1 = Sample::FATCHK_HIT1;
    const auto FATCHK_HIT2 = Sample::FATCHK_HIT2;
    const auto FATCHK_HIT3 = Sample::FATCHK_HIT3;
    const auto FENCER_FENCE1 = Sample::FENCER_FENCE1;
    const auto FROG_FROG = Sample::FROG_FROG;
    const auto FROG_FROG1 = Sample::FROG_FROG1;
    const auto FROG_FROG2 = Sample::FROG_FROG2;
    const auto FROG_FROG3 = Sample::FROG_FROG3;
    const auto FROG_FROG4 = Sample::FROG_FROG4;
    const auto FROG_FROG5 = Sample::FROG_FROG5;
    const auto FROG_JAZZ2FROG = Sample::FROG_JAZZ2FROG;
    const auto FROG_TONG = Sample::FROG_TONG;
    const auto GLOVE_HIT = Sample::GLOVE_HIT;
    const auto HATTER_CUP = Sample::HATTER_CUP;
    const auto HATTER_HAT = Sample::HATTER_HAT;
    const auto HATTER_PTOEI = Sample::HATTER_PTOEI;
    const auto HATTER_SPLIN = Sample::HATTER_SPLIN;
    const auto HATTER_SPLOUT = Sample::HATTER_SPLOUT;
    const auto INTRO_BLOW = Sample::INTRO_BLOW;
    const auto INTRO_BOEM1 = Sample::INTRO_BOEM1;
    const auto INTRO_BOEM2 = Sample::INTRO_BOEM2;
    const auto INTRO_BRAKE = Sample::INTRO_BRAKE;
    const auto INTRO_END = Sample::INTRO_END;
    const auto INTRO_GRAB = Sample::INTRO_GRAB;
    const auto INTRO_GREN1 = Sample::INTRO_GREN1;
    const auto INTRO_GREN2 = Sample::INTRO_GREN2;
    const auto INTRO_GREN3 = Sample::INTRO_GREN3;
    const auto INTRO_GUNM0 = Sample::INTRO_GUNM0;
    const auto INTRO_GUNM1 = Sample::INTRO_GUNM1;
    const auto INTRO_GUNM2 = Sample::INTRO_GUNM2;
    const auto INTRO_HELI = Sample::INTRO_HELI;
    const auto INTRO_HITSPAZ = Sample::INTRO_HITSPAZ;
    const auto INTRO_HITTURT = Sample::INTRO_HITTURT;
    const auto INTRO_IFEEL = Sample::INTRO_IFEEL;
    const auto INTRO_INHALE = Sample::INTRO_INHALE;
    const auto INTRO_INSECT = Sample::INTRO_INSECT;
    const auto INTRO_KATROL = Sample::INTRO_KATROL;
    const auto INTRO_LAND = Sample::INTRO_LAND;
    const auto INTRO_MONSTER = Sample::INTRO_MONSTER;
    const auto INTRO_MONSTER2 = Sample::INTRO_MONSTER2;
    const auto INTRO_ROCK = Sample::INTRO_ROCK;
    const auto INTRO_ROPE1 = Sample::INTRO_ROPE1;
    const auto INTRO_ROPE2 = Sample::INTRO_ROPE2;
    const auto INTRO_RUN = Sample::INTRO_RUN;
    const auto INTRO_SHOT1 = Sample::INTRO_SHOT1;
    const auto INTRO_SHOTGRN = Sample::INTRO_SHOTGRN;
    const auto INTRO_SKI = Sample::INTRO_SKI;
    const auto INTRO_STRING = Sample::INTRO_STRING;
    const auto INTRO_SWISH1 = Sample::INTRO_SWISH1;
    const auto INTRO_SWISH2 = Sample::INTRO_SWISH2;
    const auto INTRO_SWISH3 = Sample::INTRO_SWISH3;
    const auto INTRO_SWISH4 = Sample::INTRO_SWISH4;
    const auto INTRO_UHTURT = Sample::INTRO_UHTURT;
    const auto INTRO_UP1 = Sample::INTRO_UP1;
    const auto INTRO_UP2 = Sample::INTRO_UP2;
    const auto INTRO_WIND_01 = Sample::INTRO_WIND_01;
    const auto JAZZSOUNDS_BALANCE = Sample::JAZZSOUNDS_BALANCE;
    const auto JAZZSOUNDS_HEY1 = Sample::JAZZSOUNDS_HEY1;
    const auto JAZZSOUNDS_HEY2 = Sample::JAZZSOUNDS_HEY2;
    const auto JAZZSOUNDS_HEY3 = Sample::JAZZSOUNDS_HEY3;
    const auto JAZZSOUNDS_HEY4 = Sample::JAZZSOUNDS_HEY4;
    const auto JAZZSOUNDS_IDLE = Sample::JAZZSOUNDS_IDLE;
    const auto JAZZSOUNDS_JAZZV1 = Sample::JAZZSOUNDS_JAZZV1;
    const auto JAZZSOUNDS_JAZZV2 = Sample::JAZZSOUNDS_JAZZV2;
    const auto JAZZSOUNDS_JAZZV3 = Sample::JAZZSOUNDS_JAZZV3;
    const auto JAZZSOUNDS_JAZZV4 = Sample::JAZZSOUNDS_JAZZV4;
    const auto JAZZSOUNDS_JUMMY = Sample::JAZZSOUNDS_JUMMY;
    const auto JAZZSOUNDS_PFOE = Sample::JAZZSOUNDS_PFOE;
    const auto LABRAT_BITE = Sample::LABRAT_BITE;
    const auto LABRAT_EYE2 = Sample::LABRAT_EYE2;
    const auto LABRAT_EYE3 = Sample::LABRAT_EYE3;
    const auto LABRAT_MOUSE1 = Sample::LABRAT_MOUSE1;
    const auto LABRAT_MOUSE2 = Sample::LABRAT_MOUSE2;
    const auto LABRAT_MOUSE3 = Sample::LABRAT_MOUSE3;
    const auto LIZARD_LIZ1 = Sample::LIZARD_LIZ1;
    const auto LIZARD_LIZ2 = Sample::LIZARD_LIZ2;
    const auto LIZARD_LIZ4 = Sample::LIZARD_LIZ4;
    const auto LIZARD_LIZ6 = Sample::LIZARD_LIZ6;
    const auto LORISOUNDS_DIE1 = Sample::LORISOUNDS_DIE1;
    const auto LORISOUNDS_HURT0 = Sample::LORISOUNDS_HURT0;
    const auto LORISOUNDS_HURT1 = Sample::LORISOUNDS_HURT1;
    const auto LORISOUNDS_HURT2 = Sample::LORISOUNDS_HURT2;
    const auto LORISOUNDS_HURT3 = Sample::LORISOUNDS_HURT3;
    const auto LORISOUNDS_HURT4 = Sample::LORISOUNDS_HURT4;
    const auto LORISOUNDS_HURT5 = Sample::LORISOUNDS_HURT5;
    const auto LORISOUNDS_HURT6 = Sample::LORISOUNDS_HURT6;
    const auto LORISOUNDS_HURT7 = Sample::LORISOUNDS_HURT7;
    const auto LORISOUNDS_LORI1 = Sample::LORISOUNDS_LORI1;
    const auto LORISOUNDS_LORI2 = Sample::LORISOUNDS_LORI2;
    const auto LORISOUNDS_LORIBOOM = Sample::LORISOUNDS_LORIBOOM;
    const auto LORISOUNDS_LORIFALL = Sample::LORISOUNDS_LORIFALL;
    const auto LORISOUNDS_LORIJUMP = Sample::LORISOUNDS_LORIJUMP;
    const auto LORISOUNDS_LORIJUMP2 = Sample::LORISOUNDS_LORIJUMP2;
    const auto LORISOUNDS_LORIJUMP3 = Sample::LORISOUNDS_LORIJUMP3;
    const auto LORISOUNDS_LORIJUMP4 = Sample::LORISOUNDS_LORIJUMP4;
    const auto LORISOUNDS_TOUCH = Sample::LORISOUNDS_TOUCH;
    const auto LORISOUNDS_WEHOO = Sample::LORISOUNDS_WEHOO;
    const auto MENUSOUNDS_SELECT0 = Sample::MENUSOUNDS_SELECT0;
    const auto MENUSOUNDS_SELECT1 = Sample::MENUSOUNDS_SELECT1;
    const auto MENUSOUNDS_SELECT2 = Sample::MENUSOUNDS_SELECT2;
    const auto MENUSOUNDS_SELECT3 = Sample::MENUSOUNDS_SELECT3;
    const auto MENUSOUNDS_SELECT4 = Sample::MENUSOUNDS_SELECT4;
    const auto MENUSOUNDS_SELECT5 = Sample::MENUSOUNDS_SELECT5;
    const auto MENUSOUNDS_SELECT6 = Sample::MENUSOUNDS_SELECT6;
    const auto MENUSOUNDS_TYPE = Sample::MENUSOUNDS_TYPE;
    const auto MENUSOUNDS_TYPEENTER = Sample::MENUSOUNDS_TYPEENTER;
    const auto MONKEY_SPLUT = Sample::MONKEY_SPLUT;
    const auto MONKEY_THROW = Sample::MONKEY_THROW;
    const auto MOTH_FLAPMOTH = Sample::MOTH_FLAPMOTH;
    const auto ORANGE_BOEML = Sample::ORANGE_BOEML;
    const auto ORANGE_BOEMR = Sample::ORANGE_BOEMR;
    const auto ORANGE_BUBBELSL = Sample::ORANGE_BUBBELSL;
    const auto ORANGE_BUBBELSR = Sample::ORANGE_BUBBELSR;
    const auto ORANGE_GLAS1L = Sample::ORANGE_GLAS1L;
    const auto ORANGE_GLAS1R = Sample::ORANGE_GLAS1R;
    const auto ORANGE_GLAS2L = Sample::ORANGE_GLAS2L;
    const auto ORANGE_GLAS2R = Sample::ORANGE_GLAS2R;
    const auto ORANGE_MERGE = Sample::ORANGE_MERGE;
    const auto ORANGE_SWEEP0L = Sample::ORANGE_SWEEP0L;
    const auto ORANGE_SWEEP0R = Sample::ORANGE_SWEEP0R;
    const auto ORANGE_SWEEP1L = Sample::ORANGE_SWEEP1L;
    const auto ORANGE_SWEEP1R = Sample::ORANGE_SWEEP1R;
    const auto ORANGE_SWEEP2L = Sample::ORANGE_SWEEP2L;
    const auto ORANGE_SWEEP2R = Sample::ORANGE_SWEEP2R;
    const auto P2_CRUNCH = Sample::P2_CRUNCH;
    const auto P2_FART = Sample::P2_FART;
    const auto P2_FOEW1 = Sample::P2_FOEW1;
    const auto P2_FOEW4 = Sample::P2_FOEW4;
    const auto P2_FOEW5 = Sample::P2_FOEW5;
    const auto P2_FROG1 = Sample::P2_FROG1;
    const auto P2_FROG2 = Sample::P2_FROG2;
    const auto P2_FROG3 = Sample::P2_FROG3;
    const auto P2_FROG4 = Sample::P2_FROG4;
    const auto P2_FROG5 = Sample::P2_FROG5;
    const auto P2_KISS4 = Sample::P2_KISS4;
    const auto P2_OPEN = Sample::P2_OPEN;
    const auto P2_PINCH1 = Sample::P2_PINCH1;
    const auto P2_PINCH2 = Sample::P2_PINCH2;
    const auto P2_PLOPSEQ1 = Sample::P2_PLOPSEQ1;
    const auto P2_PLOPSEQ2 = Sample::P2_PLOPSEQ2;
    const auto P2_PLOPSEQ3 = Sample::P2_PLOPSEQ3;
    const auto P2_PLOPSEQ4 = Sample::P2_PLOPSEQ4;
    const auto P2_POEP = Sample::P2_POEP;
    const auto P2_PTOEI = Sample::P2_PTOEI;
    const auto P2_SPLOUT = Sample::P2_SPLOUT;
    const auto P2_SPLUT = Sample::P2_SPLUT;
    const auto P2_THROW = Sample::P2_THROW;
    const auto P2_TONG = Sample::P2_TONG;
    const auto PICKUPS_BOING_CHECK = Sample::PICKUPS_BOING_CHECK;
    const auto PICKUPS_HELI2 = Sample::PICKUPS_HELI2;
    const auto PICKUPS_STRETCH1A = Sample::PICKUPS_STRETCH1A;
    const auto PINBALL_BELL = Sample::PINBALL_BELL;
    const auto PINBALL_FLIP1 = Sample::PINBALL_FLIP1;
    const auto PINBALL_FLIP2 = Sample::PINBALL_FLIP2;
    const auto PINBALL_FLIP3 = Sample::PINBALL_FLIP3;
    const auto PINBALL_FLIP4 = Sample::PINBALL_FLIP4;
    const auto QUEEN_LADYUP = Sample::QUEEN_LADYUP;
    const auto QUEEN_SCREAM = Sample::QUEEN_SCREAM;
    const auto RAPIER_GOSTDIE = Sample::RAPIER_GOSTDIE;
    const auto RAPIER_GOSTLOOP = Sample::RAPIER_GOSTLOOP;
    const auto RAPIER_GOSTOOOH = Sample::RAPIER_GOSTOOOH;
    const auto RAPIER_GOSTRIP = Sample::RAPIER_GOSTRIP;
    const auto RAPIER_HITCHAR = Sample::RAPIER_HITCHAR;
    const auto ROBOT_BIG1 = Sample::ROBOT_BIG1;
    const auto ROBOT_BIG2 = Sample::ROBOT_BIG2;
    const auto ROBOT_CAN1 = Sample::ROBOT_CAN1;
    const auto ROBOT_CAN2 = Sample::ROBOT_CAN2;
    const auto ROBOT_HYDRO = Sample::ROBOT_HYDRO;
    const auto ROBOT_HYDRO2 = Sample::ROBOT_HYDRO2;
    const auto ROBOT_HYDROFIL = Sample::ROBOT_HYDROFIL;
    const auto ROBOT_HYDROPUF = Sample::ROBOT_HYDROPUF;
    const auto ROBOT_IDLE1 = Sample::ROBOT_IDLE1;
    const auto ROBOT_IDLE2 = Sample::ROBOT_IDLE2;
    const auto ROBOT_JMPCAN1 = Sample::ROBOT_JMPCAN1;
    const auto ROBOT_JMPCAN10 = Sample::ROBOT_JMPCAN10;
    const auto ROBOT_JMPCAN2 = Sample::ROBOT_JMPCAN2;
    const auto ROBOT_JMPCAN3 = Sample::ROBOT_JMPCAN3;
    const auto ROBOT_JMPCAN4 = Sample::ROBOT_JMPCAN4;
    const auto ROBOT_JMPCAN5 = Sample::ROBOT_JMPCAN5;
    const auto ROBOT_JMPCAN6 = Sample::ROBOT_JMPCAN6;
    const auto ROBOT_JMPCAN7 = Sample::ROBOT_JMPCAN7;
    const auto ROBOT_JMPCAN8 = Sample::ROBOT_JMPCAN8;
    const auto ROBOT_JMPCAN9 = Sample::ROBOT_JMPCAN9;
    const auto ROBOT_METAL1 = Sample::ROBOT_METAL1;
    const auto ROBOT_METAL2 = Sample::ROBOT_METAL2;
    const auto ROBOT_METAL3 = Sample::ROBOT_METAL3;
    const auto ROBOT_METAL4 = Sample::ROBOT_METAL4;
    const auto ROBOT_METAL5 = Sample::ROBOT_METAL5;
    const auto ROBOT_OPEN = Sample::ROBOT_OPEN;
    const auto ROBOT_OUT = Sample::ROBOT_OUT;
    const auto ROBOT_POEP = Sample::ROBOT_POEP;
    const auto ROBOT_POLE = Sample::ROBOT_POLE;
    const auto ROBOT_SHOOT = Sample::ROBOT_SHOOT;
    const auto ROBOT_STEP1 = Sample::ROBOT_STEP1;
    const auto ROBOT_STEP2 = Sample::ROBOT_STEP2;
    const auto ROBOT_STEP3 = Sample::ROBOT_STEP3;
    const auto ROCK_ROCK1 = Sample::ROCK_ROCK1;
    const auto RUSH_RUSH = Sample::RUSH_RUSH;
    const auto SCIENCE_PLOPKAOS = Sample::SCIENCE_PLOPKAOS;
    const auto SKELETON_BONE1 = Sample::SKELETON_BONE1;
    const auto SKELETON_BONE2 = Sample::SKELETON_BONE2;
    const auto SKELETON_BONE3 = Sample::SKELETON_BONE3;
    const auto SKELETON_BONE5 = Sample::SKELETON_BONE5;
    const auto SKELETON_BONE6 = Sample::SKELETON_BONE6;
    const auto SKELETON_BONE7 = Sample::SKELETON_BONE7;
    const auto SMALTREE_FALL = Sample::SMALTREE_FALL;
    const auto SMALTREE_GROUND = Sample::SMALTREE_GROUND;
    const auto SMALTREE_HEAD = Sample::SMALTREE_HEAD;
    const auto SONCSHIP_METAL1 = Sample::SONCSHIP_METAL1;
    const auto SONCSHIP_MISSILE2 = Sample::SONCSHIP_MISSILE2;
    const auto SONCSHIP_SCRAPE = Sample::SONCSHIP_SCRAPE;
    const auto SONCSHIP_SHIPLOOP = Sample::SONCSHIP_SHIPLOOP;
    const auto SONCSHIP_TARGETLOCK = Sample::SONCSHIP_TARGETLOCK;
    const auto SPAZSOUNDS_AUTSCH1 = Sample::SPAZSOUNDS_AUTSCH1;
    const auto SPAZSOUNDS_AUTSCH2 = Sample::SPAZSOUNDS_AUTSCH2;
    const auto SPAZSOUNDS_BIRDSIT = Sample::SPAZSOUNDS_BIRDSIT;
    const auto SPAZSOUNDS_BURP = Sample::SPAZSOUNDS_BURP;
    const auto SPAZSOUNDS_CHIRP = Sample::SPAZSOUNDS_CHIRP;
    const auto SPAZSOUNDS_EATBIRD = Sample::SPAZSOUNDS_EATBIRD;
    const auto SPAZSOUNDS_HAHAHA = Sample::SPAZSOUNDS_HAHAHA;
    const auto SPAZSOUNDS_HAHAHA2 = Sample::SPAZSOUNDS_HAHAHA2;
    const auto SPAZSOUNDS_HAPPY = Sample::SPAZSOUNDS_HAPPY;
    const auto SPAZSOUNDS_HIHI = Sample::SPAZSOUNDS_HIHI;
    const auto SPAZSOUNDS_HOHOHO1 = Sample::SPAZSOUNDS_HOHOHO1;
    const auto SPAZSOUNDS_HOOO = Sample::SPAZSOUNDS_HOOO;
    const auto SPAZSOUNDS_KARATE7 = Sample::SPAZSOUNDS_KARATE7;
    const auto SPAZSOUNDS_KARATE8 = Sample::SPAZSOUNDS_KARATE8;
    const auto SPAZSOUNDS_OHOH = Sample::SPAZSOUNDS_OHOH;
    const auto SPAZSOUNDS_OOOH = Sample::SPAZSOUNDS_OOOH;
    const auto SPAZSOUNDS_WOOHOO = Sample::SPAZSOUNDS_WOOHOO;
    const auto SPAZSOUNDS_YAHOO = Sample::SPAZSOUNDS_YAHOO;
    const auto SPAZSOUNDS_YAHOO2 = Sample::SPAZSOUNDS_YAHOO2;
    const auto SPRING_BOING_DOWN = Sample::SPRING_BOING_DOWN;
    const auto SPRING_SPRING1 = Sample::SPRING_SPRING1;
    const auto STEAM_STEAM = Sample::STEAM_STEAM;
    const auto STONED_STONED = Sample::STONED_STONED;
    const auto SUCKER_FART = Sample::SUCKER_FART;
    const auto SUCKER_PINCH1 = Sample::SUCKER_PINCH1;
    const auto SUCKER_PINCH2 = Sample::SUCKER_PINCH2;
    const auto SUCKER_PINCH3 = Sample::SUCKER_PINCH3;
    const auto SUCKER_PLOPSEQ1 = Sample::SUCKER_PLOPSEQ1;
    const auto SUCKER_PLOPSEQ2 = Sample::SUCKER_PLOPSEQ2;
    const auto SUCKER_PLOPSEQ3 = Sample::SUCKER_PLOPSEQ3;
    const auto SUCKER_PLOPSEQ4 = Sample::SUCKER_PLOPSEQ4;
    const auto SUCKER_UP = Sample::SUCKER_UP;
    const auto TUFBOSS_CATCH = Sample::TUFBOSS_CATCH;
    const auto TUFBOSS_RELEASE = Sample::TUFBOSS_RELEASE;
    const auto TUFBOSS_SWING = Sample::TUFBOSS_SWING;
    const auto TURTLE_BITE3 = Sample::TURTLE_BITE3;
    const auto TURTLE_HIDE = Sample::TURTLE_HIDE;
    const auto TURTLE_HITSHELL = Sample::TURTLE_HITSHELL;
    const auto TURTLE_IDLE1 = Sample::TURTLE_IDLE1;
    const auto TURTLE_IDLE2 = Sample::TURTLE_IDLE2;
    const auto TURTLE_NECK = Sample::TURTLE_NECK;
    const auto TURTLE_SPK1TURT = Sample::TURTLE_SPK1TURT;
    const auto TURTLE_SPK2TURT = Sample::TURTLE_SPK2TURT;
    const auto TURTLE_SPK3TURT = Sample::TURTLE_SPK3TURT;
    const auto TURTLE_SPK4TURT = Sample::TURTLE_SPK4TURT;
    const auto TURTLE_TURN = Sample::TURTLE_TURN;
    const auto UTERUS_CRABCLOSE = Sample::UTERUS_CRABCLOSE;
    const auto UTERUS_CRABOPEN2 = Sample::UTERUS_CRABOPEN2;
    const auto UTERUS_SCISSORS1 = Sample::UTERUS_SCISSORS1;
    const auto UTERUS_SCISSORS2 = Sample::UTERUS_SCISSORS2;
    const auto UTERUS_SCISSORS3 = Sample::UTERUS_SCISSORS3;
    const auto UTERUS_SCISSORS4 = Sample::UTERUS_SCISSORS4;
    const auto UTERUS_SCISSORS5 = Sample::UTERUS_SCISSORS5;
    const auto UTERUS_SCISSORS6 = Sample::UTERUS_SCISSORS6;
    const auto UTERUS_SCISSORS7 = Sample::UTERUS_SCISSORS7;
    const auto UTERUS_SCISSORS8 = Sample::UTERUS_SCISSORS8;
    const auto UTERUS_SCREAM1 = Sample::UTERUS_SCREAM1;
    const auto UTERUS_STEP1 = Sample::UTERUS_STEP1;
    const auto UTERUS_STEP2 = Sample::UTERUS_STEP2;
    const auto WIND_WIND2A = Sample::WIND_WIND2A;
    const auto WITCH_LAUGH = Sample::WITCH_LAUGH;
    const auto WITCH_MAGIC = Sample::WITCH_MAGIC;
    const auto XBILSY_BILLAPPEAR = Sample::XBILSY_BILLAPPEAR;
    const auto XBILSY_FINGERSNAP = Sample::XBILSY_FINGERSNAP;
    const auto XBILSY_FIRE = Sample::XBILSY_FIRE;
    const auto XBILSY_FIRESTART = Sample::XBILSY_FIRESTART;
    const auto XBILSY_SCARY3 = Sample::XBILSY_SCARY3;
    const auto XBILSY_THUNDER = Sample::XBILSY_THUNDER;
    const auto XBILSY_ZIP = Sample::XBILSY_ZIP;
    const auto XLIZARD_LIZ1 = Sample::XLIZARD_LIZ1;
    const auto XLIZARD_LIZ2 = Sample::XLIZARD_LIZ2;
    const auto XLIZARD_LIZ4 = Sample::XLIZARD_LIZ4;
    const auto XLIZARD_LIZ6 = Sample::XLIZARD_LIZ6;
    const auto XTURTLE_BITE3 = Sample::XTURTLE_BITE3;
    const auto XTURTLE_HIDE = Sample::XTURTLE_HIDE;
    const auto XTURTLE_HITSHELL = Sample::XTURTLE_HITSHELL;
    const auto XTURTLE_IDLE1 = Sample::XTURTLE_IDLE1;
    const auto XTURTLE_IDLE2 = Sample::XTURTLE_IDLE2;
    const auto XTURTLE_NECK = Sample::XTURTLE_NECK;
    const auto XTURTLE_SPK1TURT = Sample::XTURTLE_SPK1TURT;
    const auto XTURTLE_SPK2TURT = Sample::XTURTLE_SPK2TURT;
    const auto XTURTLE_SPK3TURT = Sample::XTURTLE_SPK3TURT;
    const auto XTURTLE_SPK4TURT = Sample::XTURTLE_SPK4TURT;
    const auto XTURTLE_TURN = Sample::XTURTLE_TURN;
    const auto ZDOG_AGRESSIV = Sample::ZDOG_AGRESSIV;
    const auto ZDOG_SNIF1 = Sample::ZDOG_SNIF1;
    const auto ZDOG_WAF1 = Sample::ZDOG_WAF1;
    const auto ZDOG_WAF2 = Sample::ZDOG_WAF2;
    const auto ZDOG_WAF3 = Sample::ZDOG_WAF3;
};
namespace BEHAVIOR {
    enum Behavior {
        BULLET,
        SEEKERBULLET,
        RFBULLET,
        TOASTERBULLET,
        PEPPERBULLET,
        ELECTROBULLET,
        BUMP,
        PADDLE,
        BIGOBJECT,
        WALKINGENEMY,
        DESTRUCTSCENERY,
        ROCKETTURTLE,
        ROCKETTURTLEPLUS,
        BOLLYTOP,
        BOLLYBOTTOM,
        PLATFORM,
        SPRING,
        AMMO15,
        MONITOR,
        CRATE,
        PICKUP,
        DIAMONDSAREFOREVER,
        FLAG,
        INACTIVE,
        DEFAULT,
        MONKEYBULLET,
        BILSYBULLET,
        BOLLYBULLET,
        BOLLYSPIKEBALL,
        WITCHBULLET,
        TUFBOSSBULLET,
        ROBOTSHARD,
        BONE,
        EXPLOSION2,
        BURNING,
        AIRBOARDFALL,
        BIRDFEATHER,
        UFO,
        CORPSE,
    };
    // Aliases
    const auto BULLET = Behavior::BULLET;
    const auto SEEKERBULLET = Behavior::SEEKERBULLET;
    const auto RFBULLET = Behavior::RFBULLET;
    const auto TOASTERBULLET = Behavior::TOASTERBULLET;
    const auto PEPPERBULLET = Behavior::PEPPERBULLET;
    const auto ELECTROBULLET = Behavior::ELECTROBULLET;
    const auto BUMP = Behavior::BUMP;
    const auto PADDLE = Behavior::PADDLE;
    const auto BIGOBJECT = Behavior::BIGOBJECT;
    const auto WALKINGENEMY = Behavior::WALKINGENEMY;
    const auto DESTRUCTSCENERY = Behavior::DESTRUCTSCENERY;
    const auto ROCKETTURTLE = Behavior::ROCKETTURTLE;
    const auto ROCKETTURTLEPLUS = Behavior::ROCKETTURTLEPLUS;
    const auto BOLLYTOP = Behavior::BOLLYTOP;
    const auto BOLLYBOTTOM = Behavior::BOLLYBOTTOM;
    const auto PLATFORM = Behavior::PLATFORM;
    const auto SPRING = Behavior::SPRING;
    const auto AMMO15 = Behavior::AMMO15;
    const auto MONITOR = Behavior::MONITOR;
    const auto CRATE = Behavior::CRATE;
    const auto PICKUP = Behavior::PICKUP;
    const auto DIAMONDSAREFOREVER = Behavior::DIAMONDSAREFOREVER;
    const auto FLAG = Behavior::FLAG;
    const auto INACTIVE = Behavior::INACTIVE;
    const auto DEFAULT = Behavior::DEFAULT;
    const auto MONKEYBULLET = Behavior::MONKEYBULLET;
    const auto BILSYBULLET = Behavior::BILSYBULLET;
    const auto BOLLYBULLET = Behavior::BOLLYBULLET;
    const auto BOLLYSPIKEBALL = Behavior::BOLLYSPIKEBALL;
    const auto WITCHBULLET = Behavior::WITCHBULLET;
    const auto TUFBOSSBULLET = Behavior::TUFBOSSBULLET;
    const auto ROBOTSHARD = Behavior::ROBOTSHARD;
    const auto BONE = Behavior::BONE;
    const auto EXPLOSION2 = Behavior::EXPLOSION2;
    const auto BURNING = Behavior::BURNING;
    const auto AIRBOARDFALL = Behavior::AIRBOARDFALL;
    const auto BIRDFEATHER = Behavior::BIRDFEATHER;
    const auto UFO = Behavior::UFO;
    const auto CORPSE = Behavior::CORPSE;
};
namespace DIRECTION {
    enum Dir {
        RIGHT,
        LEFT,
        UP,
        CURRENT,
    };
    // Aliases
    const auto RIGHT = Dir::RIGHT;
    const auto LEFT = Dir::LEFT;
    const auto UP = Dir::UP;
    const auto CURRENT = Dir::CURRENT;
};
namespace CHAR {
    enum Char {
        JAZZ,
        SPAZ,
        LORI,
        BIRD,
        FROG,
        BIRD2,
    };
    // Aliases
    const auto JAZZ = Char::JAZZ;
    const auto SPAZ = Char::SPAZ;
    const auto LORI = Char::LORI;
    const auto BIRD = Char::BIRD;
    const auto FROG = Char::FROG;
    const auto BIRD2 = Char::BIRD2;
};
namespace HANDLING {
    enum Player {
        ENEMY,
        PLAYERBULLET,
        ENEMYBULLET,
        PARTICLE,
        EXPLOSION,
        PICKUP,
        DELAYEDPICKUP,
        HURT,
        SPECIAL,
        DYING,
        SPECIALDONE,
        SELFCOLLISION,
    };
    enum Bullet {
        HURTBYBULLET,
        IGNOREBULLET,
        DESTROYBULLET,
        DETECTBULLET,
    };
    // Aliases
    const auto ENEMY = Player::ENEMY;
    const auto PLAYERBULLET = Player::PLAYERBULLET;
    const auto ENEMYBULLET = Player::ENEMYBULLET;
    const auto PARTICLE = Player::PARTICLE;
    const auto EXPLOSION = Player::EXPLOSION;
    const auto PICKUP = Player::PICKUP;
    const auto DELAYEDPICKUP = Player::DELAYEDPICKUP;
    const auto HURT = Player::HURT;
    const auto SPECIAL = Player::SPECIAL;
    const auto DYING = Player::DYING;
    const auto SPECIALDONE = Player::SPECIALDONE;
    const auto SELFCOLLISION = Player::SELFCOLLISION;
    const auto HURTBYBULLET = Bullet::HURTBYBULLET;
    const auto IGNOREBULLET = Bullet::IGNOREBULLET;
    const auto DESTROYBULLET = Bullet::DESTROYBULLET;
    const auto DETECTBULLET = Bullet::DETECTBULLET;
};
namespace GEM {
    enum Color {
        RED,
        GREEN,
        BLUE,
        PURPLE,
    };
    // Aliases
    const auto RED = Color::RED;
    const auto GREEN = Color::GREEN;
    const auto BLUE = Color::BLUE;
    const auto PURPLE = Color::PURPLE;
};
namespace CHAT {
    enum Type {
        NORMAL,
        TEAMCHAT,
        WHISPER,
        ME,
    };
    // Aliases
    const auto NORMAL = Type::NORMAL;
    const auto TEAMCHAT = Type::TEAMCHAT;
    const auto WHISPER = Type::WHISPER;
    const auto ME = Type::ME;
};
namespace OBJECT {
    enum Object {
        BLASTERBULLET,
        BOUNCERBULLET,
        ICEBULLET,
        SEEKERBULLET,
        RFBULLET,
        TOASTERBULLET,
        FIREBALLBULLET,
        ELECTROBULLET,
        BLASTERBULLETPU,
        BOUNCERBULLETPU,
        ICEBULLETPU,
        SEEKERBULLETPU,
        RFBULLETPU,
        TOASTERBULLETPU,
        FIREBALLBULLETPU,
        ELECTROBULLETPU,
        FIRESHIELDBULLET,
        WATERSHIELDBULLET,
        BUBBLESHIELDBULLET,
        LIGHTNINGSHIELDBULLET,
        PLASMASHIELDBULLET,
        BULLET,
        SMOKERING,
        SHARD,
        EXPLOSION,
        BOUNCEONCE,
        FLICKERGEM,
        LASER,
        UTERUSSPIKEBALL,
        BIRD,
        BUBBLE,
        ICEAMMO3,
        BOUNCERAMMO3,
        SEEKERAMMO3,
        RFAMMO3,
        TOASTERAMMO3,
        TNTAMMO3,
        GUN8AMMO3,
        GUN9AMMO3,
        TURTLESHELL,
        SWINGINGVINE,
        BOMB,
        SILVERCOIN,
        GOLDCOIN,
        GUNCRATE,
        CARROTCRATE,
        ONEUPCRATE,
        GEMBARREL,
        CARROTBARREL,
        ONEUPBARREL,
        BOMBCRATE,
        ICEAMMO15,
        BOUNCERAMMO15,
        SEEKERAMMO15,
        RFAMMO15,
        TOASTERAMMO15,
        TNT,
        AIRBOARDGENERATOR,
        FROZENSPRING,
        FASTFIRE,
        SPRINGCRATE,
        REDGEM,
        GREENGEM,
        BLUEGEM,
        PURPLEGEM,
        SUPERGEM,
        BIRDCAGE,
        GUNBARREL,
        GEMCRATE,
        MORPH,
        CARROT,
        FULLENERGY,
        FIRESHIELD,
        WATERSHIELD,
        BUBBLESHIELD,
        LIGHTNINGSHIELD,
        PLASMASHIELD,
        FASTFEET,
        ONEUP,
        EXTRALIFE,
        EXTRALIVE,
        EOLPOST,
        SAVEPOST,
        CHECKPOINT,
        BONUSPOST,
        REDSPRING,
        GREENSPRING,
        BLUESPRING,
        INVINCIBILITY,
        EXTRATIME,
        FREEZER,
        FREEZEENEMIES,
        HORREDSPRING,
        HORGREENSPRING,
        HORBLUESPRING,
        BIRDMORPH,
        TRIGGERCRATE,
        FLYCARROT,
        RECTREDGEM,
        RECTGREENGEM,
        RECTBLUEGEM,
        TUFTURT,
        TUFBOSS,
        LABRAT,
        DRAGON,
        LIZARD,
        BEE,
        BUMBEE,
        RAPIER,
        SPARK,
        BAT,
        SUCKER,
        CATERPILLAR,
        CHESHIRE1,
        CHESHIRE2,
        HATTER,
        BILSY,
        SKELETON,
        DOGGYDOGG,
        NORMTURTLE,
        HELMUT,
        DEMON,
        DRAGONFLY,
        MONKEY,
        FATCHICK,
        FENCER,
        FISH,
        MOTH,
        STEAM,
        ROTATINGROCK,
        BLASTERPOWERUP,
        BOUNCERPOWERUP,
        ICEPOWERUP,
        SEEKERPOWERUP,
        RFPOWERUP,
        TOASTERPOWERUP,
        LEFTPADDLE,
        RIGHTPADDLE,
        FIVEHUNDREDBUMP,
        CARROTBUMP,
        APPLE,
        BANANA,
        CHERRY,
        ORANGE,
        PEAR,
        PRETZEL,
        STRAWBERRY,
        STEADYLIGHT,
        PULZELIGHT,
        PULSELIGHT,
        FLICKERLIGHT,
        QUEEN,
        FLOATSUCKER,
        BRIDGE,
        LEMON,
        LIME,
        THING,
        WATERMELON,
        PEACH,
        GRAPES,
        LETTUCE,
        EGGPLANT,
        CUCUMB,
        CUCUMBER,
        COKE,
        SOFTDRINK,
        PEPSI,
        SODAPOP,
        MILK,
        PIE,
        CAKE,
        DONUT,
        CUPCAKE,
        CHIPS,
        CANDY,
        CHOCBAR,
        CHOCOLATEBAR,
        ICECREAM,
        BURGER,
        PIZZA,
        FRIES,
        CHICKENLEG,
        SANDWICH,
        TACO,
        WEENIE,
        HAM,
        CHEESE,
        FLOATLIZARD,
        STANDMONKEY,
        DESTRUCTSCENERY,
        DESTRUCTSCENERYBOMB,
        TNTDESTRUCTSCENERY,
        COLLAPSESCENERY,
        STOMPSCENERY,
        GEMSTOMP,
        RAVEN,
        TUBETURTLE,
        GEMRING,
        SMALLTREE,
        AMBIENTSOUND,
        UTERUS,
        CRAB,
        WITCH,
        ROCKETTURTLE,
        BUBBA,
        DEVILDEVAN,
        DEVANROBOT,
        ROBOT,
        CARROTUSPOLE,
        PSYCHPOLE,
        DIAMONDUSPOLE,
        FRUITPLATFORM,
        BOLLPLATFORM,
        GRASSPLATFORM,
        PINKPLATFORM,
        SONICPLATFORM,
        SPIKEPLATFORM,
        SPIKEBOLL,
        GENERATOR,
        EVA,
        BUBBLER,
        TNTPOWERUP,
        GUN8POWERUP,
        GUN9POWERUP,
        SPIKEBOLL3D,
        SPRINGCORD,
        BEES,
        COPTER,
        LASERSHIELD,
        STOPWATCH,
        JUNGLEPOLE,
        WARP,
        BIGROCK,
        BIGBOX,
        TRIGGERSCENERY,
        BOLLY,
        BUTTERFLY,
        BEEBOY,
        SNOW,
        TWEEDLEBOSS,
        AIRBOARD,
        CTFBASE,
        XMASNORMTURTLE,
        XMASLIZARD,
        XMASFLOATLIZARD,
        XMASBILSY,
        CAT,
        PACMANGHOST,
    };
    // Aliases
    const auto BLASTERBULLET = Object::BLASTERBULLET;
    const auto BOUNCERBULLET = Object::BOUNCERBULLET;
    const auto ICEBULLET = Object::ICEBULLET;
    const auto SEEKERBULLET = Object::SEEKERBULLET;
    const auto RFBULLET = Object::RFBULLET;
    const auto TOASTERBULLET = Object::TOASTERBULLET;
    const auto FIREBALLBULLET = Object::FIREBALLBULLET;
    const auto ELECTROBULLET = Object::ELECTROBULLET;
    const auto BLASTERBULLETPU = Object::BLASTERBULLETPU;
    const auto BOUNCERBULLETPU = Object::BOUNCERBULLETPU;
    const auto ICEBULLETPU = Object::ICEBULLETPU;
    const auto SEEKERBULLETPU = Object::SEEKERBULLETPU;
    const auto RFBULLETPU = Object::RFBULLETPU;
    const auto TOASTERBULLETPU = Object::TOASTERBULLETPU;
    const auto FIREBALLBULLETPU = Object::FIREBALLBULLETPU;
    const auto ELECTROBULLETPU = Object::ELECTROBULLETPU;
    const auto FIRESHIELDBULLET = Object::FIRESHIELDBULLET;
    const auto WATERSHIELDBULLET = Object::WATERSHIELDBULLET;
    const auto BUBBLESHIELDBULLET = Object::BUBBLESHIELDBULLET;
    const auto LIGHTNINGSHIELDBULLET = Object::LIGHTNINGSHIELDBULLET;
    const auto PLASMASHIELDBULLET = Object::PLASMASHIELDBULLET;
    const auto BULLET = Object::BULLET;
    const auto SMOKERING = Object::SMOKERING;
    const auto SHARD = Object::SHARD;
    const auto EXPLOSION = Object::EXPLOSION;
    const auto BOUNCEONCE = Object::BOUNCEONCE;
    const auto FLICKERGEM = Object::FLICKERGEM;
    const auto LASER = Object::LASER;
    const auto UTERUSSPIKEBALL = Object::UTERUSSPIKEBALL;
    const auto BIRD = Object::BIRD;
    const auto BUBBLE = Object::BUBBLE;
    const auto ICEAMMO3 = Object::ICEAMMO3;
    const auto BOUNCERAMMO3 = Object::BOUNCERAMMO3;
    const auto SEEKERAMMO3 = Object::SEEKERAMMO3;
    const auto RFAMMO3 = Object::RFAMMO3;
    const auto TOASTERAMMO3 = Object::TOASTERAMMO3;
    const auto TNTAMMO3 = Object::TNTAMMO3;
    const auto GUN8AMMO3 = Object::GUN8AMMO3;
    const auto GUN9AMMO3 = Object::GUN9AMMO3;
    const auto TURTLESHELL = Object::TURTLESHELL;
    const auto SWINGINGVINE = Object::SWINGINGVINE;
    const auto BOMB = Object::BOMB;
    const auto SILVERCOIN = Object::SILVERCOIN;
    const auto GOLDCOIN = Object::GOLDCOIN;
    const auto GUNCRATE = Object::GUNCRATE;
    const auto CARROTCRATE = Object::CARROTCRATE;
    const auto ONEUPCRATE = Object::ONEUPCRATE;
    const auto GEMBARREL = Object::GEMBARREL;
    const auto CARROTBARREL = Object::CARROTBARREL;
    const auto ONEUPBARREL = Object::ONEUPBARREL;
    const auto BOMBCRATE = Object::BOMBCRATE;
    const auto ICEAMMO15 = Object::ICEAMMO15;
    const auto BOUNCERAMMO15 = Object::BOUNCERAMMO15;
    const auto SEEKERAMMO15 = Object::SEEKERAMMO15;
    const auto RFAMMO15 = Object::RFAMMO15;
    const auto TOASTERAMMO15 = Object::TOASTERAMMO15;
    const auto TNT = Object::TNT;
    const auto AIRBOARDGENERATOR = Object::AIRBOARDGENERATOR;
    const auto FROZENSPRING = Object::FROZENSPRING;
    const auto FASTFIRE = Object::FASTFIRE;
    const auto SPRINGCRATE = Object::SPRINGCRATE;
    const auto REDGEM = Object::REDGEM;
    const auto GREENGEM = Object::GREENGEM;
    const auto BLUEGEM = Object::BLUEGEM;
    const auto PURPLEGEM = Object::PURPLEGEM;
    const auto SUPERGEM = Object::SUPERGEM;
    const auto BIRDCAGE = Object::BIRDCAGE;
    const auto GUNBARREL = Object::GUNBARREL;
    const auto GEMCRATE = Object::GEMCRATE;
    const auto MORPH = Object::MORPH;
    const auto CARROT = Object::CARROT;
    const auto FULLENERGY = Object::FULLENERGY;
    const auto FIRESHIELD = Object::FIRESHIELD;
    const auto WATERSHIELD = Object::WATERSHIELD;
    const auto BUBBLESHIELD = Object::BUBBLESHIELD;
    const auto LIGHTNINGSHIELD = Object::LIGHTNINGSHIELD;
    const auto PLASMASHIELD = Object::PLASMASHIELD;
    const auto FASTFEET = Object::FASTFEET;
    const auto ONEUP = Object::ONEUP;
    const auto EXTRALIFE = Object::EXTRALIFE;
    const auto EXTRALIVE = Object::EXTRALIVE;
    const auto EOLPOST = Object::EOLPOST;
    const auto SAVEPOST = Object::SAVEPOST;
    const auto CHECKPOINT = Object::CHECKPOINT;
    const auto BONUSPOST = Object::BONUSPOST;
    const auto REDSPRING = Object::REDSPRING;
    const auto GREENSPRING = Object::GREENSPRING;
    const auto BLUESPRING = Object::BLUESPRING;
    const auto INVINCIBILITY = Object::INVINCIBILITY;
    const auto EXTRATIME = Object::EXTRATIME;
    const auto FREEZER = Object::FREEZER;
    const auto FREEZEENEMIES = Object::FREEZEENEMIES;
    const auto HORREDSPRING = Object::HORREDSPRING;
    const auto HORGREENSPRING = Object::HORGREENSPRING;
    const auto HORBLUESPRING = Object::HORBLUESPRING;
    const auto BIRDMORPH = Object::BIRDMORPH;
    const auto TRIGGERCRATE = Object::TRIGGERCRATE;
    const auto FLYCARROT = Object::FLYCARROT;
    const auto RECTREDGEM = Object::RECTREDGEM;
    const auto RECTGREENGEM = Object::RECTGREENGEM;
    const auto RECTBLUEGEM = Object::RECTBLUEGEM;
    const auto TUFTURT = Object::TUFTURT;
    const auto TUFBOSS = Object::TUFBOSS;
    const auto LABRAT = Object::LABRAT;
    const auto DRAGON = Object::DRAGON;
    const auto LIZARD = Object::LIZARD;
    const auto BEE = Object::BEE;
    const auto BUMBEE = Object::BUMBEE;
    const auto RAPIER = Object::RAPIER;
    const auto SPARK = Object::SPARK;
    const auto BAT = Object::BAT;
    const auto SUCKER = Object::SUCKER;
    const auto CATERPILLAR = Object::CATERPILLAR;
    const auto CHESHIRE1 = Object::CHESHIRE1;
    const auto CHESHIRE2 = Object::CHESHIRE2;
    const auto HATTER = Object::HATTER;
    const auto BILSY = Object::BILSY;
    const auto SKELETON = Object::SKELETON;
    const auto DOGGYDOGG = Object::DOGGYDOGG;
    const auto NORMTURTLE = Object::NORMTURTLE;
    const auto HELMUT = Object::HELMUT;
    const auto DEMON = Object::DEMON;
    const auto DRAGONFLY = Object::DRAGONFLY;
    const auto MONKEY = Object::MONKEY;
    const auto FATCHICK = Object::FATCHICK;
    const auto FENCER = Object::FENCER;
    const auto FISH = Object::FISH;
    const auto MOTH = Object::MOTH;
    const auto STEAM = Object::STEAM;
    const auto ROTATINGROCK = Object::ROTATINGROCK;
    const auto BLASTERPOWERUP = Object::BLASTERPOWERUP;
    const auto BOUNCERPOWERUP = Object::BOUNCERPOWERUP;
    const auto ICEPOWERUP = Object::ICEPOWERUP;
    const auto SEEKERPOWERUP = Object::SEEKERPOWERUP;
    const auto RFPOWERUP = Object::RFPOWERUP;
    const auto TOASTERPOWERUP = Object::TOASTERPOWERUP;
    const auto LEFTPADDLE = Object::LEFTPADDLE;
    const auto RIGHTPADDLE = Object::RIGHTPADDLE;
    const auto FIVEHUNDREDBUMP = Object::FIVEHUNDREDBUMP;
    const auto CARROTBUMP = Object::CARROTBUMP;
    const auto APPLE = Object::APPLE;
    const auto BANANA = Object::BANANA;
    const auto CHERRY = Object::CHERRY;
    const auto ORANGE = Object::ORANGE;
    const auto PEAR = Object::PEAR;
    const auto PRETZEL = Object::PRETZEL;
    const auto STRAWBERRY = Object::STRAWBERRY;
    const auto STEADYLIGHT = Object::STEADYLIGHT;
    const auto PULZELIGHT = Object::PULZELIGHT;
    const auto PULSELIGHT = Object::PULSELIGHT;
    const auto FLICKERLIGHT = Object::FLICKERLIGHT;
    const auto QUEEN = Object::QUEEN;
    const auto FLOATSUCKER = Object::FLOATSUCKER;
    const auto BRIDGE = Object::BRIDGE;
    const auto LEMON = Object::LEMON;
    const auto LIME = Object::LIME;
    const auto THING = Object::THING;
    const auto WATERMELON = Object::WATERMELON;
    const auto PEACH = Object::PEACH;
    const auto GRAPES = Object::GRAPES;
    const auto LETTUCE = Object::LETTUCE;
    const auto EGGPLANT = Object::EGGPLANT;
    const auto CUCUMB = Object::CUCUMB;
    const auto CUCUMBER = Object::CUCUMBER;
    const auto COKE = Object::COKE;
    const auto SOFTDRINK = Object::SOFTDRINK;
    const auto PEPSI = Object::PEPSI;
    const auto SODAPOP = Object::SODAPOP;
    const auto MILK = Object::MILK;
    const auto PIE = Object::PIE;
    const auto CAKE = Object::CAKE;
    const auto DONUT = Object::DONUT;
    const auto CUPCAKE = Object::CUPCAKE;
    const auto CHIPS = Object::CHIPS;
    const auto CANDY = Object::CANDY;
    const auto CHOCBAR = Object::CHOCBAR;
    const auto CHOCOLATEBAR = Object::CHOCOLATEBAR;
    const auto ICECREAM = Object::ICECREAM;
    const auto BURGER = Object::BURGER;
    const auto PIZZA = Object::PIZZA;
    const auto FRIES = Object::FRIES;
    const auto CHICKENLEG = Object::CHICKENLEG;
    const auto SANDWICH = Object::SANDWICH;
    const auto TACO = Object::TACO;
    const auto WEENIE = Object::WEENIE;
    const auto HAM = Object::HAM;
    const auto CHEESE = Object::CHEESE;
    const auto FLOATLIZARD = Object::FLOATLIZARD;
    const auto STANDMONKEY = Object::STANDMONKEY;
    const auto DESTRUCTSCENERY = Object::DESTRUCTSCENERY;
    const auto DESTRUCTSCENERYBOMB = Object::DESTRUCTSCENERYBOMB;
    const auto TNTDESTRUCTSCENERY = Object::TNTDESTRUCTSCENERY;
    const auto COLLAPSESCENERY = Object::COLLAPSESCENERY;
    const auto STOMPSCENERY = Object::STOMPSCENERY;
    const auto GEMSTOMP = Object::GEMSTOMP;
    const auto RAVEN = Object::RAVEN;
    const auto TUBETURTLE = Object::TUBETURTLE;
    const auto GEMRING = Object::GEMRING;
    const auto SMALLTREE = Object::SMALLTREE;
    const auto AMBIENTSOUND = Object::AMBIENTSOUND;
    const auto UTERUS = Object::UTERUS;
    const auto CRAB = Object::CRAB;
    const auto WITCH = Object::WITCH;
    const auto ROCKETTURTLE = Object::ROCKETTURTLE;
    const auto BUBBA = Object::BUBBA;
    const auto DEVILDEVAN = Object::DEVILDEVAN;
    const auto DEVANROBOT = Object::DEVANROBOT;
    const auto ROBOT = Object::ROBOT;
    const auto CARROTUSPOLE = Object::CARROTUSPOLE;
    const auto PSYCHPOLE = Object::PSYCHPOLE;
    const auto DIAMONDUSPOLE = Object::DIAMONDUSPOLE;
    const auto FRUITPLATFORM = Object::FRUITPLATFORM;
    const auto BOLLPLATFORM = Object::BOLLPLATFORM;
    const auto GRASSPLATFORM = Object::GRASSPLATFORM;
    const auto PINKPLATFORM = Object::PINKPLATFORM;
    const auto SONICPLATFORM = Object::SONICPLATFORM;
    const auto SPIKEPLATFORM = Object::SPIKEPLATFORM;
    const auto SPIKEBOLL = Object::SPIKEBOLL;
    const auto GENERATOR = Object::GENERATOR;
    const auto EVA = Object::EVA;
    const auto BUBBLER = Object::BUBBLER;
    const auto TNTPOWERUP = Object::TNTPOWERUP;
    const auto GUN8POWERUP = Object::GUN8POWERUP;
    const auto GUN9POWERUP = Object::GUN9POWERUP;
    const auto SPIKEBOLL3D = Object::SPIKEBOLL3D;
    const auto SPRINGCORD = Object::SPRINGCORD;
    const auto BEES = Object::BEES;
    const auto COPTER = Object::COPTER;
    const auto LASERSHIELD = Object::LASERSHIELD;
    const auto STOPWATCH = Object::STOPWATCH;
    const auto JUNGLEPOLE = Object::JUNGLEPOLE;
    const auto WARP = Object::WARP;
    const auto BIGROCK = Object::BIGROCK;
    const auto BIGBOX = Object::BIGBOX;
    const auto TRIGGERSCENERY = Object::TRIGGERSCENERY;
    const auto BOLLY = Object::BOLLY;
    const auto BUTTERFLY = Object::BUTTERFLY;
    const auto BEEBOY = Object::BEEBOY;
    const auto SNOW = Object::SNOW;
    const auto TWEEDLEBOSS = Object::TWEEDLEBOSS;
    const auto AIRBOARD = Object::AIRBOARD;
    const auto CTFBASE = Object::CTFBASE;
    const auto XMASNORMTURTLE = Object::XMASNORMTURTLE;
    const auto XMASLIZARD = Object::XMASLIZARD;
    const auto XMASFLOATLIZARD = Object::XMASFLOATLIZARD;
    const auto XMASBILSY = Object::XMASBILSY;
    const auto CAT = Object::CAT;
    const auto PACMANGHOST = Object::PACMANGHOST;
};
namespace AREA {
    enum Area {
        ONEWAY,
        HURT,
        VINE,
        HOOK,
        SLIDE,
        HPOLE,
        VPOLE,
        FLYOFF,
        RICOCHET,
        BELTRIGHT,
        BELTLEFT,
        ACCBELTRIGHT,
        ACCBELTLEFT,
        STOPENEMY,
        WINDLEFT,
        WINDRIGHT,
        EOL,
        WARPEOL,
        REVERTMORPH,
        FLOATUP,
        TRIGGERROCK,
        DIMLIGHT,
        SETLIGHT,
        LIMITXSCROLL,
        RESETLIGHT,
        WARPSECRET,
        ECHO,
        ACTIVATEBOSS,
        JAZZLEVELSTART,
        JAZZSTART,
        SPAZLEVELSTART,
        SPAZSTART,
        MPLEVELSTART,
        MPSTART,
        LORILEVELSTART,
        LORISTART,
        WARP,
        WARPTARGET,
        PATH,
        AREAID,
        NOFIREZONE,
        TRIGGERZONE,
        SUCKERTUBE,
        TEXT,
        WATERLEVEL,
        MORPHFROG,
        WATERBLOCK,
    };
    // Aliases
    const auto ONEWAY = Area::ONEWAY;
    const auto HURT = Area::HURT;
    const auto VINE = Area::VINE;
    const auto HOOK = Area::HOOK;
    const auto SLIDE = Area::SLIDE;
    const auto HPOLE = Area::HPOLE;
    const auto VPOLE = Area::VPOLE;
    const auto FLYOFF = Area::FLYOFF;
    const auto RICOCHET = Area::RICOCHET;
    const auto BELTRIGHT = Area::BELTRIGHT;
    const auto BELTLEFT = Area::BELTLEFT;
    const auto ACCBELTRIGHT = Area::ACCBELTRIGHT;
    const auto ACCBELTLEFT = Area::ACCBELTLEFT;
    const auto STOPENEMY = Area::STOPENEMY;
    const auto WINDLEFT = Area::WINDLEFT;
    const auto WINDRIGHT = Area::WINDRIGHT;
    const auto EOL = Area::EOL;
    const auto WARPEOL = Area::WARPEOL;
    const auto REVERTMORPH = Area::REVERTMORPH;
    const auto FLOATUP = Area::FLOATUP;
    const auto TRIGGERROCK = Area::TRIGGERROCK;
    const auto DIMLIGHT = Area::DIMLIGHT;
    const auto SETLIGHT = Area::SETLIGHT;
    const auto LIMITXSCROLL = Area::LIMITXSCROLL;
    const auto RESETLIGHT = Area::RESETLIGHT;
    const auto WARPSECRET = Area::WARPSECRET;
    const auto ECHO = Area::ECHO;
    const auto ACTIVATEBOSS = Area::ACTIVATEBOSS;
    const auto JAZZLEVELSTART = Area::JAZZLEVELSTART;
    const auto JAZZSTART = Area::JAZZSTART;
    const auto SPAZLEVELSTART = Area::SPAZLEVELSTART;
    const auto SPAZSTART = Area::SPAZSTART;
    const auto MPLEVELSTART = Area::MPLEVELSTART;
    const auto MPSTART = Area::MPSTART;
    const auto LORILEVELSTART = Area::LORILEVELSTART;
    const auto LORISTART = Area::LORISTART;
    const auto WARP = Area::WARP;
    const auto WARPTARGET = Area::WARPTARGET;
    const auto PATH = Area::PATH;
    const auto AREAID = Area::AREAID;
    const auto NOFIREZONE = Area::NOFIREZONE;
    const auto TRIGGERZONE = Area::TRIGGERZONE;
    const auto SUCKERTUBE = Area::SUCKERTUBE;
    const auto TEXT = Area::TEXT;
    const auto WATERLEVEL = Area::WATERLEVEL;
    const auto MORPHFROG = Area::MORPHFROG;
    const auto WATERBLOCK = Area::WATERBLOCK;
};
namespace ANIM {
    enum Set {
        AMMO,
        BAT,
        BEEBOY,
        BEES,
        BIGBOX,
        BIGROCK,
        BIGTREE,
        BILSBOSS,
        BIRD,
        BIRD3D,
        BOLLPLAT,
        BONUS,
        BOSS,
        BRIDGE,
        BUBBA,
        BUMBEE,
        BUTTERFLY,
        CARROTPOLE,
        CAT,
        CAT2,
        CATERPIL,
        CHUCK,
        COMMON,
        CONTINUE,
        DEMON,
        DESTSCEN,
        DEVAN,
        DEVILDEVAN,
        DIAMPOLE,
        DOG,
        DOOR,
        DRAGFLY,
        DRAGON,
        EVA,
        FACES,
        FATCHK,
        FENCER,
        FISH,
        FLAG,
        FLARE,
        FONT,
        FROG,
        FRUITPLAT,
        GEMRING,
        GLOVE,
        GRASSPLAT,
        HATTER,
        HELMUT,
        JAZZ,
        JAZZ3D,
        JUNGLEPOLE,
        LABRAT,
        LIZARD,
        LORI,
        LORI2,
        MENU,
        MENUFONT,
        MONKEY,
        MOTH,
        PICKUPS,
        PINBALL,
        PINKPLAT,
        PSYCHPOLE,
        QUEEN,
        RAPIER,
        RAVEN,
        ROBOT,
        ROCK,
        ROCKTURT,
        SKELETON,
        SMALTREE,
        SNOW,
        SONCSHIP,
        SONICPLAT,
        SPARK,
        SPAZ,
        SPAZ2,
        SPAZ3D,
        SPIKEBOLL,
        SPIKEBOLL3D,
        SPIKEPLAT,
        SPRING,
        STEAM,
        SUCKER,
        TUBETURT,
        TUFBOSS,
        TUFTUR,
        TURTLE,
        TWEEDLE,
        UTERUS,
        VINE,
        WARP10,
        WARP100,
        WARP20,
        WARP50,
        WITCH,
        XBILSY,
        XLIZARD,
        XTURTLE,
        ZDOG,
        ZSPARK,
        PLUS_AMMO,
        PLUS_BETA,
        PLUS_COMMON,
        PLUS_CONTINUE,
        PLUS_FONT,
        PLUS_MENUFONT,
        PLUS_REPLACEMENTS,
        PLUS_RETICLES,
        PLUS_SCENERY,
        PLUS_WARP,
        CUSTOM,
    };
    // Aliases
    const auto AMMO = Set::AMMO;
    const auto BAT = Set::BAT;
    const auto BEEBOY = Set::BEEBOY;
    const auto BEES = Set::BEES;
    const auto BIGBOX = Set::BIGBOX;
    const auto BIGROCK = Set::BIGROCK;
    const auto BIGTREE = Set::BIGTREE;
    const auto BILSBOSS = Set::BILSBOSS;
    const auto BIRD = Set::BIRD;
    const auto BIRD3D = Set::BIRD3D;
    const auto BOLLPLAT = Set::BOLLPLAT;
    const auto BONUS = Set::BONUS;
    const auto BOSS = Set::BOSS;
    const auto BRIDGE = Set::BRIDGE;
    const auto BUBBA = Set::BUBBA;
    const auto BUMBEE = Set::BUMBEE;
    const auto BUTTERFLY = Set::BUTTERFLY;
    const auto CARROTPOLE = Set::CARROTPOLE;
    const auto CAT = Set::CAT;
    const auto CAT2 = Set::CAT2;
    const auto CATERPIL = Set::CATERPIL;
    const auto CHUCK = Set::CHUCK;
    const auto COMMON = Set::COMMON;
    const auto CONTINUE = Set::CONTINUE;
    const auto DEMON = Set::DEMON;
    const auto DESTSCEN = Set::DESTSCEN;
    const auto DEVAN = Set::DEVAN;
    const auto DEVILDEVAN = Set::DEVILDEVAN;
    const auto DIAMPOLE = Set::DIAMPOLE;
    const auto DOG = Set::DOG;
    const auto DOOR = Set::DOOR;
    const auto DRAGFLY = Set::DRAGFLY;
    const auto DRAGON = Set::DRAGON;
    const auto EVA = Set::EVA;
    const auto FACES = Set::FACES;
    const auto FATCHK = Set::FATCHK;
    const auto FENCER = Set::FENCER;
    const auto FISH = Set::FISH;
    const auto FLAG = Set::FLAG;
    const auto FLARE = Set::FLARE;
    const auto FONT = Set::FONT;
    const auto FROG = Set::FROG;
    const auto FRUITPLAT = Set::FRUITPLAT;
    const auto GEMRING = Set::GEMRING;
    const auto GLOVE = Set::GLOVE;
    const auto GRASSPLAT = Set::GRASSPLAT;
    const auto HATTER = Set::HATTER;
    const auto HELMUT = Set::HELMUT;
    const auto JAZZ = Set::JAZZ;
    const auto JAZZ3D = Set::JAZZ3D;
    const auto JUNGLEPOLE = Set::JUNGLEPOLE;
    const auto LABRAT = Set::LABRAT;
    const auto LIZARD = Set::LIZARD;
    const auto LORI = Set::LORI;
    const auto LORI2 = Set::LORI2;
    const auto MENU = Set::MENU;
    const auto MENUFONT = Set::MENUFONT;
    const auto MONKEY = Set::MONKEY;
    const auto MOTH = Set::MOTH;
    const auto PICKUPS = Set::PICKUPS;
    const auto PINBALL = Set::PINBALL;
    const auto PINKPLAT = Set::PINKPLAT;
    const auto PSYCHPOLE = Set::PSYCHPOLE;
    const auto QUEEN = Set::QUEEN;
    const auto RAPIER = Set::RAPIER;
    const auto RAVEN = Set::RAVEN;
    const auto ROBOT = Set::ROBOT;
    const auto ROCK = Set::ROCK;
    const auto ROCKTURT = Set::ROCKTURT;
    const auto SKELETON = Set::SKELETON;
    const auto SMALTREE = Set::SMALTREE;
    const auto SNOW = Set::SNOW;
    const auto SONCSHIP = Set::SONCSHIP;
    const auto SONICPLAT = Set::SONICPLAT;
    const auto SPARK = Set::SPARK;
    const auto SPAZ = Set::SPAZ;
    const auto SPAZ2 = Set::SPAZ2;
    const auto SPAZ3D = Set::SPAZ3D;
    const auto SPIKEBOLL = Set::SPIKEBOLL;
    const auto SPIKEBOLL3D = Set::SPIKEBOLL3D;
    const auto SPIKEPLAT = Set::SPIKEPLAT;
    const auto SPRING = Set::SPRING;
    const auto STEAM = Set::STEAM;
    const auto SUCKER = Set::SUCKER;
    const auto TUBETURT = Set::TUBETURT;
    const auto TUFBOSS = Set::TUFBOSS;
    const auto TUFTUR = Set::TUFTUR;
    const auto TURTLE = Set::TURTLE;
    const auto TWEEDLE = Set::TWEEDLE;
    const auto UTERUS = Set::UTERUS;
    const auto VINE = Set::VINE;
    const auto WARP10 = Set::WARP10;
    const auto WARP100 = Set::WARP100;
    const auto WARP20 = Set::WARP20;
    const auto WARP50 = Set::WARP50;
    const auto WITCH = Set::WITCH;
    const auto XBILSY = Set::XBILSY;
    const auto XLIZARD = Set::XLIZARD;
    const auto XTURTLE = Set::XTURTLE;
    const auto ZDOG = Set::ZDOG;
    const auto ZSPARK = Set::ZSPARK;
    const auto PLUS_AMMO = Set::PLUS_AMMO;
    const auto PLUS_BETA = Set::PLUS_BETA;
    const auto PLUS_COMMON = Set::PLUS_COMMON;
    const auto PLUS_CONTINUE = Set::PLUS_CONTINUE;
    const auto PLUS_FONT = Set::PLUS_FONT;
    const auto PLUS_MENUFONT = Set::PLUS_MENUFONT;
    const auto PLUS_REPLACEMENTS = Set::PLUS_REPLACEMENTS;
    const auto PLUS_RETICLES = Set::PLUS_RETICLES;
    const auto PLUS_SCENERY = Set::PLUS_SCENERY;
    const auto PLUS_WARP = Set::PLUS_WARP;
    const auto CUSTOM = Set::CUSTOM;
};
namespace COLOR {
    enum Component {
        RED,
        GREEN,
        BLUE,
    };
    // Aliases
    const auto RED = Component::RED;
    const auto GREEN = Component::GREEN;
    const auto BLUE = Component::BLUE;
};
namespace TEXTURE {
    enum Texture {
        BLADE,
        CORRUPTEDSANCTUARY,
        DESOLATION,
        DIAMONDUSBETA,
        ICTUBELECTRIC,
        MEDIVO,
        MEZ02,
        MUCKAMOKNIGHT,
        NORMAL,
        PSYCH,
        RANEFORUSV,
        WINDSTORMFORTRESS,
        WISETYNESS,
        WTF,
        XARGON,
    };
    enum Style {
        CYLINDER,
        MENU,
        REFLECTION,
        TILEMENU,
        TUNNEL,
        WAVE,
        WARPHORIZON,
    };
    // Aliases
    const auto BLADE = Texture::BLADE;
    const auto CORRUPTEDSANCTUARY = Texture::CORRUPTEDSANCTUARY;
    const auto DESOLATION = Texture::DESOLATION;
    const auto DIAMONDUSBETA = Texture::DIAMONDUSBETA;
    const auto ICTUBELECTRIC = Texture::ICTUBELECTRIC;
    const auto MEDIVO = Texture::MEDIVO;
    const auto MEZ02 = Texture::MEZ02;
    const auto MUCKAMOKNIGHT = Texture::MUCKAMOKNIGHT;
    const auto NORMAL = Texture::NORMAL;
    const auto PSYCH = Texture::PSYCH;
    const auto RANEFORUSV = Texture::RANEFORUSV;
    const auto WINDSTORMFORTRESS = Texture::WINDSTORMFORTRESS;
    const auto WISETYNESS = Texture::WISETYNESS;
    const auto WTF = Texture::WTF;
    const auto XARGON = Texture::XARGON;
    const auto CYLINDER = Style::CYLINDER;
    const auto MENU = Style::MENU;
    const auto REFLECTION = Style::REFLECTION;
    const auto TILEMENU = Style::TILEMENU;
    const auto TUNNEL = Style::TUNNEL;
    const auto WAVE = Style::WAVE;
    const auto WARPHORIZON = Style::WARPHORIZON;
};
namespace SURFACE {
    enum Surface {
        UNTEXTURED,
        LEGACY,
        FULLSREEN,
        INNERWINDOW,
        INNERLAYER,
    };
    // Aliases
    const auto UNTEXTURED = Surface::UNTEXTURED;
    const auto LEGACY = Surface::LEGACY;
    const auto FULLSREEN = Surface::FULLSREEN;
    const auto INNERWINDOW = Surface::INNERWINDOW;
    const auto INNERLAYER = Surface::INNERLAYER;
};
namespace LAYERSPEEDMODEL {
    enum LayerSpeedModel {
        NORMAL,
        LAYER8,
        BOTHSPEEDS,
        FROMSTART,
        FITLEVEL,
        SPEEDMULTIPLIERS,
    };
    // Aliases
    const auto NORMAL = LayerSpeedModel::NORMAL;
    const auto LAYER8 = LayerSpeedModel::LAYER8;
    const auto BOTHSPEEDS = LayerSpeedModel::BOTHSPEEDS;
    const auto FROMSTART = LayerSpeedModel::FROMSTART;
    const auto FITLEVEL = LayerSpeedModel::FITLEVEL;
    const auto SPEEDMULTIPLIERS = LayerSpeedModel::SPEEDMULTIPLIERS;
};
namespace LIGHT {
    enum Enforce {
        OPTIONAL,
        BASIC,
        COMPLETE,
    };
    enum Type {
        NONE,
        NORMAL,
        POINT,
        POINT2,
        FLICKER,
        BRIGHT,
        LASERBEAM,
        LASER,
        RING,
        RING2,
        PLAYER,
    };
    // Aliases
    const auto OPTIONAL = Enforce::OPTIONAL;
    const auto BASIC = Enforce::BASIC;
    const auto COMPLETE = Enforce::COMPLETE;
    const auto NONE = Type::NONE;
    const auto NORMAL = Type::NORMAL;
    const auto POINT = Type::POINT;
    const auto POINT2 = Type::POINT2;
    const auto FLICKER = Type::FLICKER;
    const auto BRIGHT = Type::BRIGHT;
    const auto LASERBEAM = Type::LASERBEAM;
    const auto LASER = Type::LASER;
    const auto RING = Type::RING;
    const auto RING2 = Type::RING2;
    const auto PLAYER = Type::PLAYER;
};
namespace SNOWING {
    enum Type {
        SNOW,
        FLOWER,
        RAIN,
        LEAF,
    };
    // Aliases
    const auto SNOW = Type::SNOW;
    const auto FLOWER = Type::FLOWER;
    const auto RAIN = Type::RAIN;
    const auto LEAF = Type::LEAF;
};
namespace WATERINTERACTION {
    enum WaterInteraction {
        SWIM,
        LOWGRAVITY,
        POSITIONBASED,
    };
    // Aliases
    const auto SWIM = WaterInteraction::SWIM;
    const auto LOWGRAVITY = WaterInteraction::LOWGRAVITY;
    const auto POSITIONBASED = WaterInteraction::POSITIONBASED;
};
namespace WATERLIGHT {
    enum wl {
        NONE,
        GLOBAL,
        LAGUNICUS,
    };
    // Aliases
    const auto NONE = wl::NONE;
    const auto GLOBAL = wl::GLOBAL;
    const auto LAGUNICUS = wl::LAGUNICUS;
};
namespace STATE {
    enum State {
        START,
        SLEEP,
        WAKE,
        KILL,
        DEACTIVATE,
        WALK,
        JUMP,
        FIRE,
        FLY,
        BOUNCE,
        EXPLODE,
        ROCKETFLY,
        STILL,
        FLOAT,
        HIT,
        SPRING,
        ACTION,
        DONE,
        PUSH,
        FALL,
        FLOATFALL,
        CIRCLE,
        ATTACK,
        FREEZE,
        FADEIN,
        FADEOUT,
        HIDE,
        TURN,
        IDLE,
        EXTRA,
        STOP,
        WAIT,
        LAND,
        DELAYEDSTART,
        ROTATE,
        DUCK,
    };
    // Aliases
    const auto START = State::START;
    const auto SLEEP = State::SLEEP;
    const auto WAKE = State::WAKE;
    const auto KILL = State::KILL;
    const auto DEACTIVATE = State::DEACTIVATE;
    const auto WALK = State::WALK;
    const auto JUMP = State::JUMP;
    const auto FIRE = State::FIRE;
    const auto FLY = State::FLY;
    const auto BOUNCE = State::BOUNCE;
    const auto EXPLODE = State::EXPLODE;
    const auto ROCKETFLY = State::ROCKETFLY;
    const auto STILL = State::STILL;
    const auto FLOAT = State::FLOAT;
    const auto HIT = State::HIT;
    const auto SPRING = State::SPRING;
    const auto ACTION = State::ACTION;
    const auto DONE = State::DONE;
    const auto PUSH = State::PUSH;
    const auto FALL = State::FALL;
    const auto FLOATFALL = State::FLOATFALL;
    const auto CIRCLE = State::CIRCLE;
    const auto ATTACK = State::ATTACK;
    const auto FREEZE = State::FREEZE;
    const auto FADEIN = State::FADEIN;
    const auto FADEOUT = State::FADEOUT;
    const auto HIDE = State::HIDE;
    const auto TURN = State::TURN;
    const auto IDLE = State::IDLE;
    const auto EXTRA = State::EXTRA;
    const auto STOP = State::STOP;
    const auto WAIT = State::WAIT;
    const auto LAND = State::LAND;
    const auto DELAYEDSTART = State::DELAYEDSTART;
    const auto ROTATE = State::ROTATE;
    const auto DUCK = State::DUCK;
};
namespace SPREAD {
    enum Spread {
        NORMAL,
        ICEPU,
        ICE,
        RFNORMAL,
        RFPU,
        RF,
        TOASTER,
        PEPPERSPRAY,
        GUN8,
    };
    // Aliases
    const auto NORMAL = Spread::NORMAL;
    const auto ICEPU = Spread::ICEPU;
    const auto ICE = Spread::ICE;
    const auto RFNORMAL = Spread::RFNORMAL;
    const auto RFPU = Spread::RFPU;
    const auto RF = Spread::RF;
    const auto TOASTER = Spread::TOASTER;
    const auto PEPPERSPRAY = Spread::PEPPERSPRAY;
    const auto GUN8 = Spread::GUN8;
};
namespace WEAPON {
    enum Style {
        NORMAL,
        MISSILE,
        POPCORN,
        CAPPED,
    };
    enum Weapon {
        BLASTER,
        BOUNCER,
        ICE,
        SEEKER,
        RF,
        TOASTER,
        TNT,
        GUN8,
        GUN9,
        CURRENT,
    };
    // Aliases
    const auto NORMAL = Style::NORMAL;
    const auto MISSILE = Style::MISSILE;
    const auto POPCORN = Style::POPCORN;
    const auto CAPPED = Style::CAPPED;
    const auto BLASTER = Weapon::BLASTER;
    const auto BOUNCER = Weapon::BOUNCER;
    const auto ICE = Weapon::ICE;
    const auto SEEKER = Weapon::SEEKER;
    const auto RF = Weapon::RF;
    const auto TOASTER = Weapon::TOASTER;
    const auto TNT = Weapon::TNT;
    const auto GUN8 = Weapon::GUN8;
    const auto GUN9 = Weapon::GUN9;
    const auto CURRENT = Weapon::CURRENT;
};
namespace TEAM {
    enum COLOR {
        NEUTRAL,
        BLUE,
        RED,
        GREEN,
        YELLOW,
    };
    enum Color {
        NEUTRAL,
        BLUE,
        RED,
        GREEN,
        YELLOW,
    };
    // Aliases
    const auto NEUTRAL = COLOR::NEUTRAL;
    const auto BLUE = COLOR::BLUE;
    const auto RED = COLOR::RED;
    const auto GREEN = COLOR::GREEN;
    const auto YELLOW = COLOR::YELLOW;
};
namespace AIR {
    enum Jump {
        NONE,
        HELICOPTER,
        DOUBLEJUMP,
    };
    // Aliases
    const auto NONE = Jump::NONE;
    const auto HELICOPTER = Jump::HELICOPTER;
    const auto DOUBLEJUMP = Jump::DOUBLEJUMP;
};
namespace GROUND {
    enum Jump {
        JAZZ,
        SPAZ,
        LORI,
        CROUCH,
        JUMP,
    };
    // Aliases
    const auto JAZZ = Jump::JAZZ;
    const auto SPAZ = Jump::SPAZ;
    const auto LORI = Jump::LORI;
    const auto CROUCH = Jump::CROUCH;
    const auto JUMP = Jump::JUMP;
};
namespace TIMER {
    enum State {
        STOPPED,
        STARTED,
        PAUSED,
    };
    // Aliases
    const auto STOPPED = State::STOPPED;
    const auto STARTED = State::STARTED;
    const auto PAUSED = State::PAUSED;
};
namespace GAME {
    enum Connection {
        LOCAL,
        ONLINE,
        LAN,
    };
    enum Custom {
        NOCUSTOM,
        RT,
        LRS,
        XLRS,
        PEST,
        TB,
        JB,
        DCTF,
        FR,
        TLRS,
        DOM,
        HEAD,
    };
    enum Mode {
        SP,
        COOP,
        BATTLE,
        CTF,
        TREASURE,
        RACE,
    };
    enum State {
        STOPPED,
        STARTED,
        PAUSED,
        PREGAME,
        OVERTIME,
    };
    // Aliases
    const auto LOCAL = Connection::LOCAL;
    const auto ONLINE = Connection::ONLINE;
    const auto LAN = Connection::LAN;
    const auto NOCUSTOM = Custom::NOCUSTOM;
    const auto RT = Custom::RT;
    const auto LRS = Custom::LRS;
    const auto XLRS = Custom::XLRS;
    const auto PEST = Custom::PEST;
    const auto TB = Custom::TB;
    const auto JB = Custom::JB;
    const auto DCTF = Custom::DCTF;
    const auto FR = Custom::FR;
    const auto TLRS = Custom::TLRS;
    const auto DOM = Custom::DOM;
    const auto HEAD = Custom::HEAD;
    const auto SP = Mode::SP;
    const auto COOP = Mode::COOP;
    const auto BATTLE = Mode::BATTLE;
    const auto CTF = Mode::CTF;
    const auto TREASURE = Mode::TREASURE;
    const auto RACE = Mode::RACE;
    const auto STOPPED = State::STOPPED;
    const auto STARTED = State::STARTED;
    const auto PAUSED = State::PAUSED;
    const auto PREGAME = State::PREGAME;
    const auto OVERTIME = State::OVERTIME;
};
namespace SHIELD {
    enum Shield {
        FIRE,
        BUBBLE,
        WATER,
        LIGHTNING,
        PLASMA,
        LASER,
    };
    // Aliases
    const auto FIRE = Shield::FIRE;
    const auto BUBBLE = Shield::BUBBLE;
    const auto WATER = Shield::WATER;
    const auto LIGHTNING = Shield::LIGHTNING;
    const auto PLASMA = Shield::PLASMA;
    const auto LASER = Shield::LASER;
};
namespace RABBIT {
    enum Anim {
        AIRBOARD,
        AIRBOARDTURN,
        BUTTSTOMPLAND,
        CORPSE,
        DIE,
        DIVE,
        DIVEFIREQUIT,
        DIVEFIRERIGHT,
        DIVEUP,
        EARBRACHIATE,
        ENDOFLEVEL,
        FALL,
        FALLBUTTSTOMP,
        FALLLAND,
        FIRE,
        FIREUP,
        FIREUPQUIT,
        FROG,
        HANGFIREQUIT,
        HANGFIREREST,
        HANGFIREUP,
        HANGIDLE1,
        HANGIDLE2,
        HANGINGFIREQUIT,
        HANGINGFIRERIGHT,
        HELICOPTER,
        HELICOPTERFIREQUIT,
        HELICOPTERFIRERIGHT,
        HPOLE,
        HURT,
        IDLE1,
        IDLE2,
        IDLE3,
        IDLE4,
        IDLE5,
        JUMPFIREQUIT,
        JUMPFIRERIGHT,
        JUMPING1,
        JUMPING2,
        JUMPING3,
        LEDGEWIGGLE,
        LIFT,
        LIFTJUMP,
        LIFTLAND,
        LOOKUP,
        LOOPY,
        PUSH,
        QUIT,
        REV1,
        REV2,
        REV3,
        RIGHTFALL,
        RIGHTJUMP,
        ROLLING,
        RUN1,
        RUN2,
        RUN3,
        SKID1,
        SKID2,
        SKID3,
        SPRING,
        STAND,
        STATIONARYJUMP,
        STATIONARYJUMPEND,
        STATIONARYJUMPSTART,
        STONED,
        SWIMDOWN,
        SWIMRIGHT,
        SWIMTURN1,
        SWIMTURN2,
        SWIMUP,
        SWINGINGVINE,
        TELEPORT,
        TELEPORTFALL,
        TELEPORTFALLING,
        TELEPORTFALLTELEPORT,
        TELEPORTSTAND,
        VPOLE,
    };
    // Aliases
    const auto AIRBOARD = Anim::AIRBOARD;
    const auto AIRBOARDTURN = Anim::AIRBOARDTURN;
    const auto BUTTSTOMPLAND = Anim::BUTTSTOMPLAND;
    const auto CORPSE = Anim::CORPSE;
    const auto DIE = Anim::DIE;
    const auto DIVE = Anim::DIVE;
    const auto DIVEFIREQUIT = Anim::DIVEFIREQUIT;
    const auto DIVEFIRERIGHT = Anim::DIVEFIRERIGHT;
    const auto DIVEUP = Anim::DIVEUP;
    const auto EARBRACHIATE = Anim::EARBRACHIATE;
    const auto ENDOFLEVEL = Anim::ENDOFLEVEL;
    const auto FALL = Anim::FALL;
    const auto FALLBUTTSTOMP = Anim::FALLBUTTSTOMP;
    const auto FALLLAND = Anim::FALLLAND;
    const auto FIRE = Anim::FIRE;
    const auto FIREUP = Anim::FIREUP;
    const auto FIREUPQUIT = Anim::FIREUPQUIT;
    const auto FROG = Anim::FROG;
    const auto HANGFIREQUIT = Anim::HANGFIREQUIT;
    const auto HANGFIREREST = Anim::HANGFIREREST;
    const auto HANGFIREUP = Anim::HANGFIREUP;
    const auto HANGIDLE1 = Anim::HANGIDLE1;
    const auto HANGIDLE2 = Anim::HANGIDLE2;
    const auto HANGINGFIREQUIT = Anim::HANGINGFIREQUIT;
    const auto HANGINGFIRERIGHT = Anim::HANGINGFIRERIGHT;
    const auto HELICOPTER = Anim::HELICOPTER;
    const auto HELICOPTERFIREQUIT = Anim::HELICOPTERFIREQUIT;
    const auto HELICOPTERFIRERIGHT = Anim::HELICOPTERFIRERIGHT;
    const auto HPOLE = Anim::HPOLE;
    const auto HURT = Anim::HURT;
    const auto IDLE1 = Anim::IDLE1;
    const auto IDLE2 = Anim::IDLE2;
    const auto IDLE3 = Anim::IDLE3;
    const auto IDLE4 = Anim::IDLE4;
    const auto IDLE5 = Anim::IDLE5;
    const auto JUMPFIREQUIT = Anim::JUMPFIREQUIT;
    const auto JUMPFIRERIGHT = Anim::JUMPFIRERIGHT;
    const auto JUMPING1 = Anim::JUMPING1;
    const auto JUMPING2 = Anim::JUMPING2;
    const auto JUMPING3 = Anim::JUMPING3;
    const auto LEDGEWIGGLE = Anim::LEDGEWIGGLE;
    const auto LIFT = Anim::LIFT;
    const auto LIFTJUMP = Anim::LIFTJUMP;
    const auto LIFTLAND = Anim::LIFTLAND;
    const auto LOOKUP = Anim::LOOKUP;
    const auto LOOPY = Anim::LOOPY;
    const auto PUSH = Anim::PUSH;
    const auto QUIT = Anim::QUIT;
    const auto REV1 = Anim::REV1;
    const auto REV2 = Anim::REV2;
    const auto REV3 = Anim::REV3;
    const auto RIGHTFALL = Anim::RIGHTFALL;
    const auto RIGHTJUMP = Anim::RIGHTJUMP;
    const auto ROLLING = Anim::ROLLING;
    const auto RUN1 = Anim::RUN1;
    const auto RUN2 = Anim::RUN2;
    const auto RUN3 = Anim::RUN3;
    const auto SKID1 = Anim::SKID1;
    const auto SKID2 = Anim::SKID2;
    const auto SKID3 = Anim::SKID3;
    const auto SPRING = Anim::SPRING;
    const auto STAND = Anim::STAND;
    const auto STATIONARYJUMP = Anim::STATIONARYJUMP;
    const auto STATIONARYJUMPEND = Anim::STATIONARYJUMPEND;
    const auto STATIONARYJUMPSTART = Anim::STATIONARYJUMPSTART;
    const auto STONED = Anim::STONED;
    const auto SWIMDOWN = Anim::SWIMDOWN;
    const auto SWIMRIGHT = Anim::SWIMRIGHT;
    const auto SWIMTURN1 = Anim::SWIMTURN1;
    const auto SWIMTURN2 = Anim::SWIMTURN2;
    const auto SWIMUP = Anim::SWIMUP;
    const auto SWINGINGVINE = Anim::SWINGINGVINE;
    const auto TELEPORT = Anim::TELEPORT;
    const auto TELEPORTFALL = Anim::TELEPORTFALL;
    const auto TELEPORTFALLING = Anim::TELEPORTFALLING;
    const auto TELEPORTFALLTELEPORT = Anim::TELEPORTFALLTELEPORT;
    const auto TELEPORTSTAND = Anim::TELEPORTSTAND;
    const auto VPOLE = Anim::VPOLE;
};

class jjPLAYER {
    /*
	Whether it is currently impossible for the player to double jump, assuming
	they're Spaz and currently in the air. To allow compatibility with multiple air
	jumps, this was replaced with doubleJumpCount.	
	*/
	bool alreadyDoubleJumped;
    /*
	How much ammo the player has of each ammo type. Possible constants appear in the
	appendix below, or you may use simple 1-indexed numbers instead (all values
	besides 1-9 will evaluate to WEAPON::CURRENT). Note that JJ2+ prevents the use
	of weapons without corresponding +3/+15/powerup events in the level while in
	online servers. To remedy this, hide some such ammo-providing event somewhere in
	the level, or else set their allowed properties to true in the jjWeapons array.	
	*/
	fakearray<WEAPON::Weapon, int, uint> ammo;
    /*
	Whether the player falls up (true) or down (false). Also causes the player to be
	drawn upside-down. (For the record, this mode is still a work-in-progress. A
	handful of objectsbridges, pinball flippers, and rotating polesdon't
	work very well with it yet. However, future revisions will be backwards
	compatible with what works already, so don't hold off on using it for that
	reason unless it truly can't do yet what you need it do.)	
	*/
	bool antiGrav;
    /*
	If greater than 0, how much longer (in ticks) the player will be tucked into a
	ball.	
	*/
	int ballTime;
    /*
	If greater than 0, how much longer (in ticks) the player will be blinking and
	invincible and unable to collide with other players, as if recently hurt. Works
	online.	
	*/
	int blink;
    /*
	The object ID of the jjOBJ whose energy is shown in the boss health meter, or -1
	if the health meter is receding off the top of the screen, or 0 if the player is
	not fighting any boss. More specifically, the boss health meter will show the
	energy of the jjOBJ as a percentage of its initial health as described in its
	entry in jjObjectPresets. If you create a Tuf Turtle enemy, give it 100 health,
	and assign a jjPLAYER's boss its object ID, JJ2 will still assume the Tuf Turtle
	started out at 4 health, not 100. On the other hand, if you write
	jjObjectPresets[OBJECT::TUFTURT].energy = 100; first, then the boss health meter
	will work as you might want it to.	
	*/
	int boss;
    /*
	The bool set by the Activate Boss event or the activateBoss method. In general,
	you should make sure this property is true for at least one local player when
	writing behaviors for custom bosses.	
	*/
	bool bossActivated;
    /*
	Buttstomp phase. Values below 41 mean the player is initializing a buttstomp, 41
	means the player is currently buttstomping, values between 41 and 121 mean the
	player is landing on the ground and values of 121 and higher mean the player is
	not currently buttstomping.	
	*/
	int buttstomp;
    /*
	The top left corner of the player's current view of the level, as measured from
	the top left corner of layer 4.	
	*/
	const float cameraX;
    /*
	The top left corner of the player's current view of the level, as measured from
	the top left corner of layer 4.	
	*/
	const float cameraY;
    /*
	The player's current character (CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD,
	CHAR::FROG or CHAR::BIRD2). This is a read-only value, because you should use
	morphTo or another related method to change it instead.	
	*/
	const CHAR::Char charCurr;
    /*
	Which character the player began the level as (CHAR::JAZZ, CHAR::SPAZ, or
	CHAR::LORI), aka the character that the Revert Morph event switches them to.	
	*/
	CHAR::Char charOrig;
    /*
	ID of the game instance controlling the player. This is particularly useful for
	packet exchange with use of jjSendPacket but can also be used to determine
	whether players are splitscreeners.	
	*/
	const int clientID;
    /*
	How many coins the player has. If you want to require the player to have a
	certain number of coins to do something, like with coin warps, consider using
	the more elaborate testForCoins method instead.	
	*/
	int coins;
    /*
	The current animation the player takes its frames from, serving as an index to
	the jjAnimations array. Each animation has a distinct value; for example, Jazz
	standing in place might be 81, but Spaz standing in place might be 185.	
	*/
	const uint16 curAnim;
    /*
	The overall current frame displayed to the screen to represent this player,
	serving as an index to the jjAnimFrames array. For any given jjPLAYER@ p,
	p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.	
	*/
	const uint curFrame;
    /*
	A shortcut value, always equalling int(xPos)/32 + int(yPos)/32*65536. Since both
	xPos and yPos are easily accessible properties, it really only makes sense to
	use currTile to compare against previous values of currTile, i.e. to see if the
	player has moved or not.	
	*/
	const int currTile;
    /*
	Which ammo type the player currently has selected. Possible constants appear in
	the appendix below, or you may use simple 1-indexed numbers instead (all values
	besides 1-9 will evaluate to WEAPON::CURRENT).	
	*/
	uint8 currWeapon;
    /*
	In competitive game modes, the number of deaths the player experienced or a
	negative value if unknown (this is currently the case when the property is
	checked by clients in XLRS mode).	
	*/
	const int deaths;
    /*
	Which direction the player is facing. Negative values mean left and non-negative
	ones mean right.	
	*/
	int8 direction;
    /*
	How many times the player used double jump in the air since their last regular
	jump.	
	*/
	int doubleJumpCount;
    /*
	The waiting time between shots, as decreased by Fastfire events or the JJFIRE
	cheat code. Starts out at 35half a secondand decreases to a minimum
	of 6 (from Fastfire events) or 1 (JJFIRE).	
	*/
	int fastfire;
    /*
	The object ID of the flag the player is carrying, or 0 if the player is not
	carrying a flag.	
	*/
	const int flag;
    /*
	Possible special constant values are FLIGHT::NONE, FLIGHT::FLYCARROT, or
	FLIGHT::AIRBOARD, from the FLIGHT::Mode enum. If the player is currently using a
	copter or Cheshire2 object, fly will equal the object ID of that object plus
	one, which is to say, the jjOBJ the player is holding will be jjObjects[p.fly -
	1].	
	*/
	int fly;
    /*
	How much food the player has eaten. Setting this to 100 will not cause a sugar
	rush. Use the startSugarRush method instead.	
	*/
	int food;
    /*
	The index of the current frame displayed to the screen to represent this player
	within its animation. For example, Jazz's standing animation is only one frame
	long, so his frameID will always equal 0 while playing that animation, while
	Spaz's will range from 0 to 4. For any given jjPLAYER@ p, p.curFrame will equal
	jjAnimations[p.curAnim].firstFrame + p.frameID.	
	*/
	const uint8 frameID;
    /*
	0 if unfrozen; otherwise, constantly counts down towards 0.	
	*/
	int8 frozen;
    /*
	Palette indexes of the player's fur in the form of 4 colors, 8 bits each. For
	potentially more intuitive ways of fur color manipulation refer to jjPLAYER
	methods furGet and furSet. Changes to this setting are automatically shared
	between all clients in the server. Clients are not allowed to change the fur
	colors of non-local players, but servers or local games can change the colors of
	any player (even if their jjPLAYER::isActive is false), which can be useful for
	drawing sprites using SPRITE::PLAYER.	
	*/
	uint32 fur;
    /*
	How many gems the player has collected. Possible values of GEM::Color are
	GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.	
	*/
	fakearray<GEM::Color, int> gems;
    /*
	How many hearts the player has remaining. If you set this in an online server,
	all other players will be notified of the change.	
	*/
	uint8 health;
    /*
	The amount of time in which player's copter ears will run out or 0 if the player
	is currently not using copter ears.	
	*/
	int helicopter;
    /*
	The amount of time player spent using copter ears since their last jump. If this
	reaches or exceeds their respective jjCHARACTER::helicopterDurationMax, the
	player will be unable to use helicopter ears again until they have landed,
	analogous to using up a double jump.	
	*/
	int helicopterElapsed;
    /*
	The amount of time since the last change of idle animation or 0 if the player is
	not idle.	
	*/
	int idle;
    /*
	How much longer the player will be invincible. (Does not work in servers.)
	Specifically, the absolute value is the remaining duration of the invincibility;
	a positive number will display the invincibility effect around the player, but a
	negative number (or zero) will not.	
	*/
	int invincibility;
    /*
	Whether the player is invisible. Invisible players don't have their sprites or
	names drawn. Changes to this setting are automatically shared between all
	clients in the server.	
	*/
	bool invisibility;
    /*
	Does this jjPLAYER object correspond to an actual player in the server, local or
	otherwise? If not, few if any of this jjPLAYER's other properties will be
	reliable. This is a fairly weak check and equals true for several types of
	players who may be present in the server but not actually playingisInGame
	may often be more useful.	
	*/
	const bool isActive;
    /*
	Whether the player is logged in as a Remote Admin in the current online server.
	Because admin privileges can vastly differ depending on server and admin group,
	a more precise tool hasPrivilege exists.	
	*/
	const bool isAdmin;
    /*
	Whether the player is a client who has not finished joining the current online
	server yet, as represented by a "C" or "D" (if downloading) next to their name
	on the player list.	
	*/
	const bool isConnecting;
    /*
	Whether the player is idle and does not appear in the level or player list.
	Currently this can only ever be true of the server.	
	*/
	const bool isIdle;
    /*
	Equals true if isActive is true but isConnecting, isIdle, isOut, and
	isSpectating are all false. If more such properties need to be added in future
	revisions of JJ2+, isInGame will be updated to reflect them.	
	*/
	const bool isInGame;
    /*
	In Jailbreak game mode, whether the player is currently in jail. False in all
	other game modes.	
	*/
	const bool isJailed;
    /*
	Is this jjPLAYER object controlled by this instance of JJ2?	
	*/
	const bool isLocal;
    /*
	Equals true if the player has lost all their lives (or joined too late) in an
	LRS-based gamemode.	
	*/
	const bool isOut;
    /*
	Equals true if the player is spectating normally, i.e. not forced into
	spectating by being out or an idle server.	
	*/
	const bool isSpectating;
    /*
	In Pestilence game mode, whether the player is currently a zombie. False in all
	other game modes.	
	*/
	const bool isZombie;
    /*
	Vertical speed gained by the player on jump. Defaults to -10.	
	*/
	float jumpStrength;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyDown;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyFire;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyJump;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyLeft;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyRight;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyRun;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keySelect;
    /*
	A series of bools controlling whether the player believes its various control
	keys are being pressed. Note that always setting keyFire to true is not the same
	as making the player constantly fire, unless their fastfire property equals 1.	
	*/
	bool keyUp;
    /*
	In Race, the number of laps the player has completed so far. 0 for other modes.	
	*/
	const int laps;
    /*
	In Race, how many ticks it took for this player to run their fastest lap so far.
	Note that because lapTimes only counts the five most recent laps, lapTimeBest
	will not appear in that array if this player's fastest lap was not one of their
	five most recent laps. Undefined for other modes or if laps is still 0.	
	*/
	const int lapTimeBest;
    /*
	In Race, how many ticks have elapsed since the player began their current lap.
	Undefined for other modes.	
	*/
	const int lapTimeCurrent;
    /*
	In Race, how many ticks it took for this player to run the five most recent laps
	they completed, where lapTimes[0] is the length of the most recent lap and
	lapTimes[4] the fifth most recent. If the player has not completed a given lap
	yeti.e. if the index used for the lapTimes array is greater or equal to
	lapsthe value will be -1. Undefined for other modes or for players for
	whom isLocal is false.	
	*/
	const array<int> lapTimes = array<int>(5);
    /*
	The intensity of light emitted by the player. Changes to this setting are
	automatically shared between all clients in the server.	
	*/
	int8 light;
    /*
	The player's current level of ambient lighting, as affected by the Set Light and
	Reset Light events.	
	*/
	uint8 lighting;
    /*
	The type of light emitted by the player. Possible values are NONE, NORMAL,
	POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER
	(default). Changes to this setting are automatically shared between all clients
	in the server.	
	*/
	LIGHT::Type lightType;
    /*
	In single player or cooperative mode, how many lives the player has remaining.
	For LRS-based game modes use lrsLives instead. Lives are not displayed in the
	HUD when jjGameConnection != GAME::LOCAL, but this number still goes up and down
	as appropriate, even into the negatives; it's just that it has no effect on
	gameplay.	
	*/
	int lives;
    /*
	Which local player the player is, in case of splitscreen. 0-3.	
	*/
	const int localPlayerID;
    /*
	In LRS-based game modes (LRS, TLRS, XLRS), how many lives the player has
	remaining, a negative value for other modes. For single player and cooperative
	modes use lives instead.	
	*/
	const int lrsLives;
    /*
	The player's name. This is a constant property; to change it, you can use the
	setName method.	
	*/
	const string name;
    /*
	The player's name in its most basic form, without any | or * characters added or
	removed for any gamemode-related reasons.	
	*/
	const string nameUnformatted;
    /*
	Whether the player is currently in Noclip Mode, as caused by Sucker Tube events
	with the "BecomeNoclip" parameter set to 1. Setting this to true could be
	dangerous if the level design is not prepared for it.	
	*/
	bool noclipMode;
    /*
	Whether the player is currently allowed to shoot bullets. Hides the default
	current weapon/ammunition display while true.	
	*/
	bool noFire;
    /*
	The object ID of the object the player is currently standing on, or 0 if
	inapplicable.	
	*/
	int platform;
    /*
	In online play, which number the player is in the server's list of players.
	0-31.	
	*/
	const int8 playerID;
    /*
	Whether each ammo type is powered-up or not. Possible constants appear in the
	appendix below, or you may use simple 1-indexed numbers instead (all values
	besides 1-9 will evaluate to WEAPON::CURRENT). Note that JJ2+ prevents the use
	of powered-up weapons without corresponding powerup events in the level while in
	online servers. To remedy this, hide powerup events somewhere in the level, or
	else set their allowedPowerup properties to true in the jjWeapons array.	
	*/
	fakearray<WEAPON::Weapon, bool, uint> powerup;
    /*
	In competitive game modes, how many kills the player made or a negative value if
	unknown (this is currently the case when the property is checked by clients in
	RT, LRS, Pestilence and TLRS modes). If the game mode doesn't allow players to
	kill other players, as is the case in Single Player, Cooperative, Treasure Hunt
	and Race, this property will always be equal to 0.	
	*/
	const int roasts;
    /*
	Is the player currently running? Detects the run key, capslock (if there is only
	one local player), and the /run <on|off> command. Apparently running is set
	based on keyRun, and then other parts of code query running exclusively.	
	*/
	bool running;
    /*
	In single player and cooperative modes, the player's current score. JJ2 only
	increments this in multiples of 50 (or 10 if you count the unpatched Butterfly
	enemy), but that's up to you.	
	*/
	int score;
    /*
	In single player and cooperative modes, the number currently displayed for the
	player's score. Whenever score increases, scoreDisplayed takes a few moments to
	catch up to the new value. Unless the level defines an onDrawScore function, in
	which case this property could mean or do anything.	
	*/
	int scoreDisplayed;
    /*
	Which set of animations the player uses, serving as an index to the jjAnimSets
	array. This is nearly a 1:1 mapping with charCurr, except that the two birds
	(CHAR::BIRD and CHAR::BIRD2) share a setID. The RABBIT::Anim enum is a
	version-independent list of all possible animations a rabbit player might use,
	expressed as indices of animations within the player's anim set. To see if a
	rabbit player p is currently standing still, for example, you can check if
	(p.curAnim - jjAnimSets[p.setID].firstAnim == RABBIT::STAND).	
	*/
	const ANIM::Set setID;
    /*
	How much longer (in ticks) the player's shield will last, or 0 if the player
	doesn't have a shield.	
	*/
	int shieldTime;
    /*
	Which shield the player currently has, assuming the player has a shield at all.
	In place of numbers, you may also use the dedicated SHIELD::Shield enum, options
	being NONE, FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. Using values from
	outside of the range of existing shields may be a reason of incompatibility with
	future versions of JJ2+ in case more shields are added.	
	*/
	int shieldType;
    /*
	How long the player has been performing their special move or 0 if the player is
	currently not using a special move.	
	*/
	int specialMove;
    /*
	Sprite mode the player's sprite is drawn in. Possible constants appear in the
	appendix below. Changes to this setting are automatically shared between all
	clients in the server.	
	*/
	SPRITE::Mode spriteMode;
    /*
	A sprite mode parameter further specifying how the player should be drawn.
	Changes to this setting are automatically shared between all clients in the
	server.	
	*/
	uint8 spriteParam;
    /*
	How much longer will the player be stoned, like after touching a smoke ring.	
	*/
	int stoned;
    /*
	Where the player's subscreen begins in the window. These will usually equal 0,
	but playing with more than one local player, in one of the two 3D modes, or
	both, may produce other numbers. For example, in a level with horizontal
	splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen
	will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the
	"subscreen" includes any black borders (as measured by jjBorderHeight and
	jjBorderWidth), so these properties are not necessarily the top left corner of a
	visible section of the level.	
	*/
	const int subscreenX;
    /*
	Where the player's subscreen begins in the window. These will usually equal 0,
	but playing with more than one local player, in one of the two 3D modes, or
	both, may produce other numbers. For example, in a level with horizontal
	splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen
	will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the
	"subscreen" includes any black borders (as measured by jjBorderHeight and
	jjBorderWidth), so these properties are not necessarily the top left corner of a
	visible section of the level.	
	*/
	const int subscreenY;
    /*
	The player's team in team-based game modes. Possible values are TEAM::BLUE,
	TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.	
	*/
	const TEAM::Color team;
    /*
	Incorrectly equals true whenever the player is not on the blue team, i.e.
	including if they're on green or yellow. Use the property above instead.	
	*/
	const bool teamRed;
    /*
	Should dying disable the Player Timer (false) or have no effect on it (true)?	
	*/
	bool timerPersists;
    /*
	The current state of the Player Timer (TIMER::STOPPED, TIMER::STARTED, or
	TIMER::PAUSED), for comparisons only. Use the corresponding timerStart,
	timerStop, timerPause, and timerResume methods to set this instead.	
	*/
	const TIMER::State timerState;
    /*
	How many ticks are left on the Player Timer.	
	*/
	int timerTime;
    /*
	If this number is higher than 0, the player is currently warping, and it will
	equal the ID of the Warp event plus one, a range of 1-256. It is often wise to
	make sure this property equals 0 before calling a warp method, lest the player
	be locked into a constant loop of beginning to warp but never finishing it.
	Something like if (conditionsForWarping && player.warpID == 0)
	player.warpToID(25);. Performing this check is however unnecessary for fast
	warps, or warps triggered by Text events, since that code is only called when
	the player first enters the tile.	
	*/
	const int warpID;
    /*
	Horizontal acceleration in pixels per game tick squared, positive or negative.	
	*/
	float xAcc;
    /*
	If this or yOrg are non-zero, where the player should respawn after death.	
	*/
	float xOrg;
    /*
	Horizontal location in pixels.	
	*/
	float xPos;
    /*
	Horizontal speed in pixels per game tick, positive or negative.	
	*/
	float xSpeed;
    /*
	Vertical acceleration in pixels per game tick squared, positive or negative.	
	*/
	float yAcc;
    /*
	If this or xOrg are non-zero, where the player should respawn after death.	
	*/
	float yOrg;
    /*
	Vertical location in pixels.	
	*/
	float yPos;
    /*
	Vertical speed in pixels per game tick, positive or negative.	
	*/
	float ySpeed;
    /*
	Activates all bosses and disables the player's sugar rush if applicable. Unlike
	the Activate Boss event, does not change the music track. (Use jjMusicLoad for
	that instead.) Setting activate to false will attempt to deactivate bosses, but
	this mostly only results in the boss health meter going away. The jjPLAYER
	object's boss is left unchanged unless you change it manually, and bosses do not
	stop moving around.	
	*/
	void activateBoss(bool activate = true);
    /*
	Fixes the camera in place, like when encountering a Robot Boss, until the
	corresponding cameraUnfreeze method is called. If instant is left false, the
	camera will take roughly half a second to scroll to its target. If centered is
	left false, the camera will position itself so that xPixel,yPixel is in the top
	left corner of the screen; otherwise, that position will be in the very center.
	In overloads containing xUnfreeze or yUnfreeze, their values determine whether
	the corresponding axis should be unfrozen by the function, allowing its free
	movement (true), or left unaffected (false). In particular,
	player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().	
	*/
	void cameraFreeze(float xPixel, float yPixel, bool centered, bool instant);
    /*
	Fixes the camera in place, like when encountering a Robot Boss, until the
	corresponding cameraUnfreeze method is called. If instant is left false, the
	camera will take roughly half a second to scroll to its target. If centered is
	left false, the camera will position itself so that xPixel,yPixel is in the top
	left corner of the screen; otherwise, that position will be in the very center.
	In overloads containing xUnfreeze or yUnfreeze, their values determine whether
	the corresponding axis should be unfrozen by the function, allowing its free
	movement (true), or left unaffected (false). In particular,
	player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().	
	*/
	void cameraFreeze(bool xUnfreeze, float yPixel, bool centered, bool instant);
    /*
	Fixes the camera in place, like when encountering a Robot Boss, until the
	corresponding cameraUnfreeze method is called. If instant is left false, the
	camera will take roughly half a second to scroll to its target. If centered is
	left false, the camera will position itself so that xPixel,yPixel is in the top
	left corner of the screen; otherwise, that position will be in the very center.
	In overloads containing xUnfreeze or yUnfreeze, their values determine whether
	the corresponding axis should be unfrozen by the function, allowing its free
	movement (true), or left unaffected (false). In particular,
	player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().	
	*/
	void cameraFreeze(float xPixel, bool yUnfreeze, bool centered, bool instant);
    /*
	Fixes the camera in place, like when encountering a Robot Boss, until the
	corresponding cameraUnfreeze method is called. If instant is left false, the
	camera will take roughly half a second to scroll to its target. If centered is
	left false, the camera will position itself so that xPixel,yPixel is in the top
	left corner of the screen; otherwise, that position will be in the very center.
	In overloads containing xUnfreeze or yUnfreeze, their values determine whether
	the corresponding axis should be unfrozen by the function, allowing its free
	movement (true), or left unaffected (false). In particular,
	player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().	
	*/
	void cameraFreeze(bool xUnfreeze, bool yUnfreeze, bool centered, bool instant);
    /*
	If cameraFreeze has been called, undoes the effect and lets the camera freely
	follow the player once again. If instant is left false, the camera will take
	roughly half a second to scroll to its target.	
	*/
	void cameraUnfreeze(bool instant = true);
    /*
	Returns true if the player's sprite collides with that of the specified object,
	otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide,
	using the positions, directions and curFrame properties of the player and object
	involved. No other variablesincluding playerHandling, bulletHandling, or
	the scale and rotation their sprites are drawn inare taken into account.	
	*/
	bool doesCollide(const jjOBJ@ object, bool always = false) const;
    /*
	A convenience method to extend the absolute value of the player's invincibility
	property by the absolute value of the duration parameter, which also makes
	invincibility positive (visible) if duration is visible. For example, collecting
	a full energy carrot extends invincibility by +350, whereas buttstomping most
	enemies extends invincibility by -70.	
	*/
	int extendInvincibility(int duration);
    /*
	Causes the player to fire, using either the specified ammo type or the current
	one. The return value will be the object ID of the new bullet, unless the weapon
	fires more than one bullet at a time. This action is visible for all players in
	an online server. Possible gun constants may be found in the appendix at the
	bottom of the page, or you may use simple 1-indexed numbers instead (all values
	besides 1-9 will evaluate to WEAPON::CURRENT). If depleteAmmo is false, the
	method will not affect how much of the ammo type the player has remaining. If
	requireAmmo is false, the player can fire a bullet of that type even if they
	don't have any ammo of that type.	
	*/
	int fireBullet(uint8 gun = WEAPON::CURRENT, bool depleteAmmo = true, bool requireAmmo = true, DIRECTION::Dir direction = DIRECTION::CURRENT);
    /*
	Causes the player to fire, using either the specified ammo type or the current
	one. The return value will be the object ID of the new bullet, unless the weapon
	fires more than one bullet at a time. This action is visible for all players in
	an online server. Possible gun constants may be found in the appendix at the
	bottom of the page, or you may use simple 1-indexed numbers instead (all values
	besides 1-9 will evaluate to WEAPON::CURRENT). If depleteAmmo is false, the
	method will not affect how much of the ammo type the player has remaining. If
	requireAmmo is false, the player can fire a bullet of that type even if they
	don't have any ammo of that type. Possible values for direction are
	DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If
	mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the
	mouse cursor is at, rather than whichever direction the player is physically
	facing. Alternatively you may pass a float angle argument instead of an
	orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is
	down, 1.5 * pi is left, and 2 * pi is up again.	
	*/
	int fireBullet(uint8 gun, bool depleteAmmo, bool requireAmmo, float angle);
    /*
	Freezes the player for the same length of time as the Freeze Enemies pickup, or
	unfreezes the player if frozen is set to false. Helper method.	
	*/
	void freeze(bool frozen = true);
    /*
	Sets provided parameters' values to palette indexes of the player's fur colors.	
	*/
	void furGet(uint8 a, uint8 b, uint8 c, uint8 d) const;
    /*
	Sets player's fur colors to those represented by provided palette indexes.
	Changes made by this method are automatically shared between all clients in the
	server. Clients are not allowed to change the fur colors of non-local players,
	but servers or local games can change the colors of any player (even if their
	jjPLAYER::isActive is false), which can be useful for drawing sprites using
	SPRITE::PLAYER.	
	*/
	void furSet(uint8 a, uint8 b, uint8 c, uint8 d);
    /*
	Returns a value expressing whether the player is currently in a state to harm
	objects or other players, equivalent to the "force" argument in objectHit or the
	onObjectHit hook/method. Specifically, this method returns -1 if the player is
	performing a special move and the canHurt property of their respective
	jjCHARACTER is true, 1 if the player is buttstomping or has a sugar rush, or 0
	if none of the above are true. Doesn't work especially well when called on
	non-local players. If a non-null jjOBJ@ is specified as target, two additional
	checks will be performed, returning -101 if the object is frozen and the player
	is running into it really fast, or -1 if the player is a frog (with a true
	canHurt) hitting the object with its tongue.	
	*/
	int getObjectHitForce(const jjOBJ@ target = null) const;
    /*
	Checks whether the player has the specified privilege within the script module
	moduleID. Privileges are specified in the admin configuration file (typically
	admin.ini) and serve as a way to determine what actions specific admin groups
	are allowed to take. You can read more about them in the Remote Admin section of
	the JJ2+ readme. Because privileges are only known to the host, this function
	will always return false if called client-side. The function will always return
	false for players who are not logged in, and will always return true if the
	player is the host or the game is local. If the privilege string contains
	invalid characters, i.e. anything besides letters, digits, underscores ('_'),
	full stops ('.'), and hyphens ('-'), or if moduleID is not valid, the function
	will also return false. In all other cases, i.e. if called server-side for a
	logged in client and with valid parameters, privileges obtained from the admin
	configuration file will be tested for a match, and if one is found, the function
	will return true, otherwise false.	
	*/
	bool hasPrivilege(const string privilege, uint moduleID = jjScriptModuleID) const;
    /*
	Attempts to hurt the player damage hearts, or at least strip the player of their
	bird or reduce their shield time. If attacker is left null, or if it's the same
	player as the one getting hurt, the injury will be counted as coming from the
	level, and if a death results, it will be marked online with the "ate it/you
	killed yourself" text. This is what you should do for injuries from enemies and
	other level-based factors. On the other hand, if the player dies from the hurt
	call and attacker is another player in the server, that player will get credit
	for the roast. Returns false if neither the hurtee nor the hurter are local
	players and the method is not called by the host, or if forceHurt (which
	bypasses traditional safety sources like the invincibility and blink properties
	and buttstomping) is false and something or other prevents the hurting from
	happening.	
	*/
	bool hurt(int8 damage = 1, bool forceHurt = false, jjPLAYER@ attacker = null);
    /*
	Returns true iff victim is a player who can be hurt by this player's bullets or
	other attacks, according to the rules of the current gamemode. Potentially
	useful if you are writing a custom weapon behavior and don't want to use
	HANDLING::PLAYERBULLET. The following conditions will cause this method to
	return false: the two jjPLAYER objects are the same player; the gamemode is
	Single Player or Cooperative; in a team-based game, the two players are on the
	same team and jjFriendlyFire is false; in Roast Tag, Eva's Ring has been
	captured, yet neither player is jjTokenOwner or jjBottomFeeder; in Pestilence,
	either both players are zombies or neither are zombies but
	jjDoZombiesAlreadyExist is false; or in Jailbreak, victim is in jail. Again,
	this method checks only gamemode-related conditions. (And if more gamemodes are
	added in the future, this method will be updated to reflect them.) It does not
	check jjPLAYER::isInGame, jjGameState, or anything that might cause
	jjPLAYER::hurt to return false if its forceHurt parameter is left false.	
	*/
	bool isEnemy(const jjPLAYER victim) const;
    /*
	Kills the player instantly. If you want the player to be roasted by some other
	player in an online server, use hurt with a high damage value instead.	
	*/
	void kill();
    /*
	Works like a Limit X Scroll event with the corresponding Left and Width
	parameters. Remember that these are measured in tiles, not pixels.	
	*/
	void limitXScroll(uint16 left, uint16 width);
    /*
	Cycles the player's character to the next on the list, just like the JJMORPH
	cheat: Jazz-Spaz-(Lori-)Bird-Frog-Bird2. Or if rabbitsOnly is true, skips birds
	and frog and acts like a morph monitor instead, restricting available morph
	targets to those whose jjCHARACTER::morphBoxCycle properties equal true. Returns
	the player's new character: CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD,
	CHAR::FROG or CHAR::BIRD2.	
	*/
	CHAR::Char morph(bool rabbitsOnly = false, bool morphEffect = true);
    /*
	Sets the player's character to charNew, possible values CHAR::JAZZ, CHAR::SPAZ,
	CHAR::LORI (in TSF), CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.	
	*/
	CHAR::Char morphTo(CHAR::Char charNew, bool morphEffect = true);
    /*
	Causes the game to think the player is colliding with object target, even if
	they are not in the same area, and returns true if (generally speaking) the
	object is affected somehow. Calling this method on a non-local player will
	return false unless called by the host of a server. The force parameter hints at
	whether the player should be able to damage the object, if the object can be
	damaged to begin with. A value of 0 means that the player is simply bumping into
	the object at random; 1 means a buttstomp or sugar rush; -1 means a special
	move; and -101 means the object is frozen and the player runs into it really
	fast. If you want this parameter to reflect reality, get the value from
	jjPLAYER's getObjectHitForce method. The playerHandling parameter specifies how
	the player should interact with the objectfor example, passing
	HANDLING::PICKUP will force the player to treat the object as a pickup, even if
	its actual playerHandling property is set to something else. If the value is not
	HANDLING::ENEMY, HANDLING::SPECIAL, HANDLING::PICKUP, HANDLING::ENEMYBULLET, or
	HANDLING::PLAYERBULLET, nothing will happen. If the value is one of the first
	three and the object has scriptedCollisions set to true, some version of
	onObjectHit will be called with a null bullet argument, this jjPLAYER as player,
	and whatever force you call this method with as force. The results of this
	collision will be broadcast to other players in the server exactly as if it had
	happened naturally through the sprites colliding. For example, collecting a
	pickup object half the level away will cause other players to see the pickup
	disappear.	
	*/
	bool objectHit(jjOBJ@ target, int force, HANDLING::Player playerHandling);
    /*
	Instantly moves the player xPixels pixels to the right and yPixels pixels down.
	The camera instantly readjusts itself to follow, as does the glowing trace
	following the player while running and any companion bird the player may have.
	The best way of creating seamlessly looping levels.	
	*/
	bool offsetPosition(int xPixels, int yPixels);
    /*
	Causes the player to appear to swing around a pole for delay ticks, then launch
	off at the specified speed/s. For reference, an H-Pole event increases the
	absolute value of your existing xSpeed by 8 (but not above 20), while a V-Pole
	event increases the absolute value of your existing ySpeed by 16, with both
	using the default delay value of 70 ticks (=one second). An H-Pole passes 0 for
	ySpeed, and a V-Pole passes 0 for xSpeed, but you may use non-orthogonal
	directions with this method if you'd rather.	
	*/
	void poleSpin(float xSpeed, float ySpeed, uint delay = 70);
    /*
	Resets player's ambient lighting value to the level's default.	
	*/
	uint8 resetLight();
    /*
	Reverts the player to the character they were when they began the level, just
	like the Revert Morph event. If morphEffect is true, displays the default visual
	effect. Returns the new character (equal to the player's charOrig).	
	*/
	CHAR::Char revertMorph(bool morphEffect = true);
    /*
	Sets the player's name. This method will only succeed if called server-side or
	in a local game, and it will then return true to indicate success. Otherwise no
	change will occur and the method will return false.	
	*/
	bool setName(const string name);
    /*
	Sets the player's score. While setting the score through the score property is
	slightly delayed as scoreDisplayed increases/decreases to catch up to the new
	value, this function sets both properties at once. Probably most helpful as a
	function for quickly showing you debug information.	
	*/
	int setScore(int score);
    /*
	Displays text on the player's screen either like a Text event, with the
	corresponding textID and offset parameters, or simply a specified text. Unique
	size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear
	in one size character set may appear in another; for instance, the underscore
	character is unique to SIZE::SMALL. To access text in help strings with specific
	ID, use jjHelpStrings instead.	
	*/
	void showText(uint8 textID, uint8 offset, STRING::Size size = STRING::SMALL);
    /*
	Displays text on the player's screen either like a Text event, with the
	corresponding textID and offset parameters, or simply a specified text. Unique
	size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear
	in one size character set may appear in another; for instance, the underscore
	character is unique to SIZE::SMALL. To access text in help strings with specific
	ID, use jjHelpStrings instead.	
	*/
	void showText(string text, STRING::Size size = STRING::SMALL);
    /*
	Simulates the player touching and getting bounced by a Spring object. For
	reference, the absolute values of red, green, and blue springs' speeds are 16,
	24, and 32 respectively: for example, an upward-facing red spring uses xSpeed 0
	and ySpeed -16. The keepZeroSpeeds argument affects what happens if either speed
	axis is left at 0, equivalent to the "Keep X-Speed" and "Keep Y-Speed" event
	parameters: if keepZeroSpeeds is false, the player's speed on that axis will be
	set to 0, but if true, it will be left at its value prior to spring being
	called. If sample is true, a sample will be chosen (from among
	SOUND::COMMON_SPRING1, SOUND::SPRING_BOING_DOWN, and SOUND::SPRING_SPRING1) and
	played depending on the xSpeed and ySpeed values, and if the player is Spaz,
	SOUND::SPAZSOUNDS_YAHOO2 may be played as well.	
	*/
	void spring(float xSpeed, float ySpeed, bool keepZeroSpeeds, bool sample);
    /*
	Gives the player a sugar rush lasting time ticks, unless their bossActivated
	property equals true, in which case the method returns false. Otherwise returns
	true. In online multiplayer, jjSugarRushAllowed should be true for the host, or
	else clients who call this method may be kicked.	
	*/
	bool startSugarRush(int time = 1400);
    /*
	Simulates the player touching a Sucker Tube event with the same parameter names
	and values (with noclip referring to "BecomeNoclip", not "Noclip Only"). For
	each axis this method instructs the player to move along, the center parameter
	first puts the player in the center of their current tile on the other
	axistherefore, passing true is generally safe, but it will get the player
	stuck if trying to move diagonally every single tick. In normal JJ2, center is
	true for the first tick the player spends in the tile with the sucker tube
	event, and false every tick thereafter.	
	*/
	void suckerTube(int xSpeed, int ySpeed, bool center, bool noclip = false, bool trigSample = false);
    /*
	If the player has at least numberOfCoins coins, depletes their coins by
	numberOfCoins and returns true. Otherwise displays a warning onscreen that they
	need more coins to continue and returns false. Basically the same as a coin warp
	event, but you get to choose the result.	
	*/
	bool testForCoins(int numberOfCoins);
    /*
	If the player has at least numberOfGems type-colored gems, depletes their type
	gems by numberOfGems and returns true. Otherwise displays a warning onscreen
	that they need more gems to continue and returns false. Basically the same as a
	coin warp event, but you get to choose the result, and it's for gems instead of
	coins. Possible values of type are GEM::RED, GEM::GREEN, GEM::BLUE, and
	GEM::PURPLE.	
	*/
	bool testForGems(int numberOfGems, GEM::Color type);
    /*
	When the Player Timer hits zero without being stopped artifically, AngelScript
	will call the function named by this method (a string is acceptable, but
	pointing directly to the function is advised instead), setting the (technically
	optional) jjPLAYER@ property to point to the player whose Player Timer just
	expired. This defaults to onPlayerTimerEnd, aka void
	onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide
	what should happen to the player.	
	*/
	void timerFunction(string functionName);
    /*
	When the Player Timer hits zero without being stopped artifically, AngelScript
	will call the function named by this method (a string is acceptable, but
	pointing directly to the function is advised instead), setting the (technically
	optional) jjPLAYER@ property to point to the player whose Player Timer just
	expired. This defaults to onPlayerTimerEnd, aka void
	onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide
	what should happen to the player.	
	*/
	void timerFunction(jjVOIDFUNC@ function);
    /*
	When the Player Timer hits zero without being stopped artifically, AngelScript
	will call the function named by this method (a string is acceptable, but
	pointing directly to the function is advised instead), setting the (technically
	optional) jjPLAYER@ property to point to the player whose Player Timer just
	expired. This defaults to onPlayerTimerEnd, aka void
	onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide
	what should happen to the player.	
	*/
	void timerFunction(jjVOIDFUNCPLAYER@ function);
    /*
	Pauses the Player Timer and returns TIMER::PAUSED.	
	*/
	TIMER::State timerPause();
    /*
	Resumes the Player Timer and returns TIMER::STARTED.	
	*/
	TIMER::State timerResume();
    /*
	Begins the Player Timer (and optionally pauses it) with ticks ticks remaining on
	the clock. Returns TIMER::STARTED or TIMER::PAUSED, depending.	
	*/
	TIMER::State timerStart(int ticks, bool startPaused = false);
    /*
	Stops the Player Timer and returns TIMER::STOPPED.	
	*/
	TIMER::State timerStop();
    /*
	Warps the player to a Warp Target event with the specified Warp ID, instantly if
	fast is true or using the standard warp effect if fast is false.	
	*/
	bool warpToID(uint8 warpID, bool fast = false);
    /*
	Warps the player to the specified tile, instantly if fast is true or using the
	standard warp effect if fast is false.	
	*/
	bool warpToTile(int xTile, int yTile, bool fast = false);
};

class jjOBJ {
    /*
	A variable totally unused by JJ2. The name comes from its original intended
	purpose as indicating how long had elapsed since the object was created.	
	*/
	int age;
    /*
	Intended to determine how fast the object animates. However, only gem rings,
	speed destruct scenery, and collapse scenery actually use this property for that
	purpose, and all other non-bullet objects leave it untouched. BULLETS: This
	property stores the amount of damage a bullet does to enemies, e.g. 1 for normal
	blaster, 2 for normal seekers, or 3 for certain shield bullets.	
	*/
	int animSpeed;
    /*
	Which function is called for this object's behavior. See jjBEHAVIORINTERFACE. In
	order to avoid common bugs, it's strongly discouraged to modify behavior of
	objects of eventID OBJECT::GENERATOR, and especially of
	jjObjectPresets[OBJECT::GENERATOR]. Currently a great portion of game code tests
	it against BEHAVIOR::GENERATOR and if it doesn't succeed, it may take unexpected
	actions, typically involving kicking and banning clients for invalid weapons.
	Similarly, replacing BEHAVIOR::DIAMONDSAREFOREVER is liable to break Treasure
	Hunt or Head Hunters games. Replacing BEHAVIOR::DESTRUCTSCENERY,
	BEHAVIOR::TRIGGERSCENERY, or BEHAVIOR::SUPERGEM will normally prevent the states
	of those objects from being shared with newly joining clients in online servers,
	but this can be circumvented by replacing them with
	jjBEHAVIORINTERFACE-implementing classes that define onGetActive/onSetActive
	methods appropriately.	
	*/
	BEHAVIOR::Behavior behavior;
    /*
	What happens when a bullet (or turtle shell, or TNT blast, or attacking bird)
	comes into contact with this object, assuming that playerHandling is either
	ENEMY or SPECIAL and state is anything other than KILL? HURTBYBULLET: If this
	object has a non-zero energy property, then hitting it will decrease its energy
	by the force of the bullet. If the object is frozen, it will be unfrozen. If the
	object's energy sinks to 0 or less, its state will change to STATE::KILL and the
	player behind the bullet will receive the object's points. Otherwise, its
	justHit property will be set to 5. The bullet will be destroyed unless it has
	bit 16 set for its var[6], like fireball bullets do, or if the object has
	causesRicochet as true. If the object's playerHandling is SPECIAL, other things
	may happen. IGNOREBULLET: The object will be unaffected in every way by the
	collision, and the bullet will not be destroyed. DESTROYBULLET: The object will
	be unaffected in every way by the collision, and the bullet will be destroyed no
	matter what its properties are. DETECTBULLET: The object is by default
	unaffected, but the bullet will be destroyed unless it has bit 16 set for its
	var[6], like fireball bullets do, or if the object has causesRicochet as true.
	If the object's playerHandling is SPECIAL, other things may happen.	
	*/
	HANDLING::Bullet bulletHandling;
    /*
	When true, colliding bullets will ricochet off of this object unless
	bulletHandling is set to DESTROYBULLET.	
	*/
	bool causesRicochet;
    /*
	A general purpose property, usually used for counting up or down to some future
	event.	
	*/
	int counter;
    /*
	A general purpose property, usually used for counting up or down to some future
	event. Only goes up to 255, so not as versatile as counter. BULLETS: how long a
	bullet will exist before exploding. Used by pretty much every bullet behavior
	but BEHAVIOR::BOLLYBULLET, although no behavior-external code seems to reference
	it specifically.	
	*/
	uint8 counterEnd;
    /*
	The sum of the creatorID and creatorType properties, which is less useful than
	you might hope.	
	*/
	int creator;
    /*
	The object ID or player ID of the object or player that created this object, as
	usable as the index for jjObjects or jjPlayers. 0 if no creator is actually
	known.	
	*/
	int creatorID;
    /*
	CREATOR::OBJECT if the object was created by another object, CREATOR::PLAYER if
	it was created by a player, or CREATOR::LEVEL if it was added directly from the
	event map. If the object was created by a Generator object specifically, then
	creatorType will equal CREATOR::LEVEL, but creatorID will equal the object ID of
	that Generator object rather than 0.	
	*/
	CREATOR::Type creatorType;
    /*
	The current animation the object takes its frames from; an index for the
	jjAnimations array. You can obtain useful values for this from the
	determineCurAnim method or else any jjANIMSET::firstAnim.	
	*/
	int16 curAnim;
    /*
	The overall current frame displayed to the screen to represent this object,
	taking into account both curAnim and frameID; an index for the jjAnimFrames
	array. You can obtain useful values for this from the determineCurFrame method
	or else any jjANIMATION::firstFrame.	
	*/
	uint curFrame;
    /*
	When true, this object will be deleted from memory if the player wanders too far
	away from it in local single player mode, and all its properties will be reset
	next time it gets loaded. This property has absolutely no effect in multiplayer,
	and setting it to false cannot force an object to remain in memory in single
	player when the player dies.	
	*/
	bool deactivates;
    /*
	Which way the object is facing. Generally, direction >= 0 is right and < 0 is
	left. Some objects may also correctly interpret SPRITE::Direction constants:
	SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV but the ones
	involving vertical flip will not be perfectly reliable for objects without
	custom behavior, except for box objects (crates, barrels, monitors), which will
	take vertically flipped direction values as a cue to fall upwards instead of
	downwards.	
	*/
	int8 direction;
    /*
	A variable totally unused by JJ2. The name comes from its original intended
	purpose as specifying whether boss objects could hurt the player.	
	*/
	uint8 doesHurt;
    /*
	If this object's playerHandling value is HANDLING::ENEMY, this number is how
	many more hits the object can take before it is destroyed, unless it equals 0,
	in which case the object is invincible to bullets (but not to special attacks).
	This property is also used to determine the fullness of the boss bar.	
	*/
	int8 energy;
    /*
	e.g. 158 for a peach, 43 for a bomb, 243 for an airboard, 1 for a blaster
	bullet, and so on. Is a uint8 for maximum flexibility, but you should probably
	set/compare it to OBJECT::Object constants instead most of the time, if for no
	other reason than readability. While this value is not strictly
	constant/read-only, changing it can lead to unpredictable and undesirable
	effects, since this is the only truly reliable way of knowing what kind of
	object a given jjOBJ really is, and JJ2 queries it very frequently. The effects
	can vary from a food pickup playing the wrong sound effect when collected to,
	say, a red spring simply not working at all when touched. You have been warned.	
	*/
	uint8 eventID;
    /*
	The object's current frame within a single animation set, e.g. which direction
	the Tube Turtle faces while it rotates in place.	
	*/
	int8 frameID;
    /*
	0 if the object is unfrozen, otherwise counts down to 0 for most behaviors,
	though you'll need to implement that manually if writing your own.	
	*/
	uint8 freeze;
    /*
	Does this jjOBJ correspond to a real object, or is it just the abandoned memory
	of one? For any jjOBJ o, (o.isActive) is the same as (o.behavior !=
	BEHAVIOR::INACTIVE), but one is obviously much shorter than the other.	
	*/
	const bool isActive;
    /*
	When true, nearby TNT explosions will set this object's xSpeed and ySpeed
	properties.	
	*/
	bool isBlastable;
    /*
	When false, this object will treat ice bullets just the same as any other bullet
	with the same properties. This is what Caterpillar and Queen do, for example.	
	*/
	bool isFreezable;
    /*
	When true, this object will be attacked by birds and seeker missiles.	
	*/
	bool isTarget;
    /*
	When this property has a non-zero value, most objects will be drawn as pure
	white until the property counts back down to 0 one tick at a time. JJ2
	deincrements this property for all objects, so you needn't worry about it when
	defining your own behavior functions.	
	*/
	uint8 justHit;
    /*
	Which animation the object uses while being destroyed, in the same format as
	curAnim.	
	*/
	int16 killAnim;
    /*
	The intensity of the light produced by the object.	
	*/
	int8 light;
    /*
	The type of light produced by the object. Possible values are NONE, NORMAL,
	POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER.	
	*/
	LIGHT::Type lightType;
    /*
	If the object is frozen, what state it was in before it was frozen. Possible
	constants are listed in the appendix at the end of this file.	
	*/
	STATE::State oldState;
    /*
	How does this object interact with the rest of the game, most specifically
	coming into contact with players, although also bullets? ENEMY: If a player
	touches this object, they will be hurt (barring invincibility and such), unless
	they are using a special attack, in which case the object's energy property will
	decrease by 4. If energy reaches 0 or lower, the object's state will be set to
	KILL and the player will receive its points. Objects of playerHandling
	PLAYERBULLET that come into contact with this object have the potential to
	collide with it, depending on its bulletHandling setting. PLAYERBULLET: When the
	object's state is anything but START or EXPLODE, this object will constantly be
	checked for collision with players other than its creatorID, as well as objects
	with playerHandling ENEMY, PICKUP, or SPECIAL. ENEMYBULLET: When the object's
	state is anything but START or EXPLODE, if a player touches this object, they
	will be hurt (barring invincibility and such). PARTICLE: Effect unknown
	(semantic only?) EXPLOSION: Effect unknown (semantic only?) PICKUP: If a player
	touches this object, something special will happen, exactly what depending on
	its eventID value. Usually if nothing else the player will receive its points,
	and its behavior will be set to BEHAVIOR::EXPLOSION2, though sometimes (e.g.
	carrots when touched by a player with full health) nothing will happen at all.
	If the object has scriptedCollisions set to true, that will override the effect
	of the eventID value. Should it have 0 xSpeed/ySpeed properties and be
	overlapped by an object of playerHandling PLAYERBULLET whose state is not START
	or EXPLODE, the pickup object will partially inherit that bullet object's speed
	and direction. DELAYEDPICKUP: Effect unknown (semantic only?) HURT: Effect
	unknown (semantic only?) SPECIAL: Whenever this object is overlapped by a player
	or an object of playerHandling PLAYERBULLET (depending in the latter case on
	this object's bulletHandling value), something special will happen, exactly what
	depending on its eventID value. If the object has scriptedCollisions set to
	true, that will override the effect of the eventID value. DYING: Effect unknown
	(semantic only?) SPECIALDONE: Effect unknown (semantic only?) SELFCOLLISION:
	Effect unknown (semantic only?)	
	*/
	HANDLING::Player playerHandling;
    /*
	How many points a player will gain for destroying the object.	
	*/
	uint16 points;
    /*
	Instead, use the properties bulletHandling, causesRicochet, isFreezable, and
	isBlastable.	
	*/
	int8 noHit;
    /*
	For all values of n such that n < jjObjectMax, jjObjects[n].objectID == n.	
	*/
	const uint16 objectID;
    /*
	Instead, use the properties playerHandling, isTarget, triggersTNT, deactivates,
	and scriptedCollisions.	
	*/
	uint8 objType;
    /*
	When true, JJ2 will call some version of onObjectHit to determine what to do if
	a bullet or player is detected as having collided with this object. See
	jjBEHAVIORINTERFACE. This property's effect if playerHandling is anything other
	than ENEMY, PICKUP, or SPECIAL is presently undefined.	
	*/
	bool scriptedCollisions;
    /*
	A general-purpose variable, means different things for different objects.
	BULLETS: This property stores the animation (curAnim-style) that is used if the
	bullet is shot upwards, not horizontally. If this property equals 0, it will not
	be possible to shoot the bullet upwards except by mouse aiming; this is how
	shields work.	
	*/
	int special;
    /*
	The current state of the state machine that is the object. Possible constants
	are listed in the appendix at the end of this file.	
	*/
	STATE::State state;
    /*
	When true, TNT will explode if this object is nearby.	
	*/
	bool triggersTNT;
    /*
	A series of general-purpose variables, used for different things by different
	objects. In general, earlier values are more likely to be used by the game's
	native behavior functions than later ones. BULLETS: var[3] represents what ammo
	type the bullet is, 1-9, which is primarily used for destroying destruct scenery
	with a non-zero "Weapon" parameter. var[6] is used as a series of boolean flags
	that specify how the bullet interacts with various objects: bit 2 for fire-based
	bullets which can melt springs and burn enemies into fire/smoke particles; bit 4
	for the laser shield's laser; bit 8 for bullets that do two damage in
	multiplayer; and bit 16 for bullets that pass through enemies, like the
	fireball, rather than explode on impact. var[7] is the xSpeed that the player
	who fired this bullet was moving at when the bullet was fired, reduced to a
	range of -88... multiplied by 65536. Sorry about that. var[9] is a counter
	for how many times the bullet has ricocheted in its lifetime, beginning at 0.
	var[10] is a counter for how long it's been since the bullet has last
	ricocheted; each ricochet resets it to 0, but traditional bullet behaviors
	constantly increment it, and a bullet cannot ricochet if the value is less than
	8.	
	*/
	array<int> var = array<int>(11);
    /*
	Horizontal acceleration in pixels per game tick squared, positive or negative.	
	*/
	float xAcc;
    /*
	Original horizontal location in pixels.	
	*/
	float xOrg;
    /*
	Current horizontal location in pixels.	
	*/
	float xPos;
    /*
	Horizontal speed in pixels per game tick, positive or negative.	
	*/
	float xSpeed;
    /*
	Vertical acceleration in pixels per game tick squared, positive or negative.	
	*/
	float yAcc;
    /*
	Current vertical location in pixels.	
	*/
	float yPos;
    /*
	Original vertical location in pixels.	
	*/
	float yOrg;
    /*
	Vertical speed in pixels per game tick, positive or negative.	
	*/
	float ySpeed;
    /*
	Causes this jjOBJ to perform the specified jjBEHAVIOR function, or its own
	behavior property if behavior is set to BEHAVIOR::DEFAULT. If draw is false, it
	will not draw anything to the screen. See jjBEHAVIORINTERFACE.	
	*/
	void behave(BEHAVIOR::Behavior behavior = BEHAVIOR::DEFAULT, bool draw = true);
    /*
	Makes the object act as a platform for players. Unlike beSolid, this method will
	only cause interactions with players on top of the object and not on its sides.
	Additionally, this method better accounts for the object's self-induced
	movement. The parameters xOld and yOld should be set to horizontal and vertical
	position of the object in the previous tick, whereas the jjOBJ properties xPos
	and yPos will be used for its current position. The remaining two parameters,
	width and height, should indicate the platform's dimensions in pixels. The
	default value of 0 will result in dimensions chosen automatically based on the
	size of the object's curFrame.	
	*/
	void bePlatform(float xOld, float yOld, int width = 0, int height = 0);
    /*
	Causes this jjOBJ to serve as a solid block for players trying to move into it.
	Used by crates, monitors, etc. Returns -1 if a player is trying to push the
	object to the left, 1 if a player is trying to push it to the right, or
	otherwise 0, in case you wish to write some code to make the object pushable. If
	shouldCheckForStompingLocalPlayers is true, any local players who are landing on
	this object while buttstomping get an additional chance to destroy this object
	before landing, effectively by calling jjPLAYER::objectHit. If the collision
	changes this object's state to either STATE::ACTION or STATE::KILL,
	jjOBJ::behave() will be called.	
	*/
	int beSolid(bool shouldCheckForStompingLocalPlayers = false);
    /*
	Sends all players within maxDistance of the object flying away, like RFs or
	Bombs do when they explode. If creatorType equals CREATOR::PLAYER and players
	can currently hurt each other, the blast will hurt nearby players unless their
	playerID is equal to this object's creatorID. If blastObjects is true, then
	other jjOBJs within maxDistance whose isBlastable property equals true will be
	damaged and/or sent flying, just like when a TNT object explodes.	
	*/
	void blast(int maxDistance, bool blastObjects);
    /*
	Causes all local players that are currently standing on top of this object or
	pushing it to no longer be standing on top of it or pushing it. Should be called
	when deleting an object that calls bePlatform or beSolid.	
	*/
	void clearPlatform();
    /*
	A wrapper method, called by most objects when their state property equals
	DEACTIVATE: obj.delete(); if(obj.creatorType == CREATOR::LEVEL) {
	jjEventSet(obj.xOrg/32, obj.yOrg/32, obj.eventID); jjParameterSet(obj.xOrg/32,
	obj.yOrg/32, -1, 1, 0); }	
	*/
	void deactivate();
    /*
	Permanently deletes the object. Like jjAddObject, this method is purely local in
	its scope.	
	*/
	void delete();
    /*
	Determines the value of the curAnim corresponding to Set ID setID and Animation
	animation as seen in Jazz Sprite Dynamite. (0-indexed.) If change is specified
	as false, this serves as essentially a static method, calculating the proper
	curAnim value but not actually setting this particular jjOBJ's curAnim to that
	value. You are allowed to use a simple uint8 to specify the setID, but an
	ANIM::Set constant is strongly recommended, since the values for certain sets
	differ between 1.23 and 1.24. The full list of constants can be found in the
	appendix at the bottom of this file. Internally, this method runs the following
	code: if (jjAnimSets[setID].firstAnim == 0) //not yet loaded
	jjAnimSets[setID].load(); //load from anims.j2a or plus.j2a, depending on setID
	const int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation; if
	(change) this.curAnim = newCurAnimValue; return newCurAnimValue;	
	*/
	int16 determineCurAnim(uint8 setID, uint8 animation, bool change = true);
    /*
	Determines the value of the curAnim corresponding to Set ID setID and Animation
	animation as seen in Jazz Sprite Dynamite. (0-indexed.) If change is specified
	as false, this serves as essentially a static method, calculating the proper
	curAnim value but not actually setting this particular jjOBJ's curAnim to that
	value. You are allowed to use a simple uint8 to specify the setID, but an
	ANIM::Set constant is strongly recommended, since the values for certain sets
	differ between 1.23 and 1.24. The full list of constants can be found in the
	appendix at the bottom of this file. Internally, this method runs the following
	code: if (jjAnimSets[setID].firstAnim == 0) //not yet loaded
	jjAnimSets[setID].load(); //load from anims.j2a or plus.j2a, depending on setID
	const int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation; if
	(change) this.curAnim = newCurAnimValue; return newCurAnimValue;	
	*/
	int16 determineCurAnim(ANIM::Set setID, uint8 animation, bool change = true);
    /*
	Determines the value of the curFrame corresponding to this jjOBJ's current
	curAnim and frameID values. If change is specified as false, this calculates the
	proper value but does not actually set this particular jjOBJ's curFrame property
	to that value. Internally, this method runs the following code: const
	jjANIMATION@ animation = jjAnimations[this.curAnim]; const uint newCurFrameValue
	= (animation.frameCount == 0) ? 0 : (animation.firstFrame + (this.frameID %
	animation.frameCount)); if (change) this.curFrame = newCurFrameValue; return
	newCurFrameValue;	
	*/
	uint determineCurFrame(bool change = true);
    /*
	Returns true if the object's sprite collides with that of the specified object
	or player, otherwise false. This is a convenient wrapper for
	jjANIMFRAME::doesCollide, using the positions, directions and curFrame
	properties of the player and object involved. No other variablesincluding
	playerHandling, bulletHandling, or the scale and rotation their sprites are
	drawn inare taken into account.	
	*/
	bool doesCollide(const jjOBJ@ object, bool always = false) const;
    /*
	Returns true if the object's sprite collides with that of the specified object
	or player, otherwise false. This is a convenient wrapper for
	jjANIMFRAME::doesCollide, using the positions, directions and curFrame
	properties of the player and object involved. No other variablesincluding
	playerHandling, bulletHandling, or the scale and rotation their sprites are
	drawn inare taken into account.	
	*/
	bool doesCollide(const jjPLAYER@ player, bool always = false) const;
    /*
	Essentially a wrapper for jjDrawSpriteFromCurFrame; uses the jjOBJ's xPos, yPos,
	direction, freeze, justHit, and curFrame properties to determine where to draw
	the sprite and what mode to use. This isn't specific enough for all objects, but
	it does the job in a high percentage of cases.	
	*/
	int draw();
    /*
	Returns the playerID property of the nearest jjPLAYER object within maxDistance,
	or a negative number if none exist. If the foundDistance parameter is included,
	it will be set to the distance of the found jjPLAYER. Both maxDistance and
	foundDistance are actually squares of the distance expressed in pixels. Used by
	numerous enemies and other objects in order to react to nearby players.	
	*/
	int findNearestPlayer(int maxDistance) const;
    /*
	Returns the playerID property of the nearest jjPLAYER object within maxDistance,
	or a negative number if none exist. If the foundDistance parameter is included,
	it will be set to the distance of the found jjPLAYER. Both maxDistance and
	foundDistance are actually squares of the distance expressed in pixels. Used by
	numerous enemies and other objects in order to react to nearby players.	
	*/
	int findNearestPlayer(int maxDistance, int foundDistance) const;
    /*
	A much-simplified version of jjAddObject. This method creates a new object of
	type eventID, directly at the "gunspot" position of the jjOBJ's current curFrame
	sprite, and sets its direction, xSpeed, and xAcc based on the jjOBJ's direction.
	The return value is the object ID of the new bullet object, or 0 if the method
	was unsuccessful. Used by dragons, hatters, Bilsy, and so on.	
	*/
	int fireBullet(OBJECT::Object eventID) const;
    /*
	Potentially creates a random pickup (red gem, green gem, blue gem, or carrot) in
	front of the jjOBJ, the likelihood depending on frequency (higher values are
	less likely). Traditionally, this method is called when an enemy or crate is
	destroyed by a bullet, and frequency equals 5 if the bullet was an unpowered-up
	blaster bullet or otherwise 10. The player parameter is necessary because one in
	every eight pickups a player is granted is a fastfire instead, so JJ2 needs to
	be able to keep track of when each individual player should next receive a
	fastfire. Only works if creatorType equals CREATOR::LEVEL.	
	*/
	void grantPickup(jjPLAYER@ player, int frequency) const;
    /*
	Assumes that this object is a player bullet colliding with object target, even
	if they are not in the same area or if this object is not actually
	HANDLING::PLAYERBULLET. You are allowed to set what HANDLING::Player value the
	target object will be treated as havingHANDLING::ENEMY, HANDLING::SPECIAL,
	or HANDLING::PICKUP, with all other values having no effectbut otherwise
	the code will run exactly as if the two objects really did collide. Effects may
	or may not be broadcast to other players in the server, and some version of
	onObjectHit will be called (with force as this object's animSpeed property) iff
	target has scriptedCollisions set to true and HANDLING::SPECIAL is passed as
	playerHandling.	
	*/
	void objectHit(jjOBJ@ target, HANDLING::Player playerHandling);
    /*
	A fast wrapper for jjAddParticlePixelExplosion, using the jjOBJ's own xPos,
	yPos, direction, and curFrame properties.	
	*/
	void particlePixelExplosion(int style) const;
    /*
	Makes the object use the same waypoint-based path movement as the Butterfly and
	Rocket Turtle objects. The method potentially sets the xAcc, yAcc, xPos, yPos,
	xSpeed, ySpeed, counter, direction, var[6] and var[7] properties in the process.	
	*/
	void pathMovement();
    /*
	Moves the object downward until it's on top of the nearest available masked tile
	below it, or else the bottom of the level. If precise is left false, the
	resulting yPos may be off by as much as three pixels either up or down, which is
	still fine for most objects.	
	*/
	void putOnGround(bool precise = false);
    /*
	To be used on bullet objects. Reverses the bullet's xSpeed/xAcc/direction, gives
	it a randomized ySpeed, plays one of the SOUND::AMMO_BUL* samples, and calls
	jjAddParticle(PARTICLE::SPARK) several times. Returns false if the bullet last
	ricocheted too recently.	
	*/
	bool ricochet();
    /*
	Sets freeze to 0, plays SOUND::COMMON_ICECRUSH, and creates an explosion of ice
	fragments radiating outward from the object. Unique values for style are 0, 1,
	or any other number.	
	*/
	int unfreeze(int style);
};

class jjPARTICLE {
    /*
	The point of this property is somewhat unclear, since JJ2 prefers to check if a
	given particle is active by testing whether type equals PARTICLE::INACTIVE or
	not, but it does exist and does get set sometimes.	
	*/
	bool isActive;
    /*
	Any of the standard type options allowed by jjAddParticle: INACTIVE, FIRE,
	FLOWER, ICETRAIL, LEAF, PIXEL, RAIN, SMOKE, SNOW, SPARK, STAR, STRING, or TILE.	
	*/
	PARTICLE::Type type;
    /*
	Horizontal location in pixels.	
	*/
	float xPos;
    /*
	Horizontal speed in pixels, positive or negative.	
	*/
	float xSpeed;
    /*
	Vertical location in pixels.	
	*/
	float yPos;
    /*
	Vertical speed in pixels, positive or negative.	
	*/
	float ySpeed;
    /*
	Corresponds to PARTICLE::FIRE. Fire particles are drawn as small horizontal
	ovals, and before they disappear, may at any time create a smoke particle. Fire
	particles are usually created when an enemy or other destructible object is
	destroyed using a fire-based weapon. uint8 fire.color is the color (palette
	entry) which a fire particle will be drawn as. This property gradually increases
	as the particle remains active, until it reaches colorStop (default 48, pink),
	at which point the particle will disappear. The default initial value is 40
	(yellow). int8 fire.colorDelta is the rate at which the color property is going
	to change. The most commonly used values for this are 1 and -1 meaning that the
	color value will respectively increase or decrease by 1 every time the game
	decides to modify it. The default value is 1. uint8 fire.colorStop is the color
	value which, when reached, will cause the particle to disappear. The default
	value is 48 (pink). uint8 fire.size decides how large the oval will be, ranging
	from 0-3. The default value is 3.	
	*/
	int fire; // (unknown type)
    /*
	Corresponds to PARTICLE::FLOWER. Flower particles are drawn as single color,
	partially transparent, rotationally symmetric flowers, and drift for a while
	while getting progressively smaller. They are traditionally created by setting
	Type=1 on a Snow event. uint8 flower.angle is the current angle of rotation the
	flower is drawn at. int8 flower.angularSpeed is how much the angle changes every
	tick, positive or negative. By default they do not rotate at all. uint8
	flower.color is the color which a flower particle will be drawn as, and does not
	change during the particle's lifetime. The default value is 16 (green) uint8
	flower.size is how large the flower should be drawn, though this is not equal to
	its size in actual pixels. Decreases by 1 every tick until it reaches 0, at
	which point the particle disappears. The default starting value is 64.	
	*/
	int flower; // (unknown type)
    /*
	Corresponds to PARTICLE::ICETRAIL. Ice trail particles are drawn as single
	pixels. In regular JJ2, ice bullets leave them in their wake as they fly. uint8
	icetrail.color is the color (palette entry) which an ice trail particle will be
	drawn as. This property gradually increases as the particle remains active,
	until it reaches colorStop (default 40, yellow), at which point the particle
	will disappear. The default initial value is 32 (light blue). int8
	icetrail.colorDelta is the rate at which the color property is going to change.
	The most commonly used values for this are 1 and -1 meaning that the color value
	will respectively increase or decrease by 1 every time the game decides to
	modify it. The default value is 1. uint8 icetrail.colorStop is the color value
	which, when reached, will cause the particle to disappear. The default value is
	40 (yellow).	
	*/
	int icetrail; // (unknown type)
    /*
	Corresponds to PARTICLE::LEAF. Leaf particles are drawn as frames of the
	ANIM::PLUS_SCENERY animation set, and float along based on their speed
	properties and some random jiggling, until they pass offscreen or hit a wall and
	fall to the ground. They are traditionally created by setting Type=3 on a Snow
	event. Note that you will need to load ANIM::PLUS_SCENERY manually in order for
	leaf particles to display properly. uint8 leaf.countup is set to 1 when the leaf
	hits a wall, then increments every tick until it hits 140 and the particle is
	deleted. uint8 leaf.frame specifies which frame of the animation will be drawn.
	This ranges from 0-31 when the leaf is in motion and 0-2 once the deathcounter
	property is non-zero. The value of this property does not exactly correspond to
	frames in the animation in plus.j2a, however, since the leaf animation repeats
	many frames that are only included once in the file. uint16 leaf.frameBase is ID
	of the frame the particle will use as a base sprite (curFrame-style), and has
	the default value of
	jjAnimations[jjAnimSets[ANIM::PLUS_SCENERY].firstAnim].firstFrame. uint8
	leaf.height is the distance from the ground in pixels that the particle must be
	in order to stop falling after hitting a wall. The default value is 2.	
	*/
	int leaf; // (unknown type)
    /*
	Corresponds to PARTICLE::PIXEL. Depending on their size value, pixel particles
	will be drawn as 1x1, 2x2, or 3x3 rectangles of pixels. They move both
	horizontally and vertically, and will also bounce off of masks. These are the
	particles created by destroying most enemies. uint8 pixel.color[9] specifies
	which colors will be drawn at each pixel in the particle's rectangle. Note that
	if the rectangle is smaller than 3x3, not every number in the array will be
	used. Values of 0 represent transparent pixels and will therefore not be drawn.
	uint8 pixel.size specifies the size of the rectangle drawn to the screen. 0 for
	1x1, 1 for 2x2, or any other number for 3x3. The default value is 0.	
	*/
	int pixel; // (unknown type)
    /*
	Corresponds to PARTICLE::RAIN. Rain particles are drawn as transparent, resized
	sprites, and move around according to their xSpeed/ySpeed properties until they
	hit a masked pixel, at which point they are either deleted (if the pixel is to
	their side) or begin a splashing animation (if the pixel is above or below).
	They are traditionally created by setting Type=2 on a Snow event. uint8
	rain.frame ranges from 0-7 while the particle is in motion, switches to 8 upon
	hitting a floor or ceiling, and then increases until it hits 18 and the particle
	is deleted. uint16 rain.frameBase is the first frame of the animation used by
	the particle, and has the default value of
	jjAnimations[jjAnimSets[ANIM::COMMON].firstAnim + 2].firstFrame. The displayed
	frame will be equal to this property plus the current value of the frame
	property.	
	*/
	int rain; // (unknown type)
    /*
	Corresponds to PARTICLE::SMOKE. Smoke particles are drawn as small gray
	rectangles and always move erratically upwards. Traditionally they are created
	from fire particles or from the BEHAVIOR::BURNING objects created by powered-up
	toaster or a frozen Bily. uint8 smoke.countdown gradually decreases until it
	reaches 64, at which point the particle will disappear. The default value is 71.	
	*/
	int smoke; // (unknown type)
    /*
	Corresponds to PARTICLE::SNOW. Snow particles are drawn as frames of the
	ANIM::SNOW animation set, and fly slowly around based on their speed properties
	and a general wind force until they hit a masked tile and slowly fade away. They
	are, of course, traditionally created by the Snow event. Note that you will need
	to load ANIM::SNOW manually in order for snow particles to display properly.
	uint8 snow.countdown specifies how long (in ticks) the particle may pass through
	masked tiles after first being created before masked tiles cause it to fade away
	and disappear. The default value is 35. uint8 snow.countup has something unknown
	to do with the particle disappearing once it hits a masked tile. The default
	value is 0. uint8 snow.frame specifies which frame of the animation will be
	drawn. This remains constant until the particle hits a wall, at which point it
	will increase to 7 before disappearing. The default initial value is 0. uint16
	snow.frameBase is ID of the frame the particle will use as a base sprite
	(curFrame-style), and has the default value of
	jjAnimations[jjAnimSets[ANIM::SNOW].firstAnim].firstFrame. The displayed frame
	will be equal to this property plus the current value of the frame property.	
	*/
	int snow; // (unknown type)
    /*
	Corresponds to PARTICLE::SPARK. Spark particles move around according to their
	xSpeed/ySpeed properties and also gravity, and are drawn as short trails left
	behind as they move. They are traditionally created by bullets ricocheting off
	of turtle shells or metallic surfaces, or by electro-blaster bullets in flight.
	uint8 spark.color is the color (palette entry) which a spark particle's trail
	will be drawn as. This property gradually increases as the particle remains
	active, until it reaches colorStop (default 46, maroon), at which point the
	particle will disappear. The default initial value is 40 (yellow). int8
	spark.colorDelta is the rate at which the color property is going to change. The
	most commonly used values for this are 1 and -1 meaning that the color value
	will respectively increase or decrease by 1 every time the game decides to
	modify it. The default value is 1. uint8 spark.colorStop is the color value
	which, when reached, will cause the particle to disappear. The default value is
	46 (maroon).	
	*/
	int spark; // (unknown type)
    /*
	Corresponds to PARTICLE::STAR. Star particles were added to the game to indicate
	sugar rush. They are drawn as a rotated star sprite. Besides linear speed they
	also have angular speed and change colors. uint8 star.angle is the current angle
	of rotation the star is drawn at. int8 star.angularSpeed is how much the angle
	changes every tick, positive or negative. By default they do not rotate at all.
	uint8 star.color is the color the star is drawn as. The default value is 40
	(yellow). uint8 star.colorChangeCounter counts down to 0, at which point it
	resets to the value of the colorChangeInterval property and changes the color
	property to one of the sprite colors at random.	
	*/
	int star; // (unknown type)
    /*
	Corresponds to PARTICLE::STRING. String particles move at ever-increasing speeds
	until they leave the screen, drawing up to eight consecutive characters as they
	go. They are traditionally used to show many points a player gained for
	destroying an object. string string.text is the series of characters that will
	be drawn. Strings longer than eight characters will be truncated.	
	*/
	int string; // (unknown type)
    /*
	Corresponds to PARTICLE::TILE. Tile particles move around according to their
	xSpeed/ySpeed properties and also gravity, and are drawn as single tiles (or
	quarters of single tiles) from the tileset used by the level. They are
	traditionally created from the destruction of destruct or collapse scenery
	blocks. TILE::Quadrant tile.quadrant specifies how much of the tile will be
	drawn to the screen. Possible values of TILE::Quadrant are TOPLEFT, TOPRIGHT,
	BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS. uint16 tile.tileID
	specifies which tile the particle draws in the first place. The default value is
	0, so remember to change it.	
	*/
	int tile; // (unknown type)
};

class jjCONTROLPOINT {
    /*
	The team that this point is presently under control of. Possible values are
	TEAM::NEUTRAL, TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.	
	*/
	const TEAM::Color controlTeam;
    /*
	Direction of the gem sprite displayed by the control point. The value has purely
	visual influence on the game.	
	*/
	const int direction;
    /*
	The control point's name.	
	*/
	const string name;
    /*
	Horizontal position in pixels.	
	*/
	const float xPos;
    /*
	Horizontal position in tiles.	
	*/
	const int xTile;
    /*
	Vertical position in pixels.	
	*/
	const float yPos;
    /*
	Vertical position in tiles.	
	*/
	const int yTile;
};

class jjCHARACTER {
    /*
	Determines the character's reaction to pressing jump in the air. Possible values
	are AIR::NONE, AIR::HELICOPTER and AIR::DOUBLEJUMP. No effect for birds or
	frogs.	
	*/
	AIR::Jump airJump;
    /*
	Whether the character can cause damage by using their special moves. This
	property also applies to Chuck's beak attack and Frog's tongue attack. Defaults
	true for all rabbits and false for birds and frogs.	
	*/
	bool canHurt;
    /*
	Whether the character is capable of fast movement. Defaults true for all rabbits
	and false for birds and frogs.	
	*/
	bool canRun;
    /*
	The maximum number of jumps the character can perform in the air if their
	airJump property allows it. Defaults 1 for Spaz.	
	*/
	int doubleJumpCountMax;
    /*
	What horizontal and vertical speed the character will gain by using double jump.
	doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is
	relative to the player's current direction, so for example a negative
	doubleJumpXSpeed will make the character move backwards.	
	*/
	float doubleJumpXSpeed;
    /*
	What horizontal and vertical speed the character will gain by using double jump.
	doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is
	relative to the player's current direction, so for example a negative
	doubleJumpXSpeed will make the character move backwards.	
	*/
	float doubleJumpYSpeed;
    /*
	The maximum amount of time the character can keep using helicopter ears if their
	airJump property allows it.	
	*/
	int helicopterDurationMax;
    /*
	What horizontal and vertical speed the character will gain by using helicopter
	ears. helicopterYSpeed defaults 1 for all rabbits; its effects when <= 0 are
	currently undefined. helicopterXSpeed defaults 0 and is relative to the player's
	current direction, so for example a negative helicopterXSpeed will make the
	character move backwards.	
	*/
	float helicopterXSpeed;
    /*
	What horizontal and vertical speed the character will gain by using helicopter
	ears. helicopterYSpeed defaults 1 for all rabbits; its effects when <= 0 are
	currently undefined. helicopterXSpeed defaults 0 and is relative to the player's
	current direction, so for example a negative helicopterXSpeed will make the
	character move backwards.	
	*/
	float helicopterYSpeed;
    /*
	Determines the character's reaction to pressing jump while crouching. Possible
	values are GROUND::JAZZ, GROUND::SPAZ, GROUND::LORI (available even in 1.23),
	GROUND::CROUCH (character remains crouching and does not jump), and GROUND::JUMP
	(character jumps but does not immediately buttstomp). No effect for birds or
	frogs. Note that changing this property to any the first three values may look
	pretty silly if the animations are not edited accordingly.	
	*/
	GROUND::Jump groundJump;
    /*
	Whether the character can be morphed to using the "Jazz<->Spaz" morph box. Also
	affects the jjPLAYER function morph when its rabbitsOnly argument is set to
	true.	
	*/
	bool morphBoxCycle;
};

class jjWEAPON {
    /*
	Whether the weapon and/or its powerup can be legally used in the level. This
	value is used by the server to detect attempts of cheating and kick offenders,
	and by all players to determine which weapons they get upon use of the /ready
	command. Between onLevelLoad and onLevelBegin, JJ2+ runs a function to determine
	the values for these properties for each weapon.
	jjWeapons[WEAPON::BLASTER].allowed will always be set to true; for the rest,
	JJ2+ looks at the current contents of jjObjects and checks each active object's
	jjOBJ::eventID. Any +3 ammo pickup or +15 ammo crate will set allowed to true
	for that weapon, and any powerup will set both allowed and allowedPowerup to
	true. Additionally, OBJECT::GUNCRATE and OBJECT::GUNBARREL will both set
	jjWeapons[WEAPON::BOUNCER].allowed to true, and OBJECT::GENERATOR and
	object-spawning crates will behave as if they were the objects they will spawn,
	e.g. a generator that creates +3 Toaster pickups will set
	jjWeapons[WEAPON::TOASTER].allowed to true. (Anything not set to true will be
	set to false, so there is no point in editing these properties in onLevelLoad.)
	This system covers most levels, but it is absolutely possible to set up your
	level to include ammo that JJ2+ was unable to guess based on a single loop
	through jjObjects, e.g. MCEs, or the "Weapon" parameter on +15 Bouncer crates,
	or any number of scripting changes. If you're at all unsure whether JJ2+ will
	make the right predictions for your particular level, there is zero harm in
	explicitly setting as many allowed and allowedPowerup values as you want, to
	true or to false, although make sure to set them in onLevelBegin at the
	earliest.	
	*/
	bool allowed;
    /*
	Whether the weapon and/or its powerup can be legally used in the level. This
	value is used by the server to detect attempts of cheating and kick offenders,
	and by all players to determine which weapons they get upon use of the /ready
	command. Between onLevelLoad and onLevelBegin, JJ2+ runs a function to determine
	the values for these properties for each weapon.
	jjWeapons[WEAPON::BLASTER].allowed will always be set to true; for the rest,
	JJ2+ looks at the current contents of jjObjects and checks each active object's
	jjOBJ::eventID. Any +3 ammo pickup or +15 ammo crate will set allowed to true
	for that weapon, and any powerup will set both allowed and allowedPowerup to
	true. Additionally, OBJECT::GUNCRATE and OBJECT::GUNBARREL will both set
	jjWeapons[WEAPON::BOUNCER].allowed to true, and OBJECT::GENERATOR and
	object-spawning crates will behave as if they were the objects they will spawn,
	e.g. a generator that creates +3 Toaster pickups will set
	jjWeapons[WEAPON::TOASTER].allowed to true. (Anything not set to true will be
	set to false, so there is no point in editing these properties in onLevelLoad.)
	This system covers most levels, but it is absolutely possible to set up your
	level to include ammo that JJ2+ was unable to guess based on a single loop
	through jjObjects, e.g. MCEs, or the "Weapon" parameter on +15 Bouncer crates,
	or any number of scripting changes. If you're at all unsure whether JJ2+ will
	make the right predictions for your particular level, there is zero harm in
	explicitly setting as many allowed and allowedPowerup values as you want, to
	true or to false, although make sure to set them in onLevelBegin at the
	earliest.	
	*/
	bool allowedPowerup;
    /*
	Determines whether or not the red companion bird is allowed to shoot bullets of
	the specified weapon (comesFromBirds), and, if so, whether they may be
	powered-up (comesFromBirdsPowerup) if the player currently has a powerup for
	that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless
	of the player's currWeapon. Bird bullets do not affect the player's ammo count,
	regardless of the weapon's infinite property, and will not be replaced by shield
	bullets (because the bird does not have its own shield), regardless of the
	weapon's replacedByShield property.	
	*/
	bool comesFromBirds;
    /*
	Determines whether or not the red companion bird is allowed to shoot bullets of
	the specified weapon (comesFromBirds), and, if so, whether they may be
	powered-up (comesFromBirdsPowerup) if the player currently has a powerup for
	that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless
	of the player's currWeapon. Bird bullets do not affect the player's ammo count,
	regardless of the weapon's infinite property, and will not be replaced by shield
	bullets (because the bird does not have its own shield), regardless of the
	weapon's replacedByShield property.	
	*/
	bool comesFromBirdsPowerup;
    /*
	Determines whether or not the ammo for the specified weapon can drop from Gun
	Crates and Gun Barrels. Defaults to true for WEAPON::BOUNCER, WEAPON::ICE,
	WEAPON::SEEKER, WEAPON::RF, WEAPON::TOASTER, and false for WEAPON::TNT,
	WEAPON::GUN8 and WEAPON::GUN9. Has no effect on WEAPON::BLASTER. In an online
	server, the pickups dropped will be according to the comesFromGunCrates settings
	for the player who destroyed the crate/barrel.	
	*/
	bool comesFromGunCrates;
    /*
	When false, the default sample of the bullet will not be played.	
	*/
	bool defaultSample;
    /*
	How many gems a player shot by this weapon will lose in Treasure Hunt. (If the
	player has fewer gems than the weapon should cause them to lose, they will lose
	all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT,
	WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making
	no difference by default. Doesn't have any effect when changed by clients, only
	by the server (or in local games).	
	*/
	int gemsLost;
    /*
	How many gems a player shot by this weapon will lose in Treasure Hunt. (If the
	player has fewer gems than the weapon should cause them to lose, they will lose
	all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT,
	WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making
	no difference by default. Doesn't have any effect when changed by clients, only
	by the server (or in local games).	
	*/
	int gemsLostPowerup;
    /*
	Whether it takes a few shots for bullets to adjust their direction to the
	direction the player is aiming, as is the case with pepper spray. If this
	weapon's spread property is SPREAD::GUN8 and jjAllowsFireball is true, this
	property will be treated as false.	
	*/
	bool gradualAim;
    /*
	When true, ammo displays an infinity symbol for its quantity and can never be
	deplenished. Defaults to true for WEAPON::BLASTER. When spectating another
	player, the ammo count will appear according to your infinite setting for their
	currently chosen weapon, not their own.	
	*/
	bool infinite;
    /*
	Determines how much of each ammo type a player can hold at a time. Defaults to
	-1, which is interpreted as "99 in single player or cooperative, otherwise 50,"
	but you may want to change some numbers individually (e.g. limit the number of
	seekers but not bouncers).	
	*/
	int maximum;
    /*
	The factor by which ammo pickups/powerups increase a weapon's ammo count, and by
	which that count is divided to be displayed onscreen. Defaults to 32 for
	WEAPON::TOASTER and 1 for everything else. When spectating another player, the
	ammo count will appear according to your multiplier setting for their currently
	chosen weapon, not their own.	
	*/
	int multiplier;
    /*
	When true, the bullet will be replaced by an air bubble when shot underwater or
	if it goes underwater subsequent to being shot. Defaults to true for
	WEAPON::TOASTER (and therefore also for fire shield bullets).	
	*/
	bool replacedByBubbles;
    /*
	When true and a shield is active, shield ammo will replace default weapon ammo.
	Defaults to true for WEAPON::BLASTER. Under certain circumstances this setting
	is used to determine validity of network packets, so keep in mind that if its
	value is not the same for the host as it is for clients, they may be kicked for
	cheating.	
	*/
	bool replacedByShield;
    /*
	When true, ammo jumps back up to 50 or 99 on level (re)load. Should be set in
	onLevelLoad, rather than onLevelBegin, since it actually takes effect between
	the two. Defaults to true for WEAPON::BLASTER.	
	*/
	bool replenishes;
    /*
	How many bullets are spawned by a single use of the weapon and in what manner.
	Possible values are: NORMAL: Fires one bullet. ICEPU: Fires two bullets; one in
	the direction you face, one in the direction you aim. ICE: Same as NORMAL when
	not powered up, and ICEPU when powered up. RFNORMAL: Fires two bullets. RFPU:
	Fires three bullets. RF: Same as RFNORMAL when not powered up, and RFPU when
	powered up. TOASTER: Fires one bullet with its speed partially determined by how
	much fastfire the player has. PEPPERSPRAY: Fires two pepper spray bullets. GUN8:
	Same as NORMAL if jjAllowsFireball is true (but ignoring this weapon's
	gradualAim property), and PEPPERSPRAY when it's off. Any assignments of GUN8 or
	PEPPERSPRAY should be shared between clients and server to prevent kicking for
	invalid gun use.	
	*/
	SPREAD::Spread spread;
    /*
	Determines how often will the weapon fire a bullet when the player holds the
	fire button. Possible values are WEAPON::NORMAL (fires continously, respecting
	the player's fastfire property), WEAPON::MISSILE (fires once per press of the
	button), WEAPON::POPCORN (fires continously and respects the player's fastfire
	property, but at a capped minimum rate of fire), and WEAPON::CAPPED (like
	NORMAL, but prevents players from shooting faster than allowed by their fastfire
	property).	
	*/
	WEAPON::Style style;
};

class jjSTREAM {
    /*
	Clears content of the stream leaving it empty.	
	*/
	void clear();
    /*
	Discards count bytes from the front of the stream. Returns whether successful,
	i.e. whether the stream contained sufficiently many bytes to perform the
	operation. If the operation fails, the stream is left in an undefined state.	
	*/
	bool discard(uint count);
    /*
	Reads count bytes from the front of the stream, removes them and places their
	contents into value. Returns whether successful, i.e. whether the stream
	contained sufficiently many bytes to perform the operation. If the operation
	fails, the stream is left in an undefined state.	
	*/
	bool get(const string value, uint count = 1);
    /*
	Reads count bytes from the front of the stream, removes them and places their
	contents into value. Returns whether successful, i.e. whether the stream
	contained sufficiently many bytes to perform the operation. If the operation
	fails, the stream is left in an undefined state.	
	*/
	bool get(const jjSTREAM value, uint count = 1);
    /*
	Reads bytes from the stream, interpreting them as text characters, until it
	finds the character sequence delim. The read bytes are placed into value. All
	read characters are removed from the stream, including delim; however, the
	resulting value will not contain delim. Returns true on success and false if
	delim was not found anywhere in the stream. In the latter case, the behavior is
	still well-defined and all contents of the stream are placed into value, making
	the stream empty.	
	*/
	bool getLine(string value, const string delim = '\n');
    /*
	Returns size of the stream in bytes.	
	*/
	uint getSize() const;
    /*
	Returns whether the stream is empty, i.e. whether getSize() == 0.	
	*/
	bool isEmpty() const;
    bool pop(int value);
	bool pop(float value);
	bool pop(string value);
	bool pop(bool value);

    bool push(int value);
	bool push(float value);
	bool push(string value);
	bool push(bool value);

    bool push(int value);
	bool push(float value);
	bool push(string value);
	bool push(bool value);

    bool push(int value);
	bool push(float value);
	bool push(string value);
	bool push(bool value);

    /*
	Saves contents of the stream to file filename and returns whether successful.
	There are several limits to this method. The file cannot be saved in any
	directory other than the default one, which is the directory containing the
	executable (for local games and servers) or cache (for clients). File extension
	has to be ".asdat" and if any other or no extension is provided in the string,
	it will be replaced. Additionally, scripts downloaded from a server can only
	save up to 16 files on the computer of a client; they are, however, allowed to
	overwrite files they saved previously. (The limit of 16 files is shared with
	jjANIMATION::save and jjPIXELMAP::save).	
	*/
	bool save(const string filename) const;
    /*
	Appends bytes of value at the end of the stream. In contrast to push, this
	method doesn't store the size of the provided string or stream, thus making it
	impossible to pop, but it can still be obtained with get if the size is known or
	getLine if it ends with a defined delimiter. Returns whether successful, which
	is always true.	
	*/
	bool write(const string value);
    /*
	Appends bytes of value at the end of the stream. In contrast to push, this
	method doesn't store the size of the provided string or stream, thus making it
	impossible to pop, but it can still be obtained with get if the size is known or
	getLine if it ends with a defined delimiter. Returns whether successful, which
	is always true.	
	*/
	bool write(const jjSTREAM value);
	jjSTREAM();
	jjSTREAM(const string &in filename);
};

class jjRNG {
    /*
	Sets the current state of the generator based on value.	
	*/
	void seed(uint64 value = 5489);
    /*
	Advances the generator's state by count. The effect is equivalent to invoking
	the call operator count times and discarding the returned values, but calculated
	more efficiently.	
	*/
	void discard(uint64 count = 1);
};

class jjPAL {
    /*
	At its heart, a palette is a collection of 256 colors, and you can access them
	individually through the color array. In fact, you could if you chose reproduce
	nearly every jjPAL method here by directly altering the colors, but the methods
	are here to save you time, so don't do that. The details of jjPALCOLOR objects
	are listed below this section, though most basically you just use their
	properties red, green, and blue.	
	*/
	array<jjPALCOLOR> color = array<jjPALCOLOR>(256);
    /*
	Causes the contents of this jjPAL object to be the current colors in use by the
	game, and by extension jjPalette. Note that this function does a fair bit of
	housekeeping behind the scenes to make sure everything is propertly converted to
	the new palettethere's a difference between myPal.apply(); and jjPalette =
	myPal;and so it should always be called after doing any edits, even if
	you've been making the edits directly to jjPalette. Failure to do so can have
	unpredictable consequences.	
	*/
	void apply() const;
    /*
	Overlays length colors from source onto the current palette, beginning at start
	on this palette and start2 on source. If opacity is below 1.0, the new colors
	will only partially replace the old.	
	*/
	void copyFrom(uint8 start, uint8 length, uint8 start2, const jjPAL source, float opacity);
    /*
	Replaces a series of length colors beginning at start with the color
	red,green,blue or, in the later 2 overloads, color. If opacity is specified and
	below 1.0, the new color will only partially replace the old ones, making for a
	tinting effect. Leave out the start and length arguments to fill (or tint) the
	entire palette.	
	*/
	void fill(uint8 red, uint8 green, uint8 blue, uint8 start, uint8 length, float opacity = 1.0);
    /*
	Replaces a series of length colors beginning at start with the color
	red,green,blue or, in the later 2 overloads, color. If opacity is specified and
	below 1.0, the new color will only partially replace the old ones, making for a
	tinting effect. Leave out the start and length arguments to fill (or tint) the
	entire palette.	
	*/
	void fill(uint8 red, uint8 green, uint8 blue, float opacity = 1.0);
    /*
	Replaces a series of length colors beginning at start with the color
	red,green,blue or, in the later 2 overloads, color. If opacity is specified and
	below 1.0, the new color will only partially replace the old ones, making for a
	tinting effect. Leave out the start and length arguments to fill (or tint) the
	entire palette.	
	*/
	void fill(jjPALCOLOR color, uint8 start, uint8 length, float opacity = 1.0);
    /*
	Replaces a series of length colors beginning at start with the color
	red,green,blue or, in the later 2 overloads, color. If opacity is specified and
	below 1.0, the new color will only partially replace the old ones, making for a
	tinting effect. Leave out the start and length arguments to fill (or tint) the
	entire palette.	
	*/
	void fill(jjPALCOLOR color, float opacity = 1.0);
    /*
	Returns index of the palette entry whose components differ the least from those
	of the provided color. Ensures the result has no special treatment by never
	returning values from the range of 0-15.	
	*/
	uint8 findNearestColor(jjPALCOLOR color) const;
    /*
	Replaces a series of length colors beginning at start with a gradient beginning
	with red1,green1,blue1 (or color1) and ending with red2,green2,blue2 (or
	color2). If opacity is specified and below 1.0, the new colors will only
	partially replace the old, making for a tinting effect. If inclusive is false
	(default), the gradient will lead up to the second color but the second color
	will not itself appear. If true, the second color will appear directly in the
	palette as the final color of the gradient. For example, a gradient of red1:100,
	red2:0, and length:3 will produce the red values 100,66,33 when inclusive is
	false, but 100,50,0 when inclusive is true. The default values for start and
	length will set a gradient for the colors used by water and (in most tilesets)
	textured backgrounds.	
	*/
	void gradient(uint8 red1, uint8 green1, uint8 blue1, uint8 red2, uint8 green2, uint8 blue2, uint8 start = 176, uint8 length = 32, float opacity = 1.0, bool inclusive = false);
    /*
	Replaces a series of length colors beginning at start with a gradient beginning
	with red1,green1,blue1 (or color1) and ending with red2,green2,blue2 (or
	color2). If opacity is specified and below 1.0, the new colors will only
	partially replace the old, making for a tinting effect. If inclusive is false
	(default), the gradient will lead up to the second color but the second color
	will not itself appear. If true, the second color will appear directly in the
	palette as the final color of the gradient. For example, a gradient of red1:100,
	red2:0, and length:3 will produce the red values 100,66,33 when inclusive is
	false, but 100,50,0 when inclusive is true. The default values for start and
	length will set a gradient for the colors used by water and (in most tilesets)
	textured backgrounds.	
	*/
	void gradient(jjPALCOLOR color1, jjPALCOLOR color2, uint8 start = 176, uint8 length = 32, float opacity = 1.0, bool inclusive = false);
    /*
	Loads a palette from the specified file. If the file is a tileset with a ".j2t"
	extension, an 8-bit globally-paletted GIF image/animation with a ".gif"
	extension, or an 8-bit paletted or grayscale PNG image with a ".png" extension,
	will try to access the palette stored in the file. Otherwise, tries to treat it
	as a palette file saved in "Color Table" format in Palette Suite, and if that
	fails, simply reads the first 1024 bytes of the file. Returns false if the file
	cannot be found, or if trying to read the file based on its extension fails, or
	if the file is fewer than 1024 bytes long; otherwise true.	
	*/
	bool load(string& filename);
    /*
	Loads the original colors used by the tileset. There is no non-stylistic
	difference between myPal.reset(); and myPal = jjBackupPalette;.	
	*/
	void reset();
};

class jjPALCOLOR {
    /*
	How red this palette color is.	
	*/
	uint8 red;
    /*
	How green this palette color is.	
	*/
	uint8 green;
    /*
	How blue this palette color is.	
	*/
	uint8 blue;
    /*
	The hue of this palette color.	
	*/
	uint8 getHue() const;
    /*
	The saturation of this palette color, where 0 is grayscale and 255 is most
	saturated.	
	*/
	uint8 getSat() const;
    /*
	The lighting of this palette color, where 0 is black and 255 is white.	
	*/
	uint8 getLight() const;
    /*
	Changes the entire color to a brand new one derived from the given HSL values.
	Due to the complexity of the calculations involved, you can only change all
	three values at a time, so if you want to leave, for instance, saturation
	constant, you'll need to read the old value through getSat and then use that as
	the sat parameter. hue is an int instead of a uint8 because it's a loop instead
	of a scale. 2, 258, 514, -254, etc., are all equally valid and all mean the same
	hue.	
	*/
	void setHSL(int hue, uint8 sat, uint8 light);
    /*
	Swaps values of selected components of the color. The value of the red component
	will be replaced with that specified by parameter red, the value of the green
	component with that specified by green and the value of blue with that specified
	by blue. Values accepted by the parameters are COLOR::RED, COLOR::GREEN and
	COLOR::BLUE.	
	*/
	void swizzle(COLOR::Component red, COLOR::Component green, COLOR::Component blue);
	jjPALCOLOR(int r, int g, int b);
};

class jjCANVAS {
    /*
	Draws a single sprite frame at xPixel,yPixel. The setID, animation, and frame
	parameters correspond to the "Set ID," "Animation," and "Frame #" sliders
	respectively in Jazz Sprite Dynamite, but are 0-indexed. You are allowed to use
	a simple integer to specify the setID, but an ANIM::Set constant is strongly
	recommended, since the values for certain sets differ between 1.23 and 1.24; the
	full list of constants can be found in the appendix at the bottom of this file.
	For an example, to draw a broken bird cage (9-5-1 in Jazz Sprite Dynamite), you
	would write ANIM::BIRD, 4, 0. The direction parameter determines which direction
	the sprite will be facing; values 0 to 63 will not flip the sprite, -64 to -1
	will flip it horizontally, 64 to 127 will flip it vertically, and -128 to -65
	will flip it both horizontally and vertically. Alternatively to integer values,
	you can use constants made for this very purpose that belong to the
	SPRITE::Direction enum: SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV,
	SPRITE::FLIPHV.	
	*/
	void drawSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, int8 direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	The same as drawSprite, but takes a single sprite parameter instead of one each
	for Set, Animation, and Frame. The name references the curFrame property of
	jjOBJ and jjPLAYER, whose real significance is as an index to jjAnimFrames[].
	Internally any draw*Sprite method is actually a call to the corresponding
	draw*SpriteFromCurFrame method, with the following formula applied to find the
	curFrame value: (jjAnimations[jjAnimSets[setID].firstAnim +
	animation].firstFrame + frame) % jjAnimations[jjAnimSets[setID].firstAnim +
	animation].frameCount	
	*/
	void drawSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, int8 direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a single resized sprite frame at xPixel,yPixel. This swaps out
	drawSprite's direction argument with a pair of float arguments, xScale and
	yScale, which determine how much the sprite is enlarged (or shrunken) on each
	axis. For example, a 32x32 sprite drawn with xScale 3 and yScale 1.5 would be
	drawn across a 9648 area. Making one or both scale values negative will
	cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing
	will be performed while resizing the sprite.	
	*/
	void drawResizedSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a single resized sprite frame at xPixel,yPixel. This swaps out
	drawSprite's direction argument with a pair of float arguments, xScale and
	yScale, which determine how much the sprite is enlarged (or shrunken) on each
	axis. For example, a 32x32 sprite drawn with xScale 3 and yScale 1.5 would be
	drawn across a 9648 area. Making one or both scale values negative will
	cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing
	will be performed while resizing the sprite.	
	*/
	void drawResizedSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a single resized and rotated sprite frame at xPixel,yPixel. This carries
	over the xScale and yScale arguments from drawResizedSprite, and adds a new
	angle parameter with the same 0-1023 domain as jjSin and jjCos. (Numbers outside
	the domain will be seemlessly moduloed.) An angle of 0 will not rotate the
	sprite at all. Without getting into matrix math, you can think of the sprite as
	being resized before it is rotated, which in most cases is exactly what you'd
	want. For example, a 3232 sprite drawn with angle 256, xScale 2, and
	yScale 1 would be drawn across an area of 3264, not 6432. Rotated
	sprites should be no larger (before transformations are applied) than 128 pixels
	wide or 256 pixels high. The results of drawing larger sprites are, for now,
	undefined while we decide whether this restriction should or can be removed. Any
	sprite that drawSprite can draw, drawResizedSprite can draw in the same way by
	setting xScale and yScale each to 1. And any sprite that drawResizedSprite can
	draw, drawRotatedSprite can draw unless it's greater than 128256, by
	setting angle to 0. As you might imagine, though, the simpler methods (besides
	being quicker to write) run faster than the more complicated methods, so you
	might as well use them when you can get away with it.	
	*/
	void drawRotatedSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a single resized and rotated sprite frame at xPixel,yPixel. This carries
	over the xScale and yScale arguments from drawResizedSprite, and adds a new
	angle parameter with the same 0-1023 domain as jjSin and jjCos. (Numbers outside
	the domain will be seemlessly moduloed.) An angle of 0 will not rotate the
	sprite at all. Without getting into matrix math, you can think of the sprite as
	being resized before it is rotated, which in most cases is exactly what you'd
	want. For example, a 3232 sprite drawn with angle 256, xScale 2, and
	yScale 1 would be drawn across an area of 3264, not 6432. Rotated
	sprites should be no larger (before transformations are applied) than 128 pixels
	wide or 256 pixels high. The results of drawing larger sprites are, for now,
	undefined while we decide whether this restriction should or can be removed. Any
	sprite that drawSprite can draw, drawResizedSprite can draw in the same way by
	setting xScale and yScale each to 1. And any sprite that drawResizedSprite can
	draw, drawRotatedSprite can draw unless it's greater than 128256, by
	setting angle to 0. As you might imagine, though, the simpler methods (besides
	being quicker to write) run faster than the more complicated methods, so you
	might as well use them when you can get away with it.	
	*/
	void drawRotatedSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a single sprite frame at xPixel,yPixel in the style of a Swinging Vine
	object. The parameters named length and curvature correspond respectively to
	properties var[1] (normally always 128) and var[2] of swinging vines; if the
	sprite is shorter than the length value, its pixels will be repeated again from
	the top as necessary. For boring internal code reasons, this method expects that
	sprites will have no transparent pixels. Instead, to tell this method not to
	draw an individual pixel from the frame, its value must be 128 instead of 0.
	Using normal transparent pixels instead will cause the sprite to be drawn as a
	jumbled mess.	
	*/
	void drawSwingingVineSpriteFromCurFrame(int xPixel, int yPixel, int sprite, int length, int curvature, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Changes the color of the pixel at xPixel,yPixel into the palette color
	corresponding to index color. If you are drawing anything more than a handful of
	pixels at a time, you should consider creating a new sprite of your own using
	jjPIXELMAP, and then drawing that sprite as a single unit with some other
	drawing method.	
	*/
	void drawPixel(int xPixel, int yPixel, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a rectangle with one of its vertices at xPixel,yPixel of specified width
	and height in the palette color corresponding to index color.	
	*/
	void drawRectangle(int xPixel, int yPixel, int width, int height, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0);
    /*
	Draws a string of characters of your choice at position (xPixel, yPixel) on the
	screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify
	a different jjANIMATION to grab character sprites from, e.g. one from a custom
	.j2a file. Whichever animation is chosen should use the same order (and,
	ideally, number) of frames/characters as the standard font animations, so frame
	16 is 0, frame 33 is A, and so on. If it helps, you may
	think of the overloads with size arguments as shorthand for
	jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size]. The following options are
	available for the mode parameter: NORMAL: Draws a left-aligned string as if
	drawing chat or player names; | changes the text color after itself, and @ and #
	are ordinary symbols. DARK: Draws a left-aligned string with darkened letters,
	as if unselectable. |, @, and # have no effect. RIGHTALIGN: Draws a
	right-aligned string with normal letters. |, @, and # have no effect. SPIN:
	Draws a left-aligned string whose letters spin around in place. | has no effect;
	@ introduces a newline; # makes every letter after it a new color. The param
	value determines how close together the letters are: 0 for a fairly ordinary
	looking string, or 255 for complete chaos, with other numbers falling
	in-between. BOUNCE: Draws a left-aligned string whose letters bounce up and down
	in place. |, @, and # have no effect. The param value determines how close
	together the letters are: 0 for a fairly ordinary looking string, or 255 for
	complete chaos, with other numbers falling in-between. PALSHIFT: Draws a
	left-aligned string with normal letters whose colors are all shifted param
	palette entries. A value of 24, for instance, would produce purple text, or 32
	would enter into the non-sprite-color portion of the palette. |, @, and # have
	no effect. Most of these modes use alignment of STRING::DEFAULT, meaning that
	values of xPixel higher than 0x4000 have a special meaning in drawing strings,
	most noticably changing their alignment on the screen. View documentation for
	jjTEXTAPPEARANCE::align for more detail. In the second prototype of the
	function, arguments mode and param are split into four arguments appearance,
	param1, spriteMode and param2 for more customizability: appearance controls
	several different aspects of text discussed in the jjTEXTAPPEARANCE section,
	param1 is a multiplier applied to amplitude of text determined by appearance,
	spriteMode is the sprite mode the characters will be drawn in, and param2 is the
	sprite mode parameter. Notice that the choice of spriteMode will also determine
	the effect of using special characters such as # and | in text (if appearance
	allows them to take effect).	
	*/
	void drawString(int xPixel, int yPixel, const string text, STRING::Size size = STRING::SMALL,STRING::Mode mode = STRING::NORMAL, uint8 param = 0);
    /*
	Draws a string of characters of your choice at position (xPixel, yPixel) on the
	screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify
	a different jjANIMATION to grab character sprites from, e.g. one from a custom
	.j2a file. Whichever animation is chosen should use the same order (and,
	ideally, number) of frames/characters as the standard font animations, so frame
	16 is 0, frame 33 is A, and so on. If it helps, you may
	think of the overloads with size arguments as shorthand for
	jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size]. The following options are
	available for the mode parameter: NORMAL: Draws a left-aligned string as if
	drawing chat or player names; | changes the text color after itself, and @ and #
	are ordinary symbols. DARK: Draws a left-aligned string with darkened letters,
	as if unselectable. |, @, and # have no effect. RIGHTALIGN: Draws a
	right-aligned string with normal letters. |, @, and # have no effect. SPIN:
	Draws a left-aligned string whose letters spin around in place. | has no effect;
	@ introduces a newline; # makes every letter after it a new color. The param
	value determines how close together the letters are: 0 for a fairly ordinary
	looking string, or 255 for complete chaos, with other numbers falling
	in-between. BOUNCE: Draws a left-aligned string whose letters bounce up and down
	in place. |, @, and # have no effect. The param value determines how close
	together the letters are: 0 for a fairly ordinary looking string, or 255 for
	complete chaos, with other numbers falling in-between. PALSHIFT: Draws a
	left-aligned string with normal letters whose colors are all shifted param
	palette entries. A value of 24, for instance, would produce purple text, or 32
	would enter into the non-sprite-color portion of the palette. |, @, and # have
	no effect. Most of these modes use alignment of STRING::DEFAULT, meaning that
	values of xPixel higher than 0x4000 have a special meaning in drawing strings,
	most noticably changing their alignment on the screen. View documentation for
	jjTEXTAPPEARANCE::align for more detail. In the second prototype of the
	function, arguments mode and param are split into four arguments appearance,
	param1, spriteMode and param2 for more customizability: appearance controls
	several different aspects of text discussed in the jjTEXTAPPEARANCE section,
	param1 is a multiplier applied to amplitude of text determined by appearance,
	spriteMode is the sprite mode the characters will be drawn in, and param2 is the
	sprite mode parameter. Notice that the choice of spriteMode will also determine
	the effect of using special characters such as # and | in text (if appearance
	allows them to take effect).	
	*/
	void drawString(int xPixel, int yPixel, const string text, const jjANIMATION animation, STRING::Mode mode = STRING::NORMAL, uint8 param = 0);
    /*
	Draws a string of characters of your choice at position (xPixel, yPixel) on the
	screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify
	a different jjANIMATION to grab character sprites from, e.g. one from a custom
	.j2a file. Whichever animation is chosen should use the same order (and,
	ideally, number) of frames/characters as the standard font animations, so frame
	16 is 0, frame 33 is A, and so on. If it helps, you may
	think of the overloads with size arguments as shorthand for
	jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size]. The following options are
	available for the mode parameter: NORMAL: Draws a left-aligned string as if
	drawing chat or player names; | changes the text color after itself, and @ and #
	are ordinary symbols. DARK: Draws a left-aligned string with darkened letters,
	as if unselectable. |, @, and # have no effect. RIGHTALIGN: Draws a
	right-aligned string with normal letters. |, @, and # have no effect. SPIN:
	Draws a left-aligned string whose letters spin around in place. | has no effect;
	@ introduces a newline; # makes every letter after it a new color. The param
	value determines how close together the letters are: 0 for a fairly ordinary
	looking string, or 255 for complete chaos, with other numbers falling
	in-between. BOUNCE: Draws a left-aligned string whose letters bounce up and down
	in place. |, @, and # have no effect. The param value determines how close
	together the letters are: 0 for a fairly ordinary looking string, or 255 for
	complete chaos, with other numbers falling in-between. PALSHIFT: Draws a
	left-aligned string with normal letters whose colors are all shifted param
	palette entries. A value of 24, for instance, would produce purple text, or 32
	would enter into the non-sprite-color portion of the palette. |, @, and # have
	no effect. Most of these modes use alignment of STRING::DEFAULT, meaning that
	values of xPixel higher than 0x4000 have a special meaning in drawing strings,
	most noticably changing their alignment on the screen. View documentation for
	jjTEXTAPPEARANCE::align for more detail. In the second prototype of the
	function, arguments mode and param are split into four arguments appearance,
	param1, spriteMode and param2 for more customizability: appearance controls
	several different aspects of text discussed in the jjTEXTAPPEARANCE section,
	param1 is a multiplier applied to amplitude of text determined by appearance,
	spriteMode is the sprite mode the characters will be drawn in, and param2 is the
	sprite mode parameter. Notice that the choice of spriteMode will also determine
	the effect of using special characters such as # and | in text (if appearance
	allows them to take effect).	
	*/
	void drawString(int xPixel, int yPixel, const string text, STRING::Size size, const jjTEXTAPPEARANCE appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0);
    /*
	Draws a string of characters of your choice at position (xPixel, yPixel) on the
	screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify
	a different jjANIMATION to grab character sprites from, e.g. one from a custom
	.j2a file. Whichever animation is chosen should use the same order (and,
	ideally, number) of frames/characters as the standard font animations, so frame
	16 is 0, frame 33 is A, and so on. If it helps, you may
	think of the overloads with size arguments as shorthand for
	jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size]. The following options are
	available for the mode parameter: NORMAL: Draws a left-aligned string as if
	drawing chat or player names; | changes the text color after itself, and @ and #
	are ordinary symbols. DARK: Draws a left-aligned string with darkened letters,
	as if unselectable. |, @, and # have no effect. RIGHTALIGN: Draws a
	right-aligned string with normal letters. |, @, and # have no effect. SPIN:
	Draws a left-aligned string whose letters spin around in place. | has no effect;
	@ introduces a newline; # makes every letter after it a new color. The param
	value determines how close together the letters are: 0 for a fairly ordinary
	looking string, or 255 for complete chaos, with other numbers falling
	in-between. BOUNCE: Draws a left-aligned string whose letters bounce up and down
	in place. |, @, and # have no effect. The param value determines how close
	together the letters are: 0 for a fairly ordinary looking string, or 255 for
	complete chaos, with other numbers falling in-between. PALSHIFT: Draws a
	left-aligned string with normal letters whose colors are all shifted param
	palette entries. A value of 24, for instance, would produce purple text, or 32
	would enter into the non-sprite-color portion of the palette. |, @, and # have
	no effect. Most of these modes use alignment of STRING::DEFAULT, meaning that
	values of xPixel higher than 0x4000 have a special meaning in drawing strings,
	most noticably changing their alignment on the screen. View documentation for
	jjTEXTAPPEARANCE::align for more detail. In the second prototype of the
	function, arguments mode and param are split into four arguments appearance,
	param1, spriteMode and param2 for more customizability: appearance controls
	several different aspects of text discussed in the jjTEXTAPPEARANCE section,
	param1 is a multiplier applied to amplitude of text determined by appearance,
	spriteMode is the sprite mode the characters will be drawn in, and param2 is the
	sprite mode parameter. Notice that the choice of spriteMode will also determine
	the effect of using special characters such as # and | in text (if appearance
	allows them to take effect).	
	*/
	void drawString(int xPixel, int yPixel, const string text, const jjANIMATION animation, const jjTEXTAPPEARANCE appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0);
    /*
	Draws a tile of your choice at some position on the screen. This is purely a
	drawing operation; using it to draw masked tiles to the screen does not create
	masked areas for players or other objects to interact with. Possible values of
	tileQuadrant are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default)
	ALLQUADRANTS.	
	*/
	void drawTile(int xPixel, int yPixel, uint16 tile, TILE::Quadrant tileQuadrant = TILE::ALLQUADRANTS);
};

class jjLAYER {
    /*
	Properties used by this layer when its textureStyle is TEXTURE::CYLINDER, which
	draws texture as the inside of a horizontal cylinder receding a little ways into
	the distance. bool cylinder.fade, when true, increasingly affects colors closer
	to the horizon: when jjColorDepth is 16, a semitransparent glowing line appears
	across the horizon using the RGB color chosen by cylinder.setFadeColor, or if 8,
	texture colors in the 176207 range are moved ever closer to 207 depending
	on their proximity to the horizon. The default value is true. float
	cylinder.fadePositionX and float cylinder.fadePositionY set the location of the
	center of the horizon, as multiplied by the size of the player's screen. The
	default values are both 0.5. Changing fadePositionY very far from 0.5 tends to
	look weird, especially when cylinder.halfSize is true. bool cylinder.halfSize,
	when true, stretches the texture four times across the screen instead of only
	once and makes the curvature more extreme. The default value is false.
	jjPALCOLOR cylinder.getFadeColor() const and void
	cylinder.setFadeColor(jjPALCOLOR) read and write the RGB components of the color
	drawn over the horizon when cylinder.fade is true and jjColorDepth is 16. The
	default value is 0,0,0.	
	*/
	int cylinder; // (unknown type)
    /*
	Layers that contain no tiles at all (other than tile 0) in JCS are saved as
	defective layers that define size, speed, etc. properties but do not include
	actual tile maps, meaning that they can never be successfully drawn to the
	screen. This property is therefore false for those defective layers and true for
	all other layers.	
	*/
	const bool hasTileMap;
    /*
	Simply, whether JJ2 should draw the layer or not. (Defaults to the same value as
	hasTileMap.) In addition to the layer's tiles, this also controls whether the
	layer's onDrawLayer# hook, if any, can be called (see jjCANVAS section), but
	does not impact sprites drawn by the jjDrawSprite family no matter the value of
	their layerZ arguments. If hasTileMap is false but hasTiles is true, the
	onDrawLayer# hook will still work but no tiles will be drawn because there will
	be no tiles to draw. As an alternative to setting hasTiles to false, you can
	also exclude a layer from the drawing order altogether using jjLayerOrderSet.	
	*/
	bool hasTiles;
    /*
	The height of the layer in tiles.	
	*/
	const int height;
    /*
	Assuming the layer's tileHeight is false and its ySpeedModel is either
	LAYERSPEEDMODEL::NORMAL or LAYERSPEEDMODEL::BOTHSPEEDS, whether the layer should
	be vertically offset some pixels downward (true) or not (false), the exact value
	depending on the current resolution.	
	*/
	bool limitVisibleRegion;
    /*
	Properties used by this layer when its textureStyle is TEXTURE::MENU, which
	draws the rotating menu effect from the game's main menu. If textureSurface is
	SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then x/yInnerAutoSpeed control the
	rotating/zooming speeds respectively. bool menu.lightToDark should be set to
	true if the palette rows are light-to-dark gradients instead of the
	dark-to-light gradients used by the game's menu palette, but the default value
	is false. uint8 menu.palrow16 and uint8 menu.palrow32 and uint8 menu.palrow256
	pick the 16-color-long palette rows used by the three different rotating
	sublayers, with the smaller numbers corresponding to the further back sublayers.
	The default values are all 0. float menu.pivotX and float menu.pivotY are the
	point that all rotation happens around, as multiplied by the size of the
	player's screen. The default values are both 0.5.	
	*/
	int menu; // (unknown type)
    /*
	Properties used by this layer when its textureStyle is TEXTURE::REFLECTION,
	which draws the bottom part of the screen as a 3D plane stretching into an
	infinite horizon (similar to warpHorizon). However, the top part of the screen
	is not drawn to by this layer at all, and the bottom part (the 3D plane)
	reflects (i.e. vertically mirrors) all the tiles and sprites that had already
	been drawn to the top part of the screen prior to this layer being drawn. This
	texture style does not support sprite modes. uint8 reflection.distance adjusts
	how close the 3D plane appears to be to the camera view. The default value is 0.
	uint8 reflection.distortion distorts the reflection away from being a pure
	vertical mirroring, with higher values being more distorted, as based on the
	texture image and its internal offset. The default value is 0. float
	reflection.fadePositionX sets the location of the horizontal center of the
	horizon, as multiplied by the size of the player's screen. The default value is
	0.5. uint8 reflection.tintColor and uint8 reflection.tintOpacity combine to draw
	a constant semitransparent color over the entire reflective plane, similar to
	drawing a rectangle with SPRITE::BLEND_NORMAL but better optimized. Their
	default values are 192 (the middle palette index from the 176207 color
	gradient used by most textured background images) and 0 (no tint at all)
	respectively.	
	*/
	int reflection; // (unknown type)
    /*
	Not settable in JCS: the offset of the angle at which this layer rotates while a
	player is stoned, with a domain of 01023 to be passed to jjSin and jjCos.
	Layers 18 have values -512, -256, 0, 0, 0, 256, 512, and 768,
	respectively. A script-created jjLAYER will default to 0.	
	*/
	int rotationAngle;
    /*
	Not settable in JCS: the multipler of the distance this layer is offset from its
	center while rotating while a player is stoned. A value of 0 means the layer
	will not rotate at all; jjLayers[5].rotationRadiusMultiplier = 0; might
	therefore be a useful line of code in levels that give Layer 5 speed values to
	match Layer 4's. Layers 18 have values 4, 3, 0, 0, 2, 2, 1, and 1,
	respectively. A script-created jjLAYER will default to 0.	
	*/
	int rotationRadiusMultiplier;
    /*
	The sprite mode and sprite mode parameter used to draw this layer's tiles or
	texture effect. The default values for all layers are SPRITE::NORMAL and 0, but
	other possible SPRITE::Mode constants appear with explanations in the appendix
	below. For non-textured layers, all tiles in this layer whose jjTileType values
	are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite
	mode and parameter, while tile types 1, 2, 3, and 6 override this with
	SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN
	respectively. Textured layers ignore tile types altogether but have their own
	caveat: they will be drawn in 8-bit style in order to create a sprite suitable
	for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is
	noticeable only when jjColorDepth is 16, textureStyle is WARPHORIZON, TUNNEL, or
	CYLINDER, and fade is true. These properties do not affect any calls made to any
	jjCANVAS methods on an onDrawLayer hook attached to this layer.
	SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No
	sprite modes other than SPRITE::NORMAL are supported by textured layers using
	TEXTURE::REFLECTION.	
	*/
	SPRITE::Mode spriteMode;
    /*
	The sprite mode and sprite mode parameter used to draw this layer's tiles or
	texture effect. The default values for all layers are SPRITE::NORMAL and 0, but
	other possible SPRITE::Mode constants appear with explanations in the appendix
	below. For non-textured layers, all tiles in this layer whose jjTileType values
	are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite
	mode and parameter, while tile types 1, 2, 3, and 6 override this with
	SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN
	respectively. Textured layers ignore tile types altogether but have their own
	caveat: they will be drawn in 8-bit style in order to create a sprite suitable
	for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is
	noticeable only when jjColorDepth is 16, textureStyle is WARPHORIZON, TUNNEL, or
	CYLINDER, and fade is true. These properties do not affect any calls made to any
	jjCANVAS methods on an onDrawLayer hook attached to this layer.
	SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No
	sprite modes other than SPRITE::NORMAL are supported by textured layers using
	TEXTURE::REFLECTION.	
	*/
	uint8 spriteParam;
    /*
	For textured layers, which 256256 pixel (aka 88 tile) texture is
	used by the layer, unless textureStyle is TEXTURE::MENU. Defaults to
	TEXTURE::FROMTILES (previously named LAYER8 after the only layer that could be
	reasonably textured), meaning whatever the first 64(=8*8) tiles in the layer
	are. (If the layer has fewer than 64 tiles, this may cause JJ2 to crash.) If
	jjPIXELMAP::makeTexture was called on this layer, then texture will equal
	TEXTURE::CUSTOM, but you cannot write that value to this property manually. The
	other options are listed in the appendix at the bottom of this file.	
	*/
	TEXTURE::Texture texture;
    /*
	Whether this layer should be drawn as a texture effect instead of as a regular
	grid of tiles, and if so, to which parts of the screen it should be drawn. A few
	enum options are available: SURFACE::UNTEXTURED: The default, corresponding to
	leaving the "Texture mode" checkbox for this layer unchecked in JCS. The layer
	will be drawn as a grid of tiles. SURFACE::LEGACY: Used by default by layers in
	levels (either as part of the main level or imported using jjLayersFromLevel)
	that have the "Texture mode" checkbox checked in JCS and use
	TEXTURE::WARPHORIZON. When used on layers other than layer 8, this option
	nevertheless copies many of layer 8's properties when deciding how to draw the
	texture, and may in some circumstances draw the warp horizon effect to only
	certain areas of the subscreen. This is included for backwards compatibility but
	FULLSCREEN should usually be preferable. SURFACE::FULLSCREEN: New in JJ2+. Used
	by default by layers with the "Texture mode" checkbox checked that use any
	textureStyle other than WARPHORIZON. Draws the texture mode to each player's
	entire subscreen. SURFACE::INNERWINDOW SURFACE::INNERLAYER: New in JJ2+. The
	layer will be drawn as some sort of texture effect, but within the same
	rectangular area that the layer would be drawn were it being drawn as a grid of
	tiles instead. This allows you to have multiple texture effects on-screen at
	once or do other cool tricks. The inner speed properties will be used for
	angling the texture within the layer's area. The difference between the two is
	that INNERWINDOW acts as if the texture were being drawn to the full size of the
	subscreen, and provides a layer-sized window to a portion of that full screen
	effect, whereas INNERLAYER exclusively uses the origin and dimensions of the
	layer itself. For example, consider a warp horizon texture effect drawn to the
	top half of the subscreen with fadePositionY at 0.5. Using INNERWINDOW, the fade
	effect will be drawn halfway down the subscreen, at the bottom of the layer.
	Using INNERLAYER, the fade effect will be drawn halfway down the layer, one
	quarter of the way down the subscreen. On tiled dimensions (using tileHeight
	and/or tileWidth), there is no difference between INNERWINDOW and INNERLAYER,
	and if both dimensions are tiled, there is no difference between either and
	FULLSCREEN, except for the use of the inner speed properties.	
	*/
	SURFACE::Surface textureSurface;
    /*
	The visual effect used by a layer for which textureSurface is not set to
	SURFACE::UNTEXTURED, defaulting to whichever is specified in the layer's texture
	dropdown box in JCS. Options are TEXTURE::CYLINDER, TEXTURE::MENU,
	TEXTURE::REFLECTION, TEXTURE::TILEMENU, TEXTURE::TUNNEL, TEXTURE::WAVE, and
	TEXTURE::WARPHORIZON (the only such option available in vanilla JJ2) For all
	cases but MENU and TILEMENU, the texture's offset is determined by combining the
	speed, autoSpeed, and offset properties of this layer, and/or of jjLayers[5] if
	the speedModel properties equal LAYERSPEEDMODEL::LAYER8, or by the various inner
	speed properties if textureSurface is SURFACE::INNERLAYER or
	SURFACE::INNERWINDOW.	
	*/
	TEXTURE::Style textureStyle;
    /*
	Whether the layer should be vertically tiled, as seen in the JCS Layer
	Properties window.	
	*/
	bool tileHeight;
    /*
	Whether the layer should be horizontally tiled, as seen in the JCS Layer
	Properties window. Setting this to true for a layer that is not saved with Tile
	Width checked in JCS may lead to unpredictable effects if the layer's width and
	widthReal are not equal. If you wish to turn it on partway through the level, it
	is best to check Tile Width in JCS and then disable it in onLevelLoad.	
	*/
	bool tileWidth;
    /*
	Properties used by this layer when its textureStyle is TEXTURE::TILEMENU, which
	draws the rotating menu effect from the game's main menu, but with different
	graphics. texture is used for the frontmost rotating sublayer, then the middle
	sublayer is filled with the 22 square set of tiles in the top left corner
	of layer 4, from 0,0 to 1,1, and the back sublayer is filled with tile 0,2 in
	layer 4. If textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then
	x/yInnerAutoSpeed control the rotating/zooming speeds respectively. bool
	tileMenu.fullSize sets whether the rotating sublayers are drawn at half size
	(false, default) or full size (true). float tileMenu.pivotX and float
	tileMenu.pivotY are the point that all rotation happens around, as multiplied by
	the size of the player's screen. The default values are both 0.5.	
	*/
	int tileMenu; // (unknown type)
    /*
	Properties used by this layer when its textureStyle is TEXTURE::TUNNEL, which
	draws texture as a series of concentric, ever-smaller circles receding into the
	distance, though it is repeated horizontally only once.. bool tunnel.fade, when
	true, increasingly affects colors farther into the background: when jjColorDepth
	is 16, a glowing circle appears in the tunnel's center using the RGB color
	chosen by tunnel.setFadeColor, or if 8, texture colors in the 176207 range
	are moved ever closer to 207 depending on their proximity to the center. The
	default value is true. float tunnel.fadePositionX and float tunnel.fadePositionY
	set the location of the center of the tunnel, clamped to a 01 range, as
	multiplied by the size of the player's screen. The default values are both 0.5.
	bool tunnel.spiral, when true, makes the concentric circles gradually spiral
	inwards into the distance. The default value is false. jjPALCOLOR
	tunnel.getFadeColor() const and void tunnel.setFadeColor(jjPALCOLOR) read and
	write the RGB components of the color drawn over the center when tunnel.fade is
	true and jjColorDepth is 16. The default value is 0,0,0.	
	*/
	int tunnel; // (unknown type)
    /*
	Properties used by this layer when its textureStyle is TEXTURE::WARPHORIZON,
	which draws this layer as two horizontal 3D planes, repeating the same texture
	several times and stretching to an infinite horizon, with some amount of
	dithering/antialiasing. bool warpHorizon.fade, when true, increasingly affects
	colors closer to the horizon: when jjColorDepth is 16, a thick glowing line
	appears across the horizon using the RGB color chosen by
	warpHorizon.setFadeColor, or if 8, texture colors in the 176207 range are
	moved ever closer to 207 depending on their proximity to the horizon. The
	default value is true. float warpHorizon.fadePositionX and float
	warpHorizon.fadePositionY set the location of the center of the horizon, as
	multiplied by the size of the player's screen. The default values are both 0.5.
	bool warpHorizon.stars, when true, draws a series of little white specks appear
	across the horizon. The default value is false. jjPALCOLOR
	warpHorizon.getFadeColor() const and void warpHorizon.setFadeColor(jjPALCOLOR)
	read and write the RGB components of the color drawn over the horizon when
	warpHorizon.fade is true and jjColorDepth is 16. The default value is 0,0,0.	
	*/
	int warpHorizon; // (unknown type)
    /*
	Properties used by this layer when its textureStyle is TEXTURE::WAVE, which
	draws texture as a repeating, unrotated 2D image, but applies sine wave
	distortions at regular intervals. The properties all affect the positions and
	dimensions of those sine wave distortions. float wave.amplitudeX and float
	wave.amplitudeY set the distortions' amplitudes as multiples of the texture's
	width and height (256 pixels). The default values are both 0.5, meaning 128
	pixels. bool wave.distortionAngle effectively rotates the movement of the two
	distortions ninety degrees. The default value is false. uint8 wave.wavelengthX
	and uint8 wave.wavelengthY set the lengths of the distortions, with
	powers-of-two-minus-one such as 255 being recommended. Their default values are
	0. int8 wave.waveSpeed moves the distortions along the surface of the texture,
	independent of the texture's movement as set by the regular or inner speed
	properties. Both distortions move at the same rate as determined by this
	property's absolute value, with the directions resulting from the sign of this
	property combined with and wave.distortionAngle. The default value is 0.	
	*/
	int wave; // (unknown type)
    /*
	The width of the layer in tiles. Normally these two values will be equal, but
	they may differ on layers that were saved with the "Tile Width" checkbox checked
	in their level editors. The reason for this is that layers are not stored as
	arrays of tile IDs but rather as arrays of "word" IDs, where each word is
	defined in the "tile cache" as a row of four adjacent tile IDs. In order to
	properly tile, therefore, a layer whose width is not a multiple of four is
	expanded by the level editor to a widthReal that is the lowest common multiple
	of 4 and width, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.	
	*/
	const int width;
    /*
	The width of the layer in tiles. Normally these two values will be equal, but
	they may differ on layers that were saved with the "Tile Width" checkbox checked
	in their level editors. The reason for this is that layers are not stored as
	arrays of tile IDs but rather as arrays of "word" IDs, where each word is
	defined in the "tile cache" as a row of four adjacent tile IDs. In order to
	properly tile, therefore, a layer whose width is not a multiple of four is
	expanded by the level editor to a widthReal that is the lowest common multiple
	of 4 and width, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.	
	*/
	const int widthReal;
    /*
	The width of the layer in "words," always equal to (jjLAYER::widthReal + 3) / 4.	
	*/
	const int widthRounded;
    /*
	The auto speed of the layer, as seen in the JCS Layer Properties window.	
	*/
	float xAutoSpeed;
    /*
	The auto speed of the layer, as seen in the JCS Layer Properties window.	
	*/
	float yAutoSpeed;
    /*
	Not settable in JCS, defaulting to 0: substitute properties for setting the
	speeds of the texture effect inside a layer whose textureSurface property equals
	SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other
	textureSurface value.) The regular speed and auto speed properties (among
	others) determine the location in the level of the layer as a rectangle, and
	these inner speed properties determine how the texture effect is drawn inside
	that rectangle.	
	*/
	float xInnerAutoSpeed;
    /*
	Not settable in JCS, defaulting to 0: substitute properties for setting the
	speeds of the texture effect inside a layer whose textureSurface property equals
	SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other
	textureSurface value.) The regular speed and auto speed properties (among
	others) determine the location in the level of the layer as a rectangle, and
	these inner speed properties determine how the texture effect is drawn inside
	that rectangle.	
	*/
	float yInnerAutoSpeed;
    /*
	Not settable in JCS, defaulting to 0: substitute properties for setting the
	speeds of the texture effect inside a layer whose textureSurface property equals
	SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other
	textureSurface value.) The regular speed and auto speed properties (among
	others) determine the location in the level of the layer as a rectangle, and
	these inner speed properties determine how the texture effect is drawn inside
	that rectangle.	
	*/
	float xInnerSpeed;
    /*
	Not settable in JCS, defaulting to 0: substitute properties for setting the
	speeds of the texture effect inside a layer whose textureSurface property equals
	SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other
	textureSurface value.) The regular speed and auto speed properties (among
	others) determine the location in the level of the layer as a rectangle, and
	these inner speed properties determine how the texture effect is drawn inside
	that rectangle.	
	*/
	float yInnerSpeed;
    /*
	Not settable in JCS: constant pixel values added to the position of the layer,
	regardless of its speed.	
	*/
	float xOffset;
    /*
	Not settable in JCS: constant pixel values added to the position of the layer,
	regardless of its speed.	
	*/
	float yOffset;
    /*
	The speed of the layer, as seen in the JCS Layer Properties window.	
	*/
	float xSpeed;
    /*
	The speed of the layer, as seen in the JCS Layer Properties window.	
	*/
	float ySpeed;
    /*
	Not settable in JCS: specifies how the layer's position on screen should be
	determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed
	properties, the resolution, and so on. There are several options available for
	the enum, as follows (for each axis): LAYERSPEEDMODEL::NORMAL: The default. A
	non-textured layer's position on this axis will be based on the layer's auto
	speed for this axis, if non-zero, or otherwise its regular speed. Except for
	jjLayers[8], only the layers that use this mode for both axes will ever be
	displayed when Low Detail is enabled. LAYERSPEEDMODEL::LAYER8: The default for
	jjLayers[8] only, a pair of odd behaviors included for backwards compatibility.
	A non-textured layer with this setting will ignore all speed and offset settings
	completely and be tied to the top/left side of the screen. A textured layer will
	instead base its position for this axis on that of jjLayers[5].
	LAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this
	axis will both be used in determining the position: for example, a layer of
	clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and
	a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to
	scroll constantly to the left but also move left or right in response to the
	player's camera. LAYERSPEEDMODEL::FROMSTART: Similar to
	LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the
	resolution and its speeds, and the top/left side of a layer will only be flush
	with the top/left side of the level if the layer's speed is 1 or the resolution
	is 320200. Using this setting forces the layer's origin to be at the
	top/left side of the level instead of varying by the resolution. Ignores
	limitVisibleRegion. LAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed
	properties, and instead ensures that the full extent of this layer will be
	visible and no blank space outside of it will be shown. The top/left side of the
	layer will be visible at the top/left edge of the level, and the bottom/right
	side of the layer will be visible at the bottom/right edge of the level, and the
	layer will scroll smoothly between those two extremes. Thus, the taller/wider
	the layer, the faster it will move, though with the exact relative speed
	dependent on the resolution and level size. If the layer is smaller than the
	window on this axis, this will effectively result in a negative relative speed.
	LAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed
	properties on this axis as multipliers of the current camera size, rather than
	camera position. When the camera is at the top/left of the level, the layer will
	be positioned at the camera size on this axis multiplied by the regular speed,
	or the auto speed instead when the camera is at the bottom/right, and the layer
	will scroll smoothly between those two extremes. For example, if the screen is
	600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the
	layer will be 450 pixels from the top of the screen when the camera is at the
	top of the level, and 300 pixels from the top of the screen when the camera is
	at the bottom of the level. Ignores limitVisibleRegion. Note that all mentions
	of "textured" layers in the above descriptions refer to when textureSurface is
	LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL,
	WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied
	to whatever position is determined by the rules above. If such a layer uses MENU
	or TILEMENU instead, then its speed models are ignored altogether. For
	INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they
	would be for non-textured layers for determining the layer's position within the
	level, and the inner speed properties are used for determining the texture's
	position within the layer.	
	*/
	LAYERSPEEDMODEL::LayerSpeedModel xSpeedModel;
    /*
	Not settable in JCS: specifies how the layer's position on screen should be
	determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed
	properties, the resolution, and so on. There are several options available for
	the enum, as follows (for each axis): LAYERSPEEDMODEL::NORMAL: The default. A
	non-textured layer's position on this axis will be based on the layer's auto
	speed for this axis, if non-zero, or otherwise its regular speed. Except for
	jjLayers[8], only the layers that use this mode for both axes will ever be
	displayed when Low Detail is enabled. LAYERSPEEDMODEL::LAYER8: The default for
	jjLayers[8] only, a pair of odd behaviors included for backwards compatibility.
	A non-textured layer with this setting will ignore all speed and offset settings
	completely and be tied to the top/left side of the screen. A textured layer will
	instead base its position for this axis on that of jjLayers[5].
	LAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this
	axis will both be used in determining the position: for example, a layer of
	clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and
	a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to
	scroll constantly to the left but also move left or right in response to the
	player's camera. LAYERSPEEDMODEL::FROMSTART: Similar to
	LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the
	resolution and its speeds, and the top/left side of a layer will only be flush
	with the top/left side of the level if the layer's speed is 1 or the resolution
	is 320200. Using this setting forces the layer's origin to be at the
	top/left side of the level instead of varying by the resolution. Ignores
	limitVisibleRegion. LAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed
	properties, and instead ensures that the full extent of this layer will be
	visible and no blank space outside of it will be shown. The top/left side of the
	layer will be visible at the top/left edge of the level, and the bottom/right
	side of the layer will be visible at the bottom/right edge of the level, and the
	layer will scroll smoothly between those two extremes. Thus, the taller/wider
	the layer, the faster it will move, though with the exact relative speed
	dependent on the resolution and level size. If the layer is smaller than the
	window on this axis, this will effectively result in a negative relative speed.
	LAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed
	properties on this axis as multipliers of the current camera size, rather than
	camera position. When the camera is at the top/left of the level, the layer will
	be positioned at the camera size on this axis multiplied by the regular speed,
	or the auto speed instead when the camera is at the bottom/right, and the layer
	will scroll smoothly between those two extremes. For example, if the screen is
	600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the
	layer will be 450 pixels from the top of the screen when the camera is at the
	top of the level, and 300 pixels from the top of the screen when the camera is
	at the bottom of the level. Ignores limitVisibleRegion. Note that all mentions
	of "textured" layers in the above descriptions refer to when textureSurface is
	LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL,
	WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied
	to whatever position is determined by the rules above. If such a layer uses MENU
	or TILEMENU instead, then its speed models are ignored altogether. For
	INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they
	would be for non-textured layers for determining the layer's position within the
	level, and the inner speed properties are used for determining the texture's
	position within the layer.	
	*/
	LAYERSPEEDMODEL::LayerSpeedModel ySpeedModel;
    /*
	Makes all tiles in the range of the rectangle with its top left corner at
	xTile,yTile and specified width and height possible to use tileSet on without
	the potential consequence of changing other occurrences of the tile in the level
	due to tile cache. The zero-argument version of the method applies to the entire
	layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and
	height to height. Does nothing if hasTileMap is false.	
	*/
	void generateSettableTileArea();
    /*
	Makes all tiles in the range of the rectangle with its top left corner at
	xTile,yTile and specified width and height possible to use tileSet on without
	the potential consequence of changing other occurrences of the tile in the level
	due to tile cache. The zero-argument version of the method applies to the entire
	layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and
	height to height. Does nothing if hasTileMap is false.	
	*/
	void generateSettableTileArea(int xTile, int yTile, int width, int height);
    /*
	Gets the last position of this layer for the specified jjPLAYER. (The results of
	calling this method for players for whom isLocal is false are undefined.) For
	example, given a jjPLAYER@ object play, you could attach water to the top of
	layer 7 by continually calling jjSetWaterLevel(play.cameraY -
	jjLayers[7].getYPosition(play), true); This takes into account everything that
	could possibly reposition a layer, including its speeds and offsets, the
	resolution and max resolution, the player's camera position, and whether the
	player is stoned. Note that these values are not updated for layers while they
	are not drawn to the screen on account of having been left out in the last call
	to jjLayerOrderSet.	
	*/
	float getXPosition(const jjPLAYER play) const;
    /*
	Gets the last position of this layer for the specified jjPLAYER. (The results of
	calling this method for players for whom isLocal is false are undefined.) For
	example, given a jjPLAYER@ object play, you could attach water to the top of
	layer 7 by continually calling jjSetWaterLevel(play.cameraY -
	jjLayers[7].getYPosition(play), true); This takes into account everything that
	could possibly reposition a layer, including its speeds and offsets, the
	resolution and max resolution, the player's camera position, and whether the
	player is stoned. Note that these values are not updated for layers while they
	are not drawn to the screen on account of having been left out in the last call
	to jjLayerOrderSet.	
	*/
	float getYPosition(const jjPLAYER play) const;
    /*
	Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is
	masked. Returns false if hasTileMap is false.	
	*/
	bool maskedHLine(int xPixel, int lineLength, int yPixel) const;
    /*
	Returns true if pixel xPixel,yPixel is masked. Returns false if hasTileMap is
	false.	
	*/
	bool maskedPixel(int xPixel, int yPixel) const;
    /*
	If any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked, returns
	the height of the topmost masked pixel relative to yPixel. (For example, if
	xPixel,yPixel+2 is masked but +1 and +0 weren't, the function returns 2.) If
	none of the pixels are masked, returns lineLength+1. Used for detecting inclines
	and the like. Returns 0 if hasTileMap is false.	
	*/
	int maskedTopVLine(int xPixel, int yPixel, int lineLength) const;
    /*
	Returns true if any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is
	masked. Returns false if hasTileMap is false.	
	*/
	bool maskedVLine(int xPixel, int yPixel, int lineLength) const;
    /*
	Changes the X or Y speed. Unlike the basic properties like xSpeed and
	yAutoSpeed, these functions will ensure that the layer remains in the same
	position it was before its speeds were changed, and can therefore be much more
	useful.	
	*/
	void setXSpeed(float newspeed, bool newSpeedIsAnAutoSpeed);
    /*
	Changes the X or Y speed. Unlike the basic properties like xSpeed and
	yAutoSpeed, these functions will ensure that the layer remains in the same
	position it was before its speeds were changed, and can therefore be much more
	useful.	
	*/
	void setYSpeed(float newspeed, bool newSpeedIsAnAutoSpeed);
    /*
	Returns the current tile at location xTile,yTile. If the tile is an animated
	tile, this function will return the tile ID for that animated tile instead of
	the current frame. Returns 0 if hasTileMap is false.	
	*/
	uint16 tileGet(int xTile, int yTile) const;
    /*
	Sets the current tile at location xTile,yTile to be newTile. The same change
	will be applied to all instances of the same four-tile word that appear
	elsewhere in the level unless the tiles had had generateSettableTileArea used on
	them prior to the change. Returns newTile, or 0 (and does nothing) if hasTileMap
	is false.	
	*/
	uint16 tileSet(int xTile, int yTile, uint16 newTile);
};

class jjTEXTAPPEARANCE {
    /*
	Horizontal alignment of text. This can take values of DEFAULT, LEFT, CENTER or
	RIGHT. Whereas LEFT, CENTER and RIGHT should be self-explanatory, DEFAULT is the
	value JJ2 used for all strings originally, defined as follows: if xPixel is less
	than 0x4000, the string will have its left side aligned to the left side of the
	screen or layer. If in the range of 0x4000 to 0xFFFF, the string will be
	center-aligned relative to 0x8000, so for instance 0x8020 would align the center
	of the string to 0x20 pixels right of the center of the screen. Finally, if
	xPixel is greater than or equal to 0x10000, it will be drawn with its right side
	aligned to the right side of the screen instead, with higher values moving
	farther left. Note that these special cases currently apply only for drawing to
	the screen; the use of values of 0x4000 or higher for onDrawLayer# hooks is
	currently undefined.	
	*/
	STRING::Alignment align;
    /*
	Treatment of the at ('@') character. If it's SPECIALSIGN, at will begin a new
	line of text 20 pixels below the previous one.	
	*/
	STRING::SignTreatment at;
    /*
	Treatment of the caret ('^') character. If it's SPECIALSIGN, caret will be
	displayed as infinity signs.	
	*/
	STRING::SignTreatment caret;
    /*
	Treatment of the hash ('#') character. If it's SPECIALSIGN, characters following
	hash will use a pattern of colors (or other parameters depending on sprite mode
	of the string).	
	*/
	STRING::SignTreatment hash;
    /*
	Usually strings achieve naturally looking spacing between characters by placing
	the next character at character width + spacing relative to the previous one.
	When this property is set to true, character width is disregarded, and placement
	is determined only by spacing, i.e. is constant throughout the string (unless
	modified by special function of section sign). Because, by default, spacing is a
	low value, you may want to modify it if you use this property. This property is
	compatible with section, although the result of changing the spacing partway
	through a string may look somewhat bizarre.	
	*/
	bool monospace;
    /*
	Treatment of the line feed character (created by the escape sequence '\n' in
	AngelScript). If it's either DISPLAYSIGN or SPECIALSIGN, line feed will begin a
	new line of text below the previous one, with vertical spacing varying depending
	on font size.	
	*/
	STRING::SignTreatment newline;
    /*
	Treatment of the pipe ('|') character. If it's SPECIALSIGN, pipe will change
	text color (or other parameter depending on sprite mode of the string) of the
	following characters.	
	*/
	STRING::SignTreatment pipe;
    /*
	Treatment of the section sign ('') character. If it's SPECIALSIGN, section
	sign will use ASCII code of the directly following character to determine
	spacing used for further text.	
	*/
	STRING::SignTreatment section;
    /*
	Whether or not to ignore the first character of a string if it's a hash ('#').
	The ignored hash will not be displayed or otherwise affect the string. If the
	string is preceded by more than one hash, all but the first one will be
	displayed. This property is provided mainly for compatibility with several
	STRING::Mode values, as it's used by JJ2 wherever strings are meant to be
	conditionally colored, such as menu items.	
	*/
	bool skipInitialHash;
    /*
	Default spacing between characters, in pixels. If section is set to SPECIALSIGN,
	this value only applies until the first section sign character is found, as the
	effect of the section sign is absolute rather than relative to this property.	
	*/
	int spacing;
    /*
	Treatment of the tilde ('~') character. If it's SPECIALSIGN, tilde will cancel
	the special effect of hash or, if it's already inactive, it will change the
	color (or other parameter depending on sprite mode) to default.	
	*/
	STRING::SignTreatment tilde;
    /*
	Horizontal and vertical amplitudes of text movement.	
	*/
	int xAmp;
    /*
	Horizontal and vertical amplitudes of text movement.	
	*/
	int yAmp;
};

class jjPLAYERDRAW {
    /*
	When true, causes the player sprite (and some other effects) to rise and fall in
	a gradual sine wave motion. By default, only true for rabbits whose
	jjPLAYER::fly is FLIGHT::AIRBOARD.	
	*/
	bool airboardBouncingMotion;
    /*
	When true, causes little brown explosions to appear behind the player at regular
	intervals. By default, only true for rabbits whose jjPLAYER::fly is
	FLIGHT::AIRBOARD.	
	*/
	bool airboardPuff;
    /*
	What angle to draw the player sprite at, in the manner of the angle parameter of
	jjCANVAS::drawRotatedSprite. (Only the player sprite itself is affected by this,
	none of the other elements potentially being drawn.) By default always 0 unless
	jjPLAYER::poleSpin has been called with both xSpeed and ySpeed using non-zero
	values.	
	*/
	int angle;
    /*
	The current sprite number, as an index to jjAnimFrames, that should be drawn for
	this player. Changing this is a purely visual effect and does not affect
	sprite-based collision with pickups, enemies, and so on. By default, equals the
	same as jjPLAYER::curFrame.	
	*/
	uint curFrame;
    /*
	When not set to TEAM::NEUTRAL, this property causes a flag of the specified
	color to be drawn behind the player, with its direction based on xScale/yScale.
	If the player is carrying a flag in CTF, DCTF, or Flag Run, this value will be
	TEAM::BLUE or TEAM::RED as appropriate. Setting this property to TEAM::GREEN or
	TEAM::YELLOW is also allowed, but the appearance of those flags is somewhat of a
	placeholder and may change in future JJ2+ revisions if they ever become
	important for actual gameplay reasons.	
	*/
	TEAM::COLOR flag;
    /*
	When true, a sprite of a small flash is drawn coming out of the player's gun.
	Has no effect when angle does not equal 0 or either xScale or yScale do not
	equal 1 or -1. By default, only true immediately after the player has fired.	
	*/
	bool gunFlash;
    /*
	When true, a series of blue circles are drawn following the player around. By
	default, only true when jjPLAYER::invincibility is greater than 0.	
	*/
	bool invincibility;
    /*
	What layer to draw the player (and related elements) in front of. By default
	always 4.	
	*/
	int layer;
    /*
	The intensity of light emitted by the player. By default, equals the same as
	jjPLAYER::light.	
	*/
	int8 light;
    /*
	The type of light emitted by the player. Possible values are NONE, NORMAL,
	POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER. By
	default, equals the same as jjPLAYER::lightType.	
	*/
	LIGHT::Type lightType;
    /*
	When true, the string jjPLAYER::name will be drawn above the player's head. By
	default, true in non-local games when jjPLAYER::frozen is 0 and the F8 key has
	not been pressed.	
	*/
	bool name;
    /*
	The player being drawn. This is a read-only property, so you can modify
	properties of the player but you cannot change which jjPLAYER object the
	jjPLAYERDRAW object has a handle to.	
	*/
	jjPLAYER@ player;
    /*
	Whether each of the possible shields should be drawn around the player: for
	example, you can set shield[SHIELD::FIRE] = true; to draw the fire shield.
	Applicable options in the SHIELD::Shield enum are FIRE, BUBBLE/WATER,
	LIGHTNING/PLASMA, and LASER. By default, each is only true if it is the value of
	jjPLAYER::shieldType, the player is non-local or jjPLAYER::shieldTime is greater
	than -128, and jjPLAYER::frozen is 0.	
	*/
	fakearray<SHIELD::Shield, bool> shield;
    /*
	Determines whether the player sprite should be drawn at all. By default, usually
	true but sometimes false when the player is flashing from being hurt or from
	timing out in an online server.	
	*/
	bool sprite;
    /*
	What sprite mode to use for the player. By default, equals the same as
	jjPLAYER::spriteMode, or SPRITE::FROZEN if jjPLAYER::frozen is non-zero.	
	*/
	SPRITE::Mode spriteMode;
    /*
	A sprite mode parameter further specifying how the player should be drawn. By
	default, equals the same as jjPLAYER::spriteParam.	
	*/
	uint8 spriteParam;
    /*
	When true, spriteMode and spriteParam will be ignored in favor of drawing the
	player in random flashing colors with lots of little star-shaped particles
	appearing nearby. By default, true when the player genuinely has a sugar rush
	but jjPLAYER::frozen is 0.	
	*/
	bool sugarRush;
    /*
	When true, a glowing white trail follows the player around. By default, true
	when the player is moving at a decent speed.	
	*/
	bool trail;
    /*
	Allows you to draw most elements of the player at some relative position offset
	from the player's actual position. This is more powerful and more customizable
	than airboardBouncingMotion, which in particular does not modify the position
	the player's name is drawn at. By default, both properties equal 0.	
	*/
	float xOffset;
    /*
	Allows you to draw most elements of the player at some relative position offset
	from the player's actual position. This is more powerful and more customizable
	than airboardBouncingMotion, which in particular does not modify the position
	the player's name is drawn at. By default, both properties equal 0.	
	*/
	float yOffset;
    /*
	What scale to draw the player at, in the manner of the corresponding parameters
	of jjCANVAS::drawResizedSprite. By default, xScale will equal 1 or -1 depending
	on jjPLAYER::direction, and yScale will equal 1 if jjPLAYER::antiGrav is false
	or -1 if it is true.	
	*/
	float xScale;
    /*
	What scale to draw the player at, in the manner of the corresponding parameters
	of jjCANVAS::drawResizedSprite. By default, xScale will equal 1 or -1 depending
	on jjPLAYER::direction, and yScale will equal 1 if jjPLAYER::antiGrav is false
	or -1 if it is true.	
	*/
	float yScale;
};

class jjANIMSET {
    /*
	ID of the first animation in the set, to be used with the jjAnimations array.	
	*/
	uint firstAnim;
    /*
	Creates space for an animation set with the number of animations equal to length
	of frameCounts, each with a number of frames determined by the corresponding
	frameCounts array element.	
	*/
	jjANIMSET@ allocate(const array<uint> frameCounts);
    /*
	Loads animation set specified by fileSetID from a j2a file specified by
	filename. Using the default value of fileSetID results in loading the set
	appropriate for the jjANIMSET it's called on. If filename is left empty, it
	deduces the file name from fileSetID, using either Anims.j2a or plus.j2a. By
	default, any new animations and animframes begin at the first unused entries in
	jjAnimations and jjAnimFrames respectively. By passing positive values to the
	firstAnimToOverwrite and/or firstFrameToOverwrite arguments, however, you may
	choose specific animations and/or animframes to overwrite instead.	
	*/
	jjANIMSET@ load(uint fileSetID = 2048, const string filename = "", int firstAnimToOverwrite = -1, int firstFrameToOverwrite = -1);
    /*
	Loads animation set defined in a sprite sheet image. This method overload is an
	alternate way to turn your external graphics into JJ2 sprites compared to the
	above overload which reads from an external j2a file instead. Loading from a
	sprite sheet is designed to be easier, though less flexible. For example,
	suppose you want to replace the sprites used by the Helmut enemy, which is a
	simple case that only uses two animations: standing and walking. We'll use these
	public domain sprites from opengameart.org. (For best results, you should
	generally use images that have been manually drawn or edited to use the standard
	JJ2 sprite palette or else the palette of the specific level you're using the
	sprites in, but the jjPIXELMAP constructor's automatic color reduction for 24-
	or 32-bit images is fine for an example.) void onLevelLoad() {
	jjAnimSets[ANIM::HELMUT].load( jjPIXELMAP("Margery.png"), frameWidth: 24,
	frameHeight: 26, frameSpacingX: 2, frameSpacingY: 2, startY: 26,
	firstAnimToOverwrite: jjAnimSets[ANIM::HELMUT] );
	jjObjectPresets[OBJECT::HELMUT].determineCurFrame(); } The spriteSheet argument
	is self-explanatory, and is primarily intended for use in combination with the
	jjPIXELMAP constructor from filename, as above, so you can load an external PNG
	image and convert it to an animation set. The sprite sheet must take the form of
	a grid of equally-sized rectangles, where each row is a separate animation for
	this animation set and each cell is a separate frame for that animation. A
	completely blank/transparent cell indicates the end of the animation, so in the
	above example image, the first animation (standing) has only one frame but the
	second animation (walking) has six frames. The number of animations in the
	animation set is inferred from the height of the image in conjunction with the
	other arguments. frameWidth and frameHeight specify the rectangular areas used
	by every frame in every animation in the sprite sheet. The largest and smallest
	sprites in your sheet must each have the same area devoted to them. However,
	JJ2+ will trim the transparent pixels from around the edges of every frame: in
	the above example, none of the sprites extend all the way to the left and right
	sides of their rectangles, so none of the resulting jjANIMFRAME objects will be
	the full 24 pixels wide.	
	*/
	jjANIMSET@ load(const jjPIXELMAP spriteSheet, uint frameWidth, uint frameHeight, uint frameSpacingX = 0, uint frameSpacingY = 0, uint startX = 0, uint startY = 0, const array<int> coldSpotYOffsets = array<int>(), int firstAnimToOverwrite = -1, int firstFrameToOverwrite = -1);
};

class jjANIMATION {
    /*
	ID of the first frame of the animation, to be used with the jjAnimFrames array.	
	*/
	uint firstFrame;
    /*
	This property corresponds to the "FPS" number for animations in Jazz Sprite
	Dynamite, but that name is only a guess, because its value is never referenced
	by JJ2 at all. Most commonly equals 10.	
	*/
	int16 fps;
    /*
	The number of frames used by the animation.	
	*/
	uint16 frameCount;
    /*
	Saves all the frames of this animation to an animated GIF image file on the
	local computer and returns whether successful. The image will be saved with
	whatever palette is passed to this method, by default the game's current
	palette. Each frame's delay time will be set to jjANIMATION::fps. There are
	several limits to this method. The file cannot be saved in any directory other
	than the default one, which is the directory containing the executable (for
	local games and servers) or cache (for clients). File extension has to be ".gif"
	and if any other or no extension is provided in the string, it will be replaced.
	Additionally, scripts downloaded from a server can only save up to 16 files on
	the computer of a client; they are, however, allowed to overwrite files they
	saved previously. (The limit of 16 files is shared with jjPIXELMAP::save and
	jjSTREAM::save).	
	*/
	bool save(const string filename, const jjPAL palette = jjPalette) const;
    /*
	Reads all frames of a GIF image on the local computer and outputs them as a
	series of jjANIMFRAME objects, and adjusts this animation's firstFrame and
	frameCount properties to match the new frames. Each frame in the animation will
	be trimmed to exclude fully transparent rows/columns on the edges. Returns true
	on success or false if the filename cannot be found or is in some way not a
	valid GIF. Each resulting sprite will use the same palette indices as the GIF
	itself. The GIF's own palette will be ignored. For the easiest to understand
	results, then, you should use a GIF using an unoptimized palette that is
	identical or similar (e.g. day vs. night versions) to the one the level is
	using, or grayscale for use with SPRITE::ALPHAMAP. Alternatively, you may want
	to load the GIF's actual palette using jjPAL::load. jjANIMFRAME::coldSpotY is
	only relevant to certain objects affected by gravity, which use it to determine
	how far off the ground their sprites should be. For the first frame, coldSpotY
	will be set to the bottom of the opaque pixels, and each subsequent sprite will
	have its coldSpotY at the same distance from its hotSpotY as in the first
	sprite. If this automatic guess isn't quite right for your sprites, and you want
	to adjust these numbers so the sprites sink into the ground or float above it a
	little more, you can use the optional coldSpotYOffset argument. By default, any
	new animframes begin at the first unused entries in jjAnimFrames. By passing a
	positive value to the firstFrameToOverwrite argument, however, you may choose
	specific animframes to overwrite instead. This method always sets
	jjANIMFRAME::gunSpotX and jjANIMFRAME::coldSpotX to the same value as
	jjANIMFRAME::hotSpotX, jjANIMFRAME::gunSpotY to the same value as
	jjANIMFRAME::hotSpotY, jjANIMFRAME::transparent to false, and jjANIMATION::fps
	to the first gif frame's delay (or 10 if no delay is specified in the file). If
	your script has any more specialized use for those properties you will have to
	set them manually.	
	*/
	bool load(const string filename, int hotSpotX, int hotSpotY, int coldSpotYOffset = 0, int firstFrameToOverwrite = -1);
};

class jjANIMFRAME {
    /*
	Horizontal and vertical position of the frame's cold spot, relative to its hot
	spot. It is considered to be the point at which the frame would touch the
	ground. It's mostly used by objects such as walking enemies and pickup crates,
	as well as players themselves. In particular, the jjOBJ method putOnGround, if
	its argument is set to true, uses coldSpotY to determine the outcome.	
	*/
	int16 coldSpotX;
    /*
	Horizontal and vertical position of the frame's cold spot, relative to its hot
	spot. It is considered to be the point at which the frame would touch the
	ground. It's mostly used by objects such as walking enemies and pickup crates,
	as well as players themselves. In particular, the jjOBJ method putOnGround, if
	its argument is set to true, uses coldSpotY to determine the outcome.	
	*/
	int16 coldSpotY;
    /*
	Horizontal and vertical position of the frame's gun spot, i.e. the point that's
	used to determine initial position of projectiles, relative to its hot spot.
	Originally this is only defined for player animations and sprites of enemies
	that produce projectiles.	
	*/
	int16 gunSpotX;
    /*
	Horizontal and vertical position of the frame's gun spot, i.e. the point that's
	used to determine initial position of projectiles, relative to its hot spot.
	Originally this is only defined for player animations and sprites of enemies
	that produce projectiles.	
	*/
	int16 gunSpotY;
    /*
	Frame height in pixels.	
	*/
	const uint16 height;
    /*
	Horizontal and vertical position of the frame's hot spot, added to the sprite
	position by all drawing operations and used by collision detection, etc. These
	properties are analogous to the hot spot coordinates shown by Jazz Sprite
	Dynamite, however it should be noted that JSD inverts their values for user
	convenience, while JJ2 doesn't. This means that you will usually want to use
	negative values for these properties.	
	*/
	int16 hotSpotX;
    /*
	Horizontal and vertical position of the frame's hot spot, added to the sprite
	position by all drawing operations and used by collision detection, etc. These
	properties are analogous to the hot spot coordinates shown by Jazz Sprite
	Dynamite, however it should be noted that JSD inverts their values for user
	convenience, while JJ2 doesn't. This means that you will usually want to use
	negative values for these properties.	
	*/
	int16 hotSpotY;
    /*
	Whether the frame is to be drawn as translucent by default. The only AngelScript
	function this directly affects is the jjOBJ method draw but JJ2 objects often
	use this property, e.g. to draw freezer ammo pickups as translucent even though
	they use the same behavior as any other pickup.	
	*/
	bool transparent;
    /*
	Frame width in pixels.	
	*/
	const uint16 width;
    /*
	Returns true if this sprite (at position xPos,yPos and direction direction)
	would collide with another sprite with its own specified coordinates and
	direction, taking both sprites' hotspot positions into account; otherwise false.
	If always is true, collisions will be registered even if there is only one
	overlapping pixel (used by bullets); the default value of false will require at
	least about eight common pixels (used by players), which is probably a better
	test in most cases. Both direction parameters will be tested for the sprites
	being horizontally flipped, vertically flipped, or both, and the collision
	detection will be carried out accordingly.	
	*/
	bool doesCollide(int xPos, int yPos, int direction, const jjANIMFRAME@ frame2, int xPos2, int yPos2, int direction2, bool always = false) const;
};

class jjTILE {
    /*
	Animation speed in frames per second. For static tiles this is always 0. This
	property is safe to modify, but it is currently undefined which animation frame
	will be visible immediately after the change.	
	*/
	uint8 fps;
    /*
	Tile ID corresponding to the instance, such that for every non-null jjTILE
	handle tile, tile is jjTiles[tile.tileID].	
	*/
	const uint16 tileID;
    /*
	Constructs and returns an array of tile IDs of animation frames of the instance.
	For static tiles this is an array of size 1 containing this tile's own ID. The
	returned array represents animation frames after all transformations selected in
	animating tile properties, such as ping-pong animation or frames to wait between
	animation cycles. This means that the result may contain more entries than the
	animation as viewed in JCS. Keep in mind that in levels edited by other means
	than JCS, entries of the array may themselves be animations.	
	*/
	array<uint16>@ getFrames() const;
    /*
	Entirely replaces the previous array of animation frames for this animated tile
	with a new one based on the passed arguments. Returns false if frames is empty
	(zero frames long) or if this is not a valid animated tile. The results are
	undefined if frames is more than 64 frames long. The arguments correspond
	exactly to the similarly named JCS animated tile properties, respectively:
	"Ping-Pong animation"; "Frames to wait between two animation cycles"; "Random
	adder amplitude for frame wait"; and "Frame wait interval between Ping-Pong
	cycle." Note that this method is used to replace an existing animated tile. At
	this time there is no way to expand the number of animated tiles past however
	many are defined in the level.	
	*/
	bool setFrames(const array<uint16> frames, bool pingPong = false, uint16 wait = 0, uint16 randomWait = 0, uint16 pingPongWait = 0);
};

class jjPIXELMAP {
    uint8& opIndex(uint x, uint y);
	const uint8& opIndex(uint x, uint y);
	/*
	Dimensions of the map in pixels, set by the map's constructor. These properties
	are read-only but may be modified using the addBorders, crop, resize, or trim
	methods, or swapped using the rotate method.	
	*/
	const uint height;
    /*
	Dimensions of the map in pixels, set by the map's constructor. These properties
	are read-only but may be modified using the addBorders, crop, resize, or trim
	methods, or swapped using the rotate method.	
	*/
	const uint width;
    /*
	For each of the four edges of the current image, this method either extends the
	image outwards by a number of pixels (positive number, filling in the new empty
	space with borderColor) or crops the image inwards (negative number). Returns a
	reference to self. If the resulting image would be size 0 on either axis, or if
	you try to crop out more of the original image than exists (e.g. width equals 9
	and both left and right equal -5), no change wil occur.	
	*/
	jjPIXELMAP& addBorders(int left, int top, int right, int bottom, uint8 borderColor = 0);
    /*
	Crops the pixel map to the specified coordinates and dimensions and returns a
	reference to self. If the arguments are invalid (width and/or height equals
	zero, or any point of the cropped rectangle is outside the current bounds), no
	change will occur.	
	*/
	jjPIXELMAP& crop(uint left, uint top, uint width, uint height);
    /*
	Flips the pixel map's image across one or both axes and returns a reference to
	self. Useful argument values are SPRITE::FLIPH, SPRITE::FLIPV and
	SPRITE::FLIPHV.	
	*/
	jjPIXELMAP& flip(SPRITE::Direction directions);
    /*
	Changes the specified layer's texture to the contents of the pixel map. If you
	leave layer as null it will default to the background layer, i.e. jjLayers[8].
	The map has to be exactly 256256 to allow this action and if that is not
	the case, the function will report failure by returning false. On success
	returns true.	
	*/
	bool makeTexture(jjLAYER@ layer = null);
    /*
	If colorMapping is length 256 or greater, replaces each index in the pixel map
	with the value in colorMapping at that index, e.g. pixels of color 10 will be
	changed to paletteColorMapping[10] instead. Returns a reference to self.	
	*/
	jjPIXELMAP& recolor(const array<uint8> colorMapping);
    /*
	If neither the old dimensions nor the new dimensions are zero on either axis,
	resizes the pixel map's image to use the new dimensions using primitive nearest
	neighbor interpolation. Returns a reference to self.	
	*/
	jjPIXELMAP& resize(uint width, uint height);
    /*
	Rotates the pixel map's image ninety degrees clockwise and returns a reference
	to self.	
	*/
	jjPIXELMAP& rotate();
    /*
	Overwrites tileset tile selected by tileID with contents of the pixel map. The
	map has to be exactly 3232 to allow this action and if that is not the
	case, the function will report failure by returning false. On success returns
	true. If (tileID & TILE::VFLIPPED) != 0, the pixel map image will be vertically
	flipped while saving the tile. TILE::HFLIPPED is somewhat more complicated,
	because JJ2 stores horizontally flipped tiles separately from their non-flipped
	versions. By default, and to avoid unnecessary memory usage, jjPIXELMAP::save
	will only save to either the regular version of the tile or the horizontally
	flipped version, depending on whether (tileID & TILE::HFLIPPED) != 0. By setting
	hFlip to true, though, you can ensure that both the regular and the horizontally
	flipped version of the tile will be overwritten. The results of saving when
	(tileID & TILE::ANIMATED) != 0 || (tileID & TILE::RAWRANGE) == 0 are undefined.	
	*/
	bool save(uint16 tileID, bool hFlip = false) const;
    /*
	Overwrites the image used by frame with contents of the pixel map. Returns true
	on success and false on failure.	
	*/
	bool save(jjANIMFRAME@ frame) const;
    /*
	Saves the contents of the pixel map to an 8-bit PNG image file on the local
	computer and returns whether successful. The image will be saved with whatever
	palette is passed to this method, by default the game's current palette. There
	are several limits to this method. The file cannot be saved in any directory
	other than the default one, which is the directory containing the executable
	(for local games and servers) or cache (for clients). File extension has to be
	".png" and if any other or no extension is provided in the string, it will be
	replaced. Additionally, scripts downloaded from a server can only save up to 16
	files on the computer of a client; they are, however, allowed to overwrite files
	they saved previously. (The limit of 16 files is shared with jjANIMATION::save
	and jjSTREAM::save).	
	*/
	bool save(const string filename, const jjPAL palette = jjPalette) const;
    /*
	Trims away all totally empty rows and columnsi.e. lines containing no
	colors other than trimColor, which defaults to 0, or transparentfrom the
	four sides of the current image and returns a reference to self. If there are no
	colors other than trimColor anywhere in the image, as a special case, the
	resulting image will be cropped to 11 instead of 00. The method
	overload with four uint &out arguments lets you know how many rows/columns were
	trimmed from each of the four sides. If no cropping occurs, they will all equal
	0, and if the image was fully trimColor, left and right will equal width (prior
	to the method being called) and top and bottom will equal height.	
	*/
	jjPIXELMAP& trim(uint8 trimColor = 0);
    /*
	Trims away all totally empty rows and columnsi.e. lines containing no
	colors other than trimColor, which defaults to 0, or transparentfrom the
	four sides of the current image and returns a reference to self. If there are no
	colors other than trimColor anywhere in the image, as a special case, the
	resulting image will be cropped to 11 instead of 00. The method
	overload with four uint &out arguments lets you know how many rows/columns were
	trimmed from each of the four sides. If no cropping occurs, they will all equal
	0, and if the image was fully trimColor, left and right will equal width (prior
	to the method being called) and top and bottom will equal height.	
	*/
	jjPIXELMAP& trim(uint left, uint top, uint right, uint bottom, uint8 trimColor = 0);
};

class jjMASKMAP {
    /*
	Overwrites mask of tileset tile selected by tileID with contents of the mask
	map. All notes mentioned for jjPIXELMAP::save apply in exactly the same way
	here, although you don't have to worry about dimensions, since mask maps are
	always 3232.	
	*/
	bool save(uint16 tileID, bool hFlip = false) const;
};
/* onChat is called whenever a chat message pops up in game. onLocalChat is called
only when chat is received from players on the same machine the script is
executing on. A return value of true indicates that the chat message should be
suppressed, whereas a return value of false will cause the message to be handled
normally. clientID is a unique ID of the game client that sent the chat message.
stringReceived is the text of the chat message that was received. chatType can
take one of the following values: NORMAL, TEAMCHAT, WHISPER amd ME. Any message
beginning with "/" is interpreted as a command, not as chat, and so will not be
passed to either of these hooks. Messages beginning with "!" will, though, as
will arguments of commands /whisper (and its aliases, /w and @) and /me.*/
void onChat(int clientID, string stringReceived, CHAT::Type chatType);
/* onChat is called whenever a chat message pops up in game. onLocalChat is called
only when chat is received from players on the same machine the script is
executing on. A return value of true indicates that the chat message should be
suppressed, whereas a return value of false will cause the message to be handled
normally. clientID is a unique ID of the game client that sent the chat message.
stringReceived is the text of the chat message that was received. chatType can
take one of the following values: NORMAL, TEAMCHAT, WHISPER amd ME. Any message
beginning with "/" is interpreted as a command, not as chat, and so will not be
passed to either of these hooks. Messages beginning with "!" will, though, as
will arguments of commands /whisper (and its aliases, /w and @) and /me.*/
bool onLocalChat(string stringReceived, CHAT::Type chatType);
/* This function is called in single player mode when a player attempts to enter a
cheat code. It will be called once for each letter appended to the cheat code
after jj. For example, in typing jjgod, onCheat will be called three times, with
cheat equal to "jjg", "jjgo" and "jjgod". A return value of true indicates the
cheat should be suppressed, whereas a return value of false will cause the cheat
to be handled normally. If you want to compare cheat to the full list of
standard cheat codes, use jjIsValidCheat, which will be updated if JJ2+ adds or
changes any cheat codes in future releases. If the player attempts to enter or
exit debug mode by pressing the F10 key, this function will be called with cheat
equaling "f10." (This is the only circumstance in which the string will not
begin with "jj.") You can test whether the player is attempting to enter or exit
by checking jjDebugF10.*/
bool onCheat(string cheat);
/* This function is called once, at the beginning of the level, and never again. If
your level's tileset has a red textured background but you want a blue one, this
is the place to change its colors. If you want the level to start with water at
a certain height without placing Water Level events all around every start
position, this is the place for that. And so on.*/
void onLevelLoad();
/* Also called only at the beginning of the level, but a little bit later, once
things have had time to be initialized. For example, onLevelLoad is fired before
any jjOBJs have been created and before certain jjPLAYER properties have been
initialized, so onLevelBegin allows you to modify those things as well.*/
void onLevelBegin();
/* In multiplayer games, these functions are called whenever the game gets started
or stopped. The firstTime parameter, if defined, is intended to capture
starts/stops resulting from the /autostart command, so it should be true for the
game being started or stopped at the beginning of the level, and false
thereafter. However, it will also be true for clients who join the level partway
through.*/
void onGameStart();
/* In multiplayer games, these functions are called whenever the game gets started
or stopped. The firstTime parameter, if defined, is intended to capture
starts/stops resulting from the /autostart command, so it should be true for the
game being started or stopped at the beginning of the level, and false
thereafter. However, it will also be true for clients who join the level partway
through.*/
void onGameStart(bool firstTime);
/* In multiplayer games, these functions are called whenever the game gets started
or stopped. The firstTime parameter, if defined, is intended to capture
starts/stops resulting from the /autostart command, so it should be true for the
game being started or stopped at the beginning of the level, and false
thereafter. However, it will also be true for clients who join the level partway
through.*/
void onGameStop();
/* In multiplayer games, these functions are called whenever the game gets started
or stopped. The firstTime parameter, if defined, is intended to capture
starts/stops resulting from the /autostart command, so it should be true for the
game being started or stopped at the beginning of the level, and false
thereafter. However, it will also be true for clients who join the level partway
through.*/
void onGameStop(bool firstTime);
/* This function is only ever called in Single Player, where it is called every
time the player dies, after everything in the level has been reinitialized.
Since a great number of things get reset in Single Player when the player dies,
this is your chance to make sure some things stay the same.*/
void onLevelReload();
/* Unlike the above functions, which are very rare, this function is called
absolutely constantly. It is important to understand that JJ2 measures time in
"ticks," which number 70 to a second. (Correspondingly, when setting the
duration for a sugar rush or somesuch, you will need to multiply by 70 to get
the desired number of seconds.) The global property jjGameTicks will tell you
how many ticks have elapsed at any given point. onMain is fired once per tick,
and allows you to check constantly whether a given property has changed, move an
object in a circle, or whatever else you find desirable.*/
void onMain();
/* This function can be called even more often than onMain: it is called once per
tick per local player. If you're playing splitscreen with two players, for
instance, it will be called two times per tick. This is a useful distinction
because of the jjPLAYER@ parameter, which points to the local player every time
onPlayer is called. If you want to prevent blaster from ever being used in a
level, for instance, void onPlayer(jjPLAYER@ play) { play.noFire =
(play.currWeapon == WEAPON::BLASTER); } is one way of doing that, whereas trying
to do the same in onMain would at minimum require manually looping through the
jjLocalPlayers array. To check which jjPLAYER is being invoked during any given
onPlayer, use the jjPLAYER.localPlayerID property. (JJ2+ used to encourage use
of a global property p (or occasionally jjP), which performed the same function
as the jjPLAYER@ argument. This coding style still works in certain cases, to
ensure backwards compatibility with older scripts, but can be unclear and is
deprecated/stylistically discouraged.)*/
void onPlayer(jjPLAYER@ play);
/* This function works essentially the same way as onPlayer, and is called very
slightly earlier in the tick, but with a caveat: it is only called when the
player's input properties, keyRight and keyJump and so on, have had the
potential to change. In particular, it is not called while chatting in a
multiplayer game unless the player can be moved by a joystick/controller instead
of the keyboard. Because of this unpredictability, it should only be used for
situations specifically relating to input, for instance swapping the effects of
a player's right and left keys.*/
void onPlayerInput(jjPLAYER@ play);
/* This function is something of a special case. By default, when a Player Timer
runs out (see the jjPLAYER section below), this function will be called for the
player whose timer just ran out. However, a single level may have multiple timer
sections with different purposes -- one where you die for not doing something
quickly enough, one where you warp after a certain delay, and so on -- so it is
also possible to change the function called using the jjPLAYER method
timerFunction. Thus onPlayerTimerEnd is simply the default function name, not
the only one you are allowed to use for this purpose.*/
void onPlayerTimerEnd(jjPLAYER@ play);
/* This function is called every time a player is roasted, including non-local
players, including self-inflicted deaths from pits and other environmental
hazards (in which case victim is killer will be true). Note however that not
every death counts as a roast, e.g. deaths from the /frustration command or from
unspectating.*/
void onRoast(jjPLAYER@ victim, jjPLAYER@ killer);
/* How long the game has been actively running, at a rate of 70 ticks per second.
Unlike jjGameTicks, this value is not incremented when the game is paused,
stopped, or in pregame. This is a local value that counts up from 0 except in
online Race games, where it is used to track lap times and is therefore synced
between server and clients.*/
const uint jjActiveGameTicks;
/* Whether weapon 8 is fireball instead pepper spray, as set by the /fireball
command.*/
const bool jjAllowsFireball;
/* Whether the server (or the SP level) allows mouse aim, as set by the
/allowmouseaim command.*/
const bool jjAllowsMouseAim;
/* Whether the server allows players to use the /ready command, as set by the
/allowready command.*/
const bool jjAllowsReady;
/* Whether the server allows players to use the walljumping bug, as set
by the /allowwalljump command.*/
const bool jjAllowsWalljump;
/* Whether always running is enabled, as set by the /run command.*/
const bool jjAlwaysRunning;
/* Animated tiles defined by the level. For every tileID,jjAnimatedTiles[tileID] is
jjTiles[tileID | TILE::ANIMATED]. See also jjTiles.*/
array<jjTILE@> jjAnimatedTiles = array<jjTILE@>(0x10000);
/* Loaded animations. See the jjANIMATION class description for more information.*/
array<jjANIMATION@> jjAnimations = array<jjANIMATION@>(1500);
/* Loaded animation frames. See the jjANIMFRAME class description for more
information.*/
array<jjANIMFRAME@> jjAnimFrames = array<jjANIMFRAME@>(15000);
/* Loaded animation sets. See the jjANIMSET class description for more information.*/
fakearray<ANIM::Set, jjANIMSET@> jjAnimSets;
/* Whether automatic weapon change is locally enabled, as set by the /weaponchange
command.*/
const bool jjAutoWeaponChange;
/* The tileset's original palette. See the jjPAL documentation above for further
details.*/
const jjPAL jjBackupPalette;
/* The size of the black borders that appear at the edges of each local player's
subscreen when a subscreen is larger than the level/server's maximum resolution,
when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile
Width/Tile Height checked), and/or when the F3 key has been used. Useful for
deciding where to draw HUD/UI elements. Note that these values refer to the size
of each border, not the overall size of the black space, so for instance if
jjBorderWidth is 80, there will be 80 columns of black pixels on the left side
of the subscreen and an additional 80 columns on the right side.*/
const int jjBorderHeight;
/* The size of the black borders that appear at the edges of each local player's
subscreen when a subscreen is larger than the level/server's maximum resolution,
when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile
Width/Tile Height checked), and/or when the F3 key has been used. Useful for
deciding where to draw HUD/UI elements. Note that these values refer to the size
of each border, not the overall size of the black space, so for instance if
jjBorderWidth is 80, there will be 80 columns of black pixels on the left side
of the subscreen and an additional 80 columns on the right side.*/
const int jjBorderWidth;
/* In Roast Tag game mode, the player who is currently the bottom feeder or null if
none. For the other special role in Roast Tag, see jjTokenOwner.*/
jjPLAYER@ jjBottomFeeder;
/* Character profiles. Use either CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD,
CHAR::FROG or CHAR::BIRD2 as an index. Refer to the jjCHARACTER section for more
information.*/
fakearray<CHAR::Char, jjCHARACTER@> jjCharacters;
/* Color depth in bits per pixel. Either 8 or 16.*/
const int jjColorDepth;
/* An array containing all Domination control points in the level. See the
jjCONTROLPOINT section for further details.*/
const array<jjCONTROLPOINT@> jjControlPoints = array<jjCONTROLPOINT@>(16);
/* When the player dies in Single Player mode, this property is set to true before
all jjOBJs have their state property set to DEACTIVATE. Since DEACTIVATE is also
used for when an object goes too far off-screen, this property is how to
discover the reason for the state change. In practice, is probably only ever
consulted by destruct scenery and trigger scenery.*/
const bool jjDeactivatingBecauseOfDeath;
/* Only ever true in single player, specifically when the player has pressed the
F10 key to enable debug mode. Among other peculiarities during this time,
neither onPlayer nor onPlayerInput nor any of the various non-layer-based
jjCANVAS onDraw hook functions will be called, because JJ2+ will be ignoring all
normal player interactions.*/
const bool jjDebugF10;
/* If set to true, box objects (trigger crates, all wooden crates, bird morph
monitors, and also bird cages) spawned from Generator objects will derive their
parameters from the tile they begin at, not the tile they are created at. If the
Generator object is in the air, the crate will appear on top of the nearest
solid tile below the Generator, and will get its parameters from the tile there.*/
bool jjDelayGeneratedCrateOrigins;
/* The current difficulty level. 1 for Normal difficulty; 0 and below for Easy; 2
for Hard; 3 and above for Turbo. Numerous enemies base their speeds at least
partially on the difficulty, so numbers outside of the well-tested 0-3 range may
have unexpected or undesirable effects with certain enemies; still, it's worth a
try! This property cannot be used to determine whether to load events specified
in JCS as Easy or Hard, since that has already been checked by the time
AngelScript starts running in a level. When you set this property,
jjDifficultyNext will also be set to the new value. So for example, if you want
to make enemies move a little faster in this level without affecting the
difficulty of the next level in the series, try: jjDifficulty += 1;
jjDifficultyNext = jjDifficultyOrig;*/
int jjDifficulty;
/* The difficulty for the next level. Normally this will be the same as
jjDifficulty, but the /difficulty command can set this property independently.
Setting this does not accomplish anything for clients, because clients will have
their difficulty updated by the server upon cycling.*/
int jjDifficultyNext;
/* The difficulty at the start of the level, prior to it being potentially changed
by scripts setting jjDifficulty. In online servers, clients who join this level
partway through will be sent this value for their difficulty, so they will
remove the same events from the event map that everyone else in the server did.*/
const int jjDifficultyOrig;
/* In Pestilence game mode, whether any player is already a zombie.*/
const bool jjDoZombiesAlreadyExist;
/* The current degree of echo, as set by the "Echo" event.*/
int jjEcho;
/* Usually all true. When a Text event is touched with AngelScript=1,Vanish=1, the
jjEnabledASFunctions[#] bool for that Text event's TextID value will be set to
false and the corresponding onFunction# will be uncallable by other Text events
until the bool is set to true again.*/
array<bool> jjEnabledASFunctions = array<bool>(256);
/* Currently enabled teams. Possible indices are TEAM::BLUE, TEAM::RED,
TEAM::GREEN, and TEAM::YELLOW.*/
const fakearray<TEAM::Color, bool> jjEnabledTeams;
/* This setting defines the minimal ambient lighting options required from the
game. It will not change game settings if they don't fulfill the requirements
but it will display lights as if the settings were changed. Allowed values are:
OPTIONAL: The default value; ambient lighting can be freely disabled and enabled
with no limits. BASIC: Ambient lighting can be disabled but basic lights, such
as those emitted by objects, players and laser shields, have to be drawn. This
only affects the game if ambient lighting is disabled and low detail is enabled,
because that's when basic lights stop being drawn. COMPLETE: Ambient lighting
cannot be disabled, all lights have to be drawn.*/
LIGHT::Enforce jjEnforceLighting;
/* Whenever one of the mask-detection functions, e.g. jjMaskedHLine, finds a masked
pixel in layer 4, this property will be set to the event at the tile containing
that pixel. This allows you to write code for object like seeker missiles, which
ignore masked pixels on tiles with the AREA::ONEWAY, AREA::HOOK, or AREA::VINE
events. There's not much reason to edit it manually, since JJ2 changes its value
all but constantly, but you can if you want.*/
uint8 jjEventAtLastMaskedPixel;
/* The current frames per second rate, as viewable by pressing F9 twice.*/
const int jjFPS;
/* Whether friendly fire is enabled, as set by the /friendlyfire command.*/
const bool jjFriendlyFire;
/* Is this game joinable by players from other computers, and if so, must they be
connected to the same network or just the internet? Options are LOCAL, ONLINE,
and LAN.*/
const GAME::Connection jjGameConnection;
/* If using a custom gamemode, what is it? Options are NOCUSTOM, RT, LRS, XLRS,
PEST, TB, JB, DCTF, FR, TLRS, DOM, and HEAD.*/
const GAME::Custom jjGameCustom;
/* What is the current base gamemode, irrespective of whether there is a custom
gamemode or not? Options are SP, COOP, BATTLE, CTF, TREASURE, and RACE.*/
const GAME::Mode jjGameMode;
/* In an online/network server, is the game started, stopped, or some other
variation? Options are. STOPPED, STARTED, PAUSED (only possible if there is a
time limit), PREGAME, and OVERTIME.*/
const GAME::State jjGameState;
/* How long the game has been actively running, at a rate of 70 ticks per second.*/
const int jjGameTicks;
/* Help strings as set in level properties and used by Text events and end bosses.
These can be modified but are limited to 511 characters each, so longer strings
will be truncated. For the standard function to display these strings, see
showText.*/
array<string> jjHelpStrings = array<string>(16);
/* Whether the current game executable is logged in as a Remote Admin in the
current online server. To check this property for any client in the server, use
jjPLAYER property isAdmin instead.*/
const bool jjIsAdmin;
/* Whether the current game executable is hosting an online server.*/
const bool jjIsServer;
/* Whether there's any active weather effect. The type of the effect is determined
by jjSnowingType.*/
bool jjIsSnowing;
/* Whether the current weather effect is specified to only take effect on
transparent tiles, i.e. appear to be limited to outdoors areas.*/
bool jjIsSnowingOutdoorsOnly;
/* Whether the current game executable is 1.23+ or 1.24+. Useful for Lori, XMas
enemies, etc.*/
const bool jjIsTSF;
/* Whether any given key on the keyboard is currently pressed, assuming JJ2 is able
to check it, including the left and right mouse buttons. Uses virtual key codes
for indexation. Note that jjKey[1] and jjKey[2] refer to the primary and
secondary mouse buttons respectively, rather than left and right.*/
const array<bool> jjKey = array<bool>(256);
/* The current virtual key used to open the chat prompt in a multiplayer game,
default value 0x54 ('T'). No matter the key (or mouse button), pressing the
Shift key at the same time will open the chat prompt in Team Chat mode (in CTF
games). Note that as a workaround to allow players to cycle and whatnot,
pressing Ctrl+T will always open the chat prompt, even if jjKeyChat is set to 0
or something similarly inaccessible.*/
uint8 jjKeyChat;
/* */
array<bool> jjLayerHasTiles = array<bool>(8);
/* */
const array<int> jjLayerHeight = array<int>(8);
/* */
array<bool> jjLayerLimitVisibleRegion = array<bool>(8);
/* */
array<bool> jjLayerTileHeight = array<bool>(8);
/* */
array<bool> jjLayerTileWidth = array<bool>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
const array<int> jjLayerWidth = array<int>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
const array<int> jjLayerWidthReal = array<int>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
const array<int> jjLayerWidthRounded = array<int>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
array<float> jjLayerXAutoSpeed = array<float>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
array<float> jjLayerYAutoSpeed = array<float>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
array<float> jjLayerXOffset = array<float>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
array<float> jjLayerYOffset = array<float>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
array<float> jjLayerXSpeed = array<float>(8);
/* Shortcut global properties for the same-named jjLAYER properties on the
same-indexed jjLayers objects.*/
array<float> jjLayerYSpeed = array<float>(8);
/* The original eight layers placed in this level (i.e. jjLevelFileName) in JCS or
some other level editor, 1-indexed to match the JCS numbers, e.g. jjLayers[4]
for the main sprite layer or jjLayers[8] for the final background layer,
regardless of what other code may have done to create new layers or alter their
order. See the jjLAYER documentation above for further details.*/
array<jjLAYER@> jjLayers = array<jjLAYER@>(8);
/* File name of the current level, e.g. castle1.j2l, all lowercase. The file
extension (.j2l) will be included, but not the folder structure.*/
const string jjLevelFileName;
/* Title of the current level, e.g. Dungeon Dilemma.*/
string jjLevelName;
/* The number of local players.*/
const int jjLocalPlayerCount;
/* The local players.*/
const array<jjPLAYER@> jjLocalPlayers = array<jjPLAYER@>(4);
/* Whether the Low Detail video setting is enabled. When true, only jjLayers[8] and
layers whose xSpeed/ySpeed both equal exactly 1 and whose
xSpeedModel/ySpeedModel both equal LAYERSPEEDMODEL::NORMAL will be drawn, and
even those only if hasTileMap and hasTiles are both true.*/
const bool jjLowDetail;
/* The most health a player can ever have, as set by the /maxhealth command.
Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.*/
const int jjMaxHealth;
/* In competitive game modes, the score required to win, as set by the /maxscore
command.*/
const int jjMaxScore;
/* Whether mouse aim is locally enabled, as set by the /mouseaim command.*/
const bool jjMouseAim;
/* The current position of the mouse cursor relative to the top left corner of the
game window. To convert these coordinates to coordinates within layer 4, you'll
need to use the jjPLAYER cameraX and cameraY properties.*/
const int jjMouseX;
/* The current position of the mouse cursor relative to the top left corner of the
game window. To convert these coordinates to coordinates within layer 4, you'll
need to use the jjPLAYER cameraX and cameraY properties.*/
const int jjMouseY;
/* Mute Music, as seen in the Sound & Music Properties window.*/
const bool jjMusicActive;
/* File name of the music file currently playing, e.g. 3ddemo.mod, all lowercase.
The file extension will be included (even if not included by the level or user,
e.g. this string will be "castle.j2b" if "castle" was written in Level
Properties), but not the folder structure. This is a const property. To change
it, use jjMusicLoad.*/
const string jjMusicFileName;
/* Music Volume, as seen in the Sound & Music Properties window.*/
const int jjMusicVolume;
/* Whether the no blink mode is enabled, as set by the /noblink command.*/
const bool jjNoBlink;
/* Whether the game blocks movement during stopped games, as set by the /nomovement
command.*/
const bool jjNoMovement;
/* When looping through jjObjects, this is the endpoint; there should never exist a
jjOBJ with an object ID higher than jjObjectCount. It is not however the number
of distinct jjOBJs in existence at any given time, since for instance
jjObjects[1] and jjObjects[3] may both be active but jjObjects[2] inactive, but
jjObjectCount would still equal 4.*/
const int jjObjectCount;
/* The most jjOBJs that can ever exist at the same time. This equals 2048 in local
Single Player/Coop, or 4096 otherwise.*/
const int jjObjectMax;
/* The templates from which each object is built. Tends to contain default xSpeed,
ySpeed, points, curAnim, and so on. Make changes here in onLevelLoad for maximum
efficiency.*/
array<jjOBJ@> jjObjectPresets = array<jjOBJ@>(256);
/* All the objects currently in memory.*/
array<jjOBJ@> jjObjects = array<jjOBJ@>(4096);
/* The current player.*/
jjPLAYER@ jjP;
/* The current palette. See the jjPAL documentation above for further details.*/
jjPAL jjPalette;
/* All the particles currently in memory. See the jjPARTICLE documentation above
for further details.*/
array<jjPARTICLE@> jjParticles = array<jjPARTICLE@>(1024);
/* Doesn't work! Check back later.*/
const int jjPlayerCount;
/* All the players in the game, local or otherwise.*/
const array<jjPLAYER@> jjPlayers = array<jjPLAYER@>(32);
/* Whether the quirks mode is enabled, as set by the /quirks command.*/
const bool jjQuirks;
/* How long the game has been running. Unlike jjGameTicks, jjRenderFrame updates
when the game is paused. This is the value used for drawing layers with
automatic x/y speeds.*/
const int jjRenderFrame;
/* The size of the current game window in pixels, usually 640 by 480.*/
const int jjResolutionHeight;
/* The size of the current game window in pixels, usually 640 by 480.*/
const int jjResolutionWidth;
/* The maximum size the game window is allowed to be in the current level/server.*/
const int jjResolutionMaxHeight;
/* The maximum size the game window is allowed to be in the current level/server.*/
const int jjResolutionMaxWidth;
/* Each script module (including mutators) will see this property as equalling a
different value: 0 for the .j2as script (if any), and 1 or higher for all
mutators (loaded in alphabetical order). For use only as parameters of function
jjSendPacket and jjPLAYER method hasPrivilege.*/
const uint jjScriptModuleID;
/* Whether the show max health option from the Plus menu is enabled.*/
const bool jjShowMaxHealth;
/* Intensity of the current weather effect. Note that that this setting only
influences the game if jjIsSnowing is true.*/
uint8 jjSnowingIntensity;
/* Type of the current weather effect. Note that that this setting only influences
the game if jjIsSnowing is true. Possible values are SNOW, FLOWER, RAIN, and
LEAF, each spawning particles of the corresponding PARTICLE::Type.*/
SNOWING::Type jjSnowingType;
/* Whether JJ2 should produce any form of audio at all.*/
const bool jjSoundEnabled;
/* Mute Sound, as seen in the Sound & Music Properties window.*/
const bool jjSoundFXActive;
/* Sound Volume, as seen in the Sound & Music Properties window.*/
const int jjSoundFXVolume;
/* How much health a player starts with, as set by the /starthealth command.
Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.*/
const int jjStartHealth;
/* Whether strong powerups is enabled, as set by the /strongpowerups command.*/
const bool jjStrongPowerups;
/* The size of a player's subscreen in pixels. If there is only one local player
and the game is not being viewed in 3D, these will be equal to
jjResolutionHeight and jjResolutionWidth -- otherwise, either or both may be cut
in half. The subscreen size includes, and is therefore not changed by the values
of, jjBorderHeight and jjBorderWidth.*/
const int jjSubscreenHeight;
/* The size of a player's subscreen in pixels. If there is only one local player
and the game is not being viewed in 3D, these will be equal to
jjResolutionHeight and jjResolutionWidth -- otherwise, either or both may be cut
in half. The subscreen size includes, and is therefore not changed by the values
of, jjBorderHeight and jjBorderWidth.*/
const int jjSubscreenWidth;
/* In online multiplayer levels where this is false for the host, clients with
sugar rushes will be kicked for hacking. This property is set to true between
onLevelLoad and onLevelBegin if there are any events in the level that will
spawn food objects. If you need to allow sugar rushes for another reason, e.g.
jjPLAYER::startSugarRush, your script should set this property to true in
onLevelBegin at the earliest. (See the description of jjWEAPON::allowed for more
technical details, but as applied to the list of food events instead.)*/
bool jjSugarRushAllowed;
/* Each team's current score in team-based game modes and undefined value in other
modes. Available indexes are BLUE, RED, GREEN and YELLOW.*/
const fakearray<TEAM::Color, int> jjTeamScore;
/* Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon
properties of the background layer, i.e. jjLayers[8].*/
float jjTexturedBGFadePositionX;
/* Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon
properties of the background layer, i.e. jjLayers[8].*/
float jjTexturedBGFadePositionY;
/* Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon
properties of the background layer, i.e. jjLayers[8].*/
bool jjTexturedBGStars;
/* Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon
properties of the background layer, i.e. jjLayers[8].*/
TEXTURE::Style jjTexturedBGStyle;
/* Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon
properties of the background layer, i.e. jjLayers[8].*/
TEXTURE::Texture jjTexturedBGTexture;
/* A shortcut property for jjLayers[8]'s textureSurface property. Returns true iff
the property is anything other than SURFACE::UNTEXTURED. Set jjTexturedBGUsed to
true to set to SURFACE::LEGACY, or to false to set to SURFACE::UNTEXTURED.*/
bool jjTexturedBGUsed;
/* The number of (non-animated, non-flipped) tiles currently defined in the level,
usually a multiple of 10. Can be increased using jjTilesFromTileset.*/
const uint jjTileCount;
/* Static and animated tiles corresponding to tile IDs. See also jjAnimatedTiles.*/
const array<jjTILE@> jjTiles = array<jjTILE@>(0x10000);
/* File name of the tileset used by the current level, e.g. castle1.j2t, all
lowercase. The file extension (.j2t) will be included, but not the folder
structure.*/
const string jjTilesetFileName;
/* Each tile's tile type: 0 for normal, 1 for translucent, 3 for invisible, and so
on. Refer to your JCS.ini for the full list.*/
array<uint8> jjTileType = array<uint8>(4096);
/* The triggers, as set by the Trigger Zone and Trigger Crate events.*/
array<bool> jjTriggers = array<bool>(32);
/* In Roast Tag game mode, the player who is currently "it" or null if none. For
the other special role in Roast Tag, see jjBottomFeeder.*/
jjPLAYER@ jjTokenOwner;
/* A shortcut property for jjLayers[8]'s xSpeedModel/ySpeedModel properties.
Returns true iff at least one of the two properties is anything other than
LAYERSPEEDMODEL::LAYER8. Set jjUseLayer8Speeds to true to set both properties to
LAYERSPEEDMODEL::NORMAL, or to false to set both properties to
LAYERSPEEDMODEL::LAYER8.*/
bool jjUseLayer8Speeds;
/* If there are exactly two local players, how the window is divided into their two
subscreens.*/
bool jjVerticalSplitscreen;
/* If set to false, using a coin warp in Single Player mode will not turn all
remaining coins into red and green gems.*/
bool jjWarpsTransmuteCoins;
/* How fast water moves up or down when the water level is set (by event or
function) with the "Instant" parameter set to false. Defaults to 1.*/
float jjWaterChangeSpeed;
/* How local players react to being underwater. If this property is set to SWIM,
they will swim; if LOWGRAVITY, they will use regular physics but will fall more
slowly than usual. If this property is set to POSITIONBASED (the default), the
game will choose between the effects of SWIM or LOWGRAVITY depending on whether
jjWaterLevel is lower or greater than 32*128. This property has no effects on
other objects or on sound effects, which always move more slowly/sound different
underwater.*/
WATERINTERACTION::WaterInteraction jjWaterInteraction;
/* Which layer, 1-8, water is drawn in front of when visible. Defaults to 1. Set to
any non-existing layer number to make water invisible. Note that this is a
purely visual setting, and putting water behind the sprite layer will not
prevent players from swimming in it. If the order of layers has been changed,
this property's distance from 4 is its distance from the sprite layer, e.g.
leaving it at 1 means that it will be drawn in front of the third layer in front
of the sprite layer. (And therefore, if the sprite layer is the first, second,
or third layer in the drawing order, water will not be drawn at all.)*/
int jjWaterLayer;
/* How high the water currently is, in pixels. This is a constant value; use the
jjSetWaterLevel helper function instead for changing it.*/
const float jjWaterLevel;
/* The current way that water and ambient lighting interact in the level. (Ambient
lighting varies by local player and as such is a jjPLAYER property.) The
following constants are permissible values: WATERLIGHT::NONE: The default. When
water is activated, the level will display at lighting 100, regardless of the
current settings. WATERLIGHT::GLOBAL: The entire level will be lit according to
the current ambient lighting settings, both above and below the water line.
WATERLIGHT::LAGUNICUS: The current ambient lighting setting is ignored. Above
the water, the level will display at lighting 100. Below the water, the level
will display darker and darker depending on how far below the water line the
player is.*/
WATERLIGHT::wl jjWaterLighting;
/* The height the water is moving towards, in pixels. If the water level is set (by
event or function) with the "Instant" parameter set to false, there will be a
period in which jjWaterLevel and jjWaterTarget are two distinct values. This is
a constant value; use the jjSetWaterLevel helper function instead for changing
it.*/
const float jjWaterTarget;
/* Various properties of the nine different weapons available to a player; see the
jjWEAPON section. Possible constants appear in the appendix below, or you may
use simple 1-indexed numbers instead.*/
fakearray<WEAPON::Weapon, jjWEAPON> jjWeapons;
/* The current player; an alias of jjP, and the only property not to begin with the
jj prefix, provided solely for convenience value.*/
jjPLAYER@ p;
/* Adds and initiates an object of type eventID at xOrg xPixel and yOrg yPixel.
Possible values for creatorType are CREATOR::OBJECT, CREATOR::LEVEL, and
CREATOR::PLAYER. Useful values for eventID can be found in the appendix at the
bottom of the page. Returns the object ID of the new object, or 0 if the
function fails for whatever reason. The difference between jjAddObject(1, 0, 0,
CREATOR::OBJECT, 0, BEHAVIOR::BOUNCERBULLET); and jjObjects[jjAddObject(1, 0,
0)].behavior = BEHAVIOR::BOUNCERBULLET; is that jjAddObject calls the object's
behavior function as part of creating it. The first version will call
BEHAVIOR::BOUNCERBULLET while the object's state is still STATE::START; the
second version will call jjObjectPresets[1].behavior and only switch the
object's behavior to BEHAVIOR::BOUNCERBULLET after it has already been
initialized and its state likely changed to something else. The same distinction
applies to setting the object's xOrg/yOrg, creatorType, and creatorID properties
as parameters to the function or later on. See jjBEHAVIORINTERFACE.*/
int jjAddObject(uint8 eventID, float xPixel, float yPixel, uint16 creatorID = 0, CREATOR::Type creatorType = CREATOR::OBJECT, BEHAVIOR::Behavior behavior = BEHAVIOR::DEFAULT);
/* Creates and returns a new particle object, or a null pointer if unsuccessful.
See the jjPARTICLE documentation above for full details.*/
jjPARTICLE@ jjAddParticle(PARTICLE::Type type);
/* Creates an explosion of particles based on the shape and possibly colors of the
specified curFrame. Use a mode value of 0 for a normal explosion, 1 for a fire
explosion caused by a toaster or fire shield bullet, or 2 for an explosion
caused by a special move. Values in the range of 15-255 will create fire
explosions whose particles will use palette index equal to mode - this effect is
currently used by weapons such as powered-up toaster and laser shield to create
blue explosions. Value 14 creates a fire explosion whose particles use
individually random colors. Values in the range of 3-13 and higher than 255 are
undefined and - to preserve backward compatibility - shouldn't be used.*/
void jjAddParticlePixelExplosion(float xPixel, float yPixel, int curFrame, int direction, int mode);
/* Creates four fragments of a tile falling from a specified location, like when
destroying a destructable scenery block. Does not produce a sound effect; use
jjSample or jjSamplePriority for that instead. The fragments will continue to be
drawn until they fall off the screen. If you want more control over the
fragments' positions, speeds, etc., use jjAddParticle instead.*/
void jjAddParticleTileExplosion(uint16 xTile, uint16 yTile, uint16 tile, bool collapseSceneryStyle);
/* Writes text to the chatlogger window, and also displays it ingame for the local
player. Uses size to determine size and positioning of text. If sendToAll is
true and the function is called by the server, text will be sent to all clients
as well.*/
void jjAlert(const string text, bool sendToAll = false, STRING::Size size = STRING::SMALL);
/* In online play, sends text to the server as a line of chat. If text is a command
(e.g. "/spectate on" or "/ready"), it will be interpreted as such to the extent
that the local player is allowed to use that command in the server. In offline
play, JJ2+ will try to parse text as a command but will not display it as chat
because there is no chat in offline mode. If you want to simulate chatting in a
local game, use jjAlert instead.*/
void jjChat(const string text, bool teamchat = false);
/* Writes text as a console message to the chatlogger window, and also displays it
ingame for the local player. If sendToAll is true and the function is called by
the server, text will be sent to all clients as well.*/
void jjConsole(const string text, bool sendToAll = false);
/* Returns the cosine of angle with a range of 0.0-1.0 and a domain of 0-1023.
Numbers outside the domain will be seemlessly moduloed. You may prefer
AngelScript's native cos function.*/
float jjCos(uint angle);
/* Computes cyclic redundancy check of input with optional initial value crc. The
checksum is computed according to the CRC-32 standard (as used in the zlib
library and all JJ2 data files that use CRC).*/
uint jjCRC32(const jjSTREAM input, uint crc = 0);
/* Writes text to the chatlogger window (but not ingame), but only if
[General]AngelscriptDebug equals True in plus.ini. If timestamp is true, adds a
timestamp before the text.*/
void jjDebug(const string text, bool timestamp = false);
/* Permanently deletes an object. Like jjAddObject, this function is purely local
in its scope.*/
void jjDeleteObject(int objectID);
/* */
void jjDrawPixel(float xPixel, float yPixel, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* */
void jjDrawRectangle(float xPixel, float yPixel, int width, int height, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* */
void jjDrawResizedSprite(float xPixel, float yPixel, int setID, uint8 animation, uint8 frame, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* */
void jjDrawResizedSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* */
void jjDrawRotatedSprite(float xPixel, float yPixel, int setID, uint8 animation, uint8 frame, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics.*/
void jjDrawRotatedSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics.*/
void jjDrawSprite(float xPixel, float yPixel, int setID, uint8 animation, uint8 frame, int direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment.*/
void jjDrawSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, int direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment.*/
void jjDrawString(float xPixel, float yPixel, const string text, STRING::SIZE size = STRING::SMALL, STRING::Mode mode = STRING::NORMAL, uint8 param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment. The layerXY parameter specifies which layer, 1-8, the graphic should
be positioned relative to the top left corner of. JJ2 always, always does layer
4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that
the layers besides layer 4 may actually move around a little after the
instruction is registered but before the graphic is drawn, so these drawing
instructions will always be one frame behind. Here the jjCANVAS methods have a
clear advantage.*/
void jjDrawString(float xPixel, float yPixel, const string text, const jjANIMATION animation, STRING::Mode mode = STRING::NORMAL, uint8 param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment. The layerXY parameter specifies which layer, 1-8, the graphic should
be positioned relative to the top left corner of. JJ2 always, always does layer
4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that
the layers besides layer 4 may actually move around a little after the
instruction is registered but before the graphic is drawn, so these drawing
instructions will always be one frame behind. Here the jjCANVAS methods have a
clear advantage.*/
void jjDrawString(float xPixel, float yPixel, const string text, STRING::SIZE size, const jjTEXTAPPEARANCE appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment. The layerXY parameter specifies which layer, 1-8, the graphic should
be positioned relative to the top left corner of. JJ2 always, always does layer
4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that
the layers besides layer 4 may actually move around a little after the
instruction is registered but before the graphic is drawn, so these drawing
instructions will always be one frame behind. Here the jjCANVAS methods have a
clear advantage. If the order of layers has been changed, then layerZ and
layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means
not necessarily jjLayers[3], but rather 4-1, the first layer in front of the
sprite layer, whichever jjLAYER that happens to be.*/
void jjDrawString(float xPixel, float yPixel, const string text, const jjANIMATION animation, const jjTEXTAPPEARANCE appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment. The layerXY parameter specifies which layer, 1-8, the graphic should
be positioned relative to the top left corner of. JJ2 always, always does layer
4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that
the layers besides layer 4 may actually move around a little after the
instruction is registered but before the graphic is drawn, so these drawing
instructions will always be one frame behind. Here the jjCANVAS methods have a
clear advantage. If the order of layers has been changed, then layerZ and
layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means
not necessarily jjLayers[3], but rather 4-1, the first layer in front of the
sprite layer, whichever jjLAYER that happens to be.*/
void jjDrawSwingingVineSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, int length, int curvature, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Global function versions of the jjCANVAS methods as applied to onDrawLayer#
hooks, differing in that the jjCANVAS methods are executed instantly, whereas
these functions create instructions for JJ2 to perform the drawing operations
later on, at the proper time. For example, a swinging platform will call
jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in
the middle of its behavior function, but the links won't actually get drawn to
the screen until later in the game cycle. Native JJ2 code uses this method for
everything but HUD graphics. The layerZ parameter specifies which layer, 1-8,
the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS
hooks, this can be used even for layers that don't have any tiles. JJ2 draws
sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to
experiment. The layerXY parameter specifies which layer, 1-8, the graphic should
be positioned relative to the top left corner of. JJ2 always, always does layer
4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that
the layers besides layer 4 may actually move around a little after the
instruction is registered but before the graphic is drawn, so these drawing
instructions will always be one frame behind. Here the jjCANVAS methods have a
clear advantage. If the order of layers has been changed, then layerZ and
layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means
not necessarily jjLayers[3], but rather 4-1, the first layer in front of the
sprite layer, whichever jjLAYER that happens to be. The playerID parameter
specifies which player should see the drawn graphic, 0-31, or -1 for all of them
(restricted only to players with true isLocal). Drawing for one player a time is
used by JJ2+ to, for example, draw fastfire pickups as green/blue or
normal/powered-up depending on the charCurr and powerup[1] values of each
jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of
the spectator, not the spectatee.*/
void jjDrawTile(float xPixel, float yPixel, uint16 tile, TILE::Quadrant tileQuadrant = TILE::ALLQUADRANTS, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1);
/* Resets all 256 bools in jjEnabledASFunctions to true.*/
void jjEnableEachASFunction();
/* Gets the Event ID at tile xTile,yTile, as seen in JCS.ini. This number can also
be compared to the OBJECT or AREA constants listed in the appendix at the bottom
of this file.*/
int jjEventGet(uint16 xTile, uint16 yTile);
/* Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA
constants are listed in the appendix at the bottom of this file. Caution: this
is a permanent change and will subsist even after death in offline play.*/
void jjEventSet(uint16 xTile, uint16 yTile, uint8 newEventID);
/* Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA
constants are listed in the appendix at the bottom of this file. Caution: this
is a permanent change and will subsist even after death in offline play.*/
void jjEventSet(uint16 xTile, uint16 yTile, OBJECT::Object newEventID);
/* Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA
constants are listed in the appendix at the bottom of this file. Caution: this
is a permanent change and will subsist even after death in offline play.*/
void jjEventSet(uint16 xTile, uint16 yTile, AREA::Area newEventID);
/* Shortcut global function for jjLAYER::generateSettableTileArea on the
same-indexed jjLayers objects.*/
void jjGenerateSettableTileArea(uint8 layer, int xTile, int yTile, int width, int height);
/* Calls and returns the result of jjLayers[8].getFadeColor().*/
jjPALCOLOR jjGetFadeColors();
/* Returns the current order in the currently playing module music, or -1 if the
currently playing music is not a module, a module not handled by BASS or no
music is playing.*/
int jjGetModOrder();
/* Returns the current row in the currently playing module music, or -1 if the
currently playing music is not a module, a module not handled by BASS or no
music is playing.*/
int jjGetModRow();
/* Returns the "speed" parameter (ticks per row) of the currently playing module
music, or -1 if the currently playing music is not a module, a module not
handled by BASS or no music is playing.*/
int jjGetModSpeed();
/* Returns the tempo of the currently playing module music, or -1 if the currently
playing music is not a module, a module not handled by BASS or no music is
playing.*/
int jjGetModTempo();
/* If moduleName is a name of a currently running script module that registers the
onGetPublicInterface hook, calls that hook and returns its result, otherwise
returns null. Module names are the same as names of files that contain the
modules, including the file extension ".j2as" or ".mut", and the comparison is
not case sensitive. In the target module, onGetPublicInterface must be a global
function with the following signature: jjPUBLICINTERFACE@ onGetPublicInterface()
The exact return type may differ as long as it is a handle to a class or
interface that implements jjPUBLICINTERFACE. This function should not be called
earlier than in onLevelLoad, i.e. it should not be used to initialize a global
variable, as the target module may not be available at that point yet. More
details about usage of this function may be found in the dedicated section of
this document.*/
jjPUBLICINTERFACE@ jjGetPublicInterface(const string moduleName);
/* If tileID is animated, i.e. (tileID & TILE::ANIMATED) != 0, returns tile ID of
the current animation frame of the tile corresponding to tileID. Otherwise
returns tileID. Like animated tiles themselves, this function relies on system
time rather than game ticks, which means that subsequent calls during the same
frame may return different results, and that results may insignificantly differ
compared to the effective state of the animation. This behavior may change in
the future. This function never returns tile ID of animated tiles. If its result
would be animated, which may happen in levels edited by other means than JCS,
the function is called recursively on the result until a static tile is
obtained.*/
uint16 jjGetStaticTile(uint16 tileID);
/* Returns width, in pixels, that text would have if it was drawn in specified size
(or animation) and style. If style allows multi-line text and text is
multi-line, width of the longest line is returned.*/
int jjGetStringWidth(const string text, STRING::Size size, const jjTEXTAPPEARANCE style);
/* Returns width, in pixels, that text would have if it was drawn in specified size
(or animation) and style. If style allows multi-line text and text is
multi-line, width of the longest line is returned.*/
int jjGetStringWidth(const string text, const jjANIMATION animation, const jjTEXTAPPEARANCE style);
/* Returns true if text is interpreted by the game as a cheat code.*/
bool jjIsValidCheat(const string text);
/* Permanently deletes an object, but first calls its native STATE::KILL code (if
any). Probably functionally identical to jjDeleteObject in most cases, but might
work a little better sometimes.*/
void jjKillObject(int objectID);
/* A pair of functions for accessing or changing the ordered list of layers drawn
to the screen. (In most cases it should be simpler to keep the jjLAYER@ array
around in your script as a variable, rather than retrieving it using
jjLayerOrderGet, but that function is there just in case you need it.) The
arrays are ordered so that the first jjLAYER is in front and the last is in
back, meaning that writing jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1],
jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7],
jjLayers[8]}); should have no visible effect in a previously unaltered level.
The array passed to jjLayerOrderSet must include jjLayers[4] (the
gameplay/sprite layer) as one of its entries and must not include any null
handles, or else the function will return false and cause a debug error.
Including multiple handles to the same jjLAYER is allowed but not very useful.
Following a call to jjLayerOrderSet, it takes some extra thought and
understanding to figure out how to refer to individual layers in other sections
of the code. Specifically there are two different patterns (which happen to come
to the same thing if the layer order is never changed at all): All global
properties or functions with a 1-indexed layer argumente.g. jjLayers,
jjLayerYSpeed, or jjTileGet refer exclusively to the level's original
eight layers as defined in the level editor. jjLayers[1] will always refer to
the same layer no matter which layer ends up being drawn foremost in the
foreground. To read or write the size, speeds, etc. of any layer besides those
eight, use the properties and methods of its jjLAYER instance. Similarly, the
jjCANVAS onDrawLayer# hooks are (currently) only available for those original
eight layers, and jjLayers[1] will always call onDrawLayer1 (if defined) no
matter its position in the drawing order.*/
array<jjLAYER@>@ jjLayerOrderGet();
/* A pair of functions for accessing or changing the ordered list of layers drawn
to the screen. (In most cases it should be simpler to keep the jjLAYER@ array
around in your script as a variable, rather than retrieving it using
jjLayerOrderGet, but that function is there just in case you need it.) The
arrays are ordered so that the first jjLAYER is in front and the last is in
back, meaning that writing jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1],
jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7],
jjLayers[8]}); should have no visible effect in a previously unaltered level.
The array passed to jjLayerOrderSet must include jjLayers[4] (the
gameplay/sprite layer) as one of its entries and must not include any null
handles, or else the function will return false and cause a debug error.
Including multiple handles to the same jjLAYER is allowed but not very useful.
Following a call to jjLayerOrderSet, it takes some extra thought and
understanding to figure out how to refer to individual layers in other sections
of the code. Specifically there are two different patterns (which happen to come
to the same thing if the layer order is never changed at all): All global
properties or functions with a 1-indexed layer argumente.g. jjLayers,
jjLayerYSpeed, or jjTileGet refer exclusively to the level's original
eight layers as defined in the level editor. jjLayers[1] will always refer to
the same layer no matter which layer ends up being drawn foremost in the
foreground. To read or write the size, speeds, etc. of any layer besides those
eight, use the properties and methods of its jjLAYER instance. Similarly, the
jjCANVAS onDrawLayer# hooks are (currently) only available for those original
eight layers, and jjLayers[1] will always call onDrawLayer1 (if defined) no
matter its position in the drawing order. When calling jjDrawSprite or any of
its related functions with their layerZ and layerXY arguments, those arguments
refer to the list of layers from jjLayerOrderGet, relative to Layer 4's position
in that list. The default layerZ value is 4 and will always draw sprites to
jjLayers[4]. If layerZ equals 3, 4-1, the sprite will be drawn to whichever
jjLAYER is ordered one in front of jjLayers[4]. If 6, 4+2, the layer two behind
jjLayers[4]. And so on. The same principle applies to jjWaterLayer.*/
bool jjLayerOrderSet(const array<jjLAYER@>& in order);
/* Returns an array containing a number of handles of new jjLAYER instances built
from the layers defined in the level filename, specifically those requested in
the 1-indexed layerIDs. (Passing numbers not in the range of 18 in
layerIDs is undefined behavior.) For example, jjLayersFromLevel("castle1.j2l",
array<uint> = {5,6}); returns an array with two layers, one of width 23 and
height 25 and the other of width 20 and height 11, containing different sets of
pillars as defined in Layer 5 and Layer 6 of castle1.j2l. These new layer
objects may then be inserted into the set of layers drawn to the screen by use
of jjLayerOrderSet. By default, the tile IDs of the tiles in these layers will
be unchanged, meaning that unless the tileset used by the level filename is the
same as is used by this level, the results will likely look very peculiar.
(Similarly, any animated tiles used in those layers should probably match those
used in this level.) In fact, you may want to make a special unplayable level
just for the sake of taking its miscellaneous background or foreground layers
into this one (and if you do, remember to tick "Hide level in Home Cooked Levels
list" in its level properties). Alternatively, the optional
tileIDAdjustmentFactor parameter is a value added to the tile IDs of any
non-zero, non-animated tiles in the layer/s imported from filename, so for
instance, if tileIDAdjustmentFactor equals 10, then a series of tiles 5,6,0,0,3
would become 15,16,0,0,13. (This option is intended for use in conjunction with
jjTilesFromTileset, though you may find other uses for it as well.) Like in
other sections of JJ2+ code, levels saved in either the TSF or regular JCSes
work equally well. It does not matter whether the level is passworded. If the
file does not exist or does not have the file extension ".j2l" then the returned
array will have zero length. If the file is not a valid level then the game may
or may not crash. As with other dependent files, it is recommended to use
#pragma require if the level being mined for layers is not a default level.*/
array<jjLAYER@>@ jjLayersFromLevel(const string filename, const array<uint> layerIDs, int tileIDAdjustmentFactor = 0);
/* Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is
masked.*/
bool jjMaskedHLine(int xPixel, int lineLength, int yPixel);
/* Returns true if pixel xPixel,yPixel is masked.*/
bool jjMaskedPixel(int xPixel, int yPixel);
/* If any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked, returns
the height of the topmost masked pixel relative to yPixel. (For example, if
xPixel,yPixel+2 is masked but +1 and +0 weren't, the function returns 2.) If
none of the pixels are masked, returns lineLength+1. Used for detecting inclines
and the like.*/
int jjMaskedTopVLine(int xPixel, int yPixel, int lineLength);
/* Returns true if any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is
masked.*/
bool jjMaskedVLine(int xPixel, int yPixel, int lineLength);
/* Shortcut global functions for the same-named jjLAYER methods on the same-indexed
jjLayers objects.*/
bool jjMaskedHLine(int xPixel, int lineLength, int yPixel, uint8 layer);
/* Shortcut global functions for the same-named jjLAYER methods on the same-indexed
jjLayers objects.*/
bool jjMaskedPixel(int xPixel, int yPixel, uint8 layer);
/* Shortcut global functions for the same-named jjLAYER methods on the same-indexed
jjLayers objects.*/
int jjMaskedTopVLine(int xPixel, int yPixel, int lineLength, uint8 layer);
/* Shortcut global functions for the same-named jjLAYER methods on the same-indexed
jjLayers objects.*/
bool jjMaskedVLine(int xPixel, int yPixel, int lineLength, uint8 layer);
/* Loads and starts playing a new music file, of any type supported by JJ2+.
Returns false if the file cannot be found in either the main game folder or the
cache subfolder, or if the specified music file is already playing and
forceReload is false. The temporary parameter is useful only in local single
player games, where it is used to load a music file only until the player's
death, at which point the non-temporary music file will resume playing: this is
how the Activate Boss event works.*/
bool jjMusicLoad(string filename, bool forceReload = false, bool temporary = false);
/* Pauses the current music track. May not work with .mp3 files.*/
void jjMusicPause();
/* (Re)starts the current music track.*/
void jjMusicPlay();
/* Resumes the current music track, once paused. May not work with .mp3 files.*/
void jjMusicResume();
/* Stops the current music track.*/
void jjMusicStop();
/* Ends the level and skips to the next one, or to filename if specified and of
length>0. Only works in Single Player and Cooperative.*/
void jjNxt(bool warp = false, bool fast = false);
/* Ends the level and skips to the next one, or to filename if specified and of
length>0. Only works in Single Player and Cooperative.*/
void jjNxt(const string& filename = "", bool warp = false, bool fast = false);
/* Gets one of the parameters at tile xTile,yTile. Follow JCS.ini's lead in
figuring out how to write the offset and length parameters. length is the
simplest: use the exact same formatting JCS.ini does. To get the speed of a belt
event, for instance, length should be -8. To get the number of blue gems in a
gem crate, length should be 4. And so on. offset is calculated by adding the
absolute values of every parameter on the tile prior to the one you want. The
first (bottommost) parameter will always have offset 0. To get the parameter
"Blue" in Gem Crate, offset should be 8 (4+4). To get the Y-Speed of a Rotating
Rock, offset should be 12 (8+abs(-4)). And so on. Set length to 2 and offset to
-4 to get the difficulty of an event (normal, easy, hard, multiplayer-only).*/
int jjParameterGet(uint16 xTile, uint16 yTile, int8 offset, int8 length);
/* Sets one of the parameters at tile xTile,yTile. length and offset work exactly
as they do for jjParameterGet; the only change is newValue, which should be a
valid number for the length setting. Trying to assign a negative number to an
unsigned length parameter doesn't really make sense, for example, nor can you
reasonably assign a newValue of 100 to a length of 3. Note that this is not
quite as powerful as it may seem, since some objects read and process their
parameters into memory when they are first created, rather than continually
reading them again and again as the game continues. The function will however
work fine for zones that affect the player, such as Warp or Sucker Tube or Wind,
and it will also successfully set parameters for any such new objects created
after the function is called. Caution: this is a permanent change and will
subsist even after death in offline play.*/
void jjParameterSet(uint16 xTile, uint16 yTile, int8 offset, int8 length, int newValue);
/* Convenience function; creates and returns an array containing handles of all
active players with a given clientID. The result is an empty array if the client
is not connected or if clientID is not a valid ID. The result is a null handle
if the function is called by a client.*/
array<jjPLAYER@>@ jjPlayersWithClientID(int clientID);
/* Writes text to the chatlogger window but does not display it ingame. If
timestamp is true, adds a timestamp before the text.*/
void jjPrint(const string text, bool timestamp = false);
/* Provides a random number.*/
uint jjRandom();
/* Returns true if expression is a valid regular expression and false otherwise.
This is the only regex function that doesn't cause debug errors when the input
is an invalid expression and as such it should be always used before calling
other regex functions when expression comes from an untrusted source (such as
from user input rather than from a constant string in the script). Expressions
will be parsed according to modified ECMAScript regular expression grammar.*/
bool jjRegexIsValid(const string expression);
/* Returns true if expression is a valid regular expression that matches text
entirely and false if no match is found. Where the second overload is used,
results will contain match results in a standard order. If ignoreCase is true,
the matching will be case insensitive. If expression is not a valid regular
expression, a debug message will be printed to the chatlogger and the return
value will be undefined. In future versions of JJ2+ this might have further
consequences including complete script shutdown. For this reason, jjRegexIsValid
should always be used to validate untrusted input. Note that this function only
returns true if expression matches the entire string, whereas jjRegexSearch
accepts substring matches.*/
bool jjRegexMatch(const string text, const string expression, bool ignoreCase = false);
/* Returns true if expression is a valid regular expression that matches text
entirely and false if no match is found. Where the second overload is used,
results will contain match results in a standard order. If ignoreCase is true,
the matching will be case insensitive. If expression is not a valid regular
expression, a debug message will be printed to the chatlogger and the return
value will be undefined. In future versions of JJ2+ this might have further
consequences including complete script shutdown. For this reason, jjRegexIsValid
should always be used to validate untrusted input. Note that this function only
returns true if expression matches the entire string, whereas jjRegexSearch
accepts substring matches.*/
bool jjRegexMatch(const string text, const string expression, array<string> results, bool ignoreCase = false);
/* Returns a string that is the result of replacement of all substrings of text
that are matched by expression with replacement. If ignoreCase is true, the
matching will be case insensitive. Capture results ($1, $2, etc., $0 always
being the entire matched substring) can be successfully used in the replacement
string. If expression is not a valid regular expression, a debug message will be
printed to the chatlogger and the return value will be undefined. In future
versions of JJ2+ this might have further consequences including complete script
shutdown. For this reason, jjRegexIsValid should always be used to validate
untrusted input.*/
string jjRegexReplace(const string text, const string expression, const string replacement, bool ignoreCase = false);
/* Returns true if expression is a valid regular expression that matches any
substring of text and false if no match is found. Where the second overload is
used, results will contain match results in a standard order. If ignoreCase is
true, the matching will be case insensitive. If expression is not a valid
regular expression, a debug message will be printed to the chatlogger and the
return value will be undefined. In future versions of JJ2+ this might have
further consequences including complete script shutdown. For this reason,
jjRegexIsValid should always be used to validate untrusted input. Note that this
function returns true if expression matches any character subsequence of text,
whereas jjRegexMatch will only look for matches with the entire string.*/
bool jjRegexSearch(const string text, const string expression, bool ignoreCase = false);
/* Returns true if expression is a valid regular expression that matches any
substring of text and false if no match is found. Where the second overload is
used, results will contain match results in a standard order. If ignoreCase is
true, the matching will be case insensitive. If expression is not a valid
regular expression, a debug message will be printed to the chatlogger and the
return value will be undefined. In future versions of JJ2+ this might have
further consequences including complete script shutdown. For this reason,
jjRegexIsValid should always be used to validate untrusted input. Note that this
function returns true if expression matches any character subsequence of text,
whereas jjRegexMatch will only look for matches with the entire string.*/
bool jjRegexSearch(const string text, const string expression, array<string> results, bool ignoreCase = false);
/* Restores 16-bit water to its natural colors.*/
void jjResetWaterGradient();
/* Plays a sound from anims.j2a at pixel xPixel, yPixel. Possible values for sample
are listed in the appendix at the bottom of this file. volume ranges from 1-63,
and 0 will default to 63. Higher values of frequency result in higher
frequencies, or leaving it at 0 will use the sample's unique default frequency.*/
void jjSample(float xPixel, float yPixel, SOUND::Sample sample, int volume = 63, int frequency = 0);
/* Returns whether sample is loaded or not.*/
bool jjSampleIsLoaded(SOUND::Sample sample);
/* Attempts to load sample from a .wav or .ogg file filename and returns true on
success or false otherwise. If there is already a loaded sample corresponding to
this SOUND::Sample constant, it will be overwritten. JJ2 assumes samples are
mono and will not correctly play stereo samples, so for the best results, only
use mono files.*/
bool jjSampleLoad(SOUND::Sample sample, string filename);
/* Plays a looped sound from anims.j2a at pixel xPixel, yPixel. For every source of
sound (e.g. a jjOBJ instance), channel should be 0 on the first call and in
later calls should be replaced with the value returned from the previous call of
this function. volume ranges from 1-63, and 0 will default to 63. Higher values
of frequency result in higher frequencies, or leaving it at 0 will use the
sample's unique default frequency.*/
int jjSampleLooped(float xPixel, float yPixel, SOUND::Sample sample, int channel, int volume = 63, int frequency = 0);
/* Plays a sound from anims.j2a, no matter what any local players' positions are.
This is the function used to play the sugar rush jingle. Possible values for
sample are listed in the appendix at the bottom of this file.*/
void jjSamplePriority(SOUND::Sample sample);
/* Sends packet from client to server (in case if you're a client) or from server
to client (in case if you're a server). Returns true on success and false on
failure. If toClientID is a positive value, the packet will be sent only to the
client with the appropriate jjPLAYER::clientID. If it's negative, it will be
sent to all clients with the exception of the one indicated by toClientID. Using
the default value of 0 results in sending the packet to all clients. For a
script to receive packet, you will need to declare an onReceive hook, which has
the following signature: void onReceive(jjSTREAM &in packet, int fromClientID)
Notice that packets can't be sent between two clients but only between the
server and a client; if the function is called client-side, the toClientID
argument is completely ignored. If a client is meant to send a packet to another
client, they have to send the packet to the server first and the server should
resend it to the other client from onReceive. If there are multiple distinct
script modules running (two or more mutators, or one mutator and a level's
primary script), the packet will only be received by the module whose
jjScriptModuleID global value matches the toScriptModuleID parameter. By leaving
this parameter as the default value, you can ensure that a packet sent from
foo.j2mut will always be read by (the onReceive hook defined in) foo.j2mut,
rather than another, simultaneously running module that wouldn't know what to do
with the data. Passing 0 instead will send the packet to the level's primary
script (if any), and is rarely a good idea. Other values are even more rarely a
good idea.*/
bool jjSendPacket(jjSTREAM packet, int toClientID = 0, uint toScriptModuleID = jjScriptModuleID);
/* Sets the color of darkness used with ambient lighting.*/
void jjSetDarknessColor(jjPALCOLOR color = jjPALCOLOR(0, 0, 0));
/* Sets the fade colors of the level's textured background, as seen in the Layer
properties window for layer 8 in JCS. Has no effect if there is no textured
background on layer 8. Exactly equivalent to jjLayers[8].setFadeColor(color). A
simpler one (or zero!) parameter version of the function also exists to set the
fade colors to the same RGB values as used by one of the entries in jjPalette.
This defaults to 207, which is the last color of the most common textured
background gradient and thus, not infrequently, the fade color used in 8-bit
color.*/
void jjSetFadeColors(uint8 red, uint8 green, uint8 blue);
/* Sets the fade colors of the level's textured background, as seen in the Layer
properties window for layer 8 in JCS. Has no effect if there is no textured
background on layer 8. Exactly equivalent to jjLayers[8].setFadeColor(color). A
simpler one (or zero!) parameter version of the function also exists to set the
fade colors to the same RGB values as used by one of the entries in jjPalette.
This defaults to 207, which is the last color of the most common textured
background gradient and thus, not infrequently, the fade color used in 8-bit
color.*/
void jjSetFadeColors(jjPALCOLOR color);
/* Sets the fade colors of the level's textured background, as seen in the Layer
properties window for layer 8 in JCS. Has no effect if there is no textured
background on layer 8. Exactly equivalent to jjLayers[8].setFadeColor(color). A
simpler one (or zero!) parameter version of the function also exists to set the
fade colors to the same RGB values as used by one of the entries in jjPalette.
This defaults to 207, which is the last color of the most common textured
background gradient and thus, not infrequently, the fade color used in 8-bit
color.*/
void jjSetFadeColors(uint8 paletteColorID = 207);
/* Shortcut global functions for setXSpeed and setYSpeed on the same-indexed
jjLayers objects.*/
void jjSetLayerXSpeed(uint8 layerID, float newspeed, bool newSpeedIsAnAutoSpeed);
/* Shortcut global functions for setXSpeed and setYSpeed on the same-indexed
jjLayers objects.*/
void jjSetLayerYSpeed(uint8 layerID, float newspeed, bool newSpeedIsAnAutoSpeed);
/* Jumps to a specific row of a specific order in the currently playing module
file. If reset is true, also stops all notes and resets the module's global
volume, tempo, etc. to their original values. Calling this function with an
invalid order or row number, or while BASS is not playing a module file, will
have no effect.*/
void jjSetModPosition(int order, int row, bool reset);
/* Sets the "speed" of the currently playing module music file. Does nothing if
BASS is not currently playing a module file. Note that the module may change its
own speed, overwriting your change.*/
void jjSetModSpeed(uint8 speed);
/* Sets the tempo of the currently playing module music file. Does nothing if BASS
is not currently playing a module file. Note that the module may change its own
tempo, overwriting your change.*/
void jjSetModTempo(uint8 tempo);
/* Changes the colors used by water in 16-bit color. If no parameters are included,
the gradient will be generated from palette entries 176 and 207 instead, the
most typical textured background colors (and most of the colors used by 8-bit
water).*/
void jjSetWaterGradient(uint8 red1, uint8 green1, uint8 blue1, uint8 red2, uint8 green2, uint8 blue2);
/* Changes the colors used by water in 16-bit color. If no parameters are included,
the gradient will be generated from palette entries 176 and 207 instead, the
most typical textured background colors (and most of the colors used by 8-bit
water).*/
void jjSetWaterGradient(jjPALCOLOR color1, jjPALCOLOR color2);
/* Changes the colors used by water in 16-bit color. If no parameters are included,
the gradient will be generated from palette entries 176 and 207 instead, the
most typical textured background colors (and most of the colors used by 8-bit
water).*/
void jjSetWaterGradient();
/* Sets jjWaterTarget to yPixel. If instant is true, jjWaterLevel will also be set
to yPixel; otherwise, it will move slowly up or down from its current height
until it reaches its new target. Caution: this function is not identical to the
Water Level event in JCS. The event measures in tiles, but this function
measures in pixels. Multiply by thirty-two to get the same effect.*/
void jjSetWaterLevel(float yPixel, bool instant);
/* Returns the sine of angle with a range of 0.0-1.0 and a domain of 0-1023.
Numbers outside the domain will be seemlessly moduloed. This is the sine
function used by JJ2 for spinning platforms and the like, though you may prefer
AngelScript's native sin function.*/
float jjSin(uint angle);
/* In currently playing module music, slide the volume of channel to volume over a
chosen number of milliseconds. Does nothing if BASS is not currently playing a
module file or channel does not exist. volume is 1.0 for the module's channel
volume, 0.0 for silent. If you give a higher or lower value, the slide will stop
when it reaches one of these boundaries. Volume slides continue while the music
is paused. If you begin sliding the volume of a channel that is already sliding,
the old slide will immediately stop.*/
void jjSlideModChannelVolume(int channel, float volume, int milliseconds);
/* Returns the minimum index from the range 0255 such that
jjSpriteModeIsMappingUsed(index) is false, or -1 if none exist.*/
int jjSpriteModeFirstFreeMapping();
/* Returns a copy of the mapping provided as the rgbMapping argument during the
most recent call to jjSpriteModeSetMapping with the same value of index. If the
most recent call didn't provide the rgbMapping argument, instead the
indexMapping argument is used in conjunction with jjPalette to determine the
result. The returned handle is never nulleven if the mapping corresponding
to index is unused, the returned handle is still a valid palette but all its
colors are black.*/
jjPAL@ jjSpriteModeGetColorMapping(uint8 index);
/* Returns a copy of the mapping provided as the indexMapping argument during the
most recent call to jjSpriteModeSetMapping with the same value of index. The
returned handle is never null and the array it holds is always of size 256. If
the mapping corresponding to index is unused, all elements of the array will be
0.*/
array<uint8>@ jjSpriteModeGetIndexMapping(uint8 index);
/* Returns whether a mapping with the given index (as used by SPRITE::MAPPING and
SPRITE::TRANSLUCENTMAPPING) has been previously successfully registered with use
of jjSpriteModeSetMapping.*/
bool jjSpriteModeIsMappingUsed(uint8 index);
/* Sets a mapping with the given index (as used by SPRITE::MAPPING and
SPRITE::TRANSLUCENTMAPPING) to the provided values. indexMapping will be used in
8-bit color mode. If it is shorter than 256 elements, it will be padded with
values corresponding to their indices (i.e., if an empty array is provided, the
corresponding SPRITE::MAPPING will act exactly like SPRITE::NORMAL in 8-bit
color mode). rgbMapping, if provided, will be used in 16-bit color mode,
ignoring the level's paletteotherwise indexMapping will be used, to the
same effect as in 8-bit color mode.*/
void jjSpriteModeSetMapping(uint8 index, const array<uint8> indexMapping, const jjPAL rgbMapping);
/* Sets a mapping with the given index (as used by SPRITE::MAPPING and
SPRITE::TRANSLUCENTMAPPING) to the provided values. indexMapping will be used in
8-bit color mode. If it is shorter than 256 elements, it will be padded with
values corresponding to their indices (i.e., if an empty array is provided, the
corresponding SPRITE::MAPPING will act exactly like SPRITE::NORMAL in 8-bit
color mode). rgbMapping, if provided, will be used in 16-bit color mode,
ignoring the level's paletteotherwise indexMapping will be used, to the
same effect as in 8-bit color mode.*/
void jjSpriteModeSetMapping(uint8 index, const array<uint8> indexMapping);
/* Prints text to the game's built-in spy window activated by running it with the
-spy command line parameter, and also writes it to your jazz2.log file.*/
void jjSpy(const string text);
/* Toggles jjTriggers[id] from true to false, or vice versa, like the "switch"
parameter on the Trigger Zone and Trigger Crate events.*/
bool jjSwitchTrigger(uint8 id);
/* Takes a screenshot of the game as if F12 was pressed. Returns true if the
screenshot request was successfully handled without being dismissed by timing or
other restrictions, otherwise returns false. The optional parameter filename can
be used to define a custom filename for the screenshot file to be saved. When a
custom filename is passed as a parameter, the .png suffix can be omitted, since
the suffix will be always ensured. Omitting the custom filename parameter or
defining it as an empty string will make the game use the default pattern for
screenshot filenames, like Jazz2-[level_filename]-001.png, etc. Note that this
feature has restrictions on how often it can be used effectively. Calling it
more often than once a second won't do anything and will cause the function to
return false, as an indicator that the call to take a screenshot was dismissed.
There is also a one second delay for using this function successfully after the
user presses F12. This is due to the possibility of this feature being able to
fill up available diskspace on the calling machine rapidly (and making the game
too sluggish to play anyway). Note that this feature may only be used to save
screenshots into the folder running JJ2 itself. Also, to avoid conflict with
system reserved filenames, etc. all custom filenames receive an enforced prefix
in their filename as Jazz2_as-, which also helps to differentiate custom
screenshot filenames from the default ones (Jazz2-). Note that only legal
characters for filenames may be used in the custom screenshot filenames to
ensure their integrity. Using any illegal characters in the filename will result
in the screenshot saving to fail and making this function return false.*/
bool jjTakeScreenshot(const string filename = "");
/* Shortcut global functions for the same-named jjLAYER methods on the same-indexed
jjLayers objects.*/
uint16 jjTileGet(uint8 layer, int xTile, int yTile);
/* Shortcut global functions for the same-named jjLAYER methods on the same-indexed
jjLayers objects.*/
uint16 jjTileSet(uint8 layer, int xTile, int yTile, uint16 newTile);
/* Opens the tileset filename, extracts tileCount tiles from it starting at tile ID
firstTileID, and appends them to the end of the currently loaded tileset,
increasing jjTileCount by tileCount. If paletteColorMapping is not null and is
of length 256 or greater, it will be used to recolor the imported tiles in a way
that better fits the palette you are currently using, e.g. pixels of color 10
will be changed to paletteColorMapping[10] instead. Returns false upon various
reasons for failure. jjTilesFromTileset is primarily intended to be combined
with jjLayersFromLevel and jjLayerOrderSet, and the three should ideally be
called in that order, so that jjLayersFromLevel has the right tiles to use in
its new layers. Here is a sample script that imports the background pillars from
Dungeon Dilemma (into any level using any tileset) and recolors them to use
colors from the textured background: void onLevelLoad() { const int oldTileCount
= jjTileCount; //the number of tiles in the level's tileset before
jjTilesFromTileset increases the number array<uint8> pillarColorMapping(256);
for (int i = 0; i < 16; ++i) pillarColorMapping[i + 128] = i + 192; //map
pillars' colors (stored in palette indices 128 through 143) to the (second row
of) textured background colors jjTilesFromTileset( //appends tiles to the end of
the internal copy of the tileset used by the current level "Castle1.j2t",
//filename to take tiles from 420, //first tile ID in tileset to take 60,
//number of tiles to take pillarColorMapping //an array<uint8>(256) that maps
colors in the source tileset to colors in the destination tileset, here only
working on a single 16-color gradient because that's all that is used in those
particular two layers ); array<jjLAYER@> castleLayers = jjLayersFromLevel(
//builds new jjLAYER instances from the layers defined in this level
"Castle1.j2l", //filename to take layers from array<uint> = {5,6}, //which
layers to grab oldTileCount - 420 //a number to offset the non-zero tileIDs by:
the pillars started at tile 420 in castle1.j2t, but here start at the end of the
old tileset, aka oldTileCount ); jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1],
jjLayers[2], jjLayers[3], jjLayers[4], castleLayers[0], castleLayers[1],
jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); //insert the two layers
from castle1.j2l between Layer 4 and Layer 5 }*/
bool jjTilesFromTileset(const string filename, uint firstTileID, uint tileCount, const array<uint8>@ paletteColorMapping = null);
/* Activates all Rotating Rock events with the "RockID" parameter set to id,
exactly like the Trigger Rock event.*/
void jjTriggerRock(uint8 id);
/* Returns unix time in milliseconds, i.e. the number of milliseconds that have
elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.*/
uint64 jjUnixTimeMs();
/* Returns unix time in seconds, i.e. the number of seconds that have elapsed since
00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.*/
uint64 jjUnixTimeSec();
/* Forces JJ2+ to reconstruct the textured background from its relevant properties.
This should be handled automatically now.*/
void jjUpdateTexturedBG();
/* Compresses data in input using the zlib library. The compression result is
placed into output. Returns whether successful, which should almost always be
true.*/
bool jjZlibCompress(const jjSTREAM input, jjSTREAM output);
/* Attempts to uncompresses data in input using the zlib library. The decompression
result is placed into output. For successful decompression, size must be at
least the same value as the amount of bytes of the predicted output. Returns
whether successful. The function can fail if input is not a valid compressed
stream or size is too small to accomodate the output or too large to allocate
memory required for performing the operation, as well as, rarely, for other
reasons.*/
bool jjZlibUncompress(const jjSTREAM input, jjSTREAM output, uint size);
