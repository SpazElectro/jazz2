{"eventsList": [{"name": "onChat", "description": "onChat is called whenever a chat message pops up in game. onLocalChat is called only when chat is received from players on the same machine the script is executing on. A return value of true indicates that the chat message should be suppressed, whereas a return value of false will cause the message to be handled normally. clientID is a unique ID of the game client that sent the chat message. stringReceived is the text of the chat message that was received. chatType can take one of the following values: NORMAL, TEAMCHAT, WHISPER amd ME.\nAny message beginning with \"/\" is interpreted as a command, not as chat, and so will not be passed to either of these hooks. Messages beginning with \"!\" will, though, as will arguments of commands /whisper (and its aliases, /w and @) and /me.\n", "full": "void onChat(int clientID, string &in stringReceived, CHAT::Type chatType)", "type": "event"}, {"name": "onLocalChat", "description": "onChat is called whenever a chat message pops up in game. onLocalChat is called only when chat is received from players on the same machine the script is executing on. A return value of true indicates that the chat message should be suppressed, whereas a return value of false will cause the message to be handled normally. clientID is a unique ID of the game client that sent the chat message. stringReceived is the text of the chat message that was received. chatType can take one of the following values: NORMAL, TEAMCHAT, WHISPER amd ME.\nAny message beginning with \"/\" is interpreted as a command, not as chat, and so will not be passed to either of these hooks. Messages beginning with \"!\" will, though, as will arguments of commands /whisper (and its aliases, /w and @) and /me.\n", "full": "bool onLocalChat(string &in stringReceived, CHAT::Type chatType)", "type": "event"}, {"name": "onCheat", "description": "This function is called in single player mode when a player attempts to enter a cheat code. It will be called once for each letter appended to the cheat code after jj. For example, in typing jjgod, onCheat will be called three times, with cheat equal to \"jjg\", \"jjgo\" and \"jjgod\". A return value of true indicates the cheat should be suppressed, whereas a return value of false will cause the cheat to be handled normally. If you want to compare cheat to the full list of standard cheat codes, use jjIsValidCheat, which will be updated if JJ2+ adds or changes any cheat codes in future releases.\nIf the player attempts to enter or exit debug mode by pressing the F10 key, this function will be called with cheat equaling \"f10.\" (This is the only circumstance in which the string will not begin with \"jj.\") You can test whether the player is attempting to enter or exit by checking jjDebugF10.\n", "full": "bool onCheat(string &in cheat)", "type": "event"}, {"name": "onLevelLoad", "description": "This function is called once, at the beginning of the level, and never again. If your level's tileset has a red textured background but you want a blue one, this is the place to change its colors. If you want the level to start with water at a certain height without placing Water Level events all around every start position, this is the place for that. And so on.\n", "full": "void onLevelLoad()", "type": "event"}, {"name": "onLevelBegin", "description": "Also called only at the beginning of the level, but a little bit later, once things have had time to be initialized. For example, onLevelLoad is fired before any jjOBJs have been created and before certain jjPLAYER properties have been initialized, so onLevelBegin allows you to modify those things as well.\n", "full": "void onLevelBegin()", "type": "event"}, {"name": "onGameStart", "description": "In multiplayer games, these functions are called whenever the game gets started or stopped. The firstTime parameter, if defined, is intended to capture starts/stops resulting from the /autostart command, so it should be true for the game being started or stopped at the beginning of the level, and false thereafter. However, it will also be true for clients who join the level partway through.\n", "full": "void onGameStart()", "type": "event"}, {"name": "onGameStart", "description": "In multiplayer games, these functions are called whenever the game gets started or stopped. The firstTime parameter, if defined, is intended to capture starts/stops resulting from the /autostart command, so it should be true for the game being started or stopped at the beginning of the level, and false thereafter. However, it will also be true for clients who join the level partway through.\n", "full": "void onGameStart(bool firstTime)", "type": "event"}, {"name": "onGameStop", "description": "In multiplayer games, these functions are called whenever the game gets started or stopped. The firstTime parameter, if defined, is intended to capture starts/stops resulting from the /autostart command, so it should be true for the game being started or stopped at the beginning of the level, and false thereafter. However, it will also be true for clients who join the level partway through.\n", "full": "void onGameStop()", "type": "event"}, {"name": "onGameStop", "description": "In multiplayer games, these functions are called whenever the game gets started or stopped. The firstTime parameter, if defined, is intended to capture starts/stops resulting from the /autostart command, so it should be true for the game being started or stopped at the beginning of the level, and false thereafter. However, it will also be true for clients who join the level partway through.\n", "full": "void onGameStop(bool firstTime)", "type": "event"}, {"name": "onLevelReload", "description": "This function is only ever called in Single Player, where it is called every time the player dies, after everything in the level has been reinitialized. Since a great number of things get reset in Single Player when the player dies, this is your chance to make sure some things stay the same.\n", "full": "void onLevelReload()", "type": "event"}, {"name": "onMain", "description": "Unlike the above functions, which are very rare, this function is called absolutely constantly. It is important to understand that JJ2 measures time in \"ticks,\" which number 70 to a second. (Correspondingly, when setting the duration for a sugar rush or somesuch, you will need to multiply by 70 to get the desired number of seconds.) The global property jjGameTicks will tell you how many ticks have elapsed at any given point. onMain is fired once per tick, and allows you to check constantly whether a given property has changed, move an object in a circle, or whatever else you find desirable.\n", "full": "void onMain()", "type": "event"}, {"name": "onPlayer", "description": "This function can be called even more often than onMain: it is called once per tick per local player. If you're playing splitscreen with two players, for instance, it will be called two times per tick. This is a useful distinction because of the jjPLAYER@ parameter, which points to the local player every time onPlayer is called. If you want to prevent blaster from ever being used in a level, for instance, void onPlayer(jjPLAYER@ play) { play.noFire = (play.currWeapon == WEAPON::BLASTER); } is one way of doing that, whereas trying to do the same in onMain would at minimum require manually looping through the jjLocalPlayers array. To check which jjPLAYER is being invoked during any given onPlayer, use the jjPLAYER.localPlayerID property.\n(JJ2+ used to encourage use of a global property p (or occasionally jjP), which performed the same function as the jjPLAYER@ argument. This coding style still works in certain cases, to ensure backwards compatibility with older scripts, but can be unclear and is deprecated/stylistically discouraged.)\n", "full": "void onPlayer(jjPLAYER@ play)", "type": "event"}, {"name": "onPlayerInput", "description": "This function works essentially the same way as onPlayer, and is called very slightly earlier in the tick, but with a caveat: it is only called when the player's input properties, keyRight and keyJump and so on, have had the potential to change. In particular, it is not called while chatting in a multiplayer game unless the player can be moved by a joystick/controller instead of the keyboard. Because of this unpredictability, it should only be used for situations specifically relating to input, for instance swapping the effects of a player's right and left keys.\n", "full": "void onPlayerInput(jjPLAYER@ play)", "type": "event"}, {"name": "onPlayerTimerEnd", "description": "This function is something of a special case. By default, when a Player Timer runs out (see the jjPLAYER section below), this function will be called for the player whose timer just ran out. However, a single level may have multiple timer sections with different purposes -- one where you die for not doing something quickly enough, one where you warp after a certain delay, and so on -- so it is also possible to change the function called using the jjPLAYER method timerFunction. Thus onPlayerTimerEnd is simply the default function name, not the only one you are allowed to use for this purpose.\n", "full": "void onPlayerTimerEnd(jjPLAYER@ play)", "type": "event"}, {"name": "onRoast", "description": "This function is called every time a player is roasted, including non-local players, including self-inflicted deaths from pits and other environmental hazards (in which case victim is killer will be true). Note however that not every death counts as a roast, e.g. deaths from the /frustration command or from unspectating.\n", "full": "void onRoast(jjPLAYER@ victim, jjPLAYER@ killer)", "type": "event"}], "globalpropertiesList": [{"name": "jjActiveGameTicks", "description": "How long the game has been actively running, at a rate of 70 ticks per second. Unlike jjGameTicks, this value is not incremented when the game is paused, stopped, or in pregame. This is a local value that counts up from 0 except in online Race games, where it is used to track lap times and is therefore synced between server and clients.\n", "full": "const uint jjActiveGameTicks", "type": "property"}, {"name": "jjAllowsFireball", "description": "Whether weapon 8 is fireball instead pepper spray, as set by the /fireball command.\n", "full": "const bool jjAllowsFireball", "type": "property"}, {"name": "jjAllowsMouseAim", "description": "Whether the server (or the SP level) allows mouse aim, as set by the /allowmouseaim command.\n", "full": "const bool jjAllowsMouseAim", "type": "property"}, {"name": "jjAllowsReady", "description": "Whether the server allows players to use the /ready command, as set by the /allowready command.\n", "full": "const bool jjAllowsReady", "type": "property"}, {"name": "jjAllowsWalljump", "description": "Whether the server allows players to use the \u00c3\u00af\u00c2\u00bf\u00c2\u00bdwalljumping\u00c3\u00af\u00c2\u00bf\u00c2\u00bd bug, as set by the /allowwalljump command.\n", "full": "const bool jjAllowsWalljump", "type": "property"}, {"name": "jjAlwaysRunning", "description": "Whether always running is enabled, as set by the /run command.\n", "full": "const bool jjAlwaysRunning", "type": "property"}, {"name": "jjAnimatedTiles", "description": "Animated tiles defined by the level. For every tileID,jjAnimatedTiles[tileID] is jjTiles[tileID | TILE::ANIMATED].\nSee also jjTiles.\n", "full": "jjTILE@ jjAnimatedTiles[0x10000]", "type": "property"}, {"name": "jjAnimations", "description": "Loaded animations. See the jjANIMATION class description for more information.\n", "full": "jjANIMATION@ jjAnimations[1500]", "type": "property"}, {"name": "jjAnimFrames", "description": "Loaded animation frames. See the jjANIMFRAME class description for more information.\n", "full": "jjANIMFRAME@ jjAnimFrames[15000]", "type": "property"}, {"name": "jjAnimSets", "description": "Loaded animation sets. See the jjANIMSET class description for more information.\n", "full": "jjANIMSET@ jjAnimSets[ANIM::Set]", "type": "property"}, {"name": "jjAutoWeaponChange", "description": "Whether automatic weapon change is locally enabled, as set by the /weaponchange command.\n", "full": "const bool jjAutoWeaponChange", "type": "property"}, {"name": "jjBackupPalette", "description": "The tileset's original palette. See the jjPAL documentation above for further details.\n", "full": "const jjPAL jjBackupPalette", "type": "property"}, {"name": "jjBorderHeight", "description": "The size of the black borders that appear at the edges of each local player's subscreen when a subscreen is larger than the level/server's maximum resolution, when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile Width/Tile Height checked), and/or when the F3 key has been used. Useful for deciding where to draw HUD/UI elements. Note that these values refer to the size of each border, not the overall size of the black space, so for instance if jjBorderWidth is 80, there will be 80 columns of black pixels on the left side of the subscreen and an additional 80 columns on the right side.\n", "full": "const int jjBorderHeight", "type": "property"}, {"name": "jjBorderWidth", "description": "The size of the black borders that appear at the edges of each local player's subscreen when a subscreen is larger than the level/server's maximum resolution, when a subscreen is larger than Layer 4 (and Layer 4 does not have Tile Width/Tile Height checked), and/or when the F3 key has been used. Useful for deciding where to draw HUD/UI elements. Note that these values refer to the size of each border, not the overall size of the black space, so for instance if jjBorderWidth is 80, there will be 80 columns of black pixels on the left side of the subscreen and an additional 80 columns on the right side.\n", "full": "const int jjBorderWidth", "type": "property"}, {"name": "jjBottomFeeder", "description": "In Roast Tag game mode, the player who is currently the bottom feeder or null if none. For the other special role in Roast Tag, see jjTokenOwner.\n", "full": "jjPLAYER@ jjBottomFeeder", "type": "property"}, {"name": "jjCharacters", "description": "Character profiles. Use either CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2 as an index. Refer to the jjCHARACTER section for more information.\n", "full": "jjCHARACTER@ jjCharacters[CHAR::Char]", "type": "property"}, {"name": "jjColorDepth", "description": "Color depth in bits per pixel. Either 8 or 16.\n", "full": "const int jjColorDepth", "type": "property"}, {"name": "jjControlPoints", "description": "An array containing all Domination control points in the level. See the jjCONTROLPOINT section for further details.\n", "full": "const jjCONTROLPOINT@ jjControlPoints[16]", "type": "property"}, {"name": "jjDeactivatingBecauseOfDeath", "description": "When the player dies in Single Player mode, this property is set to true before all jjOBJs have their state property set to DEACTIVATE. Since DEACTIVATE is also used for when an object goes too far off-screen, this property is how to discover the reason for the state change. In practice, is probably only ever consulted by destruct scenery and trigger scenery.\n", "full": "const bool jjDeactivatingBecauseOfDeath", "type": "property"}, {"name": "jjDebugF10", "description": "Only ever true in single player, specifically when the player has pressed the F10 key to enable debug mode. Among other peculiarities during this time, neither onPlayer nor onPlayerInput nor any of the various non-layer-based jjCANVAS onDraw hook functions will be called, because JJ2+ will be ignoring all normal player interactions.\n", "full": "const bool jjDebugF10", "type": "property"}, {"name": "jjDelayGeneratedCrateOrigins", "description": "If set to true, box objects (trigger crates, all wooden crates, bird morph monitors, and also bird cages) spawned from Generator objects will derive their parameters from the tile they begin at, not the tile they are created at. If the Generator object is in the air, the crate will appear on top of the nearest solid tile below the Generator, and will get its parameters from the tile there.\n", "full": "bool jjDelayGeneratedCrateOrigins", "type": "property"}, {"name": "jjDifficulty", "description": "The current difficulty level. 1 for Normal difficulty; 0 and below for Easy; 2 for Hard; 3 and above for Turbo. Numerous enemies base their speeds at least partially on the difficulty, so numbers outside of the well-tested 0-3 range may have unexpected or undesirable effects with certain enemies; still, it's worth a try! This property cannot be used to determine whether to load events specified in JCS as Easy or Hard, since that has already been checked by the time AngelScript starts running in a level.\nWhen you set this property, jjDifficultyNext will also be set to the new value. So for example, if you want to make enemies move a little faster in this level without affecting the difficulty of the next level in the series, try: jjDifficulty += 1; jjDifficultyNext = jjDifficultyOrig;\n", "full": "int jjDifficulty", "type": "property"}, {"name": "jjDifficultyNext", "description": "The difficulty for the next level. Normally this will be the same as jjDifficulty, but the /difficulty command can set this property independently. Setting this does not accomplish anything for clients, because clients will have their difficulty updated by the server upon cycling.\n", "full": "int jjDifficultyNext", "type": "property"}, {"name": "jjDifficultyOrig", "description": "The difficulty at the start of the level, prior to it being potentially changed by scripts setting jjDifficulty. In online servers, clients who join this level partway through will be sent this value for their difficulty, so they will remove the same events from the event map that everyone else in the server did.\n", "full": "const int jjDifficultyOrig", "type": "property"}, {"name": "jjDoZombiesAlreadyExist", "description": "In Pestilence game mode, whether any player is already a zombie.\n", "full": "const bool jjDoZombiesAlreadyExist", "type": "property"}, {"name": "jjEcho", "description": "The current degree of echo, as set by the \"Echo\" event.\n", "full": "int jjEcho", "type": "property"}, {"name": "jjEnabledASFunctions", "description": "Usually all true. When a Text event is touched with AngelScript=1,Vanish=1, the jjEnabledASFunctions[#] bool for that Text event's TextID value will be set to false and the corresponding onFunction# will be uncallable by other Text events until the bool is set to true again.\n", "full": "bool jjEnabledASFunctions[256]", "type": "property"}, {"name": "jjEnabledTeams", "description": "Currently enabled teams. Possible indices are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n", "full": "const bool jjEnabledTeams[TEAM::Color]", "type": "property"}, {"name": "jjEnabledTeams", "description": "Currently enabled teams. Possible indices are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n", "full": "const bool jjEnabledTeams[4]", "type": "property"}, {"name": "jjEnforceLighting", "description": "This setting defines the minimal ambient lighting options required from the game. It will not change game settings if they don't fulfill the requirements but it will display lights as if the settings were changed. Allowed values are:\n\t\t\t\tOPTIONAL: The default value; ambient lighting can be freely disabled and enabled with no limits.\n\t\t\t\tBASIC: Ambient lighting can be disabled but basic lights, such as those emitted by objects, players and laser shields, have to be drawn. This only affects the game if ambient lighting is disabled and low detail is enabled, because that's when basic lights stop being drawn.\n\t\t\t\tCOMPLETE: Ambient lighting cannot be disabled, all lights have to be drawn.\n\t\t\t\t\n", "full": "LIGHT::Enforce jjEnforceLighting", "type": "property"}, {"name": "jjEventAtLastMaskedPixel", "description": "Whenever one of the mask-detection functions, e.g. jjMaskedHLine, finds a masked pixel in layer 4, this property will be set to the event at the tile containing that pixel. This allows you to write code for object like seeker missiles, which ignore masked pixels on tiles with the AREA::ONEWAY, AREA::HOOK, or AREA::VINE events. There's not much reason to edit it manually, since JJ2 changes its value all but constantly, but you can if you want.\n", "full": "uint8 jjEventAtLastMaskedPixel", "type": "property"}, {"name": "jjFPS", "description": "The current frames per second rate, as viewable by pressing F9 twice.\n", "full": "const int jjFPS", "type": "property"}, {"name": "jjFriendlyFire", "description": "Whether friendly fire is enabled, as set by the /friendlyfire command.\n", "full": "const bool jjFriendlyFire", "type": "property"}, {"name": "jjGameConnection", "description": "Is this game joinable by players from other computers, and if so, must they be connected to the same network or just the internet? Options are LOCAL, ONLINE, and LAN.\n", "full": "const GAME::Connection jjGameConnection", "type": "property"}, {"name": "jjGameCustom", "description": "If using a custom gamemode, what is it? Options are NOCUSTOM, RT, LRS, XLRS, PEST, TB, JB, DCTF, FR, TLRS, DOM, and HEAD.\n", "full": "const GAME::Custom jjGameCustom", "type": "property"}, {"name": "jjGameMode", "description": "What is the current base gamemode, irrespective of whether there is a custom gamemode or not? Options are SP, COOP, BATTLE, CTF, TREASURE, and RACE.\n", "full": "const GAME::Mode jjGameMode", "type": "property"}, {"name": "jjGameState", "description": "In an online/network server, is the game started, stopped, or some other variation? Options are. STOPPED, STARTED, PAUSED (only possible if there is a time limit), PREGAME, and OVERTIME.\n", "full": "const GAME::State jjGameState", "type": "property"}, {"name": "jjGameTicks", "description": "How long the game has been actively running, at a rate of 70 ticks per second.\n", "full": "const int jjGameTicks", "type": "property"}, {"name": "jjHelpStrings", "description": "Help strings as set in level properties and used by Text events and end bosses. These can be modified but are limited to 511 characters each, so longer strings will be truncated. For the standard function to display these strings, see showText.\n", "full": "string jjHelpStrings[16]", "type": "property"}, {"name": "jjIsAdmin", "description": "Whether the current game executable is logged in as a Remote Admin in the current online server. To check this property for any client in the server, use jjPLAYER property isAdmin instead.\n", "full": "const bool jjIsAdmin", "type": "property"}, {"name": "jjIsServer", "description": "Whether the current game executable is hosting an online server.\n", "full": "const bool jjIsServer", "type": "property"}, {"name": "jjIsSnowing", "description": "Whether there's any active weather effect. The type of the effect is determined by jjSnowingType.\n", "full": "bool jjIsSnowing", "type": "property"}, {"name": "jjIsSnowingOutdoorsOnly", "description": "Whether the current weather effect is specified to only take effect on transparent tiles, i.e. appear to be limited to outdoors areas.\n", "full": "bool jjIsSnowingOutdoorsOnly", "type": "property"}, {"name": "jjIsTSF", "description": "Whether the current game executable is 1.23+ or 1.24+. Useful for Lori, XMas enemies, etc.\n", "full": "const bool jjIsTSF", "type": "property"}, {"name": "jjKey", "description": "Whether any given key on the keyboard is currently pressed, assuming JJ2 is able to check it, including the left and right mouse buttons. Uses virtual key codes for indexation. Note that jjKey[1] and jjKey[2] refer to the primary and secondary mouse buttons respectively, rather than left and right.\n", "full": "const bool jjKey[256]", "type": "property"}, {"name": "jjKeyChat", "description": "The current virtual key used to open the chat prompt in a multiplayer game, default value 0x54 ('T'). No matter the key (or mouse button), pressing the Shift key at the same time will open the chat prompt in Team Chat mode (in CTF games). Note that as a workaround to allow players to cycle and whatnot, pressing Ctrl+T will always open the chat prompt, even if jjKeyChat is set to 0 or something similarly inaccessible.\n", "full": "uint8 jjKeyChat", "type": "property"}, {"name": "jjLayerHasTiles", "description": "", "full": "bool jjLayerHasTiles[8]", "type": "property"}, {"name": "jjLayerHeight", "description": "", "full": "const int jjLayerHeight[8]", "type": "property"}, {"name": "jjLayerLimitVisibleRegion", "description": "", "full": "bool jjLayerLimitVisibleRegion[8]", "type": "property"}, {"name": "jjLayerTileHeight", "description": "", "full": "bool jjLayerTileHeight[8]", "type": "property"}, {"name": "jjLayerTileWidth", "description": "", "full": "bool jjLayerTileWidth[8]", "type": "property"}, {"name": "jjLayerWidth", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "const int jjLayerWidth[8]", "type": "property"}, {"name": "jjLayerWidthReal", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "const int jjLayerWidthReal[8]", "type": "property"}, {"name": "jjLayerWidthRounded", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "const int jjLayerWidthRounded[8]", "type": "property"}, {"name": "jjLayerXAutoSpeed", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "float jjLayerXAutoSpeed[8]", "type": "property"}, {"name": "jjLayerYAutoSpeed", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "float jjLayerYAutoSpeed[8]", "type": "property"}, {"name": "jjLayerXOffset", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "float jjLayerXOffset[8]", "type": "property"}, {"name": "jjLayerYOffset", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "float jjLayerYOffset[8]", "type": "property"}, {"name": "jjLayerXSpeed", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "float jjLayerXSpeed[8]", "type": "property"}, {"name": "jjLayerYSpeed", "description": "Shortcut global properties for the same-named jjLAYER properties on the same-indexed jjLayers objects.\n", "full": "float jjLayerYSpeed[8]", "type": "property"}, {"name": "jjLayers", "description": "The original eight layers placed in this level (i.e. jjLevelFileName) in JCS or some other level editor, 1-indexed to match the JCS numbers, e.g. jjLayers[4] for the main sprite layer or jjLayers[8] for the final background layer, regardless of what other code may have done to create new layers or alter their order. See the jjLAYER documentation above for further details.\n", "full": "jjLAYER@ jjLayers[8]", "type": "property"}, {"name": "jjLevelFileName", "description": "File name of the current level, e.g. castle1.j2l, all lowercase. The file extension (.j2l) will be included, but not the folder structure.\n", "full": "const string jjLevelFileName", "type": "property"}, {"name": "jjLevelName", "description": "Title of the current level, e.g. Dungeon Dilemma.\n", "full": "string jjLevelName", "type": "property"}, {"name": "jjLocalPlayerCount", "description": "The number of local players.\n", "full": "const int jjLocalPlayerCount", "type": "property"}, {"name": "jjLocalPlayers", "description": "The local players.\n", "full": "const jjPLAYER@ jjLocalPlayers[4]", "type": "property"}, {"name": "jjLowDetail", "description": "Whether the Low Detail video setting is enabled. When true, only jjLayers[8] and layers whose xSpeed/ySpeed both equal exactly 1 and whose xSpeedModel/ySpeedModel both equal LAYERSPEEDMODEL::NORMAL will be drawn, and even those only if hasTileMap and hasTiles are both true.\n", "full": "const bool jjLowDetail", "type": "property"}, {"name": "jjMaxHealth", "description": "The most health a player can ever have, as set by the /maxhealth command. Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.\n", "full": "const int jjMaxHealth", "type": "property"}, {"name": "jjMaxScore", "description": "In competitive game modes, the score required to win, as set by the /maxscore command.\n", "full": "const int jjMaxScore", "type": "property"}, {"name": "jjMouseAim", "description": "Whether mouse aim is locally enabled, as set by the /mouseaim command.\n", "full": "const bool jjMouseAim", "type": "property"}, {"name": "jjMouseX", "description": "The current position of the mouse cursor relative to the top left corner of the game window. To convert these coordinates to coordinates within layer 4, you'll need to use the jjPLAYER cameraX and cameraY properties.\n", "full": "const int jjMouseX", "type": "property"}, {"name": "jjMouseY", "description": "The current position of the mouse cursor relative to the top left corner of the game window. To convert these coordinates to coordinates within layer 4, you'll need to use the jjPLAYER cameraX and cameraY properties.\n", "full": "const int jjMouseY", "type": "property"}, {"name": "jjMusicActive", "description": "Mute Music, as seen in the Sound & Music Properties window.\n", "full": "const bool jjMusicActive", "type": "property"}, {"name": "jjMusicFileName", "description": "File name of the music file currently playing, e.g. 3ddemo.mod, all lowercase. The file extension will be included (even if not included by the level or user, e.g. this string will be \"castle.j2b\" if \"castle\" was written in Level Properties), but not the folder structure.\nThis is a const property. To change it, use jjMusicLoad.\n", "full": "const string jjMusicFileName", "type": "property"}, {"name": "jjMusicVolume", "description": "Music Volume, as seen in the Sound & Music Properties window.\n", "full": "const int jjMusicVolume", "type": "property"}, {"name": "jjNoBlink", "description": "Whether the no blink mode is enabled, as set by the /noblink command.\n", "full": "const bool jjNoBlink", "type": "property"}, {"name": "jjNoMovement", "description": "Whether the game blocks movement during stopped games, as set by the /nomovement command.\n", "full": "const bool jjNoMovement", "type": "property"}, {"name": "jjObjectCount", "description": "When looping through jjObjects, this is the endpoint; there should never exist a jjOBJ with an object ID higher than jjObjectCount. It is not however the number of distinct jjOBJs in existence at any given time, since for instance jjObjects[1] and jjObjects[3] may both be active but jjObjects[2] inactive, but jjObjectCount would still equal 4.\n", "full": "const int jjObjectCount", "type": "property"}, {"name": "jjObjectMax", "description": "The most jjOBJs that can ever exist at the same time. This equals 2048 in local Single Player/Coop, or 4096 otherwise.\n", "full": "const int jjObjectMax", "type": "property"}, {"name": "jjObjectPresets", "description": "The templates from which each object is built. Tends to contain default xSpeed, ySpeed, points, curAnim, and so on. Make changes here in onLevelLoad for maximum efficiency.\n", "full": "jjOBJ@ jjObjectPresets[256]", "type": "property"}, {"name": "jjObjects", "description": "All the objects currently in memory.\n", "full": "jjOBJ@ jjObjects[jjObjectMax]", "type": "property"}, {"name": "jjP", "description": "The current player.\n", "full": "jjPLAYER@ jjP", "type": "property"}, {"name": "jjPalette", "description": "The current palette. See the jjPAL documentation above for further details.\n", "full": "jjPAL jjPalette", "type": "property"}, {"name": "jjParticles", "description": "All the particles currently in memory. See the jjPARTICLE documentation above for further details.\n", "full": "jjPARTICLE@ jjParticles[1024]", "type": "property"}, {"name": "jjPlayerCount", "description": "Doesn't work! Check back later.\n", "full": "const int jjPlayerCount", "type": "property"}, {"name": "jjPlayers", "description": "All the players in the game, local or otherwise.\n", "full": "const jjPLAYER@ jjPlayers[32]", "type": "property"}, {"name": "jjQuirks", "description": "Whether the quirks mode is enabled, as set by the /quirks command.\n", "full": "const bool jjQuirks", "type": "property"}, {"name": "jjRenderFrame", "description": "How long the game has been running. Unlike jjGameTicks, jjRenderFrame updates when the game is paused. This is the value used for drawing layers with automatic x/y speeds.\n", "full": "const int jjRenderFrame", "type": "property"}, {"name": "jjResolutionHeight", "description": "The size of the current game window in pixels, usually 640 by 480.\n", "full": "const int jjResolutionHeight", "type": "property"}, {"name": "jjResolutionWidth", "description": "The size of the current game window in pixels, usually 640 by 480.\n", "full": "const int jjResolutionWidth", "type": "property"}, {"name": "jjResolutionMaxHeight", "description": "The maximum size the game window is allowed to be in the current level/server.\n", "full": "const int jjResolutionMaxHeight", "type": "property"}, {"name": "jjResolutionMaxWidth", "description": "The maximum size the game window is allowed to be in the current level/server.\n", "full": "const int jjResolutionMaxWidth", "type": "property"}, {"name": "jjScriptModuleID", "description": "Each script module (including mutators) will see this property as equalling a different value: 0 for the .j2as script (if any), and 1 or higher for all mutators (loaded in alphabetical order). For use only as parameters of function jjSendPacket and jjPLAYER method hasPrivilege.\n", "full": "const uint jjScriptModuleID", "type": "property"}, {"name": "jjShowMaxHealth", "description": "Whether the show max health option from the Plus menu is enabled.\n", "full": "const bool jjShowMaxHealth", "type": "property"}, {"name": "jjSnowingIntensity", "description": "Intensity of the current weather effect. Note that that this setting only influences the game if jjIsSnowing is true.\n", "full": "uint8 jjSnowingIntensity", "type": "property"}, {"name": "jjSnowingType", "description": "Type of the current weather effect. Note that that this setting only influences the game if jjIsSnowing is true. Possible values are SNOW, FLOWER, RAIN, and LEAF, each spawning particles of the corresponding PARTICLE::Type.\n", "full": "SNOWING::Type jjSnowingType", "type": "property"}, {"name": "jjSoundEnabled", "description": "Whether JJ2 should produce any form of audio at all.\n", "full": "const bool jjSoundEnabled", "type": "property"}, {"name": "jjSoundFXActive", "description": "Mute Sound, as seen in the Sound & Music Properties window.\n", "full": "const bool jjSoundFXActive", "type": "property"}, {"name": "jjSoundFXVolume", "description": "Sound Volume, as seen in the Sound & Music Properties window.\n", "full": "const int jjSoundFXVolume", "type": "property"}, {"name": "jjStartHealth", "description": "How much health a player starts with, as set by the /starthealth command. Defaults to 5 in Single Player/Cooperative/Battle, or 3 in Capture The Flag.\n", "full": "const int jjStartHealth", "type": "property"}, {"name": "jjStrongPowerups", "description": "Whether strong powerups is enabled, as set by the /strongpowerups command.\n", "full": "const bool jjStrongPowerups", "type": "property"}, {"name": "jjSubscreenHeight", "description": "The size of a player's subscreen in pixels. If there is only one local player and the game is not being viewed in 3D, these will be equal to jjResolutionHeight and jjResolutionWidth -- otherwise, either or both may be cut in half. The subscreen size includes, and is therefore not changed by the values of, jjBorderHeight and jjBorderWidth.\n", "full": "const int jjSubscreenHeight", "type": "property"}, {"name": "jjSubscreenWidth", "description": "The size of a player's subscreen in pixels. If there is only one local player and the game is not being viewed in 3D, these will be equal to jjResolutionHeight and jjResolutionWidth -- otherwise, either or both may be cut in half. The subscreen size includes, and is therefore not changed by the values of, jjBorderHeight and jjBorderWidth.\n", "full": "const int jjSubscreenWidth", "type": "property"}, {"name": "jjSugarRushAllowed", "description": "In online multiplayer levels where this is false for the host, clients with sugar rushes will be kicked for hacking. This property is set to true between onLevelLoad and onLevelBegin if there are any events in the level that will spawn food objects. If you need to allow sugar rushes for another reason, e.g. jjPLAYER::startSugarRush, your script should set this property to true in onLevelBegin at the earliest. (See the description of jjWEAPON::allowed for more technical details, but as applied to the list of food events instead.)\n", "full": "bool jjSugarRushAllowed", "type": "property"}, {"name": "jjTeamScore", "description": "Each team's current score in team-based game modes and undefined value in other modes. Available indexes are BLUE, RED, GREEN and YELLOW.\n", "full": "const int jjTeamScore[TEAM::Color]", "type": "property"}, {"name": "jjTexturedBGFadePositionX", "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n", "full": "float jjTexturedBGFadePositionX", "type": "property"}, {"name": "jjTexturedBGFadePositionY", "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n", "full": "float jjTexturedBGFadePositionY", "type": "property"}, {"name": "jjTexturedBGStars", "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n", "full": "bool jjTexturedBGStars", "type": "property"}, {"name": "jjTexturedBGStyle", "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n", "full": "TEXTURE::Style jjTexturedBGStyle", "type": "property"}, {"name": "jjTexturedBGTexture", "description": "Shortcut global properties for corresponding jjLAYER or jjLAYER::warpHorizon properties of the background layer, i.e. jjLayers[8].\n", "full": "TEXTURE::Texture jjTexturedBGTexture", "type": "property"}, {"name": "jjTexturedBGUsed", "description": "A shortcut property for jjLayers[8]'s textureSurface property. Returns true iff the property is anything other than SURFACE::UNTEXTURED. Set jjTexturedBGUsed to true to set to SURFACE::LEGACY, or to false to set to SURFACE::UNTEXTURED.\n", "full": "bool jjTexturedBGUsed", "type": "property"}, {"name": "jjTileCount", "description": "The number of (non-animated, non-flipped) tiles currently defined in the level, usually a multiple of 10. Can be increased using jjTilesFromTileset.\n", "full": "const uint jjTileCount", "type": "property"}, {"name": "jjTiles", "description": "Static and animated tiles corresponding to tile IDs.\nSee also jjAnimatedTiles.\n", "full": "const jjTILE@ jjTiles[0x10000]", "type": "property"}, {"name": "jjTilesetFileName", "description": "File name of the tileset used by the current level, e.g. castle1.j2t, all lowercase. The file extension (.j2t) will be included, but not the folder structure.\n", "full": "const string jjTilesetFileName", "type": "property"}, {"name": "jjTileType", "description": "Each tile's tile type: 0 for normal, 1 for translucent, 3 for invisible, and so on. Refer to your JCS.ini for the full list.\n", "full": "uint8 jjTileType[4096]", "type": "property"}, {"name": "jjTriggers", "description": "The triggers, as set by the Trigger Zone and Trigger Crate events.\n", "full": "bool jjTriggers[32]", "type": "property"}, {"name": "jjTokenOwner", "description": "In Roast Tag game mode, the player who is currently \"it\" or null if none. For the other special role in Roast Tag, see jjBottomFeeder.\n", "full": "jjPLAYER@ jjTokenOwner", "type": "property"}, {"name": "jjUseLayer8Speeds", "description": "A shortcut property for jjLayers[8]'s xSpeedModel/ySpeedModel properties. Returns true iff at least one of the two properties is anything other than LAYERSPEEDMODEL::LAYER8. Set jjUseLayer8Speeds to true to set both properties to LAYERSPEEDMODEL::NORMAL, or to false to set both properties to LAYERSPEEDMODEL::LAYER8.\n", "full": "bool jjUseLayer8Speeds", "type": "property"}, {"name": "jjVerticalSplitscreen", "description": "If there are exactly two local players, how the window is divided into their two subscreens.\n", "full": "bool jjVerticalSplitscreen", "type": "property"}, {"name": "jjWarpsTransmuteCoins", "description": "If set to false, using a coin warp in Single Player mode will not turn all remaining coins into red and green gems.\n", "full": "bool jjWarpsTransmuteCoins", "type": "property"}, {"name": "jjWaterChangeSpeed", "description": "How fast water moves up or down when the water level is set (by event or function) with the \"Instant\" parameter set to false. Defaults to 1.\n", "full": "float jjWaterChangeSpeed", "type": "property"}, {"name": "jjWaterInteraction", "description": "How local players react to being underwater. If this property is set to SWIM, they will swim; if LOWGRAVITY, they will use regular physics but will fall more slowly than usual. If this property is set to POSITIONBASED (the default), the game will choose between the effects of SWIM or LOWGRAVITY depending on whether jjWaterLevel is lower or greater than 32*128. This property has no effects on other objects or on sound effects, which always move more slowly/sound different underwater.\n", "full": "WATERINTERACTION::WaterInteraction jjWaterInteraction", "type": "property"}, {"name": "jjWaterLayer", "description": "Which layer, 1-8, water is drawn in front of when visible. Defaults to 1. Set to any non-existing layer number to make water invisible. Note that this is a purely visual setting, and putting water behind the sprite layer will not prevent players from swimming in it.\nIf the order of layers has been changed, this property's distance from 4 is its distance from the sprite layer, e.g. leaving it at 1 means that it will be drawn in front of the third layer in front of the sprite layer. (And therefore, if the sprite layer is the first, second, or third layer in the drawing order, water will not be drawn at all.)\n", "full": "int jjWaterLayer", "type": "property"}, {"name": "jjWaterLevel", "description": "How high the water currently is, in pixels.\nThis is a constant value; use the jjSetWaterLevel helper function instead for changing it.\n", "full": "const float jjWaterLevel", "type": "property"}, {"name": "jjWaterLighting", "description": "The current way that water and ambient lighting interact in the level. (Ambient lighting varies by local player and as such is a jjPLAYER property.) The following constants are permissible values:\n\t\t\t\t\n\t\t\t\t\tWATERLIGHT::NONE: The default. When water is activated, the level will display at lighting 100, regardless of the current settings.\n\t\t\t\t\tWATERLIGHT::GLOBAL: The entire level will be lit according to the current ambient lighting settings, both above and below the water line.\n\t\t\t\t\tWATERLIGHT::LAGUNICUS: The current ambient lighting setting is ignored. Above the water, the level will display at lighting 100. Below the water, the level will display darker and darker depending on how far below the water line the player is.\n\t\t\t\t\n", "full": "WATERLIGHT::wl jjWaterLighting", "type": "property"}, {"name": "jjWaterTarget", "description": "The height the water is moving towards, in pixels. If the water level is set (by event or function) with the \"Instant\" parameter set to false, there will be a period in which jjWaterLevel and jjWaterTarget are two distinct values.\nThis is a constant value; use the jjSetWaterLevel helper function instead for changing it.\n", "full": "const float jjWaterTarget", "type": "property"}, {"name": "jjWeapons", "description": "Various properties of the nine different weapons available to a player; see the jjWEAPON section. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead.\n", "full": "jjWEAPON jjWeapons[WEAPON::Weapon]", "type": "property"}, {"name": "jjWeapons", "description": "Various properties of the nine different weapons available to a player; see the jjWEAPON section. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead.\n", "full": "jjWEAPON jjWeapons[9]", "type": "property"}, {"name": "p", "description": "The current player; an alias of jjP, and the only property not to begin with the jj prefix, provided solely for convenience value.\n", "full": "jjPLAYER@ p", "type": "property"}], "globalfunctionsList": [{"name": "jjAddObject", "description": "Adds and initiates an object of type eventID at xOrg xPixel and yOrg yPixel. Possible values for creatorType are CREATOR::OBJECT, CREATOR::LEVEL, and CREATOR::PLAYER. Useful values for eventID can be found in the appendix at the bottom of the page. Returns the object ID of the new object, or 0 if the function fails for whatever reason.\nThe difference between jjAddObject(1, 0, 0, CREATOR::OBJECT, 0, BEHAVIOR::BOUNCERBULLET); and jjObjects[jjAddObject(1, 0, 0)].behavior = BEHAVIOR::BOUNCERBULLET; is that jjAddObject calls the object's behavior function as part of creating it. The first version will call BEHAVIOR::BOUNCERBULLET while the object's state is still STATE::START; the second version will call jjObjectPresets[1].behavior and only switch the object's behavior to BEHAVIOR::BOUNCERBULLET after it has already been initialized and its state likely changed to something else. The same distinction applies to setting the object's xOrg/yOrg, creatorType, and creatorID properties as parameters to the function or later on. See jjBEHAVIORINTERFACE.\n", "full": "int jjAddObject(uint8 eventID, float xPixel, float yPixel, uint16 creatorID = 0, CREATOR::Type creatorType = CREATOR::OBJECT, jjBEHAVIOR behavior = BEHAVIOR::DEFAULT)", "type": "function"}, {"name": "jjAddParticle", "description": "Creates and returns a new particle object, or a null pointer if unsuccessful. See the jjPARTICLE documentation above for full details.\n", "full": "jjPARTICLE@ jjAddParticle(PARTICLE::Type type)", "type": "function"}, {"name": "jjAddParticlePixelExplosion", "description": "Creates an explosion of particles based on the shape and possibly colors of the specified curFrame. Use a mode value of 0 for a normal explosion, 1 for a fire explosion caused by a toaster or fire shield bullet, or 2 for an explosion caused by a special move. Values in the range of 15-255 will create fire explosions whose particles will use palette index equal to mode - this effect is currently used by weapons such as powered-up toaster and laser shield to create blue explosions. Value 14 creates a fire explosion whose particles use individually random colors. Values in the range of 3-13 and higher than 255 are undefined and - to preserve backward compatibility - shouldn't be used.\n", "full": "void jjAddParticlePixelExplosion(float xPixel, float yPixel, int curFrame, int direction, int mode)", "type": "function"}, {"name": "jjAddParticleTileExplosion", "description": "Creates four fragments of a tile falling from a specified location, like when destroying a destructable scenery block. Does not produce a sound effect; use jjSample or jjSamplePriority for that instead. The fragments will continue to be drawn until they fall off the screen. If you want more control over the fragments' positions, speeds, etc., use jjAddParticle instead.\n", "full": "void jjAddParticleTileExplosion(uint16 xTile, uint16 yTile, uint16 tile, bool collapseSceneryStyle)", "type": "function"}, {"name": "jjAlert", "description": "Writes text to the chatlogger window, and also displays it ingame for the local player. Uses size to determine size and positioning of text. If sendToAll is true and the function is called by the server, text will be sent to all clients as well.\n", "full": "void jjAlert(const string &in text, bool sendToAll = false, STRING::Size size = STRING::SMALL)", "type": "function"}, {"name": "jjChat", "description": "In online play, sends text to the server as a line of chat. If text is a command (e.g. \"/spectate on\" or \"/ready\"), it will be interpreted as such to the extent that the local player is allowed to use that command in the server.\nIn offline play, JJ2+ will try to parse text as a command but will not display it as chat because there is no chat in offline mode. If you want to simulate chatting in a local game, use jjAlert instead.\n", "full": "void jjChat(const string &in text, bool teamchat = false)", "type": "function"}, {"name": "jjConsole", "description": "Writes text as a console message to the chatlogger window, and also displays it ingame for the local player. If sendToAll is true and the function is called by the server, text will be sent to all clients as well.\n", "full": "void jjConsole(const string &in text, bool sendToAll = false)", "type": "function"}, {"name": "jjCos", "description": "Returns the cosine of angle with a range of 0.0-1.0 and a domain of 0-1023. Numbers outside the domain will be seemlessly moduloed. You may prefer AngelScript's native cos function.\n", "full": "float jjCos(uint angle)", "type": "function"}, {"name": "jjCRC32", "description": "Computes cyclic redundancy check of input with optional initial value crc. The checksum is computed according to the CRC-32 standard (as used in the zlib library and all JJ2 data files that use CRC).\n", "full": "uint jjCRC32(const jjSTREAM &in input, uint crc = 0)", "type": "function"}, {"name": "jjDebug", "description": "Writes text to the chatlogger window (but not ingame), but only if [General]AngelscriptDebug equals True in plus.ini. If timestamp is true, adds a timestamp before the text.\n", "full": "void jjDebug(const string &in text, bool timestamp = false)", "type": "function"}, {"name": "jjDeleteObject", "description": "Permanently deletes an object. Like jjAddObject, this function is purely local in its scope.\n", "full": "void jjDeleteObject(int objectID)", "type": "function"}, {"name": "jjDrawPixel", "description": "", "full": "void jjDrawPixel(float xPixel, float yPixel, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawRectangle", "description": "", "full": "void jjDrawRectangle(float xPixel, float yPixel, int width, int height, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawResizedSprite", "description": "", "full": "void jjDrawResizedSprite(float xPixel, float yPixel, int setID, uint8 animation, uint8 frame, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawResizedSpriteFromCurFrame", "description": "", "full": "void jjDrawResizedSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawRotatedSprite", "description": "", "full": "void jjDrawRotatedSprite(float xPixel, float yPixel, int setID, uint8 animation, uint8 frame, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawRotatedSpriteFromCurFrame", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\n", "full": "void jjDrawRotatedSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawSprite", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\n", "full": "void jjDrawSprite(float xPixel, float yPixel, int setID, uint8 animation, uint8 frame, int direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawSpriteFromCurFrame", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\n", "full": "void jjDrawSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, int direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawString", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\n", "full": "void jjDrawString(float xPixel, float yPixel, const string &in text, STRING::SIZE size = STRING::SMALL, STRING::Mode mode = STRING::NORMAL, uint8 param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawString", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\n", "full": "void jjDrawString(float xPixel, float yPixel, const string &in text, const jjANIMATION &in animation, STRING::Mode mode = STRING::NORMAL, uint8 param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawString", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\n", "full": "void jjDrawString(float xPixel, float yPixel, const string &in text, STRING::SIZE size, const jjTEXTAPPEARANCE &in appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawString", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\n", "full": "void jjDrawString(float xPixel, float yPixel, const string &in text, const jjANIMATION &in animation, const jjTEXTAPPEARANCE &in appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawSwingingVineSpriteFromCurFrame", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\n", "full": "void jjDrawSwingingVineSpriteFromCurFrame(float xPixel, float yPixel, uint sprite, int length, int curvature, SPRITE::Mode mode = SPRITE::NORMAL, int param = 0, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjDrawTile", "description": "Global function versions of the jjCANVAS methods as applied to onDrawLayer# hooks, differing in that the jjCANVAS methods are executed instantly, whereas these functions create instructions for JJ2 to perform the drawing operations later on, at the proper time. For example, a swinging platform will call jjDrawSpriteFromCurFrame many times over, once for each of its chain links, in the middle of its behavior function, but the links won't actually get drawn to the screen until later in the game cycle. Native JJ2 code uses this method for everything but HUD graphics.\nThe layerZ parameter specifies which layer, 1-8, the graphic should be drawn in front of as its Z-index. Unlike the jjCANVAS hooks, this can be used even for layers that don't have any tiles. JJ2 draws sprites exclusively(?) in front of layers 3, 4, and 5, but you're welcome to experiment.\nThe layerXY parameter specifies which layer, 1-8, the graphic should be positioned relative to the top left corner of. JJ2 always, always does layer 4, but you can vary it up a bit. Unfortunately the game cycle is ordered so that the layers besides layer 4 may actually move around a little after the instruction is registered but before the graphic is drawn, so these drawing instructions will always be one frame behind. Here the jjCANVAS methods have a clear advantage.\nIf the order of layers has been changed, then layerZ and layerXY's distance from 4 are their distance from the sprite layer, e.g. 3 means not necessarily jjLayers[3], but rather 4-1, the first layer in front of the sprite layer, whichever jjLAYER that happens to be.\nThe playerID parameter specifies which player should see the drawn graphic, 0-31, or -1 for all of them (restricted only to players with true isLocal). Drawing for one player a time is used by JJ2+ to, for example, draw fastfire pickups as green/blue or normal/powered-up depending on the charCurr and powerup[1] values of each jjPLAYER viewing them. When spectating, sprites are drawn for the player ID of the spectator, not the spectatee.\n", "full": "void jjDrawTile(float xPixel, float yPixel, uint16 tile, TILE::Quadrant tileQuadrant = TILE::ALLQUADRANTS, int8 layerZ = 4, uint8 layerXY = 4, int8 playerID = -1)", "type": "function"}, {"name": "jjEnableEachASFunction", "description": "Resets all 256 bools in jjEnabledASFunctions to true.\n\t\t\t\n", "full": "void jjEnableEachASFunction()", "type": "function"}, {"name": "jjEventGet", "description": "Gets the Event ID at tile xTile,yTile, as seen in JCS.ini. This number can also be compared to the OBJECT or AREA constants listed in the appendix at the bottom of this file.\n", "full": "int jjEventGet(uint16 xTile, uint16 yTile)", "type": "function"}, {"name": "jjEventSet", "description": "Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA constants are listed in the appendix at the bottom of this file.\nCaution: this is a permanent change and will subsist even after death in offline play.\n", "full": "void jjEventSet(uint16 xTile, uint16 yTile, uint8 newEventID)", "type": "function"}, {"name": "jjEventSet", "description": "Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA constants are listed in the appendix at the bottom of this file.\nCaution: this is a permanent change and will subsist even after death in offline play.\n", "full": "void jjEventSet(uint16 xTile, uint16 yTile, OBJECT::Object newEventID)", "type": "function"}, {"name": "jjEventSet", "description": "Sets the event at tile xTile,yTile to newEventID. Possible OBJECT or AREA constants are listed in the appendix at the bottom of this file.\nCaution: this is a permanent change and will subsist even after death in offline play.\n", "full": "void jjEventSet(uint16 xTile, uint16 yTile, AREA::Area newEventID)", "type": "function"}, {"name": "jjGenerateSettableTileArea", "description": "Shortcut global function for jjLAYER::generateSettableTileArea on the same-indexed jjLayers objects.\n", "full": "void jjGenerateSettableTileArea(uint8 layer, int xTile, int yTile, int width, int height)", "type": "function"}, {"name": "jjGetFadeColors", "description": "Calls and returns the result of jjLayers[8].getFadeColor().\n", "full": "jjPALCOLOR jjGetFadeColors()", "type": "function"}, {"name": "jjGetModOrder", "description": "Returns the current order in the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n", "full": "int jjGetModOrder()", "type": "function"}, {"name": "jjGetModRow", "description": "Returns the current row in the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n", "full": "int jjGetModRow()", "type": "function"}, {"name": "jjGetModSpeed", "description": "Returns the \"speed\" parameter (ticks per row) of the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n", "full": "int jjGetModSpeed()", "type": "function"}, {"name": "jjGetModTempo", "description": "Returns the tempo of the currently playing module music, or -1 if the currently playing music is not a module, a module not handled by BASS or no music is playing.\n", "full": "int jjGetModTempo()", "type": "function"}, {"name": "jjGetPublicInterface", "description": "If moduleName is a name of a currently running script module that registers the onGetPublicInterface hook, calls that hook and returns its result, otherwise returns null. Module names are the same as names of files that contain the modules, including the file extension \".j2as\" or \".mut\", and the comparison is not case sensitive. In the target module, onGetPublicInterface must be a global function with the following signature:\n\t\t\tjjPUBLICINTERFACE@ onGetPublicInterface()\n\t\t\tThe exact return type may differ as long as it is a handle to a class or interface that implements jjPUBLICINTERFACE. This function should not be called earlier than in onLevelLoad, i.e. it should not be used to initialize a global variable, as the target module may not be available at that point yet. More details about usage of this function may be found in the dedicated section of this document.\n", "full": "jjPUBLICINTERFACE@ jjGetPublicInterface(const string &in moduleName)", "type": "function"}, {"name": "jjGetStaticTile", "description": "If tileID is animated, i.e. (tileID & TILE::ANIMATED) != 0, returns tile ID of the current animation frame of the tile corresponding to tileID. Otherwise returns tileID.\nLike animated tiles themselves, this function relies on system time rather than game ticks, which means that subsequent calls during the same frame may return different results, and that results may insignificantly differ compared to the effective state of the animation. This behavior may change in the future.\nThis function never returns tile ID of animated tiles. If its result would be animated, which may happen in levels edited by other means than JCS, the function is called recursively on the result until a static tile is obtained.\n", "full": "uint16 jjGetStaticTile(uint16 tileID)", "type": "function"}, {"name": "jjGetStringWidth", "description": "Returns width, in pixels, that text would have if it was drawn in specified size (or animation) and style. If style allows multi-line text and text is multi-line, width of the longest line is returned.\n", "full": "int jjGetStringWidth(const string &in text, STRING::Size size, const jjTEXTAPPEARANCE &in style)", "type": "function"}, {"name": "jjGetStringWidth", "description": "Returns width, in pixels, that text would have if it was drawn in specified size (or animation) and style. If style allows multi-line text and text is multi-line, width of the longest line is returned.\n", "full": "int jjGetStringWidth(const string &in text, const jjANIMATION &in animation, const jjTEXTAPPEARANCE &in style)", "type": "function"}, {"name": "jjIsValidCheat", "description": "Returns true if text is interpreted by the game as a cheat code.\n", "full": "bool jjIsValidCheat(const string &in text)", "type": "function"}, {"name": "jjKillObject", "description": "Permanently deletes an object, but first calls its native STATE::KILL code (if any). Probably functionally identical to jjDeleteObject in most cases, but might work a little better sometimes.\n", "full": "void jjKillObject(int objectID)", "type": "function"}, {"name": "jjLayerOrderGet", "description": "A pair of functions for accessing or changing the ordered list of layers drawn to the screen. (In most cases it should be simpler to keep the jjLAYER@ array around in your script as a variable, rather than retrieving it using jjLayerOrderGet, but that function is there just in case you need it.) The arrays are ordered so that the first jjLAYER is in front and the last is in back, meaning that writing jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); should have no visible effect in a previously unaltered level.\nThe array passed to jjLayerOrderSet must include jjLayers[4] (the gameplay/sprite layer) as one of its entries and must not include any null handles, or else the function will return false and cause a debug error. Including multiple handles to the same jjLAYER is allowed but not very useful.\nFollowing a call to jjLayerOrderSet, it takes some extra thought and understanding to figure out how to refer to individual layers in other sections of the code. Specifically there are two different patterns (which happen to come to the same thing if the layer order is never changed at all):\nAll global properties or functions with a 1-indexed layer argument\u00c3\u00af\u00c2\u00bf\u00c2\u00bde.g. jjLayers, jjLayerYSpeed, or jjTileGet\u00c3\u00af\u00c2\u00bf\u00c2\u00bd refer exclusively to the level's original eight layers as defined in the level editor. jjLayers[1] will always refer to the same layer no matter which layer ends up being drawn foremost in the foreground. To read or write the size, speeds, etc. of any layer besides those eight, use the properties and methods of its jjLAYER instance. Similarly, the jjCANVAS onDrawLayer# hooks are (currently) only available for those original eight layers, and jjLayers[1] will always call onDrawLayer1 (if defined) no matter its position in the drawing order.\n", "full": "array<jjLAYER@>@ jjLayerOrderGet()", "type": "function"}, {"name": "jjLayerOrderSet", "description": "A pair of functions for accessing or changing the ordered list of layers drawn to the screen. (In most cases it should be simpler to keep the jjLAYER@ array around in your script as a variable, rather than retrieving it using jjLayerOrderGet, but that function is there just in case you need it.) The arrays are ordered so that the first jjLAYER is in front and the last is in back, meaning that writing jjLayerOrderSet(array<jjLAYER@> = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); should have no visible effect in a previously unaltered level.\nThe array passed to jjLayerOrderSet must include jjLayers[4] (the gameplay/sprite layer) as one of its entries and must not include any null handles, or else the function will return false and cause a debug error. Including multiple handles to the same jjLAYER is allowed but not very useful.\nFollowing a call to jjLayerOrderSet, it takes some extra thought and understanding to figure out how to refer to individual layers in other sections of the code. Specifically there are two different patterns (which happen to come to the same thing if the layer order is never changed at all):\nAll global properties or functions with a 1-indexed layer argument\u00c3\u00af\u00c2\u00bf\u00c2\u00bde.g. jjLayers, jjLayerYSpeed, or jjTileGet\u00c3\u00af\u00c2\u00bf\u00c2\u00bd refer exclusively to the level's original eight layers as defined in the level editor. jjLayers[1] will always refer to the same layer no matter which layer ends up being drawn foremost in the foreground. To read or write the size, speeds, etc. of any layer besides those eight, use the properties and methods of its jjLAYER instance. Similarly, the jjCANVAS onDrawLayer# hooks are (currently) only available for those original eight layers, and jjLayers[1] will always call onDrawLayer1 (if defined) no matter its position in the drawing order.\nWhen calling jjDrawSprite or any of its related functions with their layerZ and layerXY arguments, those arguments refer to the list of layers from jjLayerOrderGet, relative to Layer 4's position in that list. The default layerZ value is 4 and will always draw sprites to jjLayers[4]. If layerZ equals 3, 4-1, the sprite will be drawn to whichever jjLAYER is ordered one in front of jjLayers[4]. If 6, 4+2, the layer two behind jjLayers[4]. And so on. The same principle applies to jjWaterLayer.\n", "full": "bool jjLayerOrderSet(const array<jjLAYER@>& in order)", "type": "function"}, {"name": "jjLayersFromLevel", "description": "Returns an array containing a number of handles of new jjLAYER instances built from the layers defined in the level filename, specifically those requested in the 1-indexed layerIDs. (Passing numbers not in the range of 1\u00c3\u00af\u00c2\u00bf\u00c2\u00bd8 in layerIDs is undefined behavior.) For example, jjLayersFromLevel(\"castle1.j2l\", array<uint> = {5,6}); returns an array with two layers, one of width 23 and height 25 and the other of width 20 and height 11, containing different sets of pillars as defined in Layer 5 and Layer 6 of castle1.j2l. These new layer objects may then be inserted into the set of layers drawn to the screen by use of jjLayerOrderSet.\nBy default, the tile IDs of the tiles in these layers will be unchanged, meaning that unless the tileset used by the level filename is the same as is used by this level, the results will likely look very peculiar. (Similarly, any animated tiles used in those layers should probably match those used in this level.) In fact, you may want to make a special unplayable level just for the sake of taking its miscellaneous background or foreground layers into this one (and if you do, remember to tick \"Hide level in Home Cooked Levels list\" in its level properties). Alternatively, the optional tileIDAdjustmentFactor parameter is a value added to the tile IDs of any non-zero, non-animated tiles in the layer/s imported from filename, so for instance, if tileIDAdjustmentFactor equals 10, then a series of tiles 5,6,0,0,3 would become 15,16,0,0,13. (This option is intended for use in conjunction with jjTilesFromTileset, though you may find other uses for it as well.)\nLike in other sections of JJ2+ code, levels saved in either the TSF or regular JCSes work equally well. It does not matter whether the level is passworded. If the file does not exist or does not have the file extension \".j2l\" then the returned array will have zero length. If the file is not a valid level then the game may or may not crash. As with other dependent files, it is recommended to use #pragma require if the level being mined for layers is not a default level.\n", "full": "array<jjLAYER@>@ jjLayersFromLevel(const string &in filename, const array<uint> &in layerIDs, int tileIDAdjustmentFactor = 0)", "type": "function"}, {"name": "jjMaskedHLine", "description": "Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is masked.\n", "full": "bool jjMaskedHLine(int xPixel, int lineLength, int yPixel)", "type": "function"}, {"name": "jjMaskedPixel", "description": "Returns true if pixel xPixel,yPixel is masked.\n", "full": "bool jjMaskedPixel(int xPixel, int yPixel)", "type": "function"}, {"name": "jjMaskedTopVLine", "description": "If any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked, returns the height of the topmost masked pixel relative to yPixel. (For example, if xPixel,yPixel+2 is masked but +1 and +0 weren't, the function returns 2.) If none of the pixels are masked, returns lineLength+1. Used for detecting inclines and the like.\n", "full": "int jjMaskedTopVLine(int xPixel, int yPixel, int lineLength)", "type": "function"}, {"name": "jjMaskedVLine", "description": "Returns true if any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked.\n", "full": "bool jjMaskedVLine(int xPixel, int yPixel, int lineLength)", "type": "function"}, {"name": "jjMaskedHLine", "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n", "full": "bool jjMaskedHLine(int xPixel, int lineLength, int yPixel, uint8 layer)", "type": "function"}, {"name": "jjMaskedPixel", "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n", "full": "bool jjMaskedPixel(int xPixel, int yPixel, uint8 layer)", "type": "function"}, {"name": "jjMaskedTopVLine", "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n", "full": "int jjMaskedTopVLine(int xPixel, int yPixel, int lineLength, uint8 layer)", "type": "function"}, {"name": "jjMaskedVLine", "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n", "full": "bool jjMaskedVLine(int xPixel, int yPixel, int lineLength, uint8 layer)", "type": "function"}, {"name": "jjMusicLoad", "description": "Loads and starts playing a new music file, of any type supported by JJ2+. Returns false if the file cannot be found in either the main game folder or the cache subfolder, or if the specified music file is already playing and forceReload is false. The temporary parameter is useful only in local single player games, where it is used to load a music file only until the player's death, at which point the non-temporary music file will resume playing: this is how the Activate Boss event works.\n", "full": "bool jjMusicLoad(string filename, bool forceReload = false, bool temporary = false)", "type": "function"}, {"name": "jjMusicPause", "description": "Pauses the current music track. May not work with .mp3 files.\n", "full": "void jjMusicPause()", "type": "function"}, {"name": "jjMusicPlay", "description": "(Re)starts the current music track.\n", "full": "void jjMusicPlay()", "type": "function"}, {"name": "jjMusicResume", "description": "Resumes the current music track, once paused. May not work with .mp3 files.\n", "full": "void jjMusicResume()", "type": "function"}, {"name": "jjMusicStop", "description": "Stops the current music track.\n", "full": "void jjMusicStop()", "type": "function"}, {"name": "jjNxt", "description": "Ends the level and skips to the next one, or to filename if specified and of length>0. Only works in Single Player and Cooperative.\n", "full": "void jjNxt(bool warp = false, bool fast = false)", "type": "function"}, {"name": "jjNxt", "description": "Ends the level and skips to the next one, or to filename if specified and of length>0. Only works in Single Player and Cooperative.\n", "full": "void jjNxt(const string& filename = \"\", bool warp = false, bool fast = false)", "type": "function"}, {"name": "jjParameterGet", "description": "Gets one of the parameters at tile xTile,yTile. Follow JCS.ini's lead in figuring out how to write the offset and length parameters.\nlength is the simplest: use the exact same formatting JCS.ini does. To get the speed of a belt event, for instance, length should be -8. To get the number of blue gems in a gem crate, length should be 4. And so on.\noffset is calculated by adding the absolute values of every parameter on the tile prior to the one you want. The first (bottommost) parameter will always have offset 0. To get the parameter \"Blue\" in Gem Crate, offset should be 8 (4+4). To get the Y-Speed of a Rotating Rock, offset should be 12 (8+abs(-4)). And so on.\nSet length to 2 and offset to -4 to get the difficulty of an event (normal, easy, hard, multiplayer-only).\n", "full": "int jjParameterGet(uint16 xTile, uint16 yTile, int8 offset, int8 length)", "type": "function"}, {"name": "jjParameterSet", "description": "Sets one of the parameters at tile xTile,yTile. length and offset work exactly as they do for jjParameterGet; the only change is newValue, which should be a valid number for the length setting. Trying to assign a negative number to an unsigned length parameter doesn't really make sense, for example, nor can you reasonably assign a newValue of 100 to a length of 3.\nNote that this is not quite as powerful as it may seem, since some objects read and process their parameters into memory when they are first created, rather than continually reading them again and again as the game continues. The function will however work fine for zones that affect the player, such as Warp or Sucker Tube or Wind, and it will also successfully set parameters for any such new objects created after the function is called.\nCaution: this is a permanent change and will subsist even after death in offline play.\n", "full": "void jjParameterSet(uint16 xTile, uint16 yTile, int8 offset, int8 length, int newValue)", "type": "function"}, {"name": "jjPlayersWithClientID", "description": "Convenience function; creates and returns an array containing handles of all active players with a given clientID. The result is an empty array if the client is not connected or if clientID is not a valid ID. The result is a null handle if the function is called by a client.\n", "full": "array<jjPLAYER@>@ jjPlayersWithClientID(int clientID)", "type": "function"}, {"name": "jjPrint", "description": "Writes text to the chatlogger window but does not display it ingame. If timestamp is true, adds a timestamp before the text.\n", "full": "void jjPrint(const string &in text, bool timestamp = false)", "type": "function"}, {"name": "jjRandom", "description": "Provides a random number.\n", "full": "uint jjRandom()", "type": "function"}, {"name": "jjRegexIsValid", "description": "Returns true if expression is a valid regular expression and false otherwise. This is the only regex function that doesn't cause debug errors when the input is an invalid expression and as such it should be always used before calling other regex functions when expression comes from an untrusted source (such as from user input rather than from a constant string in the script). Expressions will be parsed according to modified ECMAScript regular expression grammar.\n", "full": "bool jjRegexIsValid(const string &in expression)", "type": "function"}, {"name": "jjRegexMatch", "description": "Returns true if expression is a valid regular expression that matches text entirely and false if no match is found. Where the second overload is used, results will contain match results in a standard order. If ignoreCase is true, the matching will be case insensitive. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input. Note that this function only returns true if expression matches the entire string, whereas jjRegexSearch accepts substring matches.\n", "full": "bool jjRegexMatch(const string &in text, const string &in expression, bool ignoreCase = false)", "type": "function"}, {"name": "jjRegexMatch", "description": "Returns true if expression is a valid regular expression that matches text entirely and false if no match is found. Where the second overload is used, results will contain match results in a standard order. If ignoreCase is true, the matching will be case insensitive. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input. Note that this function only returns true if expression matches the entire string, whereas jjRegexSearch accepts substring matches.\n", "full": "bool jjRegexMatch(const string &in text, const string &in expression, array<string> &out results, bool ignoreCase = false)", "type": "function"}, {"name": "jjRegexReplace", "description": "Returns a string that is the result of replacement of all substrings of text that are matched by expression with replacement. If ignoreCase is true, the matching will be case insensitive. Capture results ($1, $2, etc., $0 always being the entire matched substring) can be successfully used in the replacement string. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input.\n", "full": "string jjRegexReplace(const string &in text, const string &in expression, const string &in replacement, bool ignoreCase = false)", "type": "function"}, {"name": "jjRegexSearch", "description": "Returns true if expression is a valid regular expression that matches any substring of text and false if no match is found. Where the second overload is used, results will contain match results in a standard order. If ignoreCase is true, the matching will be case insensitive. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input. Note that this function returns true if expression matches any character subsequence of text, whereas jjRegexMatch will only look for matches with the entire string.\n", "full": "bool jjRegexSearch(const string &in text, const string &in expression, bool ignoreCase = false)", "type": "function"}, {"name": "jjRegexSearch", "description": "Returns true if expression is a valid regular expression that matches any substring of text and false if no match is found. Where the second overload is used, results will contain match results in a standard order. If ignoreCase is true, the matching will be case insensitive. If expression is not a valid regular expression, a debug message will be printed to the chatlogger and the return value will be undefined. In future versions of JJ2+ this might have further consequences including complete script shutdown. For this reason, jjRegexIsValid should always be used to validate untrusted input. Note that this function returns true if expression matches any character subsequence of text, whereas jjRegexMatch will only look for matches with the entire string.\n", "full": "bool jjRegexSearch(const string &in text, const string &in expression, array<string> &out results, bool ignoreCase = false)", "type": "function"}, {"name": "jjResetWaterGradient", "description": "Restores 16-bit water to its natural colors.\n", "full": "void jjResetWaterGradient()", "type": "function"}, {"name": "jjSample", "description": "Plays a sound from anims.j2a at pixel xPixel, yPixel. Possible values for sample are listed in the appendix at the bottom of this file.\nvolume ranges from 1-63, and 0 will default to 63. Higher values of frequency result in higher frequencies, or leaving it at 0 will use the sample's unique default frequency.\n", "full": "void jjSample(float xPixel, float yPixel, SOUND::Sample sample, int volume = 63, int frequency = 0)", "type": "function"}, {"name": "jjSampleIsLoaded", "description": "Returns whether sample is loaded or not.\n", "full": "bool jjSampleIsLoaded(SOUND::Sample sample)", "type": "function"}, {"name": "jjSampleLoad", "description": "Attempts to load sample from a .wav or .ogg file filename and returns true on success or false otherwise. If there is already a loaded sample corresponding to this SOUND::Sample constant, it will be overwritten. JJ2 assumes samples are mono and will not correctly play stereo samples, so for the best results, only use mono files.\n", "full": "bool jjSampleLoad(SOUND::Sample sample, string &in filename)", "type": "function"}, {"name": "jjSampleLooped", "description": "Plays a looped sound from anims.j2a at pixel xPixel, yPixel. For every source of sound (e.g. a jjOBJ instance), channel should be 0 on the first call and in later calls should be replaced with the value returned from the previous call of this function.\nvolume ranges from 1-63, and 0 will default to 63. Higher values of frequency result in higher frequencies, or leaving it at 0 will use the sample's unique default frequency.\n", "full": "int jjSampleLooped(float xPixel, float yPixel, SOUND::Sample sample, int channel, int volume = 63, int frequency = 0)", "type": "function"}, {"name": "jjSamplePriority", "description": "Plays a sound from anims.j2a, no matter what any local players' positions are. This is the function used to play the sugar rush jingle. Possible values for sample are listed in the appendix at the bottom of this file.\n", "full": "void jjSamplePriority(SOUND::Sample sample)", "type": "function"}, {"name": "jjSendPacket", "description": "Sends packet from client to server (in case if you're a client) or from server to client (in case if you're a server). Returns true on success and false on failure. If toClientID is a positive value, the packet will be sent only to the client with the appropriate jjPLAYER::clientID. If it's negative, it will be sent to all clients with the exception of the one indicated by toClientID. Using the default value of 0 results in sending the packet to all clients. For a script to receive packet, you will need to declare an onReceive hook, which has the following signature:\n\t\t\tvoid onReceive(jjSTREAM &in packet, int fromClientID)\n\t\t\tNotice that packets can't be sent between two clients but only between the server and a client; if the function is called client-side, the toClientID argument is completely ignored. If a client is meant to send a packet to another client, they have to send the packet to the server first and the server should resend it to the other client from onReceive.\nIf there are multiple distinct script modules running (two or more mutators, or one mutator and a level's primary script), the packet will only be received by the module whose jjScriptModuleID global value matches the toScriptModuleID parameter. By leaving this parameter as the default value, you can ensure that a packet sent from foo.j2mut will always be read by (the onReceive hook defined in) foo.j2mut, rather than another, simultaneously running module that wouldn't know what to do with the data. Passing 0 instead will send the packet to the level's primary script (if any), and is rarely a good idea. Other values are even more rarely a good idea.\n", "full": "bool jjSendPacket(jjSTREAM &in packet, int toClientID = 0, uint toScriptModuleID = jjScriptModuleID)", "type": "function"}, {"name": "jjSetDarknessColor", "description": "Sets the color of darkness used with ambient lighting.\n", "full": "void jjSetDarknessColor(jjPALCOLOR color = jjPALCOLOR(0, 0, 0))", "type": "function"}, {"name": "jjSetFadeColors", "description": "Sets the fade colors of the level's textured background, as seen in the Layer properties window for layer 8 in JCS. Has no effect if there is no textured background on layer 8.\nExactly equivalent to jjLayers[8].setFadeColor(color).\nA simpler one (or zero!) parameter version of the function also exists to set the fade colors to the same RGB values as used by one of the entries in jjPalette. This defaults to 207, which is the last color of the most common textured background gradient and thus, not infrequently, the fade color used in 8-bit color.\n", "full": "void jjSetFadeColors(uint8 red, uint8 green, uint8 blue)", "type": "function"}, {"name": "jjSetFadeColors", "description": "Sets the fade colors of the level's textured background, as seen in the Layer properties window for layer 8 in JCS. Has no effect if there is no textured background on layer 8.\nExactly equivalent to jjLayers[8].setFadeColor(color).\nA simpler one (or zero!) parameter version of the function also exists to set the fade colors to the same RGB values as used by one of the entries in jjPalette. This defaults to 207, which is the last color of the most common textured background gradient and thus, not infrequently, the fade color used in 8-bit color.\n", "full": "void jjSetFadeColors(jjPALCOLOR color)", "type": "function"}, {"name": "jjSetFadeColors", "description": "Sets the fade colors of the level's textured background, as seen in the Layer properties window for layer 8 in JCS. Has no effect if there is no textured background on layer 8.\nExactly equivalent to jjLayers[8].setFadeColor(color).\nA simpler one (or zero!) parameter version of the function also exists to set the fade colors to the same RGB values as used by one of the entries in jjPalette. This defaults to 207, which is the last color of the most common textured background gradient and thus, not infrequently, the fade color used in 8-bit color.\n", "full": "void jjSetFadeColors(uint8 paletteColorID = 207)", "type": "function"}, {"name": "jjSetLayerXSpeed", "description": "Shortcut global functions for setXSpeed and setYSpeed on the same-indexed jjLayers objects.\n", "full": "void jjSetLayerXSpeed(uint8 layerID, float newspeed, bool newSpeedIsAnAutoSpeed)", "type": "function"}, {"name": "jjSetLayerYSpeed", "description": "Shortcut global functions for setXSpeed and setYSpeed on the same-indexed jjLayers objects.\n", "full": "void jjSetLayerYSpeed(uint8 layerID, float newspeed, bool newSpeedIsAnAutoSpeed)", "type": "function"}, {"name": "jjSetModPosition", "description": "Jumps to a specific row of a specific order in the currently playing module file. If reset is true, also stops all notes and resets the module's global volume, tempo, etc. to their original values.\nCalling this function with an invalid order or row number, or while BASS is not playing a module file, will have no effect.\n", "full": "void jjSetModPosition(int order, int row, bool reset)", "type": "function"}, {"name": "jjSetModSpeed", "description": "Sets the \"speed\" of the currently playing module music file. Does nothing if BASS is not currently playing a module file. Note that the module may change its own speed, overwriting your change.\n", "full": "void jjSetModSpeed(uint8 speed)", "type": "function"}, {"name": "jjSetModTempo", "description": "Sets the tempo of the currently playing module music file. Does nothing if BASS is not currently playing a module file. Note that the module may change its own tempo, overwriting your change.\n", "full": "void jjSetModTempo(uint8 tempo)", "type": "function"}, {"name": "jjSetWaterGradient", "description": "Changes the colors used by water in 16-bit color. If no parameters are included, the gradient will be generated from palette entries 176 and 207 instead, the most typical textured background colors (and most of the colors used by 8-bit water).\n", "full": "void jjSetWaterGradient(uint8 red1, uint8 green1, uint8 blue1, uint8 red2, uint8 green2, uint8 blue2)", "type": "function"}, {"name": "jjSetWaterGradient", "description": "Changes the colors used by water in 16-bit color. If no parameters are included, the gradient will be generated from palette entries 176 and 207 instead, the most typical textured background colors (and most of the colors used by 8-bit water).\n", "full": "void jjSetWaterGradient(jjPALCOLOR color1, jjPALCOLOR color2)", "type": "function"}, {"name": "jjSetWaterGradient", "description": "Changes the colors used by water in 16-bit color. If no parameters are included, the gradient will be generated from palette entries 176 and 207 instead, the most typical textured background colors (and most of the colors used by 8-bit water).\n", "full": "void jjSetWaterGradient()", "type": "function"}, {"name": "jjSetWaterLevel", "description": "Sets jjWaterTarget to yPixel. If instant is true, jjWaterLevel will also be set to yPixel; otherwise, it will move slowly up or down from its current height until it reaches its new target.\nCaution: this function is not identical to the Water Level event in JCS. The event measures in tiles, but this function measures in pixels. Multiply by thirty-two to get the same effect.\n", "full": "void jjSetWaterLevel(float yPixel, bool instant)", "type": "function"}, {"name": "jjSin", "description": "Returns the sine of angle with a range of 0.0-1.0 and a domain of 0-1023. Numbers outside the domain will be seemlessly moduloed. This is the sine function used by JJ2 for spinning platforms and the like, though you may prefer AngelScript's native sin function.\n", "full": "float jjSin(uint angle)", "type": "function"}, {"name": "jjSlideModChannelVolume", "description": "In currently playing module music, slide the volume of channel to volume over a chosen number of milliseconds. Does nothing if BASS is not currently playing a module file or channel does not exist. volume is 1.0 for the module's channel volume, 0.0 for silent. If you give a higher or lower value, the slide will stop when it reaches one of these boundaries. Volume slides continue while the music is paused. If you begin sliding the volume of a channel that is already sliding, the old slide will immediately stop.\n", "full": "void jjSlideModChannelVolume(int channel, float volume, int milliseconds)", "type": "function"}, {"name": "jjSpriteModeFirstFreeMapping", "description": "Returns the minimum index from the range 0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd255 such that jjSpriteModeIsMappingUsed(index) is false, or -1 if none exist.\n", "full": "int jjSpriteModeFirstFreeMapping()", "type": "function"}, {"name": "jjSpriteModeGetColorMapping", "description": "Returns a copy of the mapping provided as the rgbMapping argument during the most recent call to jjSpriteModeSetMapping with the same value of index. If the most recent call didn't provide the rgbMapping argument, instead the indexMapping argument is used in conjunction with jjPalette to determine the result. The returned handle is never null\u00c3\u00af\u00c2\u00bf\u00c2\u00bdeven if the mapping corresponding to index is unused, the returned handle is still a valid palette but all its colors are black.\n", "full": "jjPAL@ jjSpriteModeGetColorMapping(uint8 index)", "type": "function"}, {"name": "jjSpriteModeGetIndexMapping", "description": "Returns a copy of the mapping provided as the indexMapping argument during the most recent call to jjSpriteModeSetMapping with the same value of index. The returned handle is never null and the array it holds is always of size 256. If the mapping corresponding to index is unused, all elements of the array will be 0.\n", "full": "array<uint8>@ jjSpriteModeGetIndexMapping(uint8 index)", "type": "function"}, {"name": "jjSpriteModeIsMappingUsed", "description": "Returns whether a mapping with the given index (as used by SPRITE::MAPPING and SPRITE::TRANSLUCENTMAPPING) has been previously successfully registered with use of jjSpriteModeSetMapping.\n", "full": "bool jjSpriteModeIsMappingUsed(uint8 index)", "type": "function"}, {"name": "jjSpriteModeSetMapping", "description": "Sets a mapping with the given index (as used by SPRITE::MAPPING and SPRITE::TRANSLUCENTMAPPING) to the provided values. indexMapping will be used in 8-bit color mode. If it is shorter than 256 elements, it will be padded with values corresponding to their indices (i.e., if an empty array is provided, the corresponding SPRITE::MAPPING will act exactly like SPRITE::NORMAL in 8-bit color mode). rgbMapping, if provided, will be used in 16-bit color mode, ignoring the level's palette\u00c3\u00af\u00c2\u00bf\u00c2\u00bdotherwise indexMapping will be used, to the same effect as in 8-bit color mode.\n", "full": "void jjSpriteModeSetMapping(uint8 index, const array<uint8> &in indexMapping, const jjPAL &in rgbMapping)", "type": "function"}, {"name": "jjSpriteModeSetMapping", "description": "Sets a mapping with the given index (as used by SPRITE::MAPPING and SPRITE::TRANSLUCENTMAPPING) to the provided values. indexMapping will be used in 8-bit color mode. If it is shorter than 256 elements, it will be padded with values corresponding to their indices (i.e., if an empty array is provided, the corresponding SPRITE::MAPPING will act exactly like SPRITE::NORMAL in 8-bit color mode). rgbMapping, if provided, will be used in 16-bit color mode, ignoring the level's palette\u00c3\u00af\u00c2\u00bf\u00c2\u00bdotherwise indexMapping will be used, to the same effect as in 8-bit color mode.\n", "full": "void jjSpriteModeSetMapping(uint8 index, const array<uint8> &in indexMapping)", "type": "function"}, {"name": "jjSpy", "description": "Prints text to the game's built-in spy window activated by running it with the -spy command line parameter, and also writes it to your jazz2.log file.\n", "full": "void jjSpy(const string &in text)", "type": "function"}, {"name": "jjSwitchTrigger", "description": "Toggles jjTriggers[id] from true to false, or vice versa, like the \"switch\" parameter on the Trigger Zone and Trigger Crate events.\n", "full": "bool jjSwitchTrigger(uint8 id)", "type": "function"}, {"name": "jjTakeScreenshot", "description": "Takes a screenshot of the game as if F12 was pressed. Returns true if the screenshot request was successfully handled without being dismissed by timing or other restrictions, otherwise returns false.\nThe optional parameter filename can be used to define a custom filename for the screenshot file to be saved. When a custom filename is passed as a parameter, the .png suffix can be omitted, since the suffix will be always ensured. Omitting the custom filename parameter or defining it as an empty string will make the game use the default pattern for screenshot filenames, like Jazz2-[level_filename]-001.png, etc.\nNote that this feature has restrictions on how often it can be used effectively. Calling it more often than once a second won't do anything and will cause the function to return false, as an indicator that the call to take a screenshot was dismissed. There is also a one second delay for using this function successfully after the user presses F12. This is due to the possibility of this feature being able to fill up available diskspace on the calling machine rapidly (and making the game too sluggish to play anyway).\nNote that this feature may only be used to save screenshots into the folder running JJ2 itself. Also, to avoid conflict with system reserved filenames, etc. all custom filenames receive an enforced prefix in their filename as Jazz2_as-, which also helps to differentiate custom screenshot filenames from the default ones (Jazz2-).\nNote that only legal characters for filenames may be used in the custom screenshot filenames to ensure their integrity. Using any illegal characters in the filename will result in the screenshot saving to fail and making this function return false.\n", "full": "bool jjTakeScreenshot(const string &in filename = \"\")", "type": "function"}, {"name": "jjTileGet", "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n", "full": "uint16 jjTileGet(uint8 layer, int xTile, int yTile)", "type": "function"}, {"name": "jjTileSet", "description": "Shortcut global functions for the same-named jjLAYER methods on the same-indexed jjLayers objects.\n", "full": "uint16 jjTileSet(uint8 layer, int xTile, int yTile, uint16 newTile)", "type": "function"}, {"name": "jjTilesFromTileset", "description": "Opens the tileset filename, extracts tileCount tiles from it starting at tile ID firstTileID, and appends them to the end of the currently loaded tileset, increasing jjTileCount by tileCount. If paletteColorMapping is not null and is of length 256 or greater, it will be used to recolor the imported tiles in a way that better fits the palette you are currently using, e.g. pixels of color 10 will be changed to paletteColorMapping[10] instead. Returns false upon various reasons for failure.\njjTilesFromTileset is primarily intended to be combined with jjLayersFromLevel and jjLayerOrderSet, and the three should ideally be called in that order, so that jjLayersFromLevel has the right tiles to use in its new layers. Here is a sample script that imports the background pillars from Dungeon Dilemma (into any level using any tileset) and recolors them to use colors from the textured background:\n\t\t\tvoid onLevelLoad() {\n\tconst int oldTileCount = jjTileCount; //the number of tiles in the level's tileset before jjTilesFromTileset increases the number\n\tarray<uint8> pillarColorMapping(256);\n\tfor (int i = 0; i < 16; ++i)\n\t\tpillarColorMapping[i + 128] = i + 192; //map pillars' colors (stored in palette indices 128 through 143) to the (second row of) textured background colors\n\tjjTilesFromTileset( //appends tiles to the end of the internal copy of the tileset used by the current level\n\t\t\"Castle1.j2t\", //filename to take tiles from\n\t\t420, //first tile ID in tileset to take\n\t\t60, //number of tiles to take\n\t\tpillarColorMapping //an array<uint8>(256) that maps colors in the source tileset to colors in the destination tileset, here only working on a single 16-color gradient because that's all that is used in those particular two layers\n\t);\n\tarray<jjLAYER@> castleLayers = jjLayersFromLevel( //builds new jjLAYER instances from the layers defined in this level\n\t\t\"Castle1.j2l\", //filename to take layers from\n\t\tarray<uint> = {5,6}, //which layers to grab\n\t\toldTileCount - 420 //a number to offset the non-zero tileIDs by: the pillars started at tile 420 in castle1.j2t, but here start at the end of the old tileset, aka oldTileCount\n\t);\n\tjjLayerOrderSet(array<jjLAYER@> = {jjLayers[1], jjLayers[2], jjLayers[3], jjLayers[4], castleLayers[0], castleLayers[1], jjLayers[5], jjLayers[6], jjLayers[7], jjLayers[8]}); //insert the two layers from castle1.j2l between Layer 4 and Layer 5\n}\n", "full": "bool jjTilesFromTileset(const string &in filename, uint firstTileID, uint tileCount, const array<uint8>@ paletteColorMapping = null)", "type": "function"}, {"name": "jjTriggerRock", "description": "Activates all Rotating Rock events with the \"RockID\" parameter set to id, exactly like the Trigger Rock event.\n", "full": "void jjTriggerRock(uint8 id)", "type": "function"}, {"name": "jjUnixTimeMs", "description": "Returns unix time in milliseconds, i.e. the number of milliseconds that have elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.\n", "full": "uint64 jjUnixTimeMs()", "type": "function"}, {"name": "jjUnixTimeSec", "description": "Returns unix time in seconds, i.e. the number of seconds that have elapsed since 00:00:00 UTC, Thursday, 1 January 1970, not counting leap seconds.\n", "full": "uint64 jjUnixTimeSec()", "type": "function"}, {"name": "jjUpdateTexturedBG", "description": "Forces JJ2+ to reconstruct the textured background from its relevant properties. This should be handled automatically now.\n", "full": "void jjUpdateTexturedBG()", "type": "function"}, {"name": "jjZlibCompress", "description": "Compresses data in input using the zlib library. The compression result is placed into output. Returns whether successful, which should almost always be true.\n", "full": "bool jjZlibCompress(const jjSTREAM &in input, jjSTREAM &out output)", "type": "function"}, {"name": "jjZlibUncompress", "description": "Attempts to uncompresses data in input using the zlib library. The decompression result is placed into output. For successful decompression, size must be at least the same value as the amount of bytes of the predicted output. Returns whether successful. The function can fail if input is not a valid compressed stream or size is too small to accomodate the output or too large to allocate memory required for performing the operation, as well as, rarely, for other reasons.\n", "full": "bool jjZlibUncompress(const jjSTREAM &in input, jjSTREAM &out output, uint size)", "type": "function"}], "jjPLAYERList": [{"name": "alreadyDoubleJumped", "description": "Whether it is currently impossible for the player to double jump, assuming they're Spaz and currently in the air. To allow compatibility with multiple air jumps, this was replaced with doubleJumpCount.\n", "full": "bool alreadyDoubleJumped", "type": "property"}, {"name": "ammo", "description": "How much ammo the player has of each ammo type. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their allowed properties to true in the jjWeapons array.\n", "full": "int ammo[WEAPON::Weapon]", "type": "property"}, {"name": "ammo", "description": "How much ammo the player has of each ammo type. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of weapons without corresponding +3/+15/powerup events in the level while in online servers. To remedy this, hide some such ammo-providing event somewhere in the level, or else set their allowed properties to true in the jjWeapons array.\n", "full": "int ammo[9]", "type": "property"}, {"name": "antiGrav", "description": "Whether the player falls up (true) or down (false). Also causes the player to be drawn upside-down.\n(For the record, this mode is still a work-in-progress. A handful of objects\u00c3\u00af\u00c2\u00bf\u00c2\u00bdbridges, pinball flippers, and rotating poles\u00c3\u00af\u00c2\u00bf\u00c2\u00bddon't work very well with it yet. However, future revisions will be backwards compatible with what works already, so don't hold off on using it for that reason unless it truly can't do yet what you need it do.)\n", "full": "bool antiGrav", "type": "property"}, {"name": "ballTime", "description": "If greater than 0, how much longer (in ticks) the player will be tucked into a ball.\n", "full": "int ballTime", "type": "property"}, {"name": "blink", "description": "If greater than 0, how much longer (in ticks) the player will be blinking and invincible and unable to collide with other players, as if recently hurt. Works online.\n", "full": "int blink", "type": "property"}, {"name": "boss", "description": "The object ID of the jjOBJ whose energy is shown in the boss health meter, or -1 if the health meter is receding off the top of the screen, or 0 if the player is not fighting any boss.\nMore specifically, the boss health meter will show the energy of the jjOBJ as a percentage of its initial health as described in its entry in jjObjectPresets. If you create a Tuf Turtle enemy, give it 100 health, and assign a jjPLAYER's boss its object ID, JJ2 will still assume the Tuf Turtle started out at 4 health, not 100. On the other hand, if you write jjObjectPresets[OBJECT::TUFTURT].energy = 100; first, then the boss health meter will work as you might want it to.\n", "full": "int boss", "type": "property"}, {"name": "bossActivated", "description": "The bool set by the Activate Boss event or the activateBoss method. In general, you should make sure this property is true for at least one local player when writing behaviors for custom bosses.\n", "full": "bool bossActivated", "type": "property"}, {"name": "buttstomp", "description": "Buttstomp phase. Values below 41 mean the player is initializing a buttstomp, 41 means the player is currently buttstomping, values between 41 and 121 mean the player is landing on the ground and values of 121 and higher mean the player is not currently buttstomping.\n", "full": "int buttstomp", "type": "property"}, {"name": "cameraX", "description": "The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n", "full": "const float cameraX", "type": "property"}, {"name": "cameraY", "description": "The top left corner of the player's current view of the level, as measured from the top left corner of layer 4.\n", "full": "const float cameraY", "type": "property"}, {"name": "charCurr", "description": "The player's current character (CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2). This is a read-only value, because you should use morphTo or another related method to change it instead.\n", "full": "const CHAR::Char charCurr", "type": "property"}, {"name": "charOrig", "description": "Which character the player began the level as (CHAR::JAZZ, CHAR::SPAZ, or CHAR::LORI), aka the character that the Revert Morph event switches them to.\n", "full": "CHAR::Char charOrig", "type": "property"}, {"name": "clientID", "description": "ID of the game instance controlling the player. This is particularly useful for packet exchange with use of jjSendPacket but can also be used to determine whether players are splitscreeners.\n", "full": "const int clientID", "type": "property"}, {"name": "coins", "description": "How many coins the player has.\nIf you want to require the player to have a certain number of coins to do something, like with coin warps, consider using the more elaborate testForCoins method instead.\n", "full": "int coins", "type": "property"}, {"name": "curAnim", "description": "The current animation the player takes its frames from, serving as an index to the jjAnimations array. Each animation has a distinct value; for example, Jazz standing in place might be 81, but Spaz standing in place might be 185.\n", "full": "const uint16 curAnim", "type": "property"}, {"name": "curFrame", "description": "The overall current frame displayed to the screen to represent this player, serving as an index to the jjAnimFrames array. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n", "full": "const uint curFrame", "type": "property"}, {"name": "currTile", "description": "A shortcut value, always equalling int(xPos)/32 + int(yPos)/32*65536. Since both xPos and yPos are easily accessible properties, it really only makes sense to use currTile to compare against previous values of currTile, i.e. to see if the player has moved or not.\n", "full": "const int currTile", "type": "property"}, {"name": "currWeapon", "description": "Which ammo type the player currently has selected. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\n", "full": "uint8 currWeapon", "type": "property"}, {"name": "deaths", "description": "In competitive game modes, the number of deaths the player experienced or a negative value if unknown (this is currently the case when the property is checked by clients in XLRS mode).\n", "full": "const int deaths", "type": "property"}, {"name": "direction", "description": "Which direction the player is facing. Negative values mean left and non-negative ones mean right.\n", "full": "int8 direction", "type": "property"}, {"name": "doubleJumpCount", "description": "How many times the player used double jump in the air since their last regular jump.\n", "full": "int doubleJumpCount", "type": "property"}, {"name": "fastfire", "description": "The waiting time between shots, as decreased by Fastfire events or the JJFIRE cheat code. Starts out at 35\u00c3\u00af\u00c2\u00bf\u00c2\u00bdhalf a second\u00c3\u00af\u00c2\u00bf\u00c2\u00bdand decreases to a minimum of 6 (from Fastfire events) or 1 (JJFIRE).\n", "full": "int fastfire", "type": "property"}, {"name": "flag", "description": "The object ID of the flag the player is carrying, or 0 if the player is not carrying a flag.\n", "full": "const int flag", "type": "property"}, {"name": "fly", "description": "Possible special constant values are FLIGHT::NONE, FLIGHT::FLYCARROT, or FLIGHT::AIRBOARD, from the FLIGHT::Mode enum.\nIf the player is currently using a copter or Cheshire2 object, fly will equal the object ID of that object plus one, which is to say, the jjOBJ the player is holding will be jjObjects[p.fly - 1].\n", "full": "int fly", "type": "property"}, {"name": "food", "description": "How much food the player has eaten.\nSetting this to 100 will not cause a sugar rush. Use the startSugarRush method instead.\n", "full": "int food", "type": "property"}, {"name": "frameID", "description": "The index of the current frame displayed to the screen to represent this player within its animation. For example, Jazz's standing animation is only one frame long, so his frameID will always equal 0 while playing that animation, while Spaz's will range from 0 to 4. For any given jjPLAYER@ p, p.curFrame will equal jjAnimations[p.curAnim].firstFrame + p.frameID.\n", "full": "const uint8 frameID", "type": "property"}, {"name": "frozen", "description": "0 if unfrozen; otherwise, constantly counts down towards 0.\n", "full": "int8 frozen", "type": "property"}, {"name": "fur", "description": "Palette indexes of the player's fur in the form of 4 colors, 8 bits each. For potentially more intuitive ways of fur color manipulation refer to jjPLAYER methods furGet and furSet. Changes to this setting are automatically shared between all clients in the server. Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n", "full": "uint32 fur", "type": "property"}, {"name": "gems", "description": "How many gems the player has collected. Possible values of GEM::Color are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n", "full": "int gems[GEM::Color]", "type": "property"}, {"name": "health", "description": "How many hearts the player has remaining. If you set this in an online server, all other players will be notified of the change.\n", "full": "uint8 health", "type": "property"}, {"name": "helicopter", "description": "The amount of time in which player's copter ears will run out or 0 if the player is currently not using copter ears.\n", "full": "int helicopter", "type": "property"}, {"name": "helicopterElapsed", "description": "The amount of time player spent using copter ears since their last jump. If this reaches or exceeds their respective jjCHARACTER::helicopterDurationMax, the player will be unable to use helicopter ears again until they have landed, analogous to using up a double jump.\n", "full": "int helicopterElapsed", "type": "property"}, {"name": "idle", "description": "The amount of time since the last change of idle animation or 0 if the player is not idle.\n", "full": "int idle", "type": "property"}, {"name": "invincibility", "description": "How much longer the player will be invincible. (Does not work in servers.) Specifically, the absolute value is the remaining duration of the invincibility; a positive number will display the invincibility effect around the player, but a negative number (or zero) will not.\n", "full": "int invincibility", "type": "property"}, {"name": "invisibility", "description": "Whether the player is invisible. Invisible players don't have their sprites or names drawn. Changes to this setting are automatically shared between all clients in the server.\n", "full": "bool invisibility", "type": "property"}, {"name": "isActive", "description": "Does this jjPLAYER object correspond to an actual player in the server, local or otherwise? If not, few if any of this jjPLAYER's other properties will be reliable. This is a fairly weak check and equals true for several types of players who may be present in the server but not actually playing\u00c3\u00af\u00c2\u00bf\u00c2\u00bdisInGame may often be more useful.\n", "full": "const bool isActive", "type": "property"}, {"name": "isAdmin", "description": "Whether the player is logged in as a Remote Admin in the current online server. Because admin privileges can vastly differ depending on server and admin group, a more precise tool hasPrivilege exists.\n", "full": "const bool isAdmin", "type": "property"}, {"name": "isConnecting", "description": "Whether the player is a client who has not finished joining the current online server yet, as represented by a \"C\" or \"D\" (if downloading) next to their name on the player list.\n", "full": "const bool isConnecting", "type": "property"}, {"name": "isIdle", "description": "Whether the player is idle and does not appear in the level or player list. Currently this can only ever be true of the server.\n", "full": "const bool isIdle", "type": "property"}, {"name": "isInGame", "description": "Equals true if isActive is true but isConnecting, isIdle, isOut, and isSpectating are all false. If more such properties need to be added in future revisions of JJ2+, isInGame will be updated to reflect them.\n", "full": "const bool isInGame", "type": "property"}, {"name": "isJailed", "description": "In Jailbreak game mode, whether the player is currently in jail. False in all other game modes.\n", "full": "const bool isJailed", "type": "property"}, {"name": "isLocal", "description": "Is this jjPLAYER object controlled by this instance of JJ2?\n", "full": "const bool isLocal", "type": "property"}, {"name": "isOut", "description": "Equals true if the player has lost all their lives (or joined too late) in an LRS-based gamemode.\n", "full": "const bool isOut", "type": "property"}, {"name": "isSpectating", "description": "Equals true if the player is spectating normally, i.e. not forced into spectating by being out or an idle server.\n", "full": "const bool isSpectating", "type": "property"}, {"name": "isZombie", "description": "In Pestilence game mode, whether the player is currently a zombie. False in all other game modes.\n", "full": "const bool isZombie", "type": "property"}, {"name": "jumpStrength", "description": "Vertical speed gained by the player on jump. Defaults to -10.\n", "full": "float jumpStrength", "type": "property"}, {"name": "keyDown", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyDown", "type": "property"}, {"name": "keyFire", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyFire", "type": "property"}, {"name": "keyJump", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyJump", "type": "property"}, {"name": "keyLeft", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyLeft", "type": "property"}, {"name": "keyRight", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyRight", "type": "property"}, {"name": "keyRun", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyRun", "type": "property"}, {"name": "keySelect", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keySelect", "type": "property"}, {"name": "keyUp", "description": "A series of bools controlling whether the player believes its various control keys are being pressed. Note that always setting keyFire to true is not the same as making the player constantly fire, unless their fastfire property equals 1.\n", "full": "bool keyUp", "type": "property"}, {"name": "laps", "description": "In Race, the number of laps the player has completed so far. 0 for other modes.\n", "full": "const int laps", "type": "property"}, {"name": "lapTimeBest", "description": "In Race, how many ticks it took for this player to run their fastest lap so far. Note that because lapTimes only counts the five most recent laps, lapTimeBest will not appear in that array if this player's fastest lap was not one of their five most recent laps. Undefined for other modes or if laps is still 0.\n", "full": "const int lapTimeBest", "type": "property"}, {"name": "lapTimeCurrent", "description": "In Race, how many ticks have elapsed since the player began their current lap. Undefined for other modes.\n", "full": "const int lapTimeCurrent", "type": "property"}, {"name": "lapTimes", "description": "In Race, how many ticks it took for this player to run the five most recent laps they completed, where lapTimes[0] is the length of the most recent lap and lapTimes[4] the fifth most recent. If the player has not completed a given lap yet\u00c3\u00af\u00c2\u00bf\u00c2\u00bdi.e. if the index used for the lapTimes array is greater or equal to laps\u00c3\u00af\u00c2\u00bf\u00c2\u00bdthe value will be -1. Undefined for other modes or for players for whom isLocal is false.\n", "full": "const int lapTimes[5]", "type": "property"}, {"name": "light", "description": "The intensity of light emitted by the player. Changes to this setting are automatically shared between all clients in the server.\n", "full": "int8 light", "type": "property"}, {"name": "lighting", "description": "The player's current level of ambient lighting, as affected by the Set Light and Reset Light events.\n", "full": "uint8 lighting", "type": "property"}, {"name": "lightType", "description": "The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER (default). Changes to this setting are automatically shared between all clients in the server.\n", "full": "LIGHT::Type lightType", "type": "property"}, {"name": "lives", "description": "In single player or cooperative mode, how many lives the player has remaining. For LRS-based game modes use lrsLives instead. Lives are not displayed in the HUD when jjGameConnection != GAME::LOCAL, but this number still goes up and down as appropriate, even into the negatives; it's just that it has no effect on gameplay.\n", "full": "int lives", "type": "property"}, {"name": "localPlayerID", "description": "Which local player the player is, in case of splitscreen. 0-3.\n", "full": "const int localPlayerID", "type": "property"}, {"name": "lrsLives", "description": "In LRS-based game modes (LRS, TLRS, XLRS), how many lives the player has remaining, a negative value for other modes. For single player and cooperative modes use lives instead.\n", "full": "const int lrsLives", "type": "property"}, {"name": "name", "description": "The player's name. This is a constant property; to change it, you can use the setName method.\n", "full": "const string name", "type": "property"}, {"name": "nameUnformatted", "description": "The player's name in its most basic form, without any | or * characters added or removed for any gamemode-related reasons.\n", "full": "const string nameUnformatted", "type": "property"}, {"name": "noclipMode", "description": "Whether the player is currently in Noclip Mode, as caused by Sucker Tube events with the \"BecomeNoclip\" parameter set to 1. Setting this to true could be dangerous if the level design is not prepared for it.\n", "full": "bool noclipMode", "type": "property"}, {"name": "noFire", "description": "Whether the player is currently allowed to shoot bullets. Hides the default current weapon/ammunition display while true.\n", "full": "bool noFire", "type": "property"}, {"name": "platform", "description": "The object ID of the object the player is currently standing on, or 0 if inapplicable.\n", "full": "int platform", "type": "property"}, {"name": "playerID", "description": "In online play, which number the player is in the server's list of players. 0-31.\n", "full": "const int8 playerID", "type": "property"}, {"name": "powerup", "description": "Whether each ammo type is powered-up or not. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their allowedPowerup properties to true in the jjWeapons array.\n", "full": "bool powerup[WEAPON::Weapon]", "type": "property"}, {"name": "powerup", "description": "Whether each ammo type is powered-up or not. Possible constants appear in the appendix below, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nNote that JJ2+ prevents the use of powered-up weapons without corresponding powerup events in the level while in online servers. To remedy this, hide powerup events somewhere in the level, or else set their allowedPowerup properties to true in the jjWeapons array.\n", "full": "bool powerup[9]", "type": "property"}, {"name": "roasts", "description": "In competitive game modes, how many kills the player made or a negative value if unknown (this is currently the case when the property is checked by clients in RT, LRS, Pestilence and TLRS modes). If the game mode doesn't allow players to kill other players, as is the case in Single Player, Cooperative, Treasure Hunt and Race, this property will always be equal to 0.\n", "full": "const int roasts", "type": "property"}, {"name": "running", "description": "Is the player currently running? Detects the run key, capslock (if there is only one local player), and the /run <on|off> command. Apparently running is set based on keyRun, and then other parts of code query running exclusively.\n", "full": "bool running", "type": "property"}, {"name": "score", "description": "In single player and cooperative modes, the player's current score. JJ2 only increments this in multiples of 50 (or 10 if you count the unpatched Butterfly enemy), but that's up to you.\n", "full": "int score", "type": "property"}, {"name": "scoreDisplayed", "description": "In single player and cooperative modes, the number currently displayed for the player's score. Whenever score increases, scoreDisplayed takes a few moments to catch up to the new value. Unless the level defines an onDrawScore function, in which case this property could mean or do anything.\n", "full": "int scoreDisplayed", "type": "property"}, {"name": "setID", "description": "Which set of animations the player uses, serving as an index to the jjAnimSets array. This is nearly a 1:1 mapping with charCurr, except that the two birds (CHAR::BIRD and CHAR::BIRD2) share a setID.\nThe RABBIT::Anim enum is a version-independent list of all possible animations a rabbit player might use, expressed as indices of animations within the player's anim set. To see if a rabbit player p is currently standing still, for example, you can check if (p.curAnim - jjAnimSets[p.setID].firstAnim == RABBIT::STAND).\n", "full": "const ANIM::Set setID", "type": "property"}, {"name": "shieldTime", "description": "How much longer (in ticks) the player's shield will last, or 0 if the player doesn't have a shield.\n", "full": "int shieldTime", "type": "property"}, {"name": "shieldType", "description": "Which shield the player currently has, assuming the player has a shield at all. In place of numbers, you may also use the dedicated SHIELD::Shield enum, options being NONE, FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. Using values from outside of the range of existing shields may be a reason of incompatibility with future versions of JJ2+ in case more shields are added.\n", "full": "int shieldType", "type": "property"}, {"name": "specialMove", "description": "How long the player has been performing their special move or 0 if the player is currently not using a special move.\n", "full": "int specialMove", "type": "property"}, {"name": "spriteMode", "description": "Sprite mode the player's sprite is drawn in. Possible constants appear in the appendix below. Changes to this setting are automatically shared between all clients in the server.\n", "full": "SPRITE::Mode spriteMode", "type": "property"}, {"name": "spriteParam", "description": "A sprite mode parameter further specifying how the player should be drawn. Changes to this setting are automatically shared between all clients in the server.\n", "full": "uint8 spriteParam", "type": "property"}, {"name": "stoned", "description": "How much longer will the player be stoned, like after touching a smoke ring.\n", "full": "int stoned", "type": "property"}, {"name": "subscreenX", "description": "Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n", "full": "const int subscreenX", "type": "property"}, {"name": "subscreenY", "description": "Where the player's subscreen begins in the window. These will usually equal 0, but playing with more than one local player, in one of the two 3D modes, or both, may produce other numbers. For example, in a level with horizontal splitscreen while playing with Top-And-Bottom 3D, player 2's second subscreen will be drawn with subscreenY equal to 75% of jjResolutionHeight. Note that the \"subscreen\" includes any black borders (as measured by jjBorderHeight and jjBorderWidth), so these properties are not necessarily the top left corner of a visible section of the level.\n", "full": "const int subscreenY", "type": "property"}, {"name": "team", "description": "The player's team in team-based game modes. Possible values are TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n", "full": "const TEAM::Color team", "type": "property"}, {"name": "teamRed", "description": "Incorrectly equals true whenever the player is not on the blue team, i.e. including if they're on green or yellow. Use the property above instead.\n", "full": "const bool teamRed", "type": "property"}, {"name": "timerPersists", "description": "Should dying disable the Player Timer (false) or have no effect on it (true)?\n", "full": "bool timerPersists", "type": "property"}, {"name": "timerState", "description": "The current state of the Player Timer (TIMER::STOPPED, TIMER::STARTED, or TIMER::PAUSED), for comparisons only. Use the corresponding timerStart, timerStop, timerPause, and timerResume methods to set this instead.\n", "full": "const TIMER::State timerState", "type": "property"}, {"name": "timerTime", "description": "How many ticks are left on the Player Timer.\n", "full": "int timerTime", "type": "property"}, {"name": "warpID", "description": "If this number is higher than 0, the player is currently warping, and it will equal the ID of the Warp event plus one, a range of 1-256.\nIt is often wise to make sure this property equals 0 before calling a warp method, lest the player be locked into a constant loop of beginning to warp but never finishing it. Something like if (conditionsForWarping && player.warpID == 0) player.warpToID(25);. Performing this check is however unnecessary for fast warps, or warps triggered by Text events, since that code is only called when the player first enters the tile.\n", "full": "const int warpID", "type": "property"}, {"name": "xAcc", "description": "Horizontal acceleration in pixels per game tick squared, positive or negative.\n", "full": "float xAcc", "type": "property"}, {"name": "xOrg", "description": "If this or yOrg are non-zero, where the player should respawn after death.\n", "full": "float xOrg", "type": "property"}, {"name": "xPos", "description": "Horizontal location in pixels.\n", "full": "float xPos", "type": "property"}, {"name": "xSpeed", "description": "Horizontal speed in pixels per game tick, positive or negative.\n", "full": "float xSpeed", "type": "property"}, {"name": "yAcc", "description": "Vertical acceleration in pixels per game tick squared, positive or negative.\n", "full": "float yAcc", "type": "property"}, {"name": "yOrg", "description": "If this or xOrg are non-zero, where the player should respawn after death.\n", "full": "float yOrg", "type": "property"}, {"name": "yPos", "description": "Vertical location in pixels.\n", "full": "float yPos", "type": "property"}, {"name": "ySpeed", "description": "Vertical speed in pixels per game tick, positive or negative.\n", "full": "float ySpeed", "type": "property"}, {"name": "activateBoss", "description": "Activates all bosses and disables the player's sugar rush if applicable. Unlike the Activate Boss event, does not change the music track. (Use jjMusicLoad for that instead.)\nSetting activate to false will attempt to deactivate bosses, but this mostly only results in the boss health meter going away. The jjPLAYER object's boss is left unchanged unless you change it manually, and bosses do not stop moving around.\n", "full": "void activateBoss(bool activate = true)", "type": "function"}, {"name": "cameraFreeze", "description": "Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n", "full": "void cameraFreeze(float xPixel, float yPixel, bool centered, bool instant)", "type": "function"}, {"name": "cameraFreeze", "description": "Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n", "full": "void cameraFreeze(bool xUnfreeze, float yPixel, bool centered, bool instant)", "type": "function"}, {"name": "cameraFreeze", "description": "Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n", "full": "void cameraFreeze(float xPixel, bool yUnfreeze, bool centered, bool instant)", "type": "function"}, {"name": "cameraFreeze", "description": "Fixes the camera in place, like when encountering a Robot Boss, until the corresponding cameraUnfreeze method is called. If instant is left false, the camera will take roughly half a second to scroll to its target. If centered is left false, the camera will position itself so that xPixel,yPixel is in the top left corner of the screen; otherwise, that position will be in the very center. In overloads containing xUnfreeze or yUnfreeze, their values determine whether the corresponding axis should be unfrozen by the function, allowing its free movement (true), or left unaffected (false). In particular, player.cameraFreeze(true, true) is equivalent to player.cameraUnfreeze().\n", "full": "void cameraFreeze(bool xUnfreeze, bool yUnfreeze, bool centered, bool instant)", "type": "function"}, {"name": "cameraUnfreeze", "description": "If cameraFreeze has been called, undoes the effect and lets the camera freely follow the player once again. If instant is left false, the camera will take roughly half a second to scroll to its target.\n", "full": "void cameraUnfreeze(bool instant = true)", "type": "function"}, {"name": "doesCollide", "description": "Returns true if the player's sprite collides with that of the specified object, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables\u00c3\u00af\u00c2\u00bf\u00c2\u00bdincluding playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in\u00c3\u00af\u00c2\u00bf\u00c2\u00bdare taken into account.\n", "full": "bool doesCollide(const jjOBJ@ object, bool always = false) const", "type": "function"}, {"name": "extendInvincibility", "description": "A convenience method to extend the absolute value of the player's invincibility property by the absolute value of the duration parameter, which also makes invincibility positive (visible) if duration is visible. For example, collecting a full energy carrot extends invincibility by +350, whereas buttstomping most enemies extends invincibility by -70.\n", "full": "int extendInvincibility(int duration)", "type": "function"}, {"name": "fireBullet", "description": "Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.\nPossible gun constants may be found in the appendix at the bottom of the page, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nIf depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\n", "full": "int fireBullet(uint8 gun = WEAPON::CURRENT, bool depleteAmmo = true, bool requireAmmo = true, DIRECTION::Dir direction = DIRECTION::CURRENT)", "type": "function"}, {"name": "fireBullet", "description": "Causes the player to fire, using either the specified ammo type or the current one. The return value will be the object ID of the new bullet, unless the weapon fires more than one bullet at a time. This action is visible for all players in an online server.\nPossible gun constants may be found in the appendix at the bottom of the page, or you may use simple 1-indexed numbers instead (all values besides 1-9 will evaluate to WEAPON::CURRENT).\nIf depleteAmmo is false, the method will not affect how much of the ammo type the player has remaining.\nIf requireAmmo is false, the player can fire a bullet of that type even if they don't have any ammo of that type.\nPossible values for direction are DIRECTION::RIGHT, DIRECTION::LEFT, DIRECTION::UP, and DIRECTION::CURRENT. If mouse aiming is enabled, DIRECTION::CURRENT will evaluate to whatever angle the mouse cursor is at, rather than whichever direction the player is physically facing. Alternatively you may pass a float angle argument instead of an orthogonal direction argument, in which case 0 is up, .5 * pi is right, pi is down, 1.5 * pi is left, and 2 * pi is up again.\n", "full": "int fireBullet(uint8 gun, bool depleteAmmo, bool requireAmmo, float angle)", "type": "function"}, {"name": "freeze", "description": "Freezes the player for the same length of time as the Freeze Enemies pickup, or unfreezes the player if frozen is set to false. Helper method.\n", "full": "void freeze(bool frozen = true)", "type": "function"}, {"name": "furGet", "description": "Sets provided parameters' values to palette indexes of the player's fur colors.\n", "full": "void furGet(uint8 &out a, uint8 &out b, uint8 &out c, uint8 &out d) const", "type": "function"}, {"name": "furSet", "description": "Sets player's fur colors to those represented by provided palette indexes. Changes made by this method are automatically shared between all clients in the server.  Clients are not allowed to change the fur colors of non-local players, but servers or local games can change the colors of any player (even if their jjPLAYER::isActive is false), which can be useful for drawing sprites using SPRITE::PLAYER.\n", "full": "void furSet(uint8 a, uint8 b, uint8 c, uint8 d)", "type": "function"}, {"name": "getObjectHitForce", "description": "Returns a value expressing whether the player is currently in a state to harm objects or other players, equivalent to the \"force\" argument in objectHit or the onObjectHit hook/method. Specifically, this method returns -1 if the player is performing a special move and the canHurt property of their respective jjCHARACTER is true, 1 if the player is buttstomping or has a sugar rush, or 0 if none of the above are true. Doesn't work especially well when called on non-local players.\nIf a non-null jjOBJ@ is specified as target, two additional checks will be performed, returning -101 if the object is frozen and the player is running into it really fast, or -1 if the player is a frog (with a true canHurt) hitting the object with its tongue.\n", "full": "int getObjectHitForce(const jjOBJ@ target = null) const", "type": "function"}, {"name": "hasPrivilege", "description": "Checks whether the player has the specified privilege within the script module moduleID. Privileges are specified in the admin configuration file (typically admin.ini) and serve as a way to determine what actions specific admin groups are allowed to take. You can read more about them in the Remote Admin section of the JJ2+ readme.\nBecause privileges are only known to the host, this function will always return false if called client-side. The function will always return false for players who are not logged in, and will always return true if the player is the host or the game is local. If the privilege string contains invalid characters, i.e. anything besides letters, digits, underscores ('_'), full stops ('.'), and hyphens ('-'), or if moduleID is not valid, the function will also return false. In all other cases, i.e. if called server-side for a logged in client and with valid parameters, privileges obtained from the admin configuration file will be tested for a match, and if one is found, the function will return true, otherwise false.\n", "full": "bool hasPrivilege(const string &in privilege, uint moduleID = jjScriptModuleID) const", "type": "function"}, {"name": "hurt", "description": "Attempts to hurt the player damage hearts, or at least strip the player of their bird or reduce their shield time. If attacker is left null, or if it's the same player as the one getting hurt, the injury will be counted as coming from the level, and if a death results, it will be marked online with the \"ate it/you killed yourself\" text. This is what you should do for injuries from enemies and other level-based factors. On the other hand, if the player dies from the hurt call and attacker is another player in the server, that player will get credit for the roast. Returns false if neither the hurtee nor the hurter are local players and the method is not called by the host, or if forceHurt (which bypasses traditional safety sources like the invincibility and blink properties and buttstomping) is false and something or other prevents the hurting from happening.\n", "full": "bool hurt(int8 damage = 1, bool forceHurt = false, jjPLAYER@ attacker = null)", "type": "function"}, {"name": "isEnemy", "description": "Returns true iff victim is a player who can be hurt by this player's bullets or other attacks, according to the rules of the current gamemode. Potentially useful if you are writing a custom weapon behavior and don't want to use HANDLING::PLAYERBULLET.\nThe following conditions will cause this method to return false: the two jjPLAYER objects are the same player; the gamemode is Single Player or Cooperative; in a team-based game, the two players are on the same team and jjFriendlyFire is false; in Roast Tag, Eva's Ring has been captured, yet neither player is jjTokenOwner or jjBottomFeeder; in Pestilence, either both players are zombies or neither are zombies but jjDoZombiesAlreadyExist is false; or in Jailbreak, victim is in jail.\nAgain, this method checks only gamemode-related conditions. (And if more gamemodes are added in the future, this method will be updated to reflect them.) It does not check jjPLAYER::isInGame, jjGameState, or anything that might cause jjPLAYER::hurt to return false if its forceHurt parameter is left false.\n", "full": "bool isEnemy(const jjPLAYER &in victim) const", "type": "function"}, {"name": "kill", "description": "Kills the player instantly. If you want the player to be roasted by some other player in an online server, use hurt with a high damage value instead.\n", "full": "void kill()", "type": "function"}, {"name": "limitXScroll", "description": "Works like a Limit X Scroll event with the corresponding Left and Width parameters. Remember that these are measured in tiles, not pixels.\n", "full": "void limitXScroll(uint16 left, uint16 width)", "type": "function"}, {"name": "morph", "description": "Cycles the player's character to the next on the list, just like the JJMORPH cheat: Jazz-Spaz-(Lori-)Bird-Frog-Bird2. Or if rabbitsOnly is true, skips birds and frog and acts like a morph monitor instead, restricting available morph targets to those whose jjCHARACTER::morphBoxCycle properties equal true. Returns the player's new character: CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI, CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n", "full": "CHAR::Char morph(bool rabbitsOnly = false, bool morphEffect = true)", "type": "function"}, {"name": "morphTo", "description": "Sets the player's character to charNew, possible values CHAR::JAZZ, CHAR::SPAZ, CHAR::LORI (in TSF), CHAR::BIRD, CHAR::FROG or CHAR::BIRD2.\n", "full": "CHAR::Char morphTo(CHAR::Char charNew, bool morphEffect = true)", "type": "function"}, {"name": "objectHit", "description": "Causes the game to think the player is colliding with object target, even if they are not in the same area, and returns true if (generally speaking) the object is affected somehow. Calling this method on a non-local player will return false unless called by the host of a server.\nThe force parameter hints at whether the player should be able to damage the object, if the object can be damaged to begin with. A value of 0 means that the player is simply bumping into the object at random; 1 means a buttstomp or sugar rush; -1 means a special move; and -101 means the object is frozen and the player runs into it really fast. If you want this parameter to reflect reality, get the value from jjPLAYER's getObjectHitForce method.\nThe playerHandling parameter specifies how the player should interact with the object\u00c3\u00af\u00c2\u00bf\u00c2\u00bdfor example, passing HANDLING::PICKUP will force the player to treat the object as a pickup, even if its actual playerHandling property is set to something else. If the value is not HANDLING::ENEMY, HANDLING::SPECIAL, HANDLING::PICKUP, HANDLING::ENEMYBULLET, or HANDLING::PLAYERBULLET, nothing will happen. If the value is one of the first three and the object has scriptedCollisions set to true, some version of onObjectHit will be called with a null bullet argument, this jjPLAYER as player, and whatever force you call this method with as force.\nThe results of this collision will be broadcast to other players in the server exactly as if it had happened naturally through the sprites colliding. For example, collecting a pickup object half the level away will cause other players to see the pickup disappear.\n", "full": "bool objectHit(jjOBJ@ target, int force, HANDLING::Player playerHandling)", "type": "function"}, {"name": "offsetPosition", "description": "Instantly moves the player xPixels pixels to the right and yPixels pixels down. The camera instantly readjusts itself to follow, as does the glowing trace following the player while running and any companion bird the player may have. The best way of creating seamlessly looping levels.\n", "full": "bool offsetPosition(int xPixels, int yPixels)", "type": "function"}, {"name": "poleSpin", "description": "Causes the player to appear to swing around a pole for delay ticks, then launch off at the specified speed/s. For reference, an H-Pole event increases the absolute value of your existing xSpeed by 8 (but not above 20), while a V-Pole event increases the absolute value of your existing ySpeed by 16, with both using the default delay value of 70 ticks (=one second). An H-Pole passes 0 for ySpeed, and a V-Pole passes 0 for xSpeed, but you may use non-orthogonal directions with this method if you'd rather.\n", "full": "void poleSpin(float xSpeed, float ySpeed, uint delay = 70)", "type": "function"}, {"name": "resetLight", "description": "Resets player's ambient lighting value to the level's default.\n", "full": "uint8 resetLight()", "type": "function"}, {"name": "revertMorph", "description": "Reverts the player to the character they were when they began the level, just like the Revert Morph event. If morphEffect is true, displays the default visual effect. Returns the new character (equal to the player's charOrig).\n", "full": "CHAR::Char revertMorph(bool morphEffect = true)", "type": "function"}, {"name": "setName", "description": "Sets the player's name. This method will only succeed if called server-side or in a local game, and it will then return true to indicate success. Otherwise no change will occur and the method will return false.\n", "full": "bool setName(const string &in name)", "type": "function"}, {"name": "setScore", "description": "Sets the player's score. While setting the score through the score property is slightly delayed as scoreDisplayed increases/decreases to catch up to the new value, this function sets both properties at once. Probably most helpful as a function for quickly showing you debug information.\n", "full": "int setScore(int score)", "type": "function"}, {"name": "showText", "description": "Displays text on the player's screen either like a Text event, with the corresponding textID and offset parameters, or simply a specified text. Unique size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use jjHelpStrings instead.\n", "full": "void showText(uint8 textID, uint8 offset, STRING::Size size = STRING::SMALL)", "type": "function"}, {"name": "showText", "description": "Displays text on the player's screen either like a Text event, with the corresponding textID and offset parameters, or simply a specified text. Unique size values are SMALL, MEDIUM, and LARGE. Note that not all glyphs that appear in one size character set may appear in another; for instance, the underscore character is unique to SIZE::SMALL. To access text in help strings with specific ID, use jjHelpStrings instead.\n", "full": "void showText(string text, STRING::Size size = STRING::SMALL)", "type": "function"}, {"name": "spring", "description": "Simulates the player touching and getting bounced by a Spring object. For reference, the absolute values of red, green, and blue springs' speeds are 16, 24, and 32 respectively: for example, an upward-facing red spring uses xSpeed 0 and ySpeed -16.\nThe keepZeroSpeeds argument affects what happens if either speed axis is left at 0, equivalent to the \"Keep X-Speed\" and \"Keep Y-Speed\" event parameters: if keepZeroSpeeds is false, the player's speed on that axis will be set to 0, but if true, it will be left at its value prior to spring being called.\nIf sample is true, a sample will be chosen (from among SOUND::COMMON_SPRING1, SOUND::SPRING_BOING_DOWN, and SOUND::SPRING_SPRING1) and played depending on the xSpeed and ySpeed values, and if the player is Spaz, SOUND::SPAZSOUNDS_YAHOO2 may be played as well.\n", "full": "void spring(float xSpeed, float ySpeed, bool keepZeroSpeeds, bool sample)", "type": "function"}, {"name": "startSugarRush", "description": "Gives the player a sugar rush lasting time ticks, unless their bossActivated property equals true, in which case the method returns false. Otherwise returns true. In online multiplayer, jjSugarRushAllowed should be true for the host, or else clients who call this method may be kicked.\n", "full": "bool startSugarRush(int time = 1400)", "type": "function"}, {"name": "suckerTube", "description": "Simulates the player touching a Sucker Tube event with the same parameter names and values (with noclip referring to \"BecomeNoclip\", not \"Noclip Only\"). For each axis this method instructs the player to move along, the center parameter first puts the player in the center of their current tile on the other axis\u00c3\u00af\u00c2\u00bf\u00c2\u00bdtherefore, passing true is generally safe, but it will get the player stuck if trying to move diagonally every single tick. In normal JJ2, center is true for the first tick the player spends in the tile with the sucker tube event, and false every tick thereafter.\n", "full": "void suckerTube(int xSpeed, int ySpeed, bool center, bool noclip = false, bool trigSample = false)", "type": "function"}, {"name": "testForCoins", "description": "If the player has at least numberOfCoins coins, depletes their coins by numberOfCoins and returns true. Otherwise displays a warning onscreen that they need more coins to continue and returns false. Basically the same as a coin warp event, but you get to choose the result.\n", "full": "bool testForCoins(int numberOfCoins)", "type": "function"}, {"name": "testForGems", "description": "If the player has at least numberOfGems type-colored gems, depletes their type gems by numberOfGems and returns true. Otherwise displays a warning onscreen that they need more gems to continue and returns false. Basically the same as a coin warp event, but you get to choose the result, and it's for gems instead of coins.\nPossible values of type are GEM::RED, GEM::GREEN, GEM::BLUE, and GEM::PURPLE.\n", "full": "bool testForGems(int numberOfGems, GEM::Color type)", "type": "function"}, {"name": "timerFunction", "description": "When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n", "full": "void timerFunction(string functionName)", "type": "function"}, {"name": "timerFunction", "description": "When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n", "full": "void timerFunction(jjVOIDFUNC@ function)", "type": "function"}, {"name": "timerFunction", "description": "When the Player Timer hits zero without being stopped artifically, AngelScript will call the function named by this method (a string is acceptable, but pointing directly to the function is advised instead), setting the (technically optional) jjPLAYER@ property to point to the player whose Player Timer just expired. This defaults to onPlayerTimerEnd, aka void onPlayerTimerEnd(jjPLAYER@). It is up to you to define this function and decide what should happen to the player.\n", "full": "void timerFunction(jjVOIDFUNCPLAYER@ function)", "type": "function"}, {"name": "timerPause", "description": "Pauses the Player Timer and returns TIMER::PAUSED.\n", "full": "TIMER::State timerPause()", "type": "function"}, {"name": "timerResume", "description": "Resumes the Player Timer and returns TIMER::STARTED.\n", "full": "TIMER::State timerResume()", "type": "function"}, {"name": "timerStart", "description": "Begins the Player Timer (and optionally pauses it) with ticks ticks remaining on the clock. Returns TIMER::STARTED or TIMER::PAUSED, depending.\n", "full": "TIMER::State timerStart(int ticks, bool startPaused = false)", "type": "function"}, {"name": "timerStop", "description": "Stops the Player Timer and returns TIMER::STOPPED.\n", "full": "TIMER::State timerStop()", "type": "function"}, {"name": "warpToID", "description": "Warps the player to a Warp Target event with the specified Warp ID, instantly if fast is true or using the standard warp effect if fast is false.\n", "full": "bool warpToID(uint8 warpID, bool fast = false)", "type": "function"}, {"name": "warpToTile", "description": "Warps the player to the specified tile, instantly if fast is true or using the standard warp effect if fast is false.\n", "full": "bool warpToTile(int xTile, int yTile, bool fast = false)", "type": "function"}], "jjOBJList": [{"name": "age", "description": "A variable totally unused by JJ2. The name comes from its original intended purpose as indicating how long had elapsed since the object was created.\n", "full": "int age", "type": "property"}, {"name": "animSpeed", "description": "Intended to determine how fast the object animates. However, only gem rings, speed destruct scenery, and collapse scenery actually use this property for that purpose, and all other non-bullet objects leave it untouched.\nBULLETS: This property stores the amount of damage a bullet does to enemies, e.g. 1 for normal blaster, 2 for normal seekers, or 3 for certain shield bullets.\n", "full": "int animSpeed", "type": "property"}, {"name": "behavior", "description": "Which function is called for this object's behavior. See jjBEHAVIORINTERFACE.\nIn order to avoid common bugs, it's strongly discouraged to modify behavior of objects of eventID OBJECT::GENERATOR, and especially of jjObjectPresets[OBJECT::GENERATOR]. Currently a great portion of game code tests it against BEHAVIOR::GENERATOR and if it doesn't succeed, it may take unexpected actions, typically involving kicking and banning clients for invalid weapons. Similarly, replacing BEHAVIOR::DIAMONDSAREFOREVER is liable to break Treasure Hunt or Head Hunters games.\nReplacing BEHAVIOR::DESTRUCTSCENERY, BEHAVIOR::TRIGGERSCENERY, or BEHAVIOR::SUPERGEM will normally prevent the states of those objects from being shared with newly joining clients in online servers, but this can be circumvented by replacing them with jjBEHAVIORINTERFACE-implementing classes that define onGetActive/onSetActive methods appropriately.\n", "full": "jjBEHAVIOR behavior", "type": "property"}, {"name": "bulletHandling", "description": "What happens when a bullet (or turtle shell, or TNT blast, or attacking bird) comes into contact with this object, assuming that playerHandling is either ENEMY or SPECIAL and state is anything other than KILL?\n\t\t\t\tHURTBYBULLET: If this object has a non-zero energy property, then hitting it will decrease its energy by the force of the bullet. If the object is frozen, it will be unfrozen. If the object's energy sinks to 0 or less, its state will change to STATE::KILL and the player behind the bullet will receive the object's points. Otherwise, its justHit property will be set to 5. The bullet will be destroyed unless it has bit 16 set for its var[6], like fireball bullets do, or if the object has causesRicochet as true. If the object's playerHandling is SPECIAL, other things may happen.\n\t\t\t\tIGNOREBULLET: The object will be unaffected in every way by the collision, and the bullet will not be destroyed.\n\t\t\t\tDESTROYBULLET: The object will be unaffected in every way by the collision, and the bullet will be destroyed no matter what its properties are.\n\t\t\t\tDETECTBULLET: The object is by default unaffected, but the bullet will be destroyed unless it has bit 16 set for its var[6], like fireball bullets do, or if the object has causesRicochet as true. If the object's playerHandling is SPECIAL, other things may happen.\n\t\t\t\n", "full": "HANDLING::Bullet bulletHandling", "type": "property"}, {"name": "causesRicochet", "description": "When true, colliding bullets will ricochet off of this object unless bulletHandling is set to DESTROYBULLET.\n", "full": "bool causesRicochet", "type": "property"}, {"name": "counter", "description": "A general purpose property, usually used for counting up or down to some future event.\n", "full": "int counter", "type": "property"}, {"name": "counterEnd", "description": "A general purpose property, usually used for counting up or down to some future event. Only goes up to 255, so not as versatile as counter.\nBULLETS: how long a bullet will exist before exploding. Used by pretty much every bullet behavior but BEHAVIOR::BOLLYBULLET, although no behavior-external code seems to reference it specifically.\n", "full": "uint8 counterEnd", "type": "property"}, {"name": "creator", "description": "The sum of the creatorID and creatorType properties, which is less useful than you might hope.\n", "full": "int creator", "type": "property"}, {"name": "creatorID", "description": "The object ID or player ID of the object or player that created this object, as usable as the index for jjObjects or jjPlayers. 0 if no creator is actually known.\n", "full": "int creatorID", "type": "property"}, {"name": "creatorType", "description": "CREATOR::OBJECT if the object was created by another object, CREATOR::PLAYER if it was created by a player, or CREATOR::LEVEL if it was added directly from the event map.\nIf the object was created by a Generator object specifically, then creatorType will equal CREATOR::LEVEL, but creatorID will equal the object ID of that Generator object rather than 0.\n", "full": "CREATOR::Type creatorType", "type": "property"}, {"name": "curAnim", "description": "The current animation the object takes its frames from; an index for the jjAnimations array. You can obtain useful values for this from the determineCurAnim method or else any jjANIMSET::firstAnim.\n", "full": "int16 curAnim", "type": "property"}, {"name": "curFrame", "description": "The overall current frame displayed to the screen to represent this object, taking into account both curAnim and frameID; an index for the jjAnimFrames array. You can obtain useful values for this from the determineCurFrame method or else any jjANIMATION::firstFrame.\n", "full": "uint curFrame", "type": "property"}, {"name": "deactivates", "description": "When true, this object will be deleted from memory if the player wanders too far away from it in local single player mode, and all its properties will be reset next time it gets loaded. This property has absolutely no effect in multiplayer, and setting it to false cannot force an object to remain in memory in single player when the player dies.\n", "full": "bool deactivates", "type": "property"}, {"name": "direction", "description": "Which way the object is facing. Generally, direction >= 0 is right and < 0 is left. Some objects may also correctly interpret SPRITE::Direction constants: SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV but the ones involving vertical flip will not be perfectly reliable for objects without custom behavior, except for box objects (crates, barrels, monitors), which will take vertically flipped direction values as a cue to fall upwards instead of downwards.\n", "full": "int8 direction", "type": "property"}, {"name": "doesHurt", "description": "A variable totally unused by JJ2. The name comes from its original intended purpose as specifying whether boss objects could hurt the player.\n", "full": "uint8 doesHurt", "type": "property"}, {"name": "energy", "description": "If this object's playerHandling value is HANDLING::ENEMY, this number is how many more hits the object can take before it is destroyed, unless it equals 0, in which case the object is invincible to bullets (but not to special attacks). This property is also used to determine the fullness of the boss bar.\n", "full": "int8 energy", "type": "property"}, {"name": "eventID", "description": "e.g. 158 for a peach, 43 for a bomb, 243 for an airboard, 1 for a blaster bullet, and so on. Is a uint8 for maximum flexibility, but you should probably set/compare it to OBJECT::Object constants instead most of the time, if for no other reason than readability.\nWhile this value is not strictly constant/read-only, changing it can lead to unpredictable and undesirable effects, since this is the only truly reliable way of knowing what kind of object a given jjOBJ really is, and JJ2 queries it very frequently. The effects can vary from a food pickup playing the wrong sound effect when collected to, say, a red spring simply not working at all when touched. You have been warned.\n", "full": "uint8 eventID", "type": "property"}, {"name": "frameID", "description": "The object's current frame within a single animation set, e.g. which direction the Tube Turtle faces while it rotates in place.\n", "full": "int8 frameID", "type": "property"}, {"name": "freeze", "description": "0 if the object is unfrozen, otherwise counts down to 0 for most behaviors, though you'll need to implement that manually if writing your own.\n", "full": "uint8 freeze", "type": "property"}, {"name": "isActive", "description": "Does this jjOBJ correspond to a real object, or is it just the abandoned memory of one? For any jjOBJ o, (o.isActive) is the same as (o.behavior != BEHAVIOR::INACTIVE), but one is obviously much shorter than the other.\n", "full": "const bool isActive", "type": "property"}, {"name": "isBlastable", "description": "When true, nearby TNT explosions will set this object's xSpeed and ySpeed properties.\n", "full": "bool isBlastable", "type": "property"}, {"name": "isFreezable", "description": "When false, this object will treat ice bullets just the same as any other bullet with the same properties. This is what Caterpillar and Queen do, for example.\n", "full": "bool isFreezable", "type": "property"}, {"name": "isTarget", "description": "When true, this object will be attacked by birds and seeker missiles.\n", "full": "bool isTarget", "type": "property"}, {"name": "justHit", "description": "When this property has a non-zero value, most objects will be drawn as pure white until the property counts back down to 0 one tick at a time. JJ2 deincrements this property for all objects, so you needn't worry about it when defining your own behavior functions.\n", "full": "uint8 justHit", "type": "property"}, {"name": "killAnim", "description": "Which animation the object uses while being destroyed, in the same format as curAnim.\n", "full": "int16 killAnim", "type": "property"}, {"name": "light", "description": "The intensity of the light produced by the object.\n", "full": "int8 light", "type": "property"}, {"name": "lightType", "description": "The type of light produced by the object. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER.\n", "full": "LIGHT::Type lightType", "type": "property"}, {"name": "oldState", "description": "If the object is frozen, what state it was in before it was frozen. Possible constants are listed in the appendix at the end of this file.\n", "full": "STATE::State oldState", "type": "property"}, {"name": "playerHandling", "description": "How does this object interact with the rest of the game, most specifically coming into contact with players, although also bullets?\n\t\t\t\tENEMY: If a player touches this object, they will be hurt (barring invincibility and such), unless they are using a special attack, in which case the object's energy property will decrease by 4. If energy reaches 0 or lower, the object's state will be set to KILL and the player will receive its points. Objects of playerHandling PLAYERBULLET that come into contact with this object have the potential to collide with it, depending on its bulletHandling setting.\n\t\t\t\tPLAYERBULLET: When the object's state is anything but START or EXPLODE, this object will constantly be checked for collision with players other than its creatorID, as well as objects with playerHandling ENEMY, PICKUP, or SPECIAL.\n\t\t\t\tENEMYBULLET: When the object's state is anything but START or EXPLODE, if a player touches this object, they will be hurt (barring invincibility and such).\n\t\t\t\tPARTICLE: Effect unknown (semantic only?)\n\t\t\t\tEXPLOSION: Effect unknown (semantic only?)\n\t\t\t\tPICKUP: If a player touches this object, something special will happen, exactly what depending on its eventID value. Usually if nothing else the player will receive its points, and its behavior will be set to BEHAVIOR::EXPLOSION2, though sometimes (e.g. carrots when touched by a player with full health) nothing will happen at all. If the object has scriptedCollisions set to true, that will override the effect of the eventID value. Should it have 0 xSpeed/ySpeed properties and be overlapped by an object of playerHandling PLAYERBULLET whose state is not START or EXPLODE, the pickup object will partially inherit that bullet object's speed and direction.\n\t\t\t\tDELAYEDPICKUP: Effect unknown (semantic only?)\n\t\t\t\tHURT: Effect unknown (semantic only?)\n\t\t\t\tSPECIAL: Whenever this object is overlapped by a player or an object of playerHandling PLAYERBULLET (depending in the latter case on this object's bulletHandling value), something special will happen, exactly what depending on its eventID value. If the object has scriptedCollisions set to true, that will override the effect of the eventID value.\n\t\t\t\tDYING: Effect unknown (semantic only?)\n\t\t\t\tSPECIALDONE: Effect unknown (semantic only?)\n\t\t\t\tSELFCOLLISION: Effect unknown (semantic only?)\n\t\t\t\n", "full": "HANDLING::Player playerHandling", "type": "property"}, {"name": "points", "description": "How many points a player will gain for destroying the object.\n", "full": "uint16 points", "type": "property"}, {"name": "noHit", "description": "Instead, use the properties bulletHandling, causesRicochet, isFreezable, and isBlastable.\n", "full": "int8 noHit", "type": "property"}, {"name": "objectID", "description": "For all values of n such that n < jjObjectMax, jjObjects[n].objectID == n.\n", "full": "const uint16 objectID", "type": "property"}, {"name": "objType", "description": "Instead, use the properties playerHandling, isTarget, triggersTNT, deactivates, and scriptedCollisions.\n", "full": "uint8 objType", "type": "property"}, {"name": "scriptedCollisions", "description": "When true, JJ2 will call some version of onObjectHit to determine what to do if a bullet or player is detected as having collided with this object. See jjBEHAVIORINTERFACE. This property's effect if playerHandling is anything other than ENEMY, PICKUP, or SPECIAL is presently undefined.\n", "full": "bool scriptedCollisions", "type": "property"}, {"name": "special", "description": "A general-purpose variable, means different things for different objects.\nBULLETS: This property stores the animation (curAnim-style) that is used if the bullet is shot upwards, not horizontally. If this property equals 0, it will not be possible to shoot the bullet upwards except by mouse aiming; this is how shields work.\n", "full": "int special", "type": "property"}, {"name": "state", "description": "The current state of the state machine that is the object. Possible constants are listed in the appendix at the end of this file.\n", "full": "STATE::State state", "type": "property"}, {"name": "triggersTNT", "description": "When true, TNT will explode if this object is nearby.\n", "full": "bool triggersTNT", "type": "property"}, {"name": "var", "description": "A series of general-purpose variables, used for different things by different objects. In general, earlier values are more likely to be used by the game's native behavior functions than later ones.\nBULLETS:\n\t\t\t\tvar[3] represents what ammo type the bullet is, 1-9, which is primarily used for destroying destruct scenery with a non-zero \"Weapon\" parameter.\n\t\t\t\tvar[6] is used as a series of boolean flags that specify how the bullet interacts with various objects: bit 2 for fire-based bullets which can melt springs and burn enemies into fire/smoke particles; bit 4 for the laser shield's laser; bit 8 for bullets that do two damage in multiplayer; and bit 16 for bullets that pass through enemies, like the fireball, rather than explode on impact.\n\t\t\t\tvar[7] is the xSpeed that the player who fired this bullet was moving at when the bullet was fired, reduced to a range of -8\u00c3\u00af\u00c2\u00bf\u00c2\u00bd8... multiplied by 65536. Sorry about that.\n\t\t\t\tvar[9] is a counter for how many times the bullet has ricocheted in its lifetime, beginning at 0.\n\t\t\t\tvar[10] is a counter for how long it's been since the bullet has last ricocheted; each ricochet resets it to 0, but traditional bullet behaviors constantly increment it, and a bullet cannot ricochet if the value is less than 8.\n\t\t\t\n", "full": "int var[11]", "type": "property"}, {"name": "xAcc", "description": "Horizontal acceleration in pixels per game tick squared, positive or negative.\n", "full": "float xAcc", "type": "property"}, {"name": "xOrg", "description": "Original horizontal location in pixels.\n", "full": "float xOrg", "type": "property"}, {"name": "xPos", "description": "Current horizontal location in pixels.\n", "full": "float xPos", "type": "property"}, {"name": "xSpeed", "description": "Horizontal speed in pixels per game tick, positive or negative.\n", "full": "float xSpeed", "type": "property"}, {"name": "yAcc", "description": "Vertical acceleration in pixels per game tick squared, positive or negative.\n", "full": "float yAcc", "type": "property"}, {"name": "yPos", "description": "Current vertical location in pixels.\n", "full": "float yPos", "type": "property"}, {"name": "yOrg", "description": "Original vertical location in pixels.\n", "full": "float yOrg", "type": "property"}, {"name": "ySpeed", "description": "Vertical speed in pixels per game tick, positive or negative.\n", "full": "float ySpeed", "type": "property"}, {"name": "behave", "description": "Causes this jjOBJ to perform the specified jjBEHAVIOR function, or its own behavior property if behavior is set to BEHAVIOR::DEFAULT. If draw is false, it will not draw anything to the screen. See jjBEHAVIORINTERFACE.\n", "full": "void behave(jjBEHAVIOR behavior = BEHAVIOR::DEFAULT, bool draw = true)", "type": "function"}, {"name": "bePlatform", "description": "Makes the object act as a platform for players. Unlike beSolid, this method will only cause interactions with players on top of the object and not on its sides. Additionally, this method better accounts for the object's self-induced movement. The parameters xOld and yOld should be set to horizontal and vertical position of the object in the previous tick, whereas the jjOBJ properties xPos and yPos will be used for its current position. The remaining two parameters, width and height, should indicate the platform's dimensions in pixels. The default value of 0 will result in dimensions chosen automatically based on the size of the object's curFrame.\n", "full": "void bePlatform(float xOld, float yOld, int width = 0, int height = 0)", "type": "function"}, {"name": "beSolid", "description": "Causes this jjOBJ to serve as a solid block for players trying to move into it. Used by crates, monitors, etc. Returns -1 if a player is trying to push the object to the left, 1 if a player is trying to push it to the right, or otherwise 0, in case you wish to write some code to make the object pushable.\nIf shouldCheckForStompingLocalPlayers is true, any local players who are landing on this object while buttstomping get an additional chance to destroy this object before landing, effectively by calling jjPLAYER::objectHit. If the collision changes this object's state to either STATE::ACTION or STATE::KILL, jjOBJ::behave() will be called.\n", "full": "int beSolid(bool shouldCheckForStompingLocalPlayers = false)", "type": "function"}, {"name": "blast", "description": "Sends all players within maxDistance of the object flying away, like RFs or Bombs do when they explode. If creatorType equals CREATOR::PLAYER and players can currently hurt each other, the blast will hurt nearby players unless their playerID is equal to this object's creatorID. If blastObjects is true, then other jjOBJs within maxDistance whose isBlastable property equals true will be damaged and/or sent flying, just like when a TNT object explodes.\n", "full": "void blast(int maxDistance, bool blastObjects)", "type": "function"}, {"name": "clearPlatform()", "description": "Causes all local players that are currently standing on top of this object or pushing it to no longer be standing on top of it or pushing it. Should be called when deleting an object that calls bePlatform or beSolid.\n", "full": "void clearPlatform()", "type": "function"}, {"name": "deactivate", "description": "A wrapper method, called by most objects when their state property equals DEACTIVATE:\n\t\t\t\tobj.delete();\nif(obj.creatorType == CREATOR::LEVEL) {\n\tjjEventSet(obj.xOrg/32, obj.yOrg/32, obj.eventID);\n\tjjParameterSet(obj.xOrg/32, obj.yOrg/32, -1, 1, 0);\n}\n", "full": "void deactivate()", "type": "function"}, {"name": "delete", "description": "Permanently deletes the object. Like jjAddObject, this method is purely local in its scope.\n", "full": "void delete()", "type": "function"}, {"name": "determineCurAnim", "description": "Determines the value of the curAnim corresponding to Set ID setID and Animation animation as seen in Jazz Sprite Dynamite. (0-indexed.) If change is specified as false, this serves as essentially a static method, calculating the proper curAnim value but not actually setting this particular jjOBJ's curAnim to that value.\nYou are allowed to use a simple uint8 to specify the setID, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24. The full list of constants can be found in the appendix at the bottom of this file.\nInternally, this method runs the following code:\n\t\t\t\tif (jjAnimSets[setID].firstAnim == 0) //not yet loaded\n\tjjAnimSets[setID].load(); //load from anims.j2a or plus.j2a, depending on setID\nconst int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation;\nif (change)\n\tthis.curAnim = newCurAnimValue;\nreturn newCurAnimValue;\n", "full": "int16 determineCurAnim(uint8 setID, uint8 animation, bool change = true)", "type": "function"}, {"name": "determineCurAnim", "description": "Determines the value of the curAnim corresponding to Set ID setID and Animation animation as seen in Jazz Sprite Dynamite. (0-indexed.) If change is specified as false, this serves as essentially a static method, calculating the proper curAnim value but not actually setting this particular jjOBJ's curAnim to that value.\nYou are allowed to use a simple uint8 to specify the setID, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24. The full list of constants can be found in the appendix at the bottom of this file.\nInternally, this method runs the following code:\n\t\t\t\tif (jjAnimSets[setID].firstAnim == 0) //not yet loaded\n\tjjAnimSets[setID].load(); //load from anims.j2a or plus.j2a, depending on setID\nconst int16 newCurAnimValue = jjAnimSets[setID].firstAnim + animation;\nif (change)\n\tthis.curAnim = newCurAnimValue;\nreturn newCurAnimValue;\n", "full": "int16 determineCurAnim(ANIM::Set setID, uint8 animation, bool change = true)", "type": "function"}, {"name": "determineCurFrame", "description": "Determines the value of the curFrame corresponding to this jjOBJ's current curAnim and frameID values. If change is specified as false, this calculates the proper value but does not actually set this particular jjOBJ's curFrame property to that value.\nInternally, this method runs the following code:\n\t\t\t\tconst jjANIMATION@ animation = jjAnimations[this.curAnim];\nconst uint newCurFrameValue = (animation.frameCount == 0) ? 0 : (animation.firstFrame + (this.frameID % animation.frameCount));\nif (change)\n\tthis.curFrame = newCurFrameValue;\nreturn newCurFrameValue;\n", "full": "uint determineCurFrame(bool change = true)", "type": "function"}, {"name": "doesCollide", "description": "Returns true if the object's sprite collides with that of the specified object or player, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables\u00c3\u00af\u00c2\u00bf\u00c2\u00bdincluding playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in\u00c3\u00af\u00c2\u00bf\u00c2\u00bdare taken into account.\n", "full": "bool doesCollide(const jjOBJ@ object, bool always = false) const", "type": "function"}, {"name": "doesCollide", "description": "Returns true if the object's sprite collides with that of the specified object or player, otherwise false. This is a convenient wrapper for jjANIMFRAME::doesCollide, using the positions, directions and curFrame properties of the player and object involved. No other variables\u00c3\u00af\u00c2\u00bf\u00c2\u00bdincluding playerHandling, bulletHandling, or the scale and rotation their sprites are drawn in\u00c3\u00af\u00c2\u00bf\u00c2\u00bdare taken into account.\n", "full": "bool doesCollide(const jjPLAYER@ player, bool always = false) const", "type": "function"}, {"name": "draw", "description": "Essentially a wrapper for jjDrawSpriteFromCurFrame; uses the jjOBJ's xPos, yPos, direction, freeze, justHit, and curFrame properties to determine where to draw the sprite and what mode to use. This isn't specific enough for all objects, but it does the job in a high percentage of cases.\n", "full": "int draw()", "type": "function"}, {"name": "findNearestPlayer", "description": "Returns the playerID property of the nearest jjPLAYER object within maxDistance, or a negative number if none exist. If the foundDistance parameter is included, it will be set to the distance of the found jjPLAYER. Both maxDistance and foundDistance are actually squares of the distance expressed in pixels. Used by numerous enemies and other objects in order to react to nearby players.\n", "full": "int findNearestPlayer(int maxDistance) const", "type": "function"}, {"name": "findNearestPlayer", "description": "Returns the playerID property of the nearest jjPLAYER object within maxDistance, or a negative number if none exist. If the foundDistance parameter is included, it will be set to the distance of the found jjPLAYER. Both maxDistance and foundDistance are actually squares of the distance expressed in pixels. Used by numerous enemies and other objects in order to react to nearby players.\n", "full": "int findNearestPlayer(int maxDistance, int &out foundDistance) const", "type": "function"}, {"name": "fireBullet", "description": "A much-simplified version of jjAddObject. This method creates a new object of type eventID, directly at the \"gunspot\" position of the jjOBJ's current curFrame sprite, and sets its direction, xSpeed, and xAcc based on the jjOBJ's direction. The return value is the object ID of the new bullet object, or 0 if the method was unsuccessful. Used by dragons, hatters, Bilsy, and so on.\n", "full": "int fireBullet(OBJECT::Object eventID) const", "type": "function"}, {"name": "grantPickup", "description": "Potentially creates a random pickup (red gem, green gem, blue gem, or carrot) in front of the jjOBJ, the likelihood depending on frequency (higher values are less likely). Traditionally, this method is called when an enemy or crate is destroyed by a bullet, and frequency equals 5 if the bullet was an unpowered-up blaster bullet or otherwise 10.\nThe player parameter is necessary because one in every eight pickups a player is granted is a fastfire instead, so JJ2 needs to be able to keep track of when each individual player should next receive a fastfire.\nOnly works if creatorType equals CREATOR::LEVEL.\n", "full": "void grantPickup(jjPLAYER@ player, int frequency) const", "type": "function"}, {"name": "objectHit", "description": "Assumes that this object is a player bullet colliding with object target, even if they are not in the same area or if this object is not actually HANDLING::PLAYERBULLET. You are allowed to set what HANDLING::Player value the target object will be treated as having\u00c3\u00af\u00c2\u00bf\u00c2\u00bdHANDLING::ENEMY, HANDLING::SPECIAL, or HANDLING::PICKUP, with all other values having no effect\u00c3\u00af\u00c2\u00bf\u00c2\u00bdbut otherwise the code will run exactly as if the two objects really did collide. Effects may or may not be broadcast to other players in the server, and some version of onObjectHit will be called (with force as this object's animSpeed property) iff target has scriptedCollisions set to true and HANDLING::SPECIAL is passed as playerHandling.\n", "full": "void objectHit(jjOBJ@ target, HANDLING::Player playerHandling)", "type": "function"}, {"name": "particlePixelExplosion", "description": "A fast wrapper for jjAddParticlePixelExplosion, using the jjOBJ's own xPos, yPos, direction, and curFrame properties.\n", "full": "void particlePixelExplosion(int style) const", "type": "function"}, {"name": "pathMovement", "description": "Makes the object use the same waypoint-based path movement as the Butterfly and Rocket Turtle objects. The method potentially sets the xAcc, yAcc, xPos, yPos, xSpeed, ySpeed, counter, direction, var[6] and var[7] properties in the process.\n", "full": "void pathMovement()", "type": "function"}, {"name": "putOnGround", "description": "Moves the object downward until it's on top of the nearest available masked tile below it, or else the bottom of the level. If precise is left false, the resulting yPos may be off by as much as three pixels either up or down, which is still fine for most objects.\n", "full": "void putOnGround(bool precise = false)", "type": "function"}, {"name": "ricochet", "description": "To be used on bullet objects. Reverses the bullet's xSpeed/xAcc/direction, gives it a randomized ySpeed, plays one of the SOUND::AMMO_BUL* samples, and calls jjAddParticle(PARTICLE::SPARK) several times. Returns false if the bullet last ricocheted too recently.\n", "full": "bool ricochet()", "type": "function"}, {"name": "unfreeze", "description": "Sets freeze to 0, plays SOUND::COMMON_ICECRUSH, and creates an explosion of ice fragments radiating outward from the object. Unique values for style are 0, 1, or any other number.\n", "full": "int unfreeze(int style)", "type": "function"}], "jjPARTICLEList": [{"name": "isActive", "description": "The point of this property is somewhat unclear, since JJ2 prefers to check if a given particle is active by testing whether type equals PARTICLE::INACTIVE or not, but it does exist and does get set sometimes.\n", "full": "bool isActive", "type": "property"}, {"name": "type", "description": "Any of the standard type options allowed by jjAddParticle: INACTIVE, FIRE, FLOWER, ICETRAIL, LEAF, PIXEL, RAIN, SMOKE, SNOW, SPARK, STAR, STRING, or TILE.\n", "full": "PARTICLE::Type type", "type": "property"}, {"name": "xPos", "description": "Horizontal location in pixels.\n", "full": "float xPos", "type": "property"}, {"name": "xSpeed", "description": "Horizontal speed in pixels, positive or negative.\n", "full": "float xSpeed", "type": "property"}, {"name": "yPos", "description": "Vertical location in pixels.\n", "full": "float yPos", "type": "property"}, {"name": "ySpeed", "description": "Vertical speed in pixels, positive or negative.\n", "full": "float ySpeed", "type": "property"}, {"name": "fire", "description": "Corresponds to PARTICLE::FIRE. Fire particles are drawn as small horizontal ovals, and before they disappear, may at any time create a smoke particle. Fire particles are usually created when an enemy or other destructible object is destroyed using a fire-based weapon.\nuint8 fire.color is the color (palette entry) which a fire particle will be drawn as. This property gradually increases as the particle remains active, until it reaches colorStop (default 48, pink), at which point the particle will disappear. The default initial value is 40 (yellow).\nint8 fire.colorDelta is the rate at which the color property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.\nuint8 fire.colorStop is the color value which, when reached, will cause the particle to disappear. The default value is 48 (pink).\nuint8 fire.size decides how large the oval will be, ranging from 0-3. The default value is 3.\n", "full": "fire", "type": "property"}, {"name": "flower", "description": "Corresponds to PARTICLE::FLOWER. Flower particles are drawn as single color, partially transparent, rotationally symmetric flowers, and drift for a while while getting progressively smaller. They are traditionally created by setting Type=1 on a Snow event.\nuint8 flower.angle is the current angle of rotation the flower is drawn at.\nint8 flower.angularSpeed is how much the angle changes every tick, positive or negative. By default they do not rotate at all.\nuint8 flower.color is the color which a flower particle will be drawn as, and does not change during the particle's lifetime. The default value is 16 (green)\nuint8 flower.size is how large the flower should be drawn, though this is not equal to its size in actual pixels. Decreases by 1 every tick until it reaches 0, at which point the particle disappears. The default starting value is 64.\n", "full": "flower", "type": "property"}, {"name": "icetrail", "description": "Corresponds to PARTICLE::ICETRAIL. Ice trail particles are drawn as single pixels. In regular JJ2, ice bullets leave them in their wake as they fly.\nuint8 icetrail.color is the color (palette entry) which an ice trail particle will be drawn as. This property gradually increases as the particle remains active, until it reaches colorStop (default 40, yellow), at which point the particle will disappear. The default initial value is 32 (light blue).\nint8 icetrail.colorDelta is the rate at which the color property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.\nuint8 icetrail.colorStop is the color value which, when reached, will cause the particle to disappear. The default value is 40 (yellow).\n", "full": "icetrail", "type": "property"}, {"name": "leaf", "description": "Corresponds to PARTICLE::LEAF. Leaf particles are drawn as frames of the ANIM::PLUS_SCENERY animation set, and float along based on their speed properties and some random jiggling, until they pass offscreen or hit a wall and fall to the ground. They are traditionally created by setting Type=3 on a Snow event. Note that you will need to load ANIM::PLUS_SCENERY manually in order for leaf particles to display properly.\nuint8 leaf.countup is set to 1 when the leaf hits a wall, then increments every tick until it hits 140 and the particle is deleted.\nuint8 leaf.frame specifies which frame of the animation will be drawn. This ranges from 0-31 when the leaf is in motion and 0-2 once the deathcounter property is non-zero. The value of this property does not exactly correspond to frames in the animation in plus.j2a, however, since the leaf animation repeats many frames that are only included once in the file.\nuint16 leaf.frameBase is ID of the frame the particle will use as a base sprite (curFrame-style), and has the default value of jjAnimations[jjAnimSets[ANIM::PLUS_SCENERY].firstAnim].firstFrame.\nuint8 leaf.height is the distance from the ground in pixels that the particle must be in order to stop falling after hitting a wall. The default value is 2.\n", "full": "leaf", "type": "property"}, {"name": "pixel", "description": "Corresponds to PARTICLE::PIXEL. Depending on their size value, pixel particles will be drawn as\t1x1, 2x2, or 3x3 rectangles of pixels. They move both horizontally and vertically, and will also bounce off of masks. These are the particles created by destroying most enemies.\nuint8 pixel.color[9] specifies which colors will be drawn at each pixel in the particle's rectangle. Note that if the rectangle is smaller than 3x3, not every number in the array will be used. Values of 0 represent transparent pixels and will therefore not be drawn.\nuint8 pixel.size specifies the size of the rectangle drawn to the screen. 0 for 1x1, 1 for 2x2, or any other number for 3x3. The default value is 0.\n", "full": "pixel", "type": "property"}, {"name": "rain", "description": "Corresponds to PARTICLE::RAIN. Rain particles are drawn as transparent, resized sprites, and move around according to their xSpeed/ySpeed properties until they hit a masked pixel, at which point they are either deleted (if the pixel is to their side) or begin a splashing animation (if the pixel is above or below). They are traditionally created by setting Type=2 on a Snow event.\nuint8 rain.frame ranges from 0-7 while the particle is in motion, switches to 8 upon hitting a floor or ceiling, and then increases until it hits 18 and the particle is deleted.\nuint16 rain.frameBase is the first frame of the animation used by the particle, and has the default value of jjAnimations[jjAnimSets[ANIM::COMMON].firstAnim + 2].firstFrame. The displayed frame will be equal to this property plus the current value of the frame property.\n", "full": "rain", "type": "property"}, {"name": "smoke", "description": "Corresponds to PARTICLE::SMOKE. Smoke particles are drawn as small gray rectangles and always move erratically upwards. Traditionally they are created from fire particles or from the BEHAVIOR::BURNING objects created by powered-up toaster or a frozen Bily.\nuint8 smoke.countdown gradually decreases until it reaches 64, at which point the particle will disappear. The default value is 71.\n", "full": "smoke", "type": "property"}, {"name": "snow", "description": "Corresponds to PARTICLE::SNOW. Snow particles are drawn as frames of the ANIM::SNOW animation set, and fly slowly around based on their speed properties and a general wind force until they hit a masked tile and slowly fade away. They are, of course, traditionally created by the Snow event. Note that you will need to load ANIM::SNOW manually in order for snow particles to display properly.\nuint8 snow.countdown specifies how long (in ticks) the particle may pass through masked tiles after first being created before masked tiles cause it to fade away and disappear. The default value is 35.\nuint8 snow.countup has something unknown to do with the particle disappearing once it hits a masked tile. The default value is 0.\nuint8 snow.frame specifies which frame of the animation will be drawn. This remains constant until the particle hits a wall, at which point it will increase to 7 before disappearing. The default initial value is 0.\nuint16 snow.frameBase is ID of the frame the particle will use as a base sprite (curFrame-style), and has the default value of jjAnimations[jjAnimSets[ANIM::SNOW].firstAnim].firstFrame. The displayed frame will be equal to this property plus the current value of the frame property.\n", "full": "snow", "type": "property"}, {"name": "spark", "description": "Corresponds to PARTICLE::SPARK. Spark particles move around according to their xSpeed/ySpeed properties and also gravity, and are drawn as short trails left behind as they move. They are traditionally created by bullets ricocheting off of turtle shells or metallic surfaces, or by electro-blaster bullets in flight.\nuint8 spark.color is the color (palette entry) which a spark particle's trail will be drawn as. This property gradually increases as the particle remains active, until it reaches colorStop (default 46, maroon), at which point the particle will disappear. The default initial value is 40 (yellow).\nint8 spark.colorDelta is the rate at which the color property is going to change. The most commonly used values for this are 1 and -1 meaning that the color value will respectively increase or decrease by 1 every time the game decides to modify it. The default value is 1.\nuint8 spark.colorStop is the color value which, when reached, will cause the particle to disappear. The default value is 46 (maroon).\n", "full": "spark", "type": "property"}, {"name": "star", "description": "Corresponds to PARTICLE::STAR. Star particles were added to the game to indicate sugar rush. They are drawn as a rotated star sprite. Besides linear speed they also have angular speed and change colors.\nuint8 star.angle is the current angle of rotation the star is drawn at.\nint8 star.angularSpeed is how much the angle changes every tick, positive or negative. By default they do not rotate at all.\nuint8 star.color is the color the star is drawn as. The default value is 40 (yellow).\nuint8 star.colorChangeCounter counts down to 0, at which point it resets to the value of the colorChangeInterval property and changes the color property to one of the sprite colors at random.\n", "full": "star", "type": "property"}, {"name": "string", "description": "Corresponds to PARTICLE::STRING. String particles move at ever-increasing speeds until they leave the screen, drawing up to eight consecutive characters as they go. They are traditionally used to show many points a player gained for destroying an object.\nstring string.text is the series of characters that will be drawn. Strings longer than eight characters will be truncated.\n", "full": "string", "type": "property"}, {"name": "tile", "description": "Corresponds to PARTICLE::TILE. Tile particles move around according to their xSpeed/ySpeed properties and also gravity, and are drawn as single tiles (or quarters of single tiles) from the tileset used by the level. They are traditionally created from the destruction of destruct or collapse scenery blocks.\nTILE::Quadrant tile.quadrant specifies how much of the tile will be drawn to the screen. Possible values of TILE::Quadrant are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS.\nuint16 tile.tileID specifies which tile the particle draws in the first place. The default value is 0, so remember to change it.\n", "full": "tile", "type": "property"}], "jjCONTROLPOINTList": [{"name": "controlTeam", "description": "The team that this point is presently under control of. Possible values are TEAM::NEUTRAL, TEAM::BLUE, TEAM::RED, TEAM::GREEN, and TEAM::YELLOW.\n", "full": "const TEAM::Color controlTeam", "type": "property"}, {"name": "direction", "description": "Direction of the gem sprite displayed by the control point. The value has purely visual influence on the game.\n", "full": "const int direction", "type": "property"}, {"name": "name", "description": "The control point's name.\n", "full": "const string name", "type": "property"}, {"name": "xPos", "description": "Horizontal position in pixels.\n", "full": "const float xPos", "type": "property"}, {"name": "xTile", "description": "Horizontal position in tiles.\n", "full": "const int xTile", "type": "property"}, {"name": "yPos", "description": "Vertical position in pixels.\n", "full": "const float yPos", "type": "property"}, {"name": "yTile", "description": "Vertical position in tiles.\n", "full": "const int yTile", "type": "property"}], "jjCHARACTERList": [{"name": "airJump", "description": "Determines the character's reaction to pressing jump in the air. Possible values are AIR::NONE, AIR::HELICOPTER and AIR::DOUBLEJUMP. No effect for birds or frogs.\n", "full": "AIR::Jump airJump", "type": "property"}, {"name": "canHurt", "description": "Whether the character can cause damage by using their special moves. This property also applies to Chuck's beak attack and Frog's tongue attack. Defaults true for all rabbits and false for birds and frogs.\n", "full": "bool canHurt", "type": "property"}, {"name": "canRun", "description": "Whether the character is capable of fast movement. Defaults true for all rabbits and false for birds and frogs.\n", "full": "bool canRun", "type": "property"}, {"name": "doubleJumpCountMax", "description": "The maximum number of jumps the character can perform in the air if their airJump property allows it. Defaults 1 for Spaz.\n", "full": "int doubleJumpCountMax", "type": "property"}, {"name": "doubleJumpXSpeed", "description": "What horizontal and vertical speed the character will gain by using double jump. doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is relative to the player's current direction, so for example a negative doubleJumpXSpeed will make the character move backwards.\n", "full": "float doubleJumpXSpeed", "type": "property"}, {"name": "doubleJumpYSpeed", "description": "What horizontal and vertical speed the character will gain by using double jump. doubleJumpYSpeed defaults -8 for Spaz. doubleJumpXSpeed defaults 0 and is relative to the player's current direction, so for example a negative doubleJumpXSpeed will make the character move backwards.\n", "full": "float doubleJumpYSpeed", "type": "property"}, {"name": "helicopterDurationMax", "description": "The maximum amount of time the character can keep using helicopter ears if their airJump property allows it.\n", "full": "int helicopterDurationMax", "type": "property"}, {"name": "helicopterXSpeed", "description": "What horizontal and vertical speed the character will gain by using helicopter ears. helicopterYSpeed defaults 1 for all rabbits; its effects when <= 0 are currently undefined. helicopterXSpeed defaults 0 and is relative to the player's current direction, so for example a negative helicopterXSpeed will make the character move backwards.\n", "full": "float helicopterXSpeed", "type": "property"}, {"name": "helicopterYSpeed", "description": "What horizontal and vertical speed the character will gain by using helicopter ears. helicopterYSpeed defaults 1 for all rabbits; its effects when <= 0 are currently undefined. helicopterXSpeed defaults 0 and is relative to the player's current direction, so for example a negative helicopterXSpeed will make the character move backwards.\n", "full": "float helicopterYSpeed", "type": "property"}, {"name": "groundJump", "description": "Determines the character's reaction to pressing jump while crouching. Possible values are GROUND::JAZZ, GROUND::SPAZ, GROUND::LORI (available even in 1.23), GROUND::CROUCH (character remains crouching and does not jump), and GROUND::JUMP (character jumps but does not immediately buttstomp). No effect for birds or frogs. Note that changing this property to any the first three values may look pretty silly if the animations are not edited accordingly.\n", "full": "GROUND::Jump groundJump", "type": "property"}, {"name": "morphBoxCycle", "description": "Whether the character can be morphed to using the \"Jazz<->Spaz\" morph box. Also affects the jjPLAYER function morph when its rabbitsOnly argument is set to true.\n", "full": "bool morphBoxCycle", "type": "property"}], "jjWEAPONList": [{"name": "allowed", "description": "Whether the weapon and/or its powerup can be legally used in the level. This value is used by the server to detect attempts of cheating and kick offenders, and by all players to determine which weapons they get upon use of the /ready command.\nBetween onLevelLoad and onLevelBegin, JJ2+ runs a function to determine the values for these properties for each weapon. jjWeapons[WEAPON::BLASTER].allowed will always be set to true; for the rest, JJ2+ looks at the current contents of jjObjects and checks each active object's jjOBJ::eventID. Any +3 ammo pickup or +15 ammo crate will set allowed to true for that weapon, and any powerup will set both allowed and allowedPowerup to true. Additionally, OBJECT::GUNCRATE and OBJECT::GUNBARREL will both set jjWeapons[WEAPON::BOUNCER].allowed to true, and OBJECT::GENERATOR and object-spawning crates will behave as if they were the objects they will spawn, e.g. a generator that creates +3 Toaster pickups will set jjWeapons[WEAPON::TOASTER].allowed to true. (Anything not set to true will be set to false, so there is no point in editing these properties in onLevelLoad.)\nThis system covers most levels, but it is absolutely possible to set up your level to include ammo that JJ2+ was unable to guess based on a single loop through jjObjects, e.g. MCEs, or the \"Weapon\" parameter on +15 Bouncer crates, or any number of scripting changes. If you're at all unsure whether JJ2+ will make the right predictions for your particular level, there is zero harm in explicitly setting as many allowed and allowedPowerup values as you want, to true or to false, although make sure to set them in onLevelBegin at the earliest.\n", "full": "bool allowed", "type": "property"}, {"name": "allowedPowerup", "description": "Whether the weapon and/or its powerup can be legally used in the level. This value is used by the server to detect attempts of cheating and kick offenders, and by all players to determine which weapons they get upon use of the /ready command.\nBetween onLevelLoad and onLevelBegin, JJ2+ runs a function to determine the values for these properties for each weapon. jjWeapons[WEAPON::BLASTER].allowed will always be set to true; for the rest, JJ2+ looks at the current contents of jjObjects and checks each active object's jjOBJ::eventID. Any +3 ammo pickup or +15 ammo crate will set allowed to true for that weapon, and any powerup will set both allowed and allowedPowerup to true. Additionally, OBJECT::GUNCRATE and OBJECT::GUNBARREL will both set jjWeapons[WEAPON::BOUNCER].allowed to true, and OBJECT::GENERATOR and object-spawning crates will behave as if they were the objects they will spawn, e.g. a generator that creates +3 Toaster pickups will set jjWeapons[WEAPON::TOASTER].allowed to true. (Anything not set to true will be set to false, so there is no point in editing these properties in onLevelLoad.)\nThis system covers most levels, but it is absolutely possible to set up your level to include ammo that JJ2+ was unable to guess based on a single loop through jjObjects, e.g. MCEs, or the \"Weapon\" parameter on +15 Bouncer crates, or any number of scripting changes. If you're at all unsure whether JJ2+ will make the right predictions for your particular level, there is zero harm in explicitly setting as many allowed and allowedPowerup values as you want, to true or to false, although make sure to set them in onLevelBegin at the earliest.\n", "full": "bool allowedPowerup", "type": "property"}, {"name": "comesFromBirds", "description": "Determines whether or not the red companion bird is allowed to shoot bullets of the specified weapon (comesFromBirds), and, if so, whether they may be powered-up (comesFromBirdsPowerup) if the player currently has a powerup for that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless of the player's currWeapon.\nBird bullets do not affect the player's ammo count, regardless of the weapon's infinite property, and will not be replaced by shield bullets (because the bird does not have its own shield), regardless of the weapon's replacedByShield property.\n\t\t\t\n", "full": "bool comesFromBirds", "type": "property"}, {"name": "comesFromBirdsPowerup", "description": "Determines whether or not the red companion bird is allowed to shoot bullets of the specified weapon (comesFromBirds), and, if so, whether they may be powered-up (comesFromBirdsPowerup) if the player currently has a powerup for that weapon. Otherwise the bird will shoot ordinary blaster bullets regardless of the player's currWeapon.\nBird bullets do not affect the player's ammo count, regardless of the weapon's infinite property, and will not be replaced by shield bullets (because the bird does not have its own shield), regardless of the weapon's replacedByShield property.\n\t\t\t\n", "full": "bool comesFromBirdsPowerup", "type": "property"}, {"name": "comesFromGunCrates", "description": "Determines whether or not the ammo for the specified weapon can drop from Gun Crates and Gun Barrels. Defaults to true for WEAPON::BOUNCER, WEAPON::ICE, WEAPON::SEEKER, WEAPON::RF, WEAPON::TOASTER, and false for WEAPON::TNT, WEAPON::GUN8 and WEAPON::GUN9. Has no effect on WEAPON::BLASTER. In an online server, the pickups dropped will be according to the comesFromGunCrates settings for the player who destroyed the crate/barrel.\n", "full": "bool comesFromGunCrates", "type": "property"}, {"name": "defaultSample", "description": "When false, the default sample of the bullet will not be played.\n", "full": "bool defaultSample", "type": "property"}, {"name": "gemsLost", "description": "How many gems a player shot by this weapon will lose in Treasure Hunt. (If the player has fewer gems than the weapon should cause them to lose, they will lose all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT, WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making no difference by default. Doesn't have any effect when changed by clients, only by the server (or in local games).\n", "full": "int gemsLost", "type": "property"}, {"name": "gemsLostPowerup", "description": "How many gems a player shot by this weapon will lose in Treasure Hunt. (If the player has fewer gems than the weapon should cause them to lose, they will lose all their gems.) Defaults to 10 for WEAPON::SEEKER, WEAPON::RF, WEAPON::TNT, WEAPON::GUN8, and WEAPON::GUN9, and 3 for the others, with powerup status making no difference by default. Doesn't have any effect when changed by clients, only by the server (or in local games).\n", "full": "int gemsLostPowerup", "type": "property"}, {"name": "gradualAim", "description": "Whether it takes a few shots for bullets to adjust their direction to the direction the player is aiming, as is the case with pepper spray. If this weapon's spread property is SPREAD::GUN8 and jjAllowsFireball is true, this property will be treated as false.\n", "full": "bool gradualAim", "type": "property"}, {"name": "infinite", "description": "When true, ammo displays an infinity symbol for its quantity and can never be deplenished. Defaults to true for WEAPON::BLASTER. When spectating another player, the ammo count will appear according to your infinite setting for their currently chosen weapon, not their own.\n", "full": "bool infinite", "type": "property"}, {"name": "maximum", "description": "Determines how much of each ammo type a player can hold at a time. Defaults to -1, which is interpreted as \"99 in single player or cooperative, otherwise 50,\" but you may want to change some numbers individually (e.g. limit the number of seekers but not bouncers).\n", "full": "int maximum", "type": "property"}, {"name": "multiplier", "description": "The factor by which ammo pickups/powerups increase a weapon's ammo count, and by which that count is divided to be displayed onscreen. Defaults to 32 for WEAPON::TOASTER and 1 for everything else. When spectating another player, the ammo count will appear according to your multiplier setting for their currently chosen weapon, not their own.\n", "full": "int multiplier", "type": "property"}, {"name": "replacedByBubbles", "description": "When true, the bullet will be replaced by an air bubble when shot underwater or if it goes underwater subsequent to being shot. Defaults to true for WEAPON::TOASTER (and therefore also for fire shield bullets).\n", "full": "bool replacedByBubbles", "type": "property"}, {"name": "replacedByShield", "description": "When true and a shield is active, shield ammo will replace default weapon ammo. Defaults to true for WEAPON::BLASTER.\nUnder certain circumstances this setting is used to determine validity of network packets, so keep in mind that if its value is not the same for the host as it is for clients, they may be kicked for cheating.\n", "full": "bool replacedByShield", "type": "property"}, {"name": "replenishes", "description": "When true, ammo jumps back up to 50 or 99 on level (re)load. Should be set in onLevelLoad, rather than onLevelBegin, since it actually takes effect between the two. Defaults to true for WEAPON::BLASTER.\n", "full": "bool replenishes", "type": "property"}, {"name": "spread", "description": "How many bullets are spawned by a single use of the weapon and in what manner. Possible values are:\n\t\t\t\tNORMAL: Fires one bullet.\n\t\t\t\tICEPU: Fires two bullets; one in the direction you face, one in the direction you aim.\n\t\t\t\tICE: Same as NORMAL when not powered up, and ICEPU when powered up.\n\t\t\t\tRFNORMAL: Fires two bullets.\n\t\t\t\tRFPU: Fires three bullets.\n\t\t\t\tRF: Same as RFNORMAL when not powered up, and RFPU when powered up.\n\t\t\t\tTOASTER: Fires one bullet with its speed partially determined by how much fastfire the player has.\n\t\t\t\tPEPPERSPRAY: Fires two pepper spray bullets.\n\t\t\t\tGUN8: Same as NORMAL if jjAllowsFireball is true (but ignoring this weapon's gradualAim property), and PEPPERSPRAY when it's off.\n\t\t\t\t\nAny assignments of GUN8 or PEPPERSPRAY should be shared between clients and server to prevent kicking for invalid gun use.\n", "full": "SPREAD::Spread spread", "type": "property"}, {"name": "style", "description": "Determines how often will the weapon fire a bullet when the player holds the fire button. Possible values are WEAPON::NORMAL (fires continously, respecting the player's fastfire property), WEAPON::MISSILE (fires once per press of the button), WEAPON::POPCORN (fires continously and respects the player's fastfire property, but at a capped minimum rate of fire), and WEAPON::CAPPED (like NORMAL, but prevents players from shooting faster than allowed by their fastfire property).\n", "full": "WEAPON::Style style", "type": "property"}], "jjSTREAMList": [{"name": "clear", "description": "Clears content of the stream leaving it empty.\n", "full": "void clear()", "type": "function"}, {"name": "discard", "description": "Discards count bytes from the front of the stream. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n", "full": "bool discard(uint count)", "type": "function"}, {"name": "get", "description": "Reads count bytes from the front of the stream, removes them and places their contents into value. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n", "full": "bool get(const string &out value, uint count = 1)", "type": "function"}, {"name": "get", "description": "Reads count bytes from the front of the stream, removes them and places their contents into value. Returns whether successful, i.e. whether the stream contained sufficiently many bytes to perform the operation. If the operation fails, the stream is left in an undefined state.\n", "full": "bool get(const jjSTREAM &out value, uint count = 1)", "type": "function"}, {"name": "getLine", "description": "Reads bytes from the stream, interpreting them as text characters, until it finds the character sequence delim. The read bytes are placed into value. All read characters are removed from the stream, including delim; however, the resulting value will not contain delim. Returns true on success and false if delim was not found anywhere in the stream. In the latter case, the behavior is still well-defined and all contents of the stream are placed into value, making the stream empty.\n", "full": "bool getLine(string &out value, const string &in delim = '\\n')", "type": "function"}, {"name": "getSize", "description": "Returns size of the stream in bytes.\n", "full": "uint getSize() const", "type": "function"}, {"name": "isEmpty", "description": "Returns whether the stream is empty, i.e. whether getSize() == 0.\n", "full": "bool isEmpty() const", "type": "function"}, {"name": "pop", "description": "Pops value from the stream into value, causing value to be filled and reducing the size of the stream. Returns true on success and false on failure, i.e. if the stream didn't have sufficiently many bytes to perform the operation. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow obtaining data previously inserted using push (read its documentation for details).\n", "full": "bool pop(T &out value)", "type": "function"}, {"name": "push", "description": "Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n", "full": "bool push(T value)", "type": "function"}, {"name": "push", "description": "Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n", "full": "bool push(const string &in value)", "type": "function"}, {"name": "push", "description": "Pushes value onto the stream. Returns whether successful, which is always true. Supported types are all primitive types (int and its size variations, uint and its size variations, bool, float and double) as well as strings and other jjSTREAMs. The method is designed to allow easily obtaining data in the future by calling pop. Different data types are assigned different amount of space of the stream. The following rules apply:\n\t\t\t\n\t\t\t1 byte for bool, int8 and uint8\n\t\t\t2 bytes for int16 and uint16\n\t\t\t4 bytes for int, uint and float\n\t\t\t8 bytes for int64, uint64 and double\n\t\t\t4 + X bytes for strings and streams, where X is the size of the string or stream\n\t\t\t\n\t\t\tIn that last case, the initial 4 bytes are a uint containing the size, whereas the rest are the contents of the string or stream. This is necessary in order for pop to be able to recognize how many bytes to read, however it may be undesirable for other purposes, which is why additional functions exist for strings and streams: write and get.\n\t\t\t\n", "full": "bool push(const jjSTREAM &in value)", "type": "function"}, {"name": "save", "description": "Saves contents of the stream to file filename and returns whether successful.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".asdat\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjANIMATION::save and jjPIXELMAP::save).\n", "full": "bool save(const string &in filename) const", "type": "function"}, {"name": "write", "description": "Appends bytes of value at the end of the stream. In contrast to push, this method doesn't store the size of the provided string or stream, thus making it impossible to pop, but it can still be obtained with get if the size is known or getLine if it ends with a defined delimiter. Returns whether successful, which is always true.\n", "full": "bool write(const string &in value)", "type": "function"}, {"name": "write", "description": "Appends bytes of value at the end of the stream. In contrast to push, this method doesn't store the size of the provided string or stream, thus making it impossible to pop, but it can still be obtained with get if the size is known or getLine if it ends with a defined delimiter. Returns whether successful, which is always true.\n", "full": "bool write(const jjSTREAM &in value)", "type": "function"}], "jjRNGList": [{"name": "seed", "description": "Sets the current state of the generator based on value.\n", "full": "void seed(uint64 value = 5489)", "type": "function"}, {"name": "discard", "description": "Advances the generator's state by count. The effect is equivalent to invoking the call operator count times and discarding the returned values, but calculated more efficiently.\n", "full": "void discard(uint64 count = 1)", "type": "function"}], "jjPALList": [{"name": "color", "description": "At its heart, a palette is a collection of 256 colors, and you can access them individually through the color array. In fact, you could if you chose reproduce nearly every jjPAL method here by directly altering the colors, but the methods are here to save you time, so don't do that. The details of jjPALCOLOR objects are listed below this section, though most basically you just use their properties red, green, and blue.\n", "full": "jjPALCOLOR color[256]", "type": "property"}, {"name": "apply", "description": "Causes the contents of this jjPAL object to be the current colors in use by the game, and by extension jjPalette.\nNote that this function does a fair bit of housekeeping behind the scenes to make sure everything is propertly converted to the new palette\u00c3\u00af\u00c2\u00bf\u00c2\u00bdthere's a difference between myPal.apply(); and jjPalette = myPal;\u00c3\u00af\u00c2\u00bf\u00c2\u00bdand so it should always be called after doing any edits, even if you've been making the edits directly to jjPalette. Failure to do so can have unpredictable consequences.\n", "full": "void apply() const", "type": "function"}, {"name": "copyFrom", "description": "Overlays length colors from source onto the current palette, beginning at start on this palette and start2 on source. If opacity is below 1.0, the new colors will only partially replace the old.\n", "full": "void copyFrom(uint8 start, uint8 length, uint8 start2, const jjPAL &in source, float opacity)", "type": "function"}, {"name": "fill", "description": "Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n", "full": "void fill(uint8 red, uint8 green, uint8 blue, uint8 start, uint8 length, float opacity = 1.0)", "type": "function"}, {"name": "fill", "description": "Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n", "full": "void fill(uint8 red, uint8 green, uint8 blue, float opacity = 1.0)", "type": "function"}, {"name": "fill", "description": "Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n", "full": "void fill(jjPALCOLOR color, uint8 start, uint8 length, float opacity = 1.0)", "type": "function"}, {"name": "fill", "description": "Replaces a series of length colors beginning at start with the color red,green,blue or, in the later 2 overloads, color.\tIf opacity is specified and below 1.0, the new color will only partially replace the old ones, making for a tinting effect. Leave out the start and length arguments to fill (or tint) the entire palette.\n", "full": "void fill(jjPALCOLOR color, float opacity = 1.0)", "type": "function"}, {"name": "findNearestColor", "description": "Returns index of the palette entry whose components differ the least from those of the provided color. Ensures the result has no special treatment by never returning values from the range of 0-15.\n", "full": "uint8 findNearestColor(jjPALCOLOR color) const", "type": "function"}, {"name": "gradient", "description": "Replaces a series of length colors beginning at start with a gradient beginning with red1,green1,blue1 (or color1) and ending with red2,green2,blue2 (or color2). If opacity is specified and below 1.0, the new colors will only partially replace the old, making for a tinting effect.\nIf inclusive is false (default), the gradient will lead up to the second color but the second color will not itself appear. If true, the second color will appear directly in the palette as the final color of the gradient. For example, a gradient of red1:100, red2:0, and length:3 will produce the red values 100,66,33 when inclusive is false, but 100,50,0 when inclusive is true.\nThe default values for start and length will set a gradient for the colors used by water and (in most tilesets) textured backgrounds.\n", "full": "void gradient(uint8 red1, uint8 green1, uint8 blue1, uint8 red2, uint8 green2, uint8 blue2, uint8 start = 176, uint8 length = 32, float opacity = 1.0, bool inclusive = false)", "type": "function"}, {"name": "gradient", "description": "Replaces a series of length colors beginning at start with a gradient beginning with red1,green1,blue1 (or color1) and ending with red2,green2,blue2 (or color2). If opacity is specified and below 1.0, the new colors will only partially replace the old, making for a tinting effect.\nIf inclusive is false (default), the gradient will lead up to the second color but the second color will not itself appear. If true, the second color will appear directly in the palette as the final color of the gradient. For example, a gradient of red1:100, red2:0, and length:3 will produce the red values 100,66,33 when inclusive is false, but 100,50,0 when inclusive is true.\nThe default values for start and length will set a gradient for the colors used by water and (in most tilesets) textured backgrounds.\n", "full": "void gradient(jjPALCOLOR color1, jjPALCOLOR color2, uint8 start = 176, uint8 length = 32, float opacity = 1.0, bool inclusive = false)", "type": "function"}, {"name": "load", "description": "Loads a palette from the specified file. If the file is a tileset with a \".j2t\" extension, an 8-bit globally-paletted GIF image/animation with a \".gif\" extension, or an 8-bit paletted or grayscale PNG image with a \".png\" extension, will try to access the palette stored in the file. Otherwise, tries to treat it as a palette file saved in \"Color Table\" format in Palette Suite, and if that fails, simply reads the first 1024 bytes of the file. Returns false if the file cannot be found, or if trying to read the file based on its extension fails, or if the file is fewer than 1024 bytes long; otherwise true.\n", "full": "bool load(string& filename)", "type": "function"}, {"name": "reset", "description": "Loads the original colors used by the tileset. There is no non-stylistic difference between myPal.reset(); and myPal = jjBackupPalette;.\n", "full": "void reset()", "type": "function"}], "jjPALCOLORList": [{"name": "red", "description": "How red this palette color is.\n", "full": "uint8 red", "type": "property"}, {"name": "green", "description": "How green this palette color is.\n", "full": "uint8 green", "type": "property"}, {"name": "blue", "description": "How blue this palette color is.\n", "full": "uint8 blue", "type": "property"}, {"name": "getHue", "description": "The hue of this palette color.\n", "full": "uint8 getHue() const", "type": "function"}, {"name": "getSat", "description": "The saturation of this palette color, where 0 is grayscale and 255 is most saturated.\n", "full": "uint8 getSat() const", "type": "function"}, {"name": "getLight", "description": "The lighting of this palette color, where 0 is black and 255 is white.\n", "full": "uint8 getLight() const", "type": "function"}, {"name": "setHSL", "description": "Changes the entire color to a brand new one derived from the given HSL values. Due to the complexity of the calculations involved, you can only change all three values at a time, so if you want to leave, for instance, saturation constant, you'll need to read the old value through getSat and then use that as the sat parameter.\nhue is an int instead of a uint8 because it's a loop instead of a scale. 2, 258, 514, -254, etc., are all equally valid and all mean the same hue.\n", "full": "void setHSL(int hue, uint8 sat, uint8 light)", "type": "function"}, {"name": "swizzle", "description": "Swaps values of selected components of the color. The value of the red component will be replaced with that specified by parameter red, the value of the green component with that specified by green and the value of blue with that specified by blue. Values accepted by the parameters are COLOR::RED, COLOR::GREEN and COLOR::BLUE.\n", "full": "void swizzle(COLOR::Component red, COLOR::Component green, COLOR::Component blue)", "type": "function"}], "jjCANVASList": [{"name": "drawSprite", "description": "Draws a single sprite frame at xPixel,yPixel. The setID, animation, and frame parameters correspond to the \"Set ID,\" \"Animation,\" and \"Frame #\" sliders respectively in Jazz Sprite Dynamite, but are 0-indexed. You are allowed to use a simple integer to specify the setID, but an ANIM::Set constant is strongly recommended, since the values for certain sets differ between 1.23 and 1.24; the full list of constants can be found in the appendix at the bottom of this file. For an example, to draw a broken bird cage (9-5-1 in Jazz Sprite Dynamite), you would write ANIM::BIRD, 4, 0.\nThe direction parameter determines which direction the sprite will be facing; values 0 to 63 will not flip the sprite, -64 to -1 will flip it horizontally, 64 to 127 will flip it vertically, and -128 to -65 will flip it both horizontally and vertically. Alternatively to integer values, you can use constants made for this very purpose that belong to the SPRITE::Direction enum: SPRITE::FLIPNONE, SPRITE::FLIPH, SPRITE::FLIPV, SPRITE::FLIPHV.\n", "full": "void drawSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, int8 direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawSpriteFromCurFrame", "description": "The same as drawSprite, but takes a single sprite parameter instead of one each for Set, Animation, and Frame. The name references the curFrame property of jjOBJ and jjPLAYER, whose real significance is as an index to jjAnimFrames[].\nInternally any draw*Sprite method is actually a call to the corresponding draw*SpriteFromCurFrame method, with the following formula applied to find the curFrame value: (jjAnimations[jjAnimSets[setID].firstAnim + animation].firstFrame + frame) % jjAnimations[jjAnimSets[setID].firstAnim + animation].frameCount\n", "full": "void drawSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, int8 direction = 0, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawResizedSprite", "description": "Draws a single resized sprite frame at xPixel,yPixel. This swaps out drawSprite's direction argument with a pair of float arguments, xScale and yScale, which determine how much the sprite is enlarged (or shrunken) on each axis. For example, a 32x32 sprite drawn with xScale 3 and yScale 1.5 would be drawn across a 96\u00c3\u00af\u00c2\u00bf\u00c2\u00bd48 area. Making one or both scale values negative will cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing will be performed while resizing the sprite.\n", "full": "void drawResizedSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawResizedSpriteFromCurFrame", "description": "Draws a single resized sprite frame at xPixel,yPixel. This swaps out drawSprite's direction argument with a pair of float arguments, xScale and yScale, which determine how much the sprite is enlarged (or shrunken) on each axis. For example, a 32x32 sprite drawn with xScale 3 and yScale 1.5 would be drawn across a 96\u00c3\u00af\u00c2\u00bf\u00c2\u00bd48 area. Making one or both scale values negative will cause the sprite to be flipped horizontally and/or vertically. No anti-aliasing will be performed while resizing the sprite.\n", "full": "void drawResizedSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, float xScale, float yScale, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawRotatedSprite", "description": "Draws a single resized and rotated sprite frame at xPixel,yPixel. This carries over the xScale and yScale arguments from drawResizedSprite, and adds a new angle parameter with the same 0-1023 domain as jjSin and jjCos. (Numbers outside the domain will be seemlessly moduloed.) An angle of 0 will not rotate the sprite at all. Without getting into matrix math, you can think of the sprite as being resized before it is rotated, which in most cases is exactly what you'd want. For example, a 32\u00c3\u00af\u00c2\u00bf\u00c2\u00bd32 sprite drawn with angle 256, xScale 2, and yScale 1 would be drawn across an area of 32\u00c3\u00af\u00c2\u00bf\u00c2\u00bd64, not 64\u00c3\u00af\u00c2\u00bf\u00c2\u00bd32.\nRotated sprites should be no larger (before transformations are applied) than 128 pixels wide or 256 pixels high. The results of drawing larger sprites are, for now, undefined while we decide whether this restriction should or can be removed.\nAny sprite that drawSprite can draw, drawResizedSprite can draw in the same way by setting xScale and yScale each to 1. And any sprite that drawResizedSprite can draw, drawRotatedSprite can draw unless it's greater than 128\u00c3\u00af\u00c2\u00bf\u00c2\u00bd256, by setting angle to 0. As you might imagine, though, the simpler methods (besides being quicker to write) run faster than the more complicated methods, so you might as well use them when you can get away with it.\n", "full": "void drawRotatedSprite(int xPixel, int yPixel, int setID, uint8 animation, uint8 frame, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawRotatedSpriteFromCurFrame", "description": "Draws a single resized and rotated sprite frame at xPixel,yPixel. This carries over the xScale and yScale arguments from drawResizedSprite, and adds a new angle parameter with the same 0-1023 domain as jjSin and jjCos. (Numbers outside the domain will be seemlessly moduloed.) An angle of 0 will not rotate the sprite at all. Without getting into matrix math, you can think of the sprite as being resized before it is rotated, which in most cases is exactly what you'd want. For example, a 32\u00c3\u00af\u00c2\u00bf\u00c2\u00bd32 sprite drawn with angle 256, xScale 2, and yScale 1 would be drawn across an area of 32\u00c3\u00af\u00c2\u00bf\u00c2\u00bd64, not 64\u00c3\u00af\u00c2\u00bf\u00c2\u00bd32.\nRotated sprites should be no larger (before transformations are applied) than 128 pixels wide or 256 pixels high. The results of drawing larger sprites are, for now, undefined while we decide whether this restriction should or can be removed.\nAny sprite that drawSprite can draw, drawResizedSprite can draw in the same way by setting xScale and yScale each to 1. And any sprite that drawResizedSprite can draw, drawRotatedSprite can draw unless it's greater than 128\u00c3\u00af\u00c2\u00bf\u00c2\u00bd256, by setting angle to 0. As you might imagine, though, the simpler methods (besides being quicker to write) run faster than the more complicated methods, so you might as well use them when you can get away with it.\n", "full": "void drawRotatedSpriteFromCurFrame(int xPixel, int yPixel, uint sprite, int angle, float xScale = 1, float yScale = 1, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawSwingingVineSpriteFromCurFrame", "description": "Draws a single sprite frame at xPixel,yPixel in the style of a Swinging Vine object. The parameters named length and curvature correspond respectively to properties var[1] (normally always 128) and var[2] of swinging vines; if the sprite is shorter than the length value, its pixels will be repeated again from the top as necessary.\nFor boring internal code reasons, this method expects that sprites will have no transparent pixels. Instead, to tell this method not to draw an individual pixel from the frame, its value must be 128 instead of 0. Using normal transparent pixels instead will cause the sprite to be drawn as a jumbled mess.\n", "full": "void drawSwingingVineSpriteFromCurFrame(int xPixel, int yPixel, int sprite, int length, int curvature, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawPixel", "description": "Changes the color of the pixel at xPixel,yPixel into the palette color corresponding to index color. If you are drawing anything more than a handful of pixels at a time, you should consider creating a new sprite of your own using jjPIXELMAP, and then drawing that sprite as a single unit with some other drawing method.\n", "full": "void drawPixel(int xPixel, int yPixel, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawRectangle", "description": "Draws a rectangle with one of its vertices at xPixel,yPixel of specified width and height in the palette color corresponding to index color.\n", "full": "void drawRectangle(int xPixel, int yPixel, int width, int height, uint8 color, SPRITE::Mode mode = SPRITE::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawString", "description": "Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bd0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, frame 33 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bdA\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n", "full": "void drawString(int xPixel, int yPixel, const string &in text, STRING::Size size = STRING::SMALL,STRING::Mode mode = STRING::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawString", "description": "Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bd0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, frame 33 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bdA\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n", "full": "void drawString(int xPixel, int yPixel, const string &in text, const jjANIMATION &in animation, STRING::Mode mode = STRING::NORMAL, uint8 param = 0)", "type": "function"}, {"name": "drawString", "description": "Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bd0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, frame 33 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bdA\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n", "full": "void drawString(int xPixel, int yPixel, const string &in text, STRING::Size size, const jjTEXTAPPEARANCE &in appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0)", "type": "function"}, {"name": "drawString", "description": "Draws a string of characters of your choice at position (xPixel, yPixel) on the screen. Unique size values are SMALL, MEDIUM, and LARGE, or you can also specify a different jjANIMATION to grab character sprites from, e.g. one from a custom .j2a file. Whichever animation is chosen should use the same order (and, ideally, number) of frames/characters as the standard font animations, so frame 16 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bd0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, frame 33 is \u00c3\u00af\u00c2\u00bf\u00c2\u00bdA\u00c3\u00af\u00c2\u00bf\u00c2\u00bd, and so on. If it helps, you may think of the overloads with size arguments as shorthand for jjAnimations[jjAnimSets[ANIM::FONT].firstAnim + size].\nThe following options are available for the mode parameter:\n\t\t\t\tNORMAL: Draws a left-aligned string as if drawing chat or player names; | changes the text color after itself, and @ and # are ordinary symbols.\n\t\t\t\tDARK: Draws a left-aligned string with darkened letters, as if unselectable. |, @, and # have no effect.\n\t\t\t\tRIGHTALIGN: Draws a right-aligned string with normal letters. |, @, and # have no effect.\n\t\t\t\tSPIN: Draws a left-aligned string whose letters spin around in place. | has no effect; @ introduces a newline; # makes every letter after it a new color. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tBOUNCE: Draws a left-aligned string whose letters bounce up and down in place. |, @, and # have no effect. The param value determines how close together the letters are: 0 for a fairly ordinary looking string, or 255 for complete chaos, with other numbers falling in-between.\n\t\t\t\tPALSHIFT: Draws a left-aligned string with normal letters whose colors are all shifted param palette entries. A value of 24, for instance, would produce purple text, or 32 would enter into the non-sprite-color portion of the palette. |, @, and # have no effect.\n\t\t\t\n\t\t\tMost of these modes use alignment of STRING::DEFAULT, meaning that values of xPixel higher than 0x4000 have a special meaning in drawing strings, most noticably changing their alignment on the screen. View documentation for jjTEXTAPPEARANCE::align for more detail.\nIn the second prototype of the function, arguments mode and param are split into four arguments appearance, param1, spriteMode and param2 for more customizability: appearance controls several different aspects of text discussed in the jjTEXTAPPEARANCE section, param1 is a multiplier applied to amplitude of text determined by appearance, spriteMode is the sprite mode the characters will be drawn in, and param2 is the sprite mode parameter. Notice that the choice of spriteMode will also determine the effect of using special characters such as # and | in text (if appearance allows them to take effect).\n", "full": "void drawString(int xPixel, int yPixel, const string &in text, const jjANIMATION &in animation, const jjTEXTAPPEARANCE &in appearance, uint8 param1 = 0, SPRITE::Mode spriteMode = SPRITE::PALSHIFT, uint8 param2 = 0)", "type": "function"}, {"name": "drawTile", "description": "Draws a tile of your choice at some position on the screen. This is purely a drawing operation; using it to draw masked tiles to the screen does not create masked areas for players or other objects to interact with. Possible values of tileQuadrant are TOPLEFT, TOPRIGHT, BOTTOMLEFT, BOTTOMRIGHT, and (default) ALLQUADRANTS.\n", "full": "void drawTile(int xPixel, int yPixel, uint16 tile, TILE::Quadrant tileQuadrant = TILE::ALLQUADRANTS)", "type": "function"}], "jjLAYERList": [{"name": "cylinder", "description": "Properties used by this layer when its textureStyle is TEXTURE::CYLINDER, which draws texture as the inside of a horizontal cylinder receding a little ways into the distance.\nbool cylinder.fade, when true, increasingly affects colors closer to the horizon: when jjColorDepth is 16, a semitransparent glowing line appears across the horizon using the RGB color chosen by cylinder.setFadeColor, or if 8, texture colors in the 176\u00c3\u00af\u00c2\u00bf\u00c2\u00bd207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.\nfloat cylinder.fadePositionX and float cylinder.fadePositionY set the location of the center of the horizon, as multiplied by the size of the player's screen. The default values are both 0.5. Changing fadePositionY very far from 0.5 tends to look weird, especially when cylinder.halfSize is true.\nbool cylinder.halfSize, when true, stretches the texture four times across the screen instead of only once and makes the curvature more extreme. The default value is false.\njjPALCOLOR cylinder.getFadeColor() const and void cylinder.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the horizon when cylinder.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n", "full": "cylinder", "type": "property"}, {"name": "hasTileMap", "description": "Layers that contain no tiles at all (other than tile 0) in JCS are saved as defective layers that define size, speed, etc. properties but do not include actual tile maps, meaning that they can never be successfully drawn to the screen. This property is therefore false for those defective layers and true for all other layers.\n", "full": "const bool hasTileMap", "type": "property"}, {"name": "hasTiles", "description": "Simply, whether JJ2 should draw the layer or not. (Defaults to the same value as hasTileMap.) In addition to the layer's tiles, this also controls whether the layer's onDrawLayer# hook, if any, can be called (see jjCANVAS section), but does not impact sprites drawn by the jjDrawSprite family no matter the value of their layerZ arguments. If hasTileMap is false but hasTiles is true, the onDrawLayer# hook will still work but no tiles will be drawn because there will be no tiles to draw.\nAs an alternative to setting hasTiles to false, you can also exclude a layer from the drawing order altogether using jjLayerOrderSet.\n", "full": "bool hasTiles", "type": "property"}, {"name": "height", "description": "The height of the layer in tiles.\n", "full": "const int height", "type": "property"}, {"name": "limitVisibleRegion", "description": "Assuming the layer's tileHeight is false and its ySpeedModel is either LAYERSPEEDMODEL::NORMAL or LAYERSPEEDMODEL::BOTHSPEEDS, whether the layer should be vertically offset some pixels downward (true) or not (false), the exact value depending on the current resolution.\n", "full": "bool limitVisibleRegion", "type": "property"}, {"name": "menu", "description": "Properties used by this layer when its textureStyle is TEXTURE::MENU, which draws the rotating menu effect from the game's main menu. If textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then x/yInnerAutoSpeed control the rotating/zooming speeds respectively.\nbool menu.lightToDark should be set to true if the palette rows are light-to-dark gradients instead of the dark-to-light gradients used by the game's menu palette, but the default value is false.\nuint8 menu.palrow16 and uint8 menu.palrow32 and uint8 menu.palrow256 pick the 16-color-long palette rows used by the three different rotating sublayers, with the smaller numbers corresponding to the further back sublayers. The default values are all 0.\nfloat menu.pivotX and float menu.pivotY are the point that all rotation happens around, as multiplied by the size of the player's screen. The default values are both 0.5.\n", "full": "menu", "type": "property"}, {"name": "reflection", "description": "Properties used by this layer when its textureStyle is TEXTURE::REFLECTION, which draws the bottom part of the screen as a 3D plane stretching into an infinite horizon (similar to warpHorizon). However, the top part of the screen is not drawn to by this layer at all, and the bottom part (the 3D plane) reflects (i.e. vertically mirrors) all the tiles and sprites that had already been drawn to the top part of the screen prior to this layer being drawn. This texture style does not support sprite modes.\nuint8 reflection.distance adjusts how close the 3D plane appears to be to the camera view. The default value is 0.\nuint8 reflection.distortion distorts the reflection away from being a pure vertical mirroring, with higher values being more distorted, as based on the texture image and its internal offset. The default value is 0.\nfloat reflection.fadePositionX sets the location of the horizontal center of the horizon, as multiplied by the size of the player's screen. The default value is 0.5.\nuint8 reflection.tintColor and uint8 reflection.tintOpacity combine to draw a constant semitransparent color over the entire reflective plane, similar to drawing a rectangle with SPRITE::BLEND_NORMAL but better optimized. Their default values are 192 (the middle palette index from the 176\u00c3\u00af\u00c2\u00bf\u00c2\u00bd207 color gradient used by most textured background images) and 0 (no tint at all) respectively.\n", "full": "reflection", "type": "property"}, {"name": "rotationAngle", "description": "Not settable in JCS: the offset of the angle at which this layer rotates while a player is stoned, with a domain of 0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd1023 to be passed to jjSin and jjCos.\nLayers 1\u00c3\u00af\u00c2\u00bf\u00c2\u00bd8 have values -512, -256, 0, 0, 0, 256, 512, and 768, respectively. A script-created jjLAYER will default to 0.\n", "full": "int rotationAngle", "type": "property"}, {"name": "rotationRadiusMultiplier", "description": "Not settable in JCS: the multipler of the distance this layer is offset from its center while rotating while a player is stoned. A value of 0 means the layer will not rotate at all; jjLayers[5].rotationRadiusMultiplier = 0; might therefore be a useful line of code in levels that give Layer 5 speed values to match Layer 4's.\nLayers 1\u00c3\u00af\u00c2\u00bf\u00c2\u00bd8 have values 4, 3, 0, 0, 2, 2, 1, and 1, respectively. A script-created jjLAYER will default to 0.\n", "full": "int rotationRadiusMultiplier", "type": "property"}, {"name": "spriteMode", "description": "The sprite mode and sprite mode parameter used to draw this layer's tiles or texture effect. The default values for all layers are SPRITE::NORMAL and 0, but other possible SPRITE::Mode constants appear with explanations in the appendix below.\nFor non-textured layers, all tiles in this layer whose jjTileType values are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite mode and parameter, while tile types 1, 2, 3, and 6 override this with SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN respectively. Textured layers ignore tile types altogether but have their own caveat: they will be drawn in 8-bit style in order to create a sprite suitable for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is noticeable only when jjColorDepth is 16, textureStyle is WARPHORIZON, TUNNEL, or CYLINDER, and fade is true.\nThese properties do not affect any calls made to any jjCANVAS methods on an onDrawLayer hook attached to this layer. SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No sprite modes other than SPRITE::NORMAL are supported by textured layers using TEXTURE::REFLECTION.\n", "full": "SPRITE::Mode spriteMode", "type": "property"}, {"name": "spriteParam", "description": "The sprite mode and sprite mode parameter used to draw this layer's tiles or texture effect. The default values for all layers are SPRITE::NORMAL and 0, but other possible SPRITE::Mode constants appear with explanations in the appendix below.\nFor non-textured layers, all tiles in this layer whose jjTileType values are 0 (default), 4 (caption), or 5 (heat effect) will be drawn using this sprite mode and parameter, while tile types 1, 2, 3, and 6 override this with SPRITE::TRANSLUCENTTILE, SPRITE::NORMAL, SPRITE::INVISIBLE, and SPRITE::FROZEN respectively. Textured layers ignore tile types altogether but have their own caveat: they will be drawn in 8-bit style in order to create a sprite suitable for drawing with any non-NORMAL and non-CHROMAKEY sprite mode. This is noticeable only when jjColorDepth is 16, textureStyle is WARPHORIZON, TUNNEL, or CYLINDER, and fade is true.\nThese properties do not affect any calls made to any jjCANVAS methods on an onDrawLayer hook attached to this layer. SPRITE::BLEND_DISSOLVE is not supported by textured layers at this time. No sprite modes other than SPRITE::NORMAL are supported by textured layers using TEXTURE::REFLECTION.\n", "full": "uint8 spriteParam", "type": "property"}, {"name": "texture", "description": "For textured layers, which 256\u00c3\u00af\u00c2\u00bf\u00c2\u00bd256 pixel (aka 8\u00c3\u00af\u00c2\u00bf\u00c2\u00bd8 tile) texture is used by the layer, unless textureStyle is TEXTURE::MENU. Defaults to TEXTURE::FROMTILES (previously named LAYER8 after the only layer that could be reasonably textured), meaning whatever the first 64(=8*8) tiles in the layer are. (If the layer has fewer than 64 tiles, this may cause JJ2 to crash.) If jjPIXELMAP::makeTexture was called on this layer, then texture will equal TEXTURE::CUSTOM, but you cannot write that value to this property manually. The other options are listed in the appendix at the bottom of this file.\n", "full": "TEXTURE::Texture texture", "type": "property"}, {"name": "textureSurface", "description": "Whether this layer should be drawn as a texture effect instead of as a regular grid of tiles, and if so, to which parts of the screen it should be drawn. A few enum options are available:\n\t\t\t\t\n\t\t\t\t\tSURFACE::UNTEXTURED: The default, corresponding to leaving the \"Texture mode\" checkbox for this layer unchecked in JCS. The layer will be drawn as a grid of tiles.\n\t\t\t\t\tSURFACE::LEGACY: Used by default by layers in levels (either as part of the main level or imported using jjLayersFromLevel) that have the \"Texture mode\" checkbox checked in JCS and use TEXTURE::WARPHORIZON. When used on layers other than layer 8, this option nevertheless copies many of layer 8's properties when deciding how to draw the texture, and may in some circumstances draw the warp horizon effect to only certain areas of the subscreen. This is included for backwards compatibility but FULLSCREEN should usually be preferable.\n\t\t\t\t\tSURFACE::FULLSCREEN: New in JJ2+. Used by default by layers with the \"Texture mode\" checkbox checked that use any textureStyle other than WARPHORIZON. Draws the texture mode to each player's entire subscreen.\n\t\t\t\t\tSURFACE::INNERWINDOW\n\t\t\t\t\tSURFACE::INNERLAYER: New in JJ2+. The layer will be drawn as some sort of texture effect, but within the same rectangular area that the layer would be drawn were it being drawn as a grid of tiles instead. This allows you to have multiple texture effects on-screen at once or do other cool tricks. The inner speed properties will be used for angling the texture within the layer's area. The difference between the two is that INNERWINDOW acts as if the texture were being drawn to the full size of the subscreen, and provides a layer-sized window to a portion of that full screen effect, whereas INNERLAYER exclusively uses the origin and dimensions of the layer itself. For example, consider a warp horizon texture effect drawn to the top half of the subscreen with fadePositionY at 0.5. Using INNERWINDOW, the fade effect will be drawn halfway down the subscreen, at the bottom of the layer. Using INNERLAYER, the fade effect will be drawn halfway down the layer, one quarter of the way down the subscreen. On tiled dimensions (using tileHeight and/or tileWidth), there is no difference between INNERWINDOW and INNERLAYER, and if both dimensions are tiled, there is no difference between either and FULLSCREEN, except for the use of the inner speed properties.\n\t\t\t\t\n", "full": "SURFACE::Surface textureSurface", "type": "property"}, {"name": "textureStyle", "description": "The visual effect used by a layer for which textureSurface is not set to SURFACE::UNTEXTURED, defaulting to whichever is specified in the layer's texture dropdown box in JCS. Options are TEXTURE::CYLINDER, TEXTURE::MENU, TEXTURE::REFLECTION, TEXTURE::TILEMENU, TEXTURE::TUNNEL, TEXTURE::WAVE, and TEXTURE::WARPHORIZON (the only such option available in vanilla JJ2)\nFor all cases but MENU and TILEMENU, the texture's offset is determined by combining the speed, autoSpeed, and offset properties of this layer, and/or of jjLayers[5] if the speedModel properties equal LAYERSPEEDMODEL::LAYER8, or by the various inner speed properties if textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW.\n", "full": "TEXTURE::Style textureStyle", "type": "property"}, {"name": "tileHeight", "description": "Whether the layer should be vertically tiled, as seen in the JCS Layer Properties window.\n", "full": "bool tileHeight", "type": "property"}, {"name": "tileWidth", "description": "Whether the layer should be horizontally tiled, as seen in the JCS Layer Properties window.\nSetting this to true for a layer that is not saved with Tile Width checked in JCS may lead to unpredictable effects if the layer's width and widthReal are not equal. If you wish to turn it on partway through the level, it is best to check Tile Width in JCS and then disable it in onLevelLoad.\n", "full": "bool tileWidth", "type": "property"}, {"name": "tileMenu", "description": "Properties used by this layer when its textureStyle is TEXTURE::TILEMENU, which draws the rotating menu effect from the game's main menu, but with different graphics. texture is used for the frontmost rotating sublayer, then the middle sublayer is filled with the 2\u00c3\u00af\u00c2\u00bf\u00c2\u00bd2 square set of tiles in the top left corner of layer 4, from 0,0 to 1,1, and the back sublayer is filled with tile 0,2 in layer 4. If textureSurface is SURFACE::INNERLAYER or SURFACE::INNERWINDOW, then x/yInnerAutoSpeed control the rotating/zooming speeds respectively.\nbool tileMenu.fullSize sets whether the rotating sublayers are drawn at half size (false, default) or full size (true).\nfloat tileMenu.pivotX and float tileMenu.pivotY are the point that all rotation happens around, as multiplied by the size of the player's screen. The default values are both 0.5.\n", "full": "tileMenu", "type": "property"}, {"name": "tunnel", "description": "Properties used by this layer when its textureStyle is TEXTURE::TUNNEL, which draws texture as a series of concentric, ever-smaller circles receding into the distance, though it is repeated horizontally only once..\nbool tunnel.fade, when true, increasingly affects colors farther into the background: when jjColorDepth is 16, a glowing circle appears in the tunnel's center using the RGB color chosen by tunnel.setFadeColor, or if 8, texture colors in the 176\u00c3\u00af\u00c2\u00bf\u00c2\u00bd207 range are moved ever closer to 207 depending on their proximity to the center. The default value is true.\nfloat tunnel.fadePositionX and float tunnel.fadePositionY set the location of the center of the tunnel, clamped to a 0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd1 range, as multiplied by the size of the player's screen. The default values are both 0.5.\nbool tunnel.spiral, when true, makes the concentric circles gradually spiral inwards into the distance. The default value is false.\njjPALCOLOR tunnel.getFadeColor() const and void tunnel.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the center when tunnel.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n", "full": "tunnel", "type": "property"}, {"name": "warpHorizon", "description": "Properties used by this layer when its textureStyle is TEXTURE::WARPHORIZON, which draws this layer as two horizontal 3D planes, repeating the same texture several times and stretching to an infinite horizon, with some amount of dithering/antialiasing.\nbool warpHorizon.fade, when true, increasingly affects colors closer to the horizon: when jjColorDepth is 16, a thick glowing line appears across the horizon using the RGB color chosen by warpHorizon.setFadeColor, or if 8, texture colors in the 176\u00c3\u00af\u00c2\u00bf\u00c2\u00bd207 range are moved ever closer to 207 depending on their proximity to the horizon. The default value is true.\nfloat warpHorizon.fadePositionX and float warpHorizon.fadePositionY set the location of the center of the horizon, as multiplied by the size of the player's screen. The default values are both 0.5.\nbool warpHorizon.stars, when true, draws a series of little white specks appear across the horizon. The default value is false.\njjPALCOLOR warpHorizon.getFadeColor() const and void warpHorizon.setFadeColor(jjPALCOLOR) read and write the RGB components of the color drawn over the horizon when warpHorizon.fade is true and jjColorDepth is 16. The default value is 0,0,0.\n", "full": "warpHorizon", "type": "property"}, {"name": "wave", "description": "Properties used by this layer when its textureStyle is TEXTURE::WAVE, which draws texture as a repeating, unrotated 2D image, but applies sine wave distortions at regular intervals. The properties all affect the positions and dimensions of those sine wave distortions.\nfloat wave.amplitudeX and float wave.amplitudeY set the distortions' amplitudes as multiples of the texture's width and height (256 pixels). The default values are both 0.5, meaning 128 pixels.\nbool wave.distortionAngle effectively rotates the movement of the two distortions ninety degrees. The default value is false.\nuint8 wave.wavelengthX and uint8 wave.wavelengthY set the lengths of the distortions, with powers-of-two-minus-one such as 255 being recommended. Their default values are 0.\nint8 wave.waveSpeed moves the distortions along the surface of the texture, independent of the texture's movement as set by the regular or inner speed properties. Both distortions move at the same rate as determined by this property's absolute value, with the directions resulting from the sign of this property combined with and wave.distortionAngle. The default value is 0.\n", "full": "wave", "type": "property"}, {"name": "width", "description": "The width of the layer in tiles. Normally these two values will be equal, but they may differ on layers that were saved with the \"Tile Width\" checkbox checked in their level editors. The reason for this is that layers are not stored as arrays of tile IDs but rather as arrays of \"word\" IDs, where each word is defined in the \"tile cache\" as a row of four adjacent tile IDs. In order to properly tile, therefore, a layer whose width is not a multiple of four is expanded by the level editor to a widthReal that is the lowest common multiple of 4 and width, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.\n", "full": "const int width", "type": "property"}, {"name": "widthReal", "description": "The width of the layer in tiles. Normally these two values will be equal, but they may differ on layers that were saved with the \"Tile Width\" checkbox checked in their level editors. The reason for this is that layers are not stored as arrays of tile IDs but rather as arrays of \"word\" IDs, where each word is defined in the \"tile cache\" as a row of four adjacent tile IDs. In order to properly tile, therefore, a layer whose width is not a multiple of four is expanded by the level editor to a widthReal that is the lowest common multiple of 4 and width, e.g. 8 for 8, 36 for 9, 20 for 10, 44 for 11, and 12 for 12.\n", "full": "const int widthReal", "type": "property"}, {"name": "widthRounded", "description": "The width of the layer in \"words,\" always equal to (jjLAYER::widthReal + 3) / 4.\n", "full": "const int widthRounded", "type": "property"}, {"name": "xAutoSpeed", "description": "The auto speed of the layer, as seen in the JCS Layer Properties window.\n", "full": "float xAutoSpeed", "type": "property"}, {"name": "yAutoSpeed", "description": "The auto speed of the layer, as seen in the JCS Layer Properties window.\n", "full": "float yAutoSpeed", "type": "property"}, {"name": "xInnerAutoSpeed", "description": "Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n", "full": "float xInnerAutoSpeed", "type": "property"}, {"name": "yInnerAutoSpeed", "description": "Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n", "full": "float yInnerAutoSpeed", "type": "property"}, {"name": "xInnerSpeed", "description": "Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n", "full": "float xInnerSpeed", "type": "property"}, {"name": "yInnerSpeed", "description": "Not settable in JCS, defaulting to 0: substitute properties for setting the speeds of the texture effect inside a layer whose textureSurface property equals SURFACE::INNERLAYER or SURFACE::INNERWINDOW. (No effect for any other textureSurface value.) The regular speed and auto speed properties (among others) determine the location in the level of the layer as a rectangle, and these inner speed properties determine how the texture effect is drawn inside that rectangle.\n", "full": "float yInnerSpeed", "type": "property"}, {"name": "xOffset", "description": "Not settable in JCS: constant pixel values added to the position of the layer, regardless of its speed.\n", "full": "float xOffset", "type": "property"}, {"name": "yOffset", "description": "Not settable in JCS: constant pixel values added to the position of the layer, regardless of its speed.\n", "full": "float yOffset", "type": "property"}, {"name": "xSpeed", "description": "The speed of the layer, as seen in the JCS Layer Properties window.\n", "full": "float xSpeed", "type": "property"}, {"name": "ySpeed", "description": "The speed of the layer, as seen in the JCS Layer Properties window.\n", "full": "float ySpeed", "type": "property"}, {"name": "xSpeedModel", "description": "Not settable in JCS: specifies how the layer's position on screen should be determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed properties, the resolution, and so on. There are several options available for the enum, as follows (for each axis):\n\t\t\t\t\n\t\t\t\t\tLAYERSPEEDMODEL::NORMAL: The default. A non-textured layer's position on this axis will be based on the layer's auto speed for this axis, if non-zero, or otherwise its regular speed. Except for jjLayers[8], only the layers that use this mode for both axes will ever be displayed when Low Detail is enabled.\n\t\t\t\t\tLAYERSPEEDMODEL::LAYER8: The default for jjLayers[8] only, a pair of odd behaviors included for backwards compatibility. A non-textured layer with this setting will ignore all speed and offset settings completely and be tied to the top/left side of the screen. A textured layer will instead base its position for this axis on that of jjLayers[5].\n\t\t\t\t\tLAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this axis will both be used in determining the position: for example, a layer of clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to scroll constantly to the left but also move left or right in response to the player's camera.\n\t\t\t\t\tLAYERSPEEDMODEL::FROMSTART: Similar to LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the resolution and its speeds, and the top/left side of a layer will only be flush with the top/left side of the level if the layer's speed is 1 or the resolution is 320\u00c3\u00af\u00c2\u00bf\u00c2\u00bd200. Using this setting forces the layer's origin to be at the top/left side of the level instead of varying by the resolution. Ignores limitVisibleRegion.\n\t\t\t\t\tLAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed properties, and instead ensures that the full extent of this layer will be visible and no blank space outside of it will be shown. The top/left side of the layer will be visible at the top/left edge of the level, and the bottom/right side of the layer will be visible at the bottom/right edge of the level, and the layer will scroll smoothly between those two extremes. Thus, the taller/wider the layer, the faster it will move, though with the exact relative speed dependent on the resolution and level size. If the layer is smaller than the window on this axis, this will effectively result in a negative relative speed.\n\t\t\t\t\tLAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed properties on this axis as multipliers of the current camera size, rather than camera position. When the camera is at the top/left of the level, the layer will be positioned at the camera size on this axis multiplied by the regular speed, or the auto speed instead when the camera is at the bottom/right, and the layer will scroll smoothly between those two extremes. For example, if the screen is 600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the layer will be 450 pixels from the top of the screen when the camera is at the top of the level, and 300 pixels from the top of the screen when the camera is at the bottom of the level. Ignores limitVisibleRegion.\n\t\t\t\t\nNote that all mentions of \"textured\" layers in the above descriptions refer to when textureSurface is LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL, WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied to whatever position is determined by the rules above. If such a layer uses MENU or TILEMENU instead, then its speed models are ignored altogether.\nFor INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they would be for non-textured layers for determining the layer's position within the level, and the inner speed properties are used for determining the texture's position within the layer.\n", "full": "LAYERSPEEDMODEL::LayerSpeedModel xSpeedModel", "type": "property"}, {"name": "ySpeedModel", "description": "Not settable in JCS: specifies how the layer's position on screen should be determined, based (or not) on its xSpeed/ySpeed and xAutoSpeed/yAutoSpeed properties, the resolution, and so on. There are several options available for the enum, as follows (for each axis):\n\t\t\t\t\n\t\t\t\t\tLAYERSPEEDMODEL::NORMAL: The default. A non-textured layer's position on this axis will be based on the layer's auto speed for this axis, if non-zero, or otherwise its regular speed. Except for jjLayers[8], only the layers that use this mode for both axes will ever be displayed when Low Detail is enabled.\n\t\t\t\t\tLAYERSPEEDMODEL::LAYER8: The default for jjLayers[8] only, a pair of odd behaviors included for backwards compatibility. A non-textured layer with this setting will ignore all speed and offset settings completely and be tied to the top/left side of the screen. A textured layer will instead base its position for this axis on that of jjLayers[5].\n\t\t\t\t\tLAYERSPEEDMODEL::BOTHSPEEDS: The layer's speed and auto speed settings for this axis will both be used in determining the position: for example, a layer of clouds in the background might have an xSpeed of 0.2, an xAutoSpeed of 0.25, and a xSpeedModel of LAYERSPEEDMODEL::BOTHSPEEDS, which would cause the layer to scroll constantly to the left but also move left or right in response to the player's camera.\n\t\t\t\t\tLAYERSPEEDMODEL::FROMSTART: Similar to LAYERSPEEDMODEL::BOTHSPEEDS. Normally a layer's top/left origin depends on the resolution and its speeds, and the top/left side of a layer will only be flush with the top/left side of the level if the layer's speed is 1 or the resolution is 320\u00c3\u00af\u00c2\u00bf\u00c2\u00bd200. Using this setting forces the layer's origin to be at the top/left side of the level instead of varying by the resolution. Ignores limitVisibleRegion.\n\t\t\t\t\tLAYERSPEEDMODEL::FITLEVEL: Ignores the speed and auto speed properties, and instead ensures that the full extent of this layer will be visible and no blank space outside of it will be shown. The top/left side of the layer will be visible at the top/left edge of the level, and the bottom/right side of the layer will be visible at the bottom/right edge of the level, and the layer will scroll smoothly between those two extremes. Thus, the taller/wider the layer, the faster it will move, though with the exact relative speed dependent on the resolution and level size. If the layer is smaller than the window on this axis, this will effectively result in a negative relative speed.\n\t\t\t\t\tLAYERSPEEDMODEL::SPEEDMULTIPLIERS: Treats the layer's speed and auto speed properties on this axis as multipliers of the current camera size, rather than camera position. When the camera is at the top/left of the level, the layer will be positioned at the camera size on this axis multiplied by the regular speed, or the auto speed instead when the camera is at the bottom/right, and the layer will scroll smoothly between those two extremes. For example, if the screen is 600 pixels tall and ySpeed is 0.75 and yAutoSpeed is 0.5, then the top of the layer will be 450 pixels from the top of the screen when the camera is at the top of the level, and 300 pixels from the top of the screen when the camera is at the bottom of the level. Ignores limitVisibleRegion.\n\t\t\t\t\nNote that all mentions of \"textured\" layers in the above descriptions refer to when textureSurface is LEGACY or FULLSCREEN. In these cases, if textureStyle is WARPHORIZON, TUNNEL, WAVE, CYLINDER, or REFLECTION, then its auto speed will be additionally applied to whatever position is determined by the rules above. If such a layer uses MENU or TILEMENU instead, then its speed models are ignored altogether.\nFor INNERLAYER and INNERWINDOW layers, the speed models are evaluated just as they would be for non-textured layers for determining the layer's position within the level, and the inner speed properties are used for determining the texture's position within the layer.\n", "full": "LAYERSPEEDMODEL::LayerSpeedModel ySpeedModel", "type": "property"}, {"name": "generateSettableTileArea", "description": "Makes all tiles in the range of the rectangle with its top left corner at xTile,yTile and specified width and height possible to use tileSet on without the potential consequence of changing other occurrences of the tile in the level due to tile cache. The zero-argument version of the method applies to the entire layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and height to height. Does nothing if hasTileMap is false.\n", "full": "void generateSettableTileArea()", "type": "function"}, {"name": "generateSettableTileArea", "description": "Makes all tiles in the range of the rectangle with its top left corner at xTile,yTile and specified width and height possible to use tileSet on without the potential consequence of changing other occurrences of the tile in the level due to tile cache. The zero-argument version of the method applies to the entire layer, or to be precise, passes 0,0 to xTile,yTile, widthReal to width, and height to height. Does nothing if hasTileMap is false.\n", "full": "void generateSettableTileArea(int xTile, int yTile, int width, int height)", "type": "function"}, {"name": "getXPosition", "description": "Gets the last position of this layer for the specified jjPLAYER. (The results of calling this method for players for whom isLocal is false are undefined.) For example, given a jjPLAYER@ object play, you could attach water to the top of layer 7 by continually calling jjSetWaterLevel(play.cameraY - jjLayers[7].getYPosition(play), true); This takes into account everything that could possibly reposition a layer, including its speeds and offsets, the resolution and max resolution, the player's camera position, and whether the player is stoned.\nNote that these values are not updated for layers while they are not drawn to the screen on account of having been left out in the last call to jjLayerOrderSet.\n", "full": "float getXPosition(const jjPLAYER &in play) const", "type": "function"}, {"name": "getYPosition", "description": "Gets the last position of this layer for the specified jjPLAYER. (The results of calling this method for players for whom isLocal is false are undefined.) For example, given a jjPLAYER@ object play, you could attach water to the top of layer 7 by continually calling jjSetWaterLevel(play.cameraY - jjLayers[7].getYPosition(play), true); This takes into account everything that could possibly reposition a layer, including its speeds and offsets, the resolution and max resolution, the player's camera position, and whether the player is stoned.\nNote that these values are not updated for layers while they are not drawn to the screen on account of having been left out in the last call to jjLayerOrderSet.\n", "full": "float getYPosition(const jjPLAYER &in play) const", "type": "function"}, {"name": "maskedHLine", "description": "Returns true if any pixel from xPixel,yPixel to xPixel+lineLength,yPixel is masked. Returns false if hasTileMap is false.\n", "full": "bool maskedHLine(int xPixel, int lineLength, int yPixel) const", "type": "function"}, {"name": "maskedPixel", "description": "Returns true if pixel xPixel,yPixel is masked. Returns false if hasTileMap is false.\n", "full": "bool maskedPixel(int xPixel, int yPixel) const", "type": "function"}, {"name": "maskedTopVLine", "description": "If any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked, returns the height of the topmost masked pixel relative to yPixel. (For example, if xPixel,yPixel+2 is masked but +1 and +0 weren't, the function returns 2.) If none of the pixels are masked, returns lineLength+1. Used for detecting inclines and the like. Returns 0 if hasTileMap is false.\n", "full": "int maskedTopVLine(int xPixel, int yPixel, int lineLength) const", "type": "function"}, {"name": "maskedVLine", "description": "Returns true if any pixel from xPixel,yPixel to xPixel,yPixel+lineLength is masked. Returns false if hasTileMap is false.\n", "full": "bool maskedVLine(int xPixel, int yPixel, int lineLength) const", "type": "function"}, {"name": "setXSpeed", "description": "Changes the X or Y speed. Unlike the basic properties like xSpeed and yAutoSpeed, these functions will ensure that the layer remains in the same position it was before its speeds were changed, and can therefore be much more useful.\n", "full": "void setXSpeed(float newspeed, bool newSpeedIsAnAutoSpeed)", "type": "function"}, {"name": "setYSpeed", "description": "Changes the X or Y speed. Unlike the basic properties like xSpeed and yAutoSpeed, these functions will ensure that the layer remains in the same position it was before its speeds were changed, and can therefore be much more useful.\n", "full": "void setYSpeed(float newspeed, bool newSpeedIsAnAutoSpeed)", "type": "function"}, {"name": "tileGet", "description": "Returns the current tile at location xTile,yTile. If the tile is an animated tile, this function will return the tile ID for that animated tile instead of the current frame. Returns 0 if hasTileMap is false.\n", "full": "uint16 tileGet(int xTile, int yTile) const", "type": "function"}, {"name": "tileSet", "description": "Sets the current tile at location xTile,yTile to be newTile. The same change will be applied to all instances of the same four-tile word that appear elsewhere in the level unless the tiles had had generateSettableTileArea used on them prior to the change. Returns newTile, or 0 (and does nothing) if hasTileMap is false.\n", "full": "uint16 tileSet(int xTile, int yTile, uint16 newTile)", "type": "function"}], "jjTEXTAPPEARANCEList": [{"name": "align", "description": "Horizontal alignment of text. This can take values of DEFAULT, LEFT, CENTER or RIGHT.\nWhereas LEFT, CENTER and RIGHT should be self-explanatory, DEFAULT is the value JJ2 used for all strings originally, defined as follows: if xPixel is less than 0x4000, the string will have its left side aligned to the left side of the screen or layer. If in the range of 0x4000 to 0xFFFF, the string will be center-aligned relative to 0x8000, so for instance 0x8020 would align the center of the string to 0x20 pixels right of the center of the screen. Finally, if xPixel is greater than or equal to 0x10000, it will be drawn with its right side aligned to the right side of the screen instead, with higher values moving farther left. Note that these special cases currently apply only for drawing to the screen; the use of values of 0x4000 or higher for onDrawLayer# hooks is currently undefined.\n", "full": "STRING::Alignment align", "type": "property"}, {"name": "at", "description": "Treatment of the at ('@') character. If it's SPECIALSIGN, at will begin a new line of text 20 pixels below the previous one.\n", "full": "STRING::SignTreatment at", "type": "property"}, {"name": "caret", "description": "Treatment of the caret ('^') character. If it's SPECIALSIGN, caret will be displayed as infinity signs.\n", "full": "STRING::SignTreatment caret", "type": "property"}, {"name": "hash", "description": "Treatment of the hash ('#') character. If it's SPECIALSIGN, characters following hash will use a pattern of colors (or other parameters depending on sprite mode of the string).\n", "full": "STRING::SignTreatment hash", "type": "property"}, {"name": "monospace", "description": "Usually strings achieve naturally looking spacing between characters by placing the next character at character width + spacing relative to the previous one. When this property is set to true, character width is disregarded, and placement is determined only by spacing, i.e. is constant throughout the string (unless modified by special function of section sign). Because, by default, spacing is a low value, you may want to modify it if you use this property. This property is compatible with section, although the result of changing the spacing partway through a string may look somewhat bizarre.\n", "full": "bool monospace", "type": "property"}, {"name": "newline", "description": "Treatment of the line feed character (created by the escape sequence '\\n' in AngelScript). If it's either DISPLAYSIGN or SPECIALSIGN, line feed will begin a new line of text below the previous one, with vertical spacing varying depending on font size.\n", "full": "STRING::SignTreatment newline", "type": "property"}, {"name": "pipe", "description": "Treatment of the pipe ('|') character. If it's SPECIALSIGN, pipe will change text color (or other parameter depending on sprite mode of the string) of the following characters.\n", "full": "STRING::SignTreatment pipe", "type": "property"}, {"name": "section", "description": "Treatment of the section sign ('\u00c3\u00af\u00c2\u00bf\u00c2\u00bd') character. If it's SPECIALSIGN, section sign will use ASCII code of the directly following character to determine spacing used for further text.\n", "full": "STRING::SignTreatment section", "type": "property"}, {"name": "skipInitialHash", "description": "Whether or not to ignore the first character of a string if it's a hash ('#'). The ignored hash will not be displayed or otherwise affect the string. If the string is preceded by more than one hash, all but the first one will be displayed.\nThis property is provided mainly for compatibility with several STRING::Mode values, as it's used by JJ2 wherever strings are meant to be conditionally colored, such as menu items.\n", "full": "bool skipInitialHash", "type": "property"}, {"name": "spacing", "description": "Default spacing between characters, in pixels. If section is set to SPECIALSIGN, this value only applies until the first section sign character is found, as the effect of the section sign is absolute rather than relative to this property.\n", "full": "int spacing", "type": "property"}, {"name": "tilde", "description": "Treatment of the tilde ('~') character. If it's SPECIALSIGN, tilde will cancel the special effect of hash or, if it's already inactive, it will change the color (or other parameter depending on sprite mode) to default.\n", "full": "STRING::SignTreatment tilde", "type": "property"}, {"name": "xAmp", "description": "Horizontal and vertical amplitudes of text movement.\n", "full": "int xAmp", "type": "property"}, {"name": "yAmp", "description": "Horizontal and vertical amplitudes of text movement.\n", "full": "int yAmp", "type": "property"}], "jjPLAYERDRAWList": [{"name": "airboardBouncingMotion", "description": "When true, causes the player sprite (and some other effects) to rise and fall in a gradual sine wave motion. By default, only true for rabbits whose jjPLAYER::fly is FLIGHT::AIRBOARD.\n", "full": "bool airboardBouncingMotion", "type": "property"}, {"name": "airboardPuff", "description": "When true, causes little brown explosions to appear behind the player at regular intervals. By default, only true for rabbits whose jjPLAYER::fly is FLIGHT::AIRBOARD.\n", "full": "bool airboardPuff", "type": "property"}, {"name": "angle", "description": "What angle to draw the player sprite at, in the manner of the angle parameter of jjCANVAS::drawRotatedSprite. (Only the player sprite itself is affected by this, none of the other elements potentially being drawn.) By default always 0 unless jjPLAYER::poleSpin has been called with both xSpeed and ySpeed using non-zero values.\n", "full": "int angle", "type": "property"}, {"name": "curFrame", "description": "The current sprite number, as an index to jjAnimFrames, that should be drawn for this player. Changing this is a purely visual effect and does not affect sprite-based collision with pickups, enemies, and so on. By default, equals the same as jjPLAYER::curFrame.\n", "full": "uint curFrame", "type": "property"}, {"name": "flag", "description": "When not set to TEAM::NEUTRAL, this property causes a flag of the specified color to be drawn behind the player, with its direction based on xScale/yScale. If the player is carrying a flag in CTF, DCTF, or Flag Run, this value will be TEAM::BLUE or TEAM::RED as appropriate. Setting this property to TEAM::GREEN or TEAM::YELLOW is also allowed, but the appearance of those flags is somewhat of a placeholder and may change in future JJ2+ revisions if they ever become important for actual gameplay reasons.\n", "full": "TEAM::COLOR flag", "type": "property"}, {"name": "gunFlash", "description": "When true, a sprite of a small flash is drawn coming out of the player's gun. Has no effect when angle does not equal 0 or either xScale or yScale do not equal 1 or -1. By default, only true immediately after the player has fired.\n", "full": "bool gunFlash", "type": "property"}, {"name": "invincibility", "description": "When true, a series of blue circles are drawn following the player around. By default, only true when jjPLAYER::invincibility is greater than 0.\n", "full": "bool invincibility", "type": "property"}, {"name": "layer", "description": "What layer to draw the player (and related elements) in front of. By default always 4.\n", "full": "int layer", "type": "property"}, {"name": "light", "description": "The intensity of light emitted by the player. By default, equals the same as jjPLAYER::light.\n\t\t\t\n", "full": "int8 light", "type": "property"}, {"name": "lightType", "description": "The type of light emitted by the player. Possible values are NONE, NORMAL, POINT, POINT2, FLICKER, BRIGHT, LASERBEAM, LASER, RING, RING2, and PLAYER. By default, equals the same as jjPLAYER::lightType.\n", "full": "LIGHT::Type lightType", "type": "property"}, {"name": "name", "description": "When true, the string jjPLAYER::name will be drawn above the player's head. By default, true in non-local games when jjPLAYER::frozen is 0 and the F8 key has not been pressed.\n", "full": "bool name", "type": "property"}, {"name": "player", "description": "The player being drawn. This is a read-only property, so you can modify properties of the player but you cannot change which jjPLAYER object the jjPLAYERDRAW object has a handle to.\n", "full": "jjPLAYER@ player", "type": "property"}, {"name": "shield", "description": "Whether each of the possible shields should be drawn around the player: for example, you can set shield[SHIELD::FIRE] = true; to draw the fire shield. Applicable options in the SHIELD::Shield enum are FIRE, BUBBLE/WATER, LIGHTNING/PLASMA, and LASER. By default, each is only true if it is the value of jjPLAYER::shieldType, the player is non-local or jjPLAYER::shieldTime is greater than -128, and jjPLAYER::frozen is 0.\n", "full": "bool shield[SHIELD::Shield]", "type": "property"}, {"name": "sprite", "description": "Determines whether the player sprite should be drawn at all. By default, usually true but sometimes false when the player is flashing from being hurt or from timing out in an online server.\n", "full": "bool sprite", "type": "property"}, {"name": "spriteMode", "description": "What sprite mode to use for the player. By default, equals the same as jjPLAYER::spriteMode, or SPRITE::FROZEN if jjPLAYER::frozen is non-zero.\n", "full": "SPRITE::Mode spriteMode", "type": "property"}, {"name": "spriteParam", "description": "A sprite mode parameter further specifying how the player should be drawn. By default, equals the same as jjPLAYER::spriteParam.\n", "full": "uint8 spriteParam", "type": "property"}, {"name": "sugarRush", "description": "When true, spriteMode and spriteParam will be ignored in favor of drawing the player in random flashing colors with lots of little star-shaped particles appearing nearby. By default, true when the player genuinely has a sugar rush but jjPLAYER::frozen is 0.\n", "full": "bool sugarRush", "type": "property"}, {"name": "trail", "description": "When true, a glowing white trail follows the player around. By default, true when the player is moving at a decent speed.\n", "full": "bool trail", "type": "property"}, {"name": "xOffset", "description": "Allows you to draw most elements of the player at some relative position offset from the player's actual position. This is more powerful and more customizable than airboardBouncingMotion, which in particular does not modify the position the player's name is drawn at. By default, both properties equal 0.\n", "full": "float xOffset", "type": "property"}, {"name": "yOffset", "description": "Allows you to draw most elements of the player at some relative position offset from the player's actual position. This is more powerful and more customizable than airboardBouncingMotion, which in particular does not modify the position the player's name is drawn at. By default, both properties equal 0.\n", "full": "float yOffset", "type": "property"}, {"name": "xScale", "description": "What scale to draw the player at, in the manner of the corresponding parameters of jjCANVAS::drawResizedSprite. By default, xScale will equal 1 or -1 depending on jjPLAYER::direction, and yScale will equal 1 if jjPLAYER::antiGrav is false or -1 if it is true.\n", "full": "float xScale", "type": "property"}, {"name": "yScale", "description": "What scale to draw the player at, in the manner of the corresponding parameters of jjCANVAS::drawResizedSprite. By default, xScale will equal 1 or -1 depending on jjPLAYER::direction, and yScale will equal 1 if jjPLAYER::antiGrav is false or -1 if it is true.\n", "full": "float yScale", "type": "property"}], "jjANIMSETList": [{"name": "firstAnim", "description": "ID of the first animation in the set, to be used with the jjAnimations array.\n", "full": "uint firstAnim", "type": "property"}, {"name": "allocate", "description": "Creates space for an animation set with the number of animations equal to length of frameCounts, each with a number of frames determined by the corresponding frameCounts array element.\n", "full": "jjANIMSET@ allocate(const array<uint> &in frameCounts)", "type": "function"}, {"name": "load", "description": "Loads animation set specified by fileSetID from a j2a file specified by filename. Using the default value of fileSetID results in loading the set appropriate for the jjANIMSET it's called on. If filename is left empty, it deduces the file name from fileSetID, using either Anims.j2a or plus.j2a.\nBy default, any new animations and animframes begin at the first unused entries in jjAnimations and jjAnimFrames respectively. By passing positive values to the firstAnimToOverwrite and/or firstFrameToOverwrite arguments, however, you may choose specific animations and/or animframes to overwrite instead.\n", "full": "jjANIMSET@ load(uint fileSetID = 2048, const string &in filename = \"\", int firstAnimToOverwrite = -1, int firstFrameToOverwrite = -1)", "type": "function"}, {"name": "load", "description": "Loads animation set defined in a sprite sheet image. This method overload is an alternate way to turn your external graphics into JJ2 sprites compared to the above overload which reads from an external j2a file instead. Loading from a sprite sheet is designed to be easier, though less flexible.\nFor example, suppose you want to replace the sprites used by the Helmut enemy, which is a simple case that only uses two animations: standing and walking. We'll use these public domain sprites from opengameart.org. (For best results, you should generally use images that have been manually drawn or edited to use the standard JJ2 sprite palette or else the palette of the specific level you're using the sprites in, but the jjPIXELMAP constructor's automatic color reduction for 24- or 32-bit images is fine for an example.)\n\n\t\t\tvoid onLevelLoad() {\n\tjjAnimSets[ANIM::HELMUT].load(\n\t\tjjPIXELMAP(\"Margery.png\"),\n\t\tframeWidth: 24,\n\t\tframeHeight: 26,\n\t\tframeSpacingX: 2,\n\t\tframeSpacingY: 2,\n\t\tstartY: 26,\n\t\tfirstAnimToOverwrite: jjAnimSets[ANIM::HELMUT]\n\t);\n\tjjObjectPresets[OBJECT::HELMUT].determineCurFrame();\n}\nThe spriteSheet argument is self-explanatory, and is primarily intended for use in combination with the jjPIXELMAP constructor from filename, as above, so you can load an external PNG image and convert it to an animation set. The sprite sheet must take the form of a grid of equally-sized rectangles, where each row is a separate animation for this animation set and each cell is a separate frame for that animation. A completely blank/transparent cell indicates the end of the animation, so in the above example image, the first animation (standing) has only one frame but the second animation (walking) has six frames. The number of animations in the animation set is inferred from the height of the image in conjunction with the other arguments.\nframeWidth and frameHeight specify the rectangular areas used by every frame in every animation in the sprite sheet. The largest and smallest sprites in your sheet must each have the same area devoted to them. However, JJ2+ will trim the transparent pixels from around the edges of every frame: in the above example, none of the sprites extend all the way to the left and right sides of their rectangles, so none of the resulting jjANIMFRAME objects will be the full 24 pixels wide.\n", "full": "jjANIMSET@ load(const jjPIXELMAP &in spriteSheet, uint frameWidth, uint frameHeight, uint frameSpacingX = 0, uint frameSpacingY = 0, uint startX = 0, uint startY = 0, const array<int> &in coldSpotYOffsets = array<int>(), int firstAnimToOverwrite = -1, int firstFrameToOverwrite = -1)", "type": "function"}], "jjANIMATIONList": [{"name": "firstFrame", "description": "ID of the first frame of the animation, to be used with the jjAnimFrames array.\n", "full": "uint firstFrame", "type": "property"}, {"name": "fps", "description": "This property corresponds to the \"FPS\" number for animations in Jazz Sprite Dynamite, but that name is only a guess, because its value is never referenced by JJ2 at all. Most commonly equals 10.\n", "full": "int16 fps", "type": "property"}, {"name": "frameCount", "description": "The number of frames used by the animation.\n", "full": "uint16 frameCount", "type": "property"}, {"name": "save", "description": "Saves all the frames of this animation to an animated GIF image file on the local computer and returns whether successful. The image will be saved with whatever palette is passed to this method, by default the game's current palette. Each frame's delay time will be set to jjANIMATION::fps.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".gif\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjPIXELMAP::save and jjSTREAM::save).\n", "full": "bool save(const string &in filename, const jjPAL &in palette = jjPalette) const", "type": "function"}, {"name": "load", "description": "Reads all frames of a GIF image on the local computer and outputs them as a series of jjANIMFRAME objects, and adjusts this animation's firstFrame and frameCount properties to match the new frames. Each frame in the animation will be trimmed to exclude fully transparent rows/columns on the edges. Returns true on success or false if the filename cannot be found or is in some way not a valid GIF.\nEach resulting sprite will use the same palette indices as the GIF itself. The GIF's own palette will be ignored. For the easiest to understand results, then, you should use a GIF using an unoptimized palette that is identical or similar (e.g. day vs. night versions) to the one the level is using, or grayscale for use with SPRITE::ALPHAMAP. Alternatively, you may want to load the GIF's actual palette using jjPAL::load.\njjANIMFRAME::coldSpotY is only relevant to certain objects affected by gravity, which use it to determine how far off the ground their sprites should be. For the first frame, coldSpotY will be set to the bottom of the opaque pixels, and each subsequent sprite will have its coldSpotY at the same distance from its hotSpotY as in the first sprite. If this automatic guess isn't quite right for your sprites, and you want to adjust these numbers so the sprites sink into the ground or float above it a little more, you can use the optional coldSpotYOffset argument.\nBy default, any new animframes begin at the first unused entries in jjAnimFrames. By passing a positive value to the firstFrameToOverwrite argument, however, you may choose specific animframes to overwrite instead.\nThis method always sets jjANIMFRAME::gunSpotX and jjANIMFRAME::coldSpotX to the same value as jjANIMFRAME::hotSpotX, jjANIMFRAME::gunSpotY to the same value as jjANIMFRAME::hotSpotY, jjANIMFRAME::transparent to false, and jjANIMATION::fps to the first gif frame's delay (or 10 if no delay is specified in the file). If your script has any more specialized use for those properties you will have to set them manually.\n", "full": "bool load(const string &in filename, int hotSpotX, int hotSpotY, int coldSpotYOffset = 0, int firstFrameToOverwrite = -1)", "type": "function"}], "jjANIMFRAMEList": [{"name": "coldSpotX", "description": "Horizontal and vertical position of the frame's cold spot, relative to its hot spot. It is considered to be the point at which the frame would touch the ground. It's mostly used by objects such as walking enemies and pickup crates, as well as players themselves. In particular, the jjOBJ method putOnGround, if its argument is set to true, uses coldSpotY to determine the outcome.\n", "full": "int16 coldSpotX", "type": "property"}, {"name": "coldSpotY", "description": "Horizontal and vertical position of the frame's cold spot, relative to its hot spot. It is considered to be the point at which the frame would touch the ground. It's mostly used by objects such as walking enemies and pickup crates, as well as players themselves. In particular, the jjOBJ method putOnGround, if its argument is set to true, uses coldSpotY to determine the outcome.\n", "full": "int16 coldSpotY", "type": "property"}, {"name": "gunSpotX", "description": "Horizontal and vertical position of the frame's gun spot, i.e. the point that's used to determine initial position of projectiles, relative to its hot spot. Originally this is only defined for player animations and sprites of enemies that produce projectiles.\n", "full": "int16 gunSpotX", "type": "property"}, {"name": "gunSpotY", "description": "Horizontal and vertical position of the frame's gun spot, i.e. the point that's used to determine initial position of projectiles, relative to its hot spot. Originally this is only defined for player animations and sprites of enemies that produce projectiles.\n", "full": "int16 gunSpotY", "type": "property"}, {"name": "height", "description": "Frame height in pixels.\n", "full": "const uint16 height", "type": "property"}, {"name": "hotSpotX", "description": "Horizontal and vertical position of the frame's hot spot, added to the sprite position by all drawing operations and used by collision detection, etc. These properties are analogous to the hot spot coordinates shown by Jazz Sprite Dynamite, however it should be noted that JSD inverts their values for user convenience, while JJ2 doesn't. This means that you will usually want to use negative values for these properties.\n", "full": "int16 hotSpotX", "type": "property"}, {"name": "hotSpotY", "description": "Horizontal and vertical position of the frame's hot spot, added to the sprite position by all drawing operations and used by collision detection, etc. These properties are analogous to the hot spot coordinates shown by Jazz Sprite Dynamite, however it should be noted that JSD inverts their values for user convenience, while JJ2 doesn't. This means that you will usually want to use negative values for these properties.\n", "full": "int16 hotSpotY", "type": "property"}, {"name": "transparent", "description": "Whether the frame is to be drawn as translucent by default. The only AngelScript function this directly affects is the jjOBJ method draw but JJ2 objects often use this property, e.g. to draw freezer ammo pickups as translucent even though they use the same behavior as any other pickup.\n", "full": "bool transparent", "type": "property"}, {"name": "width", "description": "Frame width in pixels.\n", "full": "const uint16 width", "type": "property"}, {"name": "doesCollide", "description": "Returns true if this sprite (at position xPos,yPos and direction direction) would collide with another sprite with its own specified coordinates and direction, taking both sprites' hotspot positions into account; otherwise false. If always is true, collisions will be registered even if there is only one overlapping pixel (used by bullets); the default value of false will require at least about eight common pixels (used by players), which is probably a better test in most cases. Both direction parameters will be tested for the sprites being horizontally flipped, vertically flipped, or both, and the collision detection will be carried out accordingly.\n", "full": "bool doesCollide(int xPos, int yPos, int direction, const jjANIMFRAME@ frame2, int xPos2, int yPos2, int direction2, bool always = false) const", "type": "function"}], "jjTILEList": [{"name": "fps", "description": "Animation speed in frames per second. For static tiles this is always 0.\nThis property is safe to modify, but it is currently undefined which animation frame will be visible immediately after the change.\n", "full": "uint8 fps", "type": "property"}, {"name": "tileID", "description": "Tile ID corresponding to the instance, such that for every non-null jjTILE handle tile, tile is jjTiles[tile.tileID].\n", "full": "const uint16 tileID", "type": "property"}, {"name": "getFrames", "description": "Constructs and returns an array of tile IDs of animation frames of the instance. For static tiles this is an array of size 1 containing this tile's own ID.\nThe returned array represents animation frames after all transformations selected in animating tile properties, such as ping-pong animation or frames to wait between animation cycles. This means that the result may contain more entries than the animation as viewed in JCS.\nKeep in mind that in levels edited by other means than JCS, entries of the array may themselves be animations.\n", "full": "array<uint16>@ getFrames() const", "type": "function"}, {"name": "setFrames", "description": "Entirely replaces the previous array of animation frames for this animated tile with a new one based on the passed arguments. Returns false if frames is empty (zero frames long) or if this is not a valid animated tile. The results are undefined if frames is more than 64 frames long.\nThe arguments correspond exactly to the similarly named JCS animated tile properties, respectively: \"Ping-Pong animation\"; \"Frames to wait between two animation cycles\"; \"Random adder amplitude for frame wait\"; and \"Frame wait interval between Ping-Pong cycle.\"\nNote that this method is used to replace an existing animated tile. At this time there is no way to expand the number of animated tiles past however many are defined in the level.\n", "full": "bool setFrames(const array<uint16> &in frames, bool pingPong = false, uint16 wait = 0, uint16 randomWait = 0, uint16 pingPongWait = 0)", "type": "function"}], "jjPIXELMAPList": [{"name": "height", "description": "Dimensions of the map in pixels, set by the map's constructor. These properties are read-only but may be modified using the addBorders, crop, resize, or trim methods, or swapped using the rotate method.\n", "full": "const uint height", "type": "property"}, {"name": "width", "description": "Dimensions of the map in pixels, set by the map's constructor. These properties are read-only but may be modified using the addBorders, crop, resize, or trim methods, or swapped using the rotate method.\n", "full": "const uint width", "type": "property"}, {"name": "addBorders", "description": "For each of the four edges of the current image, this method either extends the image outwards by a number of pixels (positive number, filling in the new empty space with borderColor) or crops the image inwards (negative number). Returns a reference to self. If the resulting image would be size 0 on either axis, or if you try to crop out more of the original image than exists (e.g. width equals 9 and both left and right equal -5), no change wil occur.\n\t\t\t\n", "full": "jjPIXELMAP& addBorders(int left, int top, int right, int bottom, uint8 borderColor = 0)", "type": "function"}, {"name": "crop", "description": "Crops the pixel map to the specified coordinates and dimensions and returns a reference to self. If the arguments are invalid (width and/or height equals zero, or any point of the cropped rectangle is outside the current bounds), no change will occur.\n", "full": "jjPIXELMAP& crop(uint left, uint top, uint width, uint height)", "type": "function"}, {"name": "flip", "description": "Flips the pixel map's image across one or both axes and returns a reference to self. Useful argument values are SPRITE::FLIPH, SPRITE::FLIPV and SPRITE::FLIPHV.\n", "full": "jjPIXELMAP& flip(SPRITE::Direction directions)", "type": "function"}, {"name": "makeTexture", "description": "Changes the specified layer's texture to the contents of the pixel map. If you leave layer as null it will default to the background layer,  i.e. jjLayers[8]. The map has to be exactly 256\u00c3\u00af\u00c2\u00bf\u00c2\u00bd256 to allow this action and if that is not the case, the function will report failure by returning false. On success returns true.\n", "full": "bool makeTexture(jjLAYER@ layer = null)", "type": "function"}, {"name": "recolor", "description": "If colorMapping is length 256 or greater, replaces each index in the pixel map with the value in colorMapping at that index, e.g. pixels of color 10 will be changed to paletteColorMapping[10] instead. Returns a reference to self.\n", "full": "jjPIXELMAP& recolor(const array<uint8> &in colorMapping)", "type": "function"}, {"name": "resize", "description": "If neither the old dimensions nor the new dimensions are zero on either axis, resizes the pixel map's image to use the new dimensions using primitive nearest neighbor interpolation. Returns a reference to self.\n", "full": "jjPIXELMAP& resize(uint width, uint height)", "type": "function"}, {"name": "rotate", "description": "Rotates the pixel map's image ninety degrees clockwise and returns a reference to self.\n", "full": "jjPIXELMAP& rotate()", "type": "function"}, {"name": "save", "description": "Overwrites tileset tile selected by tileID with contents of the pixel map. The map has to be exactly 32\u00c3\u00af\u00c2\u00bf\u00c2\u00bd32 to allow this action and if that is not the case, the function will report failure by returning false. On success returns true.\nIf (tileID & TILE::VFLIPPED) != 0, the pixel map image will be vertically flipped while saving the tile. TILE::HFLIPPED is somewhat more complicated, because JJ2 stores horizontally flipped tiles separately from their non-flipped versions. By default, and to avoid unnecessary memory usage, jjPIXELMAP::save will only save to either the regular version of the tile or the horizontally flipped version, depending on whether (tileID & TILE::HFLIPPED) != 0. By setting hFlip to true, though, you can ensure that both the regular and the horizontally flipped version of the tile will be overwritten.\nThe results of saving when (tileID & TILE::ANIMATED) != 0 || (tileID & TILE::RAWRANGE) == 0 are undefined.\n", "full": "bool save(uint16 tileID, bool hFlip = false) const", "type": "function"}, {"name": "save", "description": "Overwrites the image used by frame with contents of the pixel map. Returns true on success and false on failure.\n", "full": "bool save(jjANIMFRAME@ frame) const", "type": "function"}, {"name": "save", "description": "Saves the contents of the pixel map to an 8-bit PNG image file on the local computer and returns whether successful. The image will be saved with whatever palette is passed to this method, by default the game's current palette.\nThere are several limits to this method. The file cannot be saved in any directory other than the default one, which is the directory containing the executable (for local games and servers) or cache (for clients). File extension has to be \".png\" and if any other or no extension is provided in the string, it will be replaced. Additionally, scripts downloaded from a server can only save up to 16 files on the computer of a client; they are, however, allowed to overwrite files they saved previously. (The limit of 16 files is shared with jjANIMATION::save and jjSTREAM::save).\n", "full": "bool save(const string &in filename, const jjPAL &in palette = jjPalette) const", "type": "function"}, {"name": "trim", "description": "Trims away all totally empty rows and columns\u00c3\u00af\u00c2\u00bf\u00c2\u00bdi.e. lines containing no colors other than trimColor, which defaults to 0, or transparent\u00c3\u00af\u00c2\u00bf\u00c2\u00bdfrom the four sides of the current image and returns a reference to self. If there are no colors other than trimColor anywhere in the image, as a special case, the resulting image will be cropped to 1\u00c3\u00af\u00c2\u00bf\u00c2\u00bd1 instead of 0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd0.\nThe method overload with four uint &out arguments lets you know how many rows/columns were trimmed from each of the four sides. If no cropping occurs, they will all equal 0, and if the image was fully trimColor, left and right will equal width (prior to the method being called) and top and bottom will equal height.\n", "full": "jjPIXELMAP& trim(uint8 trimColor = 0)", "type": "function"}, {"name": "trim", "description": "Trims away all totally empty rows and columns\u00c3\u00af\u00c2\u00bf\u00c2\u00bdi.e. lines containing no colors other than trimColor, which defaults to 0, or transparent\u00c3\u00af\u00c2\u00bf\u00c2\u00bdfrom the four sides of the current image and returns a reference to self. If there are no colors other than trimColor anywhere in the image, as a special case, the resulting image will be cropped to 1\u00c3\u00af\u00c2\u00bf\u00c2\u00bd1 instead of 0\u00c3\u00af\u00c2\u00bf\u00c2\u00bd0.\nThe method overload with four uint &out arguments lets you know how many rows/columns were trimmed from each of the four sides. If no cropping occurs, they will all equal 0, and if the image was fully trimColor, left and right will equal width (prior to the method being called) and top and bottom will equal height.\n", "full": "jjPIXELMAP& trim(uint left &out, uint top &out, uint right &out, uint bottom &out, uint8 trimColor = 0)", "type": "function"}], "jjMASKMAPList": [{"name": "save", "description": "Overwrites mask of tileset tile selected by tileID with contents of the mask map. All notes mentioned for jjPIXELMAP::save apply in exactly the same way here, although you don't have to worry about dimensions, since mask maps are always 32\u00c3\u00af\u00c2\u00bf\u00c2\u00bd32.\n", "full": "bool save(uint16 tileID, bool hFlip = false) const", "type": "function"}], "enums": {"CREATOR::Type": ["OBJECT", "LEVEL", "PLAYER"], "PARTICLE::Type": ["INACTIVE", "FIRE", "FLOWER", "ICETRAIL", "LEAF", "PIXEL", "RAIN", "SMOKE", "SNOW", "SPARK", "STAR", "STRING", "TILE"], "STRING::Size": ["SMALL", "MEDIUM", "LARGE"], "STRING::SIZE": ["SMALL", "MEDIUM", "LARGE"], "SPRITE::Mode": ["ALPHAMAP", "BLEND_NORMAL", "BLEND_DISSOLVE", "BLEND_DARKEN", "BLEND_MULTIPLY", "BLEND_BURN", "BLEND_LIGHTEN", "BLEND_SCREEN", "BLEND_DODGE", "BLEND_OVERLAY", "BLEND_SOFTLIGHT", "BLEND_HARDLIGHT", "BLEND_DIFFERENCE", "BLEND_EXCLUSION", "BLEND_COLOR", "BLEND_HUE", "BLEND_SATURATION", "BLEND_LUMINANCE", "BRIGHTNESS", "CHROMAKEY", "FROZEN", "GEM", "INVISIBLE", "MAPPING", "MENUPLAYER", "NEONGLOW", "NORMAL", "PALSHIFT", "PLAYER", "RESIZED", "SHADOW", "SINGLECOLOR", "SINGLEHUE", "TINTED", "TRANSLUCENT", "TRANSLUCENTCOLOR", "TRANSLUCENTMAPPING", "TRANSLUCENTPALSHIFT", "TRANSLUCENTPLAYER", "TRANSLUCENTSINGLEHUE", "TRANSLUCENTTILE"], "TILE::Quadrant": ["TOPLEFT", "TOPRIGHT", "BOTTOMLEFT", "BOTTOMRIGHT", "ALLQUADRANTS"], "SOUND::Sample": ["AMMO_BLUB1", "AMMO_BLUB2", "AMMO_BMP1", "AMMO_BMP2", "AMMO_BMP3", "AMMO_BMP4", "AMMO_BMP5", "AMMO_BMP6", "AMMO_BOEM1", "AMMO_BUL1", "AMMO_BULFL1", "AMMO_BULFL2", "AMMO_BULFL3", "AMMO_FIREGUN1A", "AMMO_FIREGUN2A", "AMMO_FUMP", "AMMO_GUN1", "AMMO_GUN2", "AMMO_GUN3PLOP", "AMMO_GUNFLP", "AMMO_GUNFLP1", "AMMO_GUNFLP2", "AMMO_GUNFLP3", "AMMO_GUNFLP4", "AMMO_GUNFLPL", "AMMO_GUNJAZZ", "AMMO_GUNVELOCITY", "AMMO_ICEGUN", "AMMO_ICEGUN2", "AMMO_ICEGUNPU", "AMMO_ICEPU1", "AMMO_ICEPU2", "AMMO_ICEPU3", "AMMO_ICEPU4", "AMMO_LASER", "AMMO_LASER2", "AMMO_LASER3", "AMMO_LAZRAYS", "AMMO_MISSILE", "AMMO_SPZBL1", "AMMO_SPZBL2", "AMMO_SPZBL3", "BAT_BATFLY1", "BILSBOSS_BILLAPPEAR", "BILSBOSS_FINGERSNAP", "BILSBOSS_FIRE", "BILSBOSS_FIRESTART", "BILSBOSS_SCARY3", "BILSBOSS_THUNDER", "BILSBOSS_ZIP", "BONUS_BONUS1", "BONUS_BONUSBLUB", "BUBBA_BUBBABOUNCE1", "BUBBA_BUBBABOUNCE2", "BUBBA_BUBBAEXPLO", "BUBBA_FROG2", "BUBBA_FROG3", "BUBBA_FROG4", "BUBBA_FROG5", "BUBBA_SNEEZE2", "BUBBA_TORNADOATTACK2", "BUMBEE_BEELOOP", "CATERPIL_RIDOE", "COMMON_AIRBOARD", "COMMON_AIRBTURN", "COMMON_AIRBTURN2", "COMMON_BASE1", "COMMON_BELL_FIRE", "COMMON_BELL_FIRE2", "COMMON_BENZIN1", "COMMON_BIRDFLY", "COMMON_BIRDFLY2", "COMMON_BLOKPLOP", "COMMON_BLUB1", "COMMON_BUBBLGN1", "COMMON_BURN", "COMMON_BURNIN", "COMMON_CANSPS", "COMMON_CLOCK", "COMMON_COIN", "COMMON_COLLAPS", "COMMON_CUP", "COMMON_DAMPED1", "COMMON_DOWN", "COMMON_DOWNFL2", "COMMON_DRINKSPAZZ1", "COMMON_DRINKSPAZZ2", "COMMON_DRINKSPAZZ3", "COMMON_DRINKSPAZZ4", "COMMON_EAT1", "COMMON_EAT2", "COMMON_EAT3", "COMMON_EAT4", "COMMON_ELECTRIC1", "COMMON_ELECTRIC2", "COMMON_ELECTRICHIT", "COMMON_EXPL_TNT", "COMMON_EXPSM1", "COMMON_FLAMER", "COMMON_FLAP", "COMMON_FOEW1", "COMMON_FOEW2", "COMMON_FOEW3", "COMMON_FOEW4", "COMMON_FOEW5", "COMMON_GEMSMSH1", "COMMON_GLASS2", "COMMON_GUNSM1", "COMMON_HARP1", "COMMON_HEAD", "COMMON_HELI1", "COMMON_HIBELL", "COMMON_HOLYFLUT", "COMMON_HORN1", "COMMON_ICECRUSH", "COMMON_IMPACT1", "COMMON_IMPACT2", "COMMON_IMPACT3", "COMMON_IMPACT4", "COMMON_IMPACT5", "COMMON_IMPACT6", "COMMON_IMPACT7", "COMMON_IMPACT8", "COMMON_IMPACT9", "COMMON_ITEMTRE", "COMMON_JUMP", "COMMON_JUMP2", "COMMON_LAND", "COMMON_LAND1", "COMMON_LAND2", "COMMON_LANDCAN1", "COMMON_LANDCAN2", "COMMON_LANDPOP", "COMMON_LOADJAZZ", "COMMON_LOADSPAZ", "COMMON_METALHIT", "COMMON_MONITOR", "COMMON_NOCOIN", "COMMON_PICKUP1", "COMMON_PICKUPW1", "COMMON_PISTOL1", "COMMON_PLOOP1", "COMMON_PLOP1", "COMMON_PLOP2", "COMMON_PLOP3", "COMMON_PLOP4", "COMMON_PLOPKORK", "COMMON_PREEXPL1", "COMMON_PREHELI", "COMMON_REVUP", "COMMON_RINGGUN", "COMMON_RINGGUN2", "COMMON_SHIELD1", "COMMON_SHIELD4", "COMMON_SHIELD_ELEC", "COMMON_SHLDOF3", "COMMON_SLIP", "COMMON_SMASH", "COMMON_SPLAT1", "COMMON_SPLAT2", "COMMON_SPLAT3", "COMMON_SPLAT4", "COMMON_SPLUT", "COMMON_SPRING1", "COMMON_STEAM", "COMMON_STEP", "COMMON_STRETCH", "COMMON_SWISH1", "COMMON_SWISH2", "COMMON_SWISH3", "COMMON_SWISH4", "COMMON_SWISH5", "COMMON_SWISH6", "COMMON_SWISH7", "COMMON_SWISH8", "COMMON_TELPORT1", "COMMON_TELPORT2", "COMMON_UP", "COMMON_WATER", "COMMON_WOOD1", "DEMON_RUN", "DEVILDEVAN_DRAGONFIRE", "DEVILDEVAN_FLAP", "DEVILDEVAN_FROG4", "DEVILDEVAN_JUMPUP", "DEVILDEVAN_LAUGH", "DEVILDEVAN_PHASER2", "DEVILDEVAN_STRECh3", "DEVILDEVAN_STRECHTAIL", "DEVILDEVAN_STRETCH1", "DEVILDEVAN_STRETCH3", "DEVILDEVAN_VANISH1", "DEVILDEVAN_WHISTLEDESCENDING2", "DEVILDEVAN_WINGSOUT", "DOG_AGRESSIV", "DOG_SNIF1", "DOG_WAF1", "DOG_WAF2", "DOG_WAF3", "DRAGFLY_BEELOOP", "ENDING_OHTHANK", "ENDTUNEJAZZ_TUNE", "ENDTUNELORI_CAKE", "ENDTUNESPAZ_TUNE", "EPICLOGO_EPIC1", "EPICLOGO_EPIC2", "EVA_KISS1", "EVA_KISS2", "EVA_KISS3", "EVA_KISS4", "FAN_FAN", "FATCHK_HIT1", "FATCHK_HIT2", "FATCHK_HIT3", "FENCER_FENCE1", "FROG_FROG", "FROG_FROG1", "FROG_FROG2", "FROG_FROG3", "FROG_FROG4", "FROG_FROG5", "FROG_JAZZ2FROG", "FROG_TONG", "GLOVE_HIT", "HATTER_CUP", "HATTER_HAT", "HATTER_PTOEI", "HATTER_SPLIN", "HATTER_SPLOUT", "INTRO_BLOW", "INTRO_BOEM1", "INTRO_BOEM2", "INTRO_BRAKE", "INTRO_END", "INTRO_GRAB", "INTRO_GREN1", "INTRO_GREN2", "INTRO_GREN3", "INTRO_GUNM0", "INTRO_GUNM1", "INTRO_GUNM2", "INTRO_HELI", "INTRO_HITSPAZ", "INTRO_HITTURT", "INTRO_IFEEL", "INTRO_INHALE", "INTRO_INSECT", "INTRO_KATROL", "INTRO_LAND", "INTRO_MONSTER", "INTRO_MONSTER2", "INTRO_ROCK", "INTRO_ROPE1", "INTRO_ROPE2", "INTRO_RUN", "INTRO_SHOT1", "INTRO_SHOTGRN", "INTRO_SKI", "INTRO_STRING", "INTRO_SWISH1", "INTRO_SWISH2", "INTRO_SWISH3", "INTRO_SWISH4", "INTRO_UHTURT", "INTRO_UP1", "INTRO_UP2", "INTRO_WIND_01", "JAZZSOUNDS_BALANCE", "JAZZSOUNDS_HEY1", "JAZZSOUNDS_HEY2", "JAZZSOUNDS_HEY3", "JAZZSOUNDS_HEY4", "JAZZSOUNDS_IDLE", "JAZZSOUNDS_JAZZV1", "JAZZSOUNDS_JAZZV2", "JAZZSOUNDS_JAZZV3", "JAZZSOUNDS_JAZZV4", "JAZZSOUNDS_JUMMY", "JAZZSOUNDS_PFOE", "LABRAT_BITE", "LABRAT_EYE2", "LABRAT_EYE3", "LABRAT_MOUSE1", "LABRAT_MOUSE2", "LABRAT_MOUSE3", "LIZARD_LIZ1", "LIZARD_LIZ2", "LIZARD_LIZ4", "LIZARD_LIZ6", "LORISOUNDS_DIE1", "LORISOUNDS_HURT0", "LORISOUNDS_HURT1", "LORISOUNDS_HURT2", "LORISOUNDS_HURT3", "LORISOUNDS_HURT4", "LORISOUNDS_HURT5", "LORISOUNDS_HURT6", "LORISOUNDS_HURT7", "LORISOUNDS_LORI1", "LORISOUNDS_LORI2", "LORISOUNDS_LORIBOOM", "LORISOUNDS_LORIFALL", "LORISOUNDS_LORIJUMP", "LORISOUNDS_LORIJUMP2", "LORISOUNDS_LORIJUMP3", "LORISOUNDS_LORIJUMP4", "LORISOUNDS_TOUCH", "LORISOUNDS_WEHOO", "MENUSOUNDS_SELECT0", "MENUSOUNDS_SELECT1", "MENUSOUNDS_SELECT2", "MENUSOUNDS_SELECT3", "MENUSOUNDS_SELECT4", "MENUSOUNDS_SELECT5", "MENUSOUNDS_SELECT6", "MENUSOUNDS_TYPE", "MENUSOUNDS_TYPEENTER", "MONKEY_SPLUT", "MONKEY_THROW", "MOTH_FLAPMOTH", "ORANGE_BOEML", "ORANGE_BOEMR", "ORANGE_BUBBELSL", "ORANGE_BUBBELSR", "ORANGE_GLAS1L", "ORANGE_GLAS1R", "ORANGE_GLAS2L", "ORANGE_GLAS2R", "ORANGE_MERGE", "ORANGE_SWEEP0L", "ORANGE_SWEEP0R", "ORANGE_SWEEP1L", "ORANGE_SWEEP1R", "ORANGE_SWEEP2L", "ORANGE_SWEEP2R", "P2_CRUNCH", "P2_FART", "P2_FOEW1", "P2_FOEW4", "P2_FOEW5", "P2_FROG1", "P2_FROG2", "P2_FROG3", "P2_FROG4", "P2_FROG5", "P2_KISS4", "P2_OPEN", "P2_PINCH1", "P2_PINCH2", "P2_PLOPSEQ1", "P2_PLOPSEQ2", "P2_PLOPSEQ3", "P2_PLOPSEQ4", "P2_POEP", "P2_PTOEI", "P2_SPLOUT", "P2_SPLUT", "P2_THROW", "P2_TONG", "PICKUPS_BOING_CHECK", "PICKUPS_HELI2", "PICKUPS_STRETCH1A", "PINBALL_BELL", "PINBALL_FLIP1", "PINBALL_FLIP2", "PINBALL_FLIP3", "PINBALL_FLIP4", "QUEEN_LADYUP", "QUEEN_SCREAM", "RAPIER_GOSTDIE", "RAPIER_GOSTLOOP", "RAPIER_GOSTOOOH", "RAPIER_GOSTRIP", "RAPIER_HITCHAR", "ROBOT_BIG1", "ROBOT_BIG2", "ROBOT_CAN1", "ROBOT_CAN2", "ROBOT_HYDRO", "ROBOT_HYDRO2", "ROBOT_HYDROFIL", "ROBOT_HYDROPUF", "ROBOT_IDLE1", "ROBOT_IDLE2", "ROBOT_JMPCAN1", "ROBOT_JMPCAN10", "ROBOT_JMPCAN2", "ROBOT_JMPCAN3", "ROBOT_JMPCAN4", "ROBOT_JMPCAN5", "ROBOT_JMPCAN6", "ROBOT_JMPCAN7", "ROBOT_JMPCAN8", "ROBOT_JMPCAN9", "ROBOT_METAL1", "ROBOT_METAL2", "ROBOT_METAL3", "ROBOT_METAL4", "ROBOT_METAL5", "ROBOT_OPEN", "ROBOT_OUT", "ROBOT_POEP", "ROBOT_POLE", "ROBOT_SHOOT", "ROBOT_STEP1", "ROBOT_STEP2", "ROBOT_STEP3", "ROCK_ROCK1", "RUSH_RUSH", "SCIENCE_PLOPKAOS", "SKELETON_BONE1", "SKELETON_BONE2", "SKELETON_BONE3", "SKELETON_BONE5", "SKELETON_BONE6", "SKELETON_BONE7", "SMALTREE_FALL", "SMALTREE_GROUND", "SMALTREE_HEAD", "SONCSHIP_METAL1", "SONCSHIP_MISSILE2", "SONCSHIP_SCRAPE", "SONCSHIP_SHIPLOOP", "SONCSHIP_TARGETLOCK", "SPAZSOUNDS_AUTSCH1", "SPAZSOUNDS_AUTSCH2", "SPAZSOUNDS_BIRDSIT", "SPAZSOUNDS_BURP", "SPAZSOUNDS_CHIRP", "SPAZSOUNDS_EATBIRD", "SPAZSOUNDS_HAHAHA", "SPAZSOUNDS_HAHAHA2", "SPAZSOUNDS_HAPPY", "SPAZSOUNDS_HIHI", "SPAZSOUNDS_HOHOHO1", "SPAZSOUNDS_HOOO", "SPAZSOUNDS_KARATE7", "SPAZSOUNDS_KARATE8", "SPAZSOUNDS_OHOH", "SPAZSOUNDS_OOOH", "SPAZSOUNDS_WOOHOO", "SPAZSOUNDS_YAHOO", "SPAZSOUNDS_YAHOO2", "SPRING_BOING_DOWN", "SPRING_SPRING1", "STEAM_STEAM", "STONED_STONED", "SUCKER_FART", "SUCKER_PINCH1", "SUCKER_PINCH2", "SUCKER_PINCH3", "SUCKER_PLOPSEQ1", "SUCKER_PLOPSEQ2", "SUCKER_PLOPSEQ3", "SUCKER_PLOPSEQ4", "SUCKER_UP", "TUFBOSS_CATCH", "TUFBOSS_RELEASE", "TUFBOSS_SWING", "TURTLE_BITE3", "TURTLE_HIDE", "TURTLE_HITSHELL", "TURTLE_IDLE1", "TURTLE_IDLE2", "TURTLE_NECK", "TURTLE_SPK1TURT", "TURTLE_SPK2TURT", "TURTLE_SPK3TURT", "TURTLE_SPK4TURT", "TURTLE_TURN", "UTERUS_CRABCLOSE", "UTERUS_CRABOPEN2", "UTERUS_SCISSORS1", "UTERUS_SCISSORS2", "UTERUS_SCISSORS3", "UTERUS_SCISSORS4", "UTERUS_SCISSORS5", "UTERUS_SCISSORS6", "UTERUS_SCISSORS7", "UTERUS_SCISSORS8", "UTERUS_SCREAM1", "UTERUS_STEP1", "UTERUS_STEP2", "WIND_WIND2A", "WITCH_LAUGH", "WITCH_MAGIC", "XBILSY_BILLAPPEAR", "XBILSY_FINGERSNAP", "XBILSY_FIRE", "XBILSY_FIRESTART", "XBILSY_SCARY3", "XBILSY_THUNDER", "XBILSY_ZIP", "XLIZARD_LIZ1", "XLIZARD_LIZ2", "XLIZARD_LIZ4", "XLIZARD_LIZ6", "XTURTLE_BITE3", "XTURTLE_HIDE", "XTURTLE_HITSHELL", "XTURTLE_IDLE1", "XTURTLE_IDLE2", "XTURTLE_NECK", "XTURTLE_SPK1TURT", "XTURTLE_SPK2TURT", "XTURTLE_SPK3TURT", "XTURTLE_SPK4TURT", "XTURTLE_TURN", "ZDOG_AGRESSIV", "ZDOG_SNIF1", "ZDOG_WAF1", "ZDOG_WAF2", "ZDOG_WAF3"], "BEHAVIOR::Behavior": ["BULLET", "SEEKERBULLET", "RFBULLET", "TOASTERBULLET", "PEPPERBULLET", "ELECTROBULLET", "BUMP", "PADDLE", "BIGOBJECT", "WALKINGENEMY", "DESTRUCTSCENERY", "ROCKETTURTLE", "ROCKETTURTLEPLUS", "BOLLYTOP", "BOLLYBOTTOM", "PLATFORM", "SPRING", "AMMO15", "MONITOR", "CRATE", "PICKUP", "DIAMONDSAREFOREVER", "FLAG", "INACTIVE", "DEFAULT", "MONKEYBULLET", "BILSYBULLET", "BOLLYBULLET", "BOLLYSPIKEBALL", "WITCHBULLET", "TUFBOSSBULLET", "ROBOTSHARD", "BONE", "EXPLOSION2", "BURNING", "AIRBOARDFALL", "BIRDFEATHER", "UFO", "CORPSE"], "DIRECTION::Dir": ["RIGHT", "LEFT", "UP", "CURRENT"], "CHAR::Char": ["JAZZ", "SPAZ", "LORI", "BIRD", "FROG", "BIRD2"], "HANDLING::Player": ["ENEMY", "PLAYERBULLET", "ENEMYBULLET", "PARTICLE", "EXPLOSION", "PICKUP", "DELAYEDPICKUP", "HURT", "SPECIAL", "DYING", "SPECIALDONE", "SELFCOLLISION"], "GEM::Color": ["RED", "GREEN", "BLUE", "PURPLE"], "STRING::Mode": ["NORMAL", "DARK", "RIGHTALIGN", "BOUNCE", "SPIN", "PALSHIFT"], "CHAT::Type": ["NORMAL", "TEAMCHAT", "WHISPER", "ME"], "OBJECT::Object": ["BLASTERBULLET", "BOUNCERBULLET", "ICEBULLET", "SEEKERBULLET", "RFBULLET", "TOASTERBULLET", "FIREBALLBULLET", "ELECTROBULLET", "BLASTERBULLETPU", "BOUNCERBULLETPU", "ICEBULLETPU", "SEEKERBULLETPU", "RFBULLETPU", "TOASTERBULLETPU", "FIREBALLBULLETPU", "ELECTROBULLETPU", "FIRESHIELDBULLET", "WATERSHIELDBULLET", "BUBBLESHIELDBULLET", "LIGHTNINGSHIELDBULLET", "PLASMASHIELDBULLET", "BULLET", "SMOKERING", "SHARD", "EXPLOSION", "BOUNCEONCE", "FLICKERGEM", "LASER", "UTERUSSPIKEBALL", "BIRD", "BUBBLE", "ICEAMMO3", "BOUNCERAMMO3", "SEEKERAMMO3", "RFAMMO3", "TOASTERAMMO3", "TNTAMMO3", "GUN8AMMO3", "GUN9AMMO3", "TURTLESHELL", "SWINGINGVINE", "BOMB", "SILVERCOIN", "GOLDCOIN", "GUNCRATE", "CARROTCRATE", "ONEUPCRATE", "GEMBARREL", "CARROTBARREL", "ONEUPBARREL", "BOMBCRATE", "ICEAMMO15", "BOUNCERAMMO15", "SEEKERAMMO15", "RFAMMO15", "TOASTERAMMO15", "TNT", "AIRBOARDGENERATOR", "FROZENSPRING", "FASTFIRE", "SPRINGCRATE", "REDGEM", "GREENGEM", "BLUEGEM", "PURPLEGEM", "SUPERGEM", "BIRDCAGE", "GUNBARREL", "GEMCRATE", "MORPH", "CARROT", "FULLENERGY", "FIRESHIELD", "WATERSHIELD", "BUBBLESHIELD", "LIGHTNINGSHIELD", "PLASMASHIELD", "FASTFEET", "ONEUP", "EXTRALIFE", "EXTRALIVE", "EOLPOST", "SAVEPOST", "CHECKPOINT", "BONUSPOST", "REDSPRING", "GREENSPRING", "BLUESPRING", "INVINCIBILITY", "EXTRATIME", "FREEZER", "FREEZEENEMIES", "HORREDSPRING", "HORGREENSPRING", "HORBLUESPRING", "BIRDMORPH", "TRIGGERCRATE", "FLYCARROT", "RECTREDGEM", "RECTGREENGEM", "RECTBLUEGEM", "TUFTURT", "TUFBOSS", "LABRAT", "DRAGON", "LIZARD", "BEE", "BUMBEE", "RAPIER", "SPARK", "BAT", "SUCKER", "CATERPILLAR", "CHESHIRE1", "CHESHIRE2", "HATTER", "BILSY", "SKELETON", "DOGGYDOGG", "NORMTURTLE", "HELMUT", "DEMON", "DRAGONFLY", "MONKEY", "FATCHICK", "FENCER", "FISH", "MOTH", "STEAM", "ROTATINGROCK", "BLASTERPOWERUP", "BOUNCERPOWERUP", "ICEPOWERUP", "SEEKERPOWERUP", "RFPOWERUP", "TOASTERPOWERUP", "LEFTPADDLE", "RIGHTPADDLE", "FIVEHUNDREDBUMP", "CARROTBUMP", "APPLE", "BANANA", "CHERRY", "ORANGE", "PEAR", "PRETZEL", "STRAWBERRY", "STEADYLIGHT", "PULZELIGHT", "PULSELIGHT", "FLICKERLIGHT", "QUEEN", "FLOATSUCKER", "BRIDGE", "LEMON", "LIME", "THING", "WATERMELON", "PEACH", "GRAPES", "LETTUCE", "EGGPLANT", "CUCUMB", "CUCUMBER", "COKE", "SOFTDRINK", "PEPSI", "SODAPOP", "MILK", "PIE", "CAKE", "DONUT", "CUPCAKE", "CHIPS", "CANDY", "CHOCBAR", "CHOCOLATEBAR", "ICECREAM", "BURGER", "PIZZA", "FRIES", "CHICKENLEG", "SANDWICH", "TACO", "WEENIE", "HAM", "CHEESE", "FLOATLIZARD", "STANDMONKEY", "DESTRUCTSCENERY", "DESTRUCTSCENERYBOMB", "TNTDESTRUCTSCENERY", "COLLAPSESCENERY", "STOMPSCENERY", "GEMSTOMP", "RAVEN", "TUBETURTLE", "GEMRING", "SMALLTREE", "AMBIENTSOUND", "UTERUS", "CRAB", "WITCH", "ROCKETTURTLE", "BUBBA", "DEVILDEVAN", "DEVANROBOT", "ROBOT", "CARROTUSPOLE", "PSYCHPOLE", "DIAMONDUSPOLE", "FRUITPLATFORM", "BOLLPLATFORM", "GRASSPLATFORM", "PINKPLATFORM", "SONICPLATFORM", "SPIKEPLATFORM", "SPIKEBOLL", "GENERATOR", "EVA", "BUBBLER", "TNTPOWERUP", "GUN8POWERUP", "GUN9POWERUP", "SPIKEBOLL3D", "SPRINGCORD", "BEES", "COPTER", "LASERSHIELD", "STOPWATCH", "JUNGLEPOLE", "WARP", "BIGROCK", "BIGBOX", "TRIGGERSCENERY", "BOLLY", "BUTTERFLY", "BEEBOY", "SNOW", "TWEEDLEBOSS", "AIRBOARD", "CTFBASE", "XMASNORMTURTLE", "XMASLIZARD", "XMASFLOATLIZARD", "XMASBILSY", "CAT", "PACMANGHOST"], "AREA::Area": ["ONEWAY", "HURT", "VINE", "HOOK", "SLIDE", "HPOLE", "VPOLE", "FLYOFF", "RICOCHET", "BELTRIGHT", "BELTLEFT", "ACCBELTRIGHT", "ACCBELTLEFT", "STOPENEMY", "WINDLEFT", "WINDRIGHT", "EOL", "WARPEOL", "REVERTMORPH", "FLOATUP", "TRIGGERROCK", "DIMLIGHT", "SETLIGHT", "LIMITXSCROLL", "RESETLIGHT", "WARPSECRET", "ECHO", "ACTIVATEBOSS", "JAZZLEVELSTART", "JAZZSTART", "SPAZLEVELSTART", "SPAZSTART", "MPLEVELSTART", "MPSTART", "LORILEVELSTART", "LORISTART", "WARP", "WARPTARGET", "PATH", "AREAID", "NOFIREZONE", "TRIGGERZONE", "SUCKERTUBE", "TEXT", "WATERLEVEL", "MORPHFROG", "WATERBLOCK"], "ANIM::Set": ["AMMO", "BAT", "BEEBOY", "BEES", "BIGBOX", "BIGROCK", "BIGTREE", "BILSBOSS", "BIRD", "BIRD3D", "BOLLPLAT", "BONUS", "BOSS", "BRIDGE", "BUBBA", "BUMBEE", "BUTTERFLY", "CARROTPOLE", "CAT", "CAT2", "CATERPIL", "CHUCK", "COMMON", "CONTINUE", "DEMON", "DESTSCEN", "DEVAN", "DEVILDEVAN", "DIAMPOLE", "DOG", "DOOR", "DRAGFLY", "DRAGON", "EVA", "FACES", "FATCHK", "FENCER", "FISH", "FLAG", "FLARE", "FONT", "FROG", "FRUITPLAT", "GEMRING", "GLOVE", "GRASSPLAT", "HATTER", "HELMUT", "JAZZ", "JAZZ3D", "JUNGLEPOLE", "LABRAT", "LIZARD", "LORI", "LORI2", "MENU", "MENUFONT", "MONKEY", "MOTH", "PICKUPS", "PINBALL", "PINKPLAT", "PSYCHPOLE", "QUEEN", "RAPIER", "RAVEN", "ROBOT", "ROCK", "ROCKTURT", "SKELETON", "SMALTREE", "SNOW", "SONCSHIP", "SONICPLAT", "SPARK", "SPAZ", "SPAZ2", "SPAZ3D", "SPIKEBOLL", "SPIKEBOLL3D", "SPIKEPLAT", "SPRING", "STEAM", "SUCKER", "TUBETURT", "TUFBOSS", "TUFTUR", "TURTLE", "TWEEDLE", "UTERUS", "VINE", "WARP10", "WARP100", "WARP20", "WARP50", "WITCH", "XBILSY", "XLIZARD", "XTURTLE", "ZDOG", "ZSPARK", "PLUS_AMMO", "PLUS_BETA", "PLUS_COMMON", "PLUS_CONTINUE", "PLUS_FONT", "PLUS_MENUFONT", "PLUS_REPLACEMENTS", "PLUS_RETICLES", "PLUS_SCENERY", "PLUS_WARP", "CUSTOM"], "COLOR::Component": ["RED", "GREEN", "BLUE"], "TEXTURE::Texture": ["BLADE", "CORRUPTEDSANCTUARY", "DESOLATION", "DIAMONDUSBETA", "ICTUBELECTRIC", "MEDIVO", "MEZ02", "MUCKAMOKNIGHT", "NORMAL", "PSYCH", "RANEFORUSV", "WINDSTORMFORTRESS", "WISETYNESS", "WTF", "XARGON"], "TEXTURE::Style": ["CYLINDER", "MENU", "REFLECTION", "TILEMENU", "TUNNEL", "WAVE", "WARPHORIZON"], "SURFACE::Surface": ["UNTEXTURED", "LEGACY", "FULLSREEN", "INNERWINDOW", "INNERLAYER"], "LAYERSPEEDMODEL::LayerSpeedModel": ["NORMAL", "LAYER8", "BOTHSPEEDS", "FROMSTART", "FITLEVEL", "SPEEDMULTIPLIERS"], "LIGHT::Enforce": ["OPTIONAL", "BASIC", "COMPLETE"], "SNOWING::Type": ["SNOW", "FLOWER", "RAIN", "LEAF"], "WATERINTERACTION::WaterInteraction": ["SWIM", "LOWGRAVITY", "POSITIONBASED"], "WATERLIGHT::wl": ["NONE", "GLOBAL", "LAGUNICUS"], "LIGHT::Type": ["NONE", "NORMAL", "POINT", "POINT2", "FLICKER", "BRIGHT", "LASERBEAM", "LASER", "RING", "RING2", "PLAYER"], "HANDLING::Bullet": ["HURTBYBULLET", "IGNOREBULLET", "DESTROYBULLET", "DETECTBULLET"], "STATE::State": ["START", "SLEEP", "WAKE", "KILL", "DEACTIVATE", "WALK", "JUMP", "FIRE", "FLY", "BOUNCE", "EXPLODE", "ROCKETFLY", "STILL", "FLOAT", "HIT", "SPRING", "ACTION", "DONE", "PUSH", "FALL", "FLOATFALL", "CIRCLE", "ATTACK", "FREEZE", "FADEIN", "FADEOUT", "HIDE", "TURN", "IDLE", "EXTRA", "STOP", "WAIT", "LAND", "DELAYEDSTART", "ROTATE", "DUCK"], "SPREAD::Spread": ["NORMAL", "ICEPU", "ICE", "RFNORMAL", "RFPU", "RF", "TOASTER", "PEPPERSPRAY", "GUN8"], "WEAPON::Style": ["NORMAL", "MISSILE", "POPCORN", "CAPPED"], "WEAPON::Weapon": ["BLASTER", "BOUNCER", "ICE", "SEEKER", "RF", "TOASTER", "TNT", "GUN8", "GUN9", "CURRENT"], "STRING::Alignment": ["DEFAULT", "LEFT", "CENTER", "RIGHT"], "STRING::SignTreatment": ["HIDESIGN", "DISPLAYSIGN", "SPECIALSIGN"], "TEAM::COLOR": ["NEUTRAL", "BLUE", "RED", "GREEN", "YELLOW"], "TEAM::Color": ["NEUTRAL", "BLUE", "RED", "GREEN", "YELLOW"], "AIR::Jump": ["NONE", "HELICOPTER", "DOUBLEJUMP"], "GROUND::Jump": ["JAZZ", "SPAZ", "LORI", "CROUCH", "JUMP"], "TIMER::State": ["STOPPED", "STARTED", "PAUSED"], "SPRITE::Direction": ["FLIPNONE", "FLIPH", "FLIPV", "FLIPHV"], "GAME::Connection": ["LOCAL", "ONLINE", "LAN"], "GAME::Custom": ["NOCUSTOM", "RT", "LRS", "XLRS", "PEST", "TB", "JB", "DCTF", "FR", "TLRS", "DOM", "HEAD"], "GAME::Mode": ["SP", "COOP", "BATTLE", "CTF", "TREASURE", "RACE"], "GAME::State": ["STOPPED", "STARTED", "PAUSED", "PREGAME", "OVERTIME"], "SHIELD::Shield": ["FIRE", "BUBBLE", "WATER", "LIGHTNING", "PLASMA", "LASER"], "RABBIT::Anim": ["AIRBOARD", "AIRBOARDTURN", "BUTTSTOMPLAND", "CORPSE", "DIE", "DIVE", "DIVEFIREQUIT", "DIVEFIRERIGHT", "DIVEUP", "EARBRACHIATE", "ENDOFLEVEL", "FALL", "FALLBUTTSTOMP", "FALLLAND", "FIRE", "FIREUP", "FIREUPQUIT", "FROG", "HANGFIREQUIT", "HANGFIREREST", "HANGFIREUP", "HANGIDLE1", "HANGIDLE2", "HANGINGFIREQUIT", "HANGINGFIRERIGHT", "HELICOPTER", "HELICOPTERFIREQUIT", "HELICOPTERFIRERIGHT", "HPOLE", "HURT", "IDLE1", "IDLE2", "IDLE3", "IDLE4", "IDLE5", "JUMPFIREQUIT", "JUMPFIRERIGHT", "JUMPING1", "JUMPING2", "JUMPING3", "LEDGEWIGGLE", "LIFT", "LIFTJUMP", "LIFTLAND", "LOOKUP", "LOOPY", "PUSH", "QUIT", "REV1", "REV2", "REV3", "RIGHTFALL", "RIGHTJUMP", "ROLLING", "RUN1", "RUN2", "RUN3", "SKID1", "SKID2", "SKID3", "SPRING", "STAND", "STATIONARYJUMP", "STATIONARYJUMPEND", "STATIONARYJUMPSTART", "STONED", "SWIMDOWN", "SWIMRIGHT", "SWIMTURN1", "SWIMTURN2", "SWIMUP", "SWINGINGVINE", "TELEPORT", "TELEPORTFALL", "TELEPORTFALLING", "TELEPORTFALLTELEPORT", "TELEPORTSTAND", "VPOLE"]}}